diff --git a/mlir/include/mlir/Dialect/LLVMIR/FunctionCallUtils.h b/mlir/include/mlir/Dialect/LLVMIR/FunctionCallUtils.h
index 123ce36cb..b284a35e8 100644
--- a/mlir/include/mlir/Dialect/LLVMIR/FunctionCallUtils.h
+++ b/mlir/include/mlir/Dialect/LLVMIR/FunctionCallUtils.h
@@ -60,7 +60,14 @@ LLVM::LLVMFuncOp lookupOrCreateGenericAlignedAllocFn(ModuleOp moduleOp,
 LLVM::LLVMFuncOp lookupOrCreateGenericFreeFn(ModuleOp moduleOp);
 LLVM::LLVMFuncOp lookupOrCreateMemRefCopyFn(ModuleOp moduleOp, Type indexType,
                                             Type unrankedDescriptorType);
-
+/// modified
+/// Functions for Rapid Allocator.
+LLVM::LLVMFuncOp lookupOrCreateRapidInitializeFn(ModuleOp moduleOp);
+LLVM::LLVMFuncOp lookupOrCreateRapidMallocFn(ModuleOp moduleOp,
+                                             Type rapidHandleType,
+                                             Type indexType);
+LLVM::LLVMFuncOp lookupOrCreateRapidFreeFn(ModuleOp moduleOp);
+/// end modified
 /// Create a FuncOp with signature `resultType`(`paramTypes`)` and name `name`.
 LLVM::LLVMFuncOp lookupOrCreateFn(ModuleOp moduleOp, StringRef name,
                                   ArrayRef<Type> paramTypes = {},
diff --git a/mlir/lib/Conversion/MemRefToLLVM/AllocLikeConversion.cpp b/mlir/lib/Conversion/MemRefToLLVM/AllocLikeConversion.cpp
index b29abc94c..8a9ad7d6d 100644
--- a/mlir/lib/Conversion/MemRefToLLVM/AllocLikeConversion.cpp
+++ b/mlir/lib/Conversion/MemRefToLLVM/AllocLikeConversion.cpp
@@ -38,6 +38,44 @@ LLVM::LLVMFuncOp getAlignedAllocFn(const LLVMTypeConverter *typeConverter,
   return LLVM::lookupOrCreateAlignedAllocFn(module, indexType);
 }
 
+/// modified
+LLVM::LLVMFuncOp getRapidInitializeFn(
+    const LLVMTypeConverter *typeConverter, ModuleOp module) {
+  return LLVM::lookupOrCreateRapidInitializeFn(module);
+}
+
+Value getRapidHandle(
+    const LLVMTypeConverter *typeConverter, Operation *op) {
+  StringRef name = "rapid_initialize";
+  ModuleOp moduleOp = op->getParentOfType<ModuleOp>();
+  Value rapidHandle = nullptr;
+  moduleOp.walk([&](LLVM::CallOp callOp) {
+    if (auto calleeAttr = callOp.getCalleeAttr()) {
+      if (calleeAttr.getValue() == name) {
+        rapidHandle = callOp.getResult();
+      }
+    }
+  });
+  if (!rapidHandle) {
+    LLVM::LLVMFuncOp rapidInitializeFuncOp =
+        getRapidInitializeFn(typeConverter, moduleOp);
+    /// Create the LLVM::CallOp
+    OpBuilder builder(op);
+    LLVM::CallOp callOp = builder.create<LLVM::CallOp>(
+        op->getLoc(), rapidInitializeFuncOp, ValueRange{});
+    rapidHandle = callOp.getResult();
+  }
+
+  return rapidHandle;
+}
+
+LLVM::LLVMFuncOp getNotalignedRapidAllocFn(
+    const LLVMTypeConverter *typeConverter, ModuleOp module,
+    Type rapidHandleType, Type indexType) {
+  return LLVM::lookupOrCreateRapidMallocFn(module, rapidHandleType, indexType);
+}
+/// end modified
+
 } // end namespace
 
 Value AllocationOpLLVMLowering::createAligned(
@@ -78,9 +116,39 @@ std::tuple<Value, Value> AllocationOpLLVMLowering::allocateBufferManuallyAlign(
   MemRefType memRefType = getMemRefResultType(op);
   // Allocate the underlying buffer.
   Type elementPtrType = this->getElementPtrType(memRefType);
-  LLVM::LLVMFuncOp allocFuncOp = getNotalignedAllocFn(
-      getTypeConverter(), op->getParentOfType<ModuleOp>(), getIndexType());
-  auto results = rewriter.create<LLVM::CallOp>(loc, allocFuncOp, sizeBytes);
+  /// modified
+//  LLVM::LLVMFuncOp allocFuncOp = getNotalignedAllocFn(
+//      getTypeConverter(), op->getParentOfType<ModuleOp>(), getIndexType());
+//  auto results = rewriter.create<LLVM::CallOp>(loc, allocFuncOp, sizeBytes);
+  LLVM::LLVMFuncOp allocFuncOp = nullptr;
+  LLVM::CallOp results = nullptr;
+  if (StringAttr allocatorAttr = op->getAttrOfType<StringAttr>("allocator")) {
+    /// did indicate allocator
+    StringRef allocatorStr = allocatorAttr.getValue();
+    if ("rapid" == allocatorStr) {
+      /// Found the rapidHandle
+      Value rapidHandle = getRapidHandle(getTypeConverter(), op);
+//      llvm::errs() << __FILE__ << ":" << __LINE__ << " rapid_handle: " << rapidHandle << "\n";
+      allocFuncOp = getNotalignedRapidAllocFn(
+          getTypeConverter(), op->getParentOfType<ModuleOp>(),
+          getVoidPtrType()/*rapidHandleType=*/, getIndexType());
+      results = rewriter.create<LLVM::CallOp>(loc, allocFuncOp,
+            ValueRange{rapidHandle, sizeBytes});
+//      llvm::errs() << __FILE__ << ":" << __LINE__ << " rapid_malloc: " << results.getResult() << "\n";
+    } else if ("default" == allocatorStr) {
+      allocFuncOp = getNotalignedAllocFn(
+          getTypeConverter(), op->getParentOfType<ModuleOp>(), getIndexType());
+      results = rewriter.create<LLVM::CallOp>(loc, allocFuncOp, sizeBytes);
+    } else {
+      assert(false && "Unknown value for attribute `allocator`.");
+    }
+  } else {
+    /// did not indicate allocator, so use the default one.
+    allocFuncOp = getNotalignedAllocFn(
+        getTypeConverter(), op->getParentOfType<ModuleOp>(), getIndexType());
+    results = rewriter.create<LLVM::CallOp>(loc, allocFuncOp, sizeBytes);
+  }
+  /// modified
 
   Value allocatedPtr =
       castAllocFuncResult(rewriter, loc, results.getResult(), memRefType,
diff --git a/mlir/lib/Conversion/MemRefToLLVM/MemRefToLLVM.cpp b/mlir/lib/Conversion/MemRefToLLVM/MemRefToLLVM.cpp
index 2bfca303b..c84fd4a78 100644
--- a/mlir/lib/Conversion/MemRefToLLVM/MemRefToLLVM.cpp
+++ b/mlir/lib/Conversion/MemRefToLLVM/MemRefToLLVM.cpp
@@ -53,15 +53,42 @@ LLVM::LLVMFuncOp getFreeFn(const LLVMTypeConverter *typeConverter,
 }
 
 struct AllocOpLowering : public AllocLikeOpLLVMLowering {
+//  /// modified
+//  Value rapidHandle = nullptr;
+//  /// end modified
   AllocOpLowering(const LLVMTypeConverter &converter)
       : AllocLikeOpLLVMLowering(memref::AllocOp::getOperationName(),
                                 converter) {}
   std::tuple<Value, Value> allocateBuffer(ConversionPatternRewriter &rewriter,
                                           Location loc, Value sizeBytes,
                                           Operation *op) const override {
+    /// modified
     return allocateBufferManuallyAlign(
         rewriter, loc, sizeBytes, op,
         getAlignment(rewriter, loc, cast<memref::AllocOp>(op)));
+//    /// This will not work, because `allocateBuffer()` is const override, so
+//    /// its callees needs to be const, too, so we cannot modify rapidHandle.
+//    if (StringAttr allocatorAttr = op->getAttrOfType<StringAttr>("allocator")) {
+//      /// did indicate allocator.
+//      StringRef allocatorStr = allocatorAttr.getValue();
+//      if ("rapid" == allocatorStr) {
+//        return allocateRapidBufferManuallyAlign(
+//            rewriter, loc, rapidHandle, sizeBytes, op,
+//            getAlignment(rewriter, loc, cast<memref::AllocOp>(op)));
+//      } else if ("default" == allocatorStr) {
+//        return allocateBufferManuallyAlign(
+//            rewriter, loc, sizeBytes, op,
+//            getAlignment(rewriter, loc, cast<memref::AllocOp>(op)));
+//      } else {
+//        assert(false && "Unknown value for attribute `allocator`.");
+//      }
+//    } else {
+//      /// did not indicate allocator, so use the default one.
+//      return allocateBufferManuallyAlign(
+//          rewriter, loc, sizeBytes, op,
+//          getAlignment(rewriter, loc, cast<memref::AllocOp>(op)));
+//    }
+    /// end modified
   }
 };
 
diff --git a/mlir/lib/Dialect/LLVMIR/IR/FunctionCallUtils.cpp b/mlir/lib/Dialect/LLVMIR/IR/FunctionCallUtils.cpp
index 0004c2e34..1794b6f90 100644
--- a/mlir/lib/Dialect/LLVMIR/IR/FunctionCallUtils.cpp
+++ b/mlir/lib/Dialect/LLVMIR/IR/FunctionCallUtils.cpp
@@ -43,6 +43,12 @@ static constexpr llvm::StringRef kGenericAlignedAlloc =
     "_mlir_memref_to_llvm_aligned_alloc";
 static constexpr llvm::StringRef kGenericFree = "_mlir_memref_to_llvm_free";
 static constexpr llvm::StringRef kMemRefCopy = "memrefCopy";
+/// modified
+/// Functions for Rapid Allocator.
+static constexpr llvm::StringRef kRapidInitialize = "rapid_initialize";
+static constexpr llvm::StringRef kRapidMalloc = "rapid_malloc";
+static constexpr llvm::StringRef kRapidFree = "rapid_free";
+/// end modified
 
 /// Generic print function lookupOrCreate helper.
 LLVM::LLVMFuncOp mlir::LLVM::lookupOrCreateFn(ModuleOp moduleOp, StringRef name,
@@ -175,3 +181,26 @@ mlir::LLVM::lookupOrCreateMemRefCopyFn(ModuleOp moduleOp, Type indexType,
       ArrayRef<Type>{indexType, unrankedDescriptorType, unrankedDescriptorType},
       LLVM::LLVMVoidType::get(moduleOp->getContext()));
 }
+
+/// modified
+LLVM::LLVMFuncOp mlir::LLVM::lookupOrCreateRapidMallocFn(ModuleOp moduleOp,
+                                                         Type rapidHandleType,
+                                                         Type indexType) {
+  return LLVM::lookupOrCreateFn(moduleOp, kRapidMalloc,
+                                {rapidHandleType, indexType},
+                                getVoidPtr(moduleOp->getContext()));
+}
+
+LLVM::LLVMFuncOp mlir::LLVM::lookupOrCreateRapidInitializeFn(ModuleOp moduleOp) {
+  return LLVM::lookupOrCreateFn(moduleOp, kRapidInitialize,
+                                {},
+                                getVoidPtr(moduleOp->getContext()));
+}
+
+LLVM::LLVMFuncOp mlir::LLVM::lookupOrCreateRapidFreeFn(ModuleOp moduleOp) {
+  return LLVM::lookupOrCreateFn(
+      moduleOp, kRapidFree,
+      {getVoidPtr(moduleOp->getContext()), getVoidPtr(moduleOp->getContext())},
+      LLVM::LLVMVoidType::get(moduleOp->getContext()));
+}
+/// end modified
\ No newline at end of file
