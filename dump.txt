Args: llvm/build/bin/mlir-cpu-runner first.mlir -O3 -e main -entry-point-result=void -shared-libs=build/lib/libcomet_runner_utils.dylib,llvm/build/lib/libmlir_runner_utils.dylib -debug 
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefLayoutAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ElementsAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::TypedAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConditionallySpeculatable)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ResourceBlobManagerDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineBinaryOpExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineConstantExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineDimExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineMapStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::IntegerSetStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneRegion<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroSuccessors<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoRegionArguments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlock<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OpInvariants<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AffineScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsIsolatedFromAbove<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SymbolTable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasOnlyGraphRegion<Empty>)
Load new dialect in Context llvm
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMVoidType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMPPCFP128Type)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMX86MMXType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMTokenType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMLabelType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMMetadataType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMStructType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FastmathFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectInlinerInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVMTranslationDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AutomaticAllocationScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroRegions<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneResult<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConditionallySpeculatable::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ConstantLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::LLVM::LLVMPointerType>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneOperand<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FastmathFlagsInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NOperands<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneSuccessor<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BranchOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameTypeOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NSuccessors<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AttrSizedOperandSegments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameOperandsAndResultType<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsCommutative<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ReturnLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutSpecInterface)
Preparing to create LLJIT instance...
  No explicitly set JITTargetMachineBuilder. Detecting host...
  JITTargetMachineBuilder is   {
    Triple = "x86_64-apple-darwin22.5.0"
    CPU = "skylake"
    Features = "+xsaves,+sse2,-hreset,-avx512cd,-sha,+xsaveopt,-kl,-avxvnni,-mwaitx,-clzero,+sse4.2,+bmi,-cldemote,-widekl,-avx512f,-raoint,+xsavec,+lzcnt,-serialize,-avxvnniint8,+fsgsbase,+aes,+sse,-sse4a,-rdpru,-tbm,-avx512bf16,-rtm,+fma,-waitpkg,-amx-fp16,-avx512ifma,-avx512vp2intersect,+popcnt,-vaes,-prefetchi,+f16c,+avx2,+sahf,+xsave,-uintr,+fxsr,+sgx,-pconfig,-avx512er,-avx512fp16,-gfni,+rdseed,+bmi2,-movdir64b,-avx512vl,-pku,-xop,-avx512bw,-avx512vbmi,+prfchw,-rdpid,+sse3,+cx16,-vpclmulqdq,-avx512vbmi2,-enqcmd,-amx-bf16,+64bit,-amx-int8,-avx512pf,-ptwrite,-amx-tile,-lwp,-avx512vpopcntdq,-avx512dq,-avxneconvert,+mmx,-fma4,-avx512vnni,-avxifma,+avx,+cmov,+sse4.1,+movbe,+invpcid,+adx,-clwb,-prefetchwt1,-cmpccxadd,+ssse3,+cx8,+clflushopt,-tsxldtrk,+pclmul,+crc32,+rdrnd,-avx512bitalg,-shstk,-movdiri,-wbnoinvd"
    Options = <not-printable>
    Relocation Model = unspecified (will use target default)
    Code Model = unspecified (will use target default)
    Optimization Level = Default
  }
  Pre-constructed ExecutionSession: No
  DataLayout: None (will be created by JITTargetMachineBuilder)
  Custom object-linking-layer creator: Yes
  Custom compile-function creator: Yes
  Custom platform-setup function: No
  Number of compile threads: 0 (code will be compiled on the execution thread)
ExecutorProcessControl not specified, Creating SelfExecutorProcessControl instance
Defining MU /Users/flyn908/Projects/COMET/build/lib/libcomet_runner_utils.dylib for /Users/flyn908/Projects/COMET/build/lib/libcomet_runner_utils.dylib (tracker: default)  { ("_comet_print_memref_f64", [Callable]), ("_comet_memset_i1", [Callable]), ("__ZNSt3__120__half_inplace_mergeINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIfES6_S6_S6_S6_EEvT1_T2_T3_T4_T5_OT0_", [Callable][Weak]), ("__ZNSt3__120__half_inplace_mergeINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIdES6_S6_S6_S6_EEvT1_T2_T3_T4_T5_OT0_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE16__construct_nodeIJRKNS_21piecewise_construct_tENS_5tupleIJRKiEEENSH_IJEEEEEENS_10unique_ptrINS_11__tree_nodeIS5_PvEENS_22__tree_node_destructorINSA_ISP_EEEEEEDpOT_", [Callable][Weak]), ("__ZNSt3__120__half_inplace_mergeINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIfES6_S6_S6_S6_EEvT1_T2_T3_T4_T5_OT0_", [Callable][Weak]), ("__ZNSt3__120__half_inplace_mergeINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIdES6_S6_S6_S6_EEvT1_T2_T3_T4_T5_OT0_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE25__emplace_unique_key_argsIiJRKNS_21piecewise_construct_tENS_5tupleIJRKiEEENSH_IJEEEEEENS_4pairINS_15__tree_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEEbEERKT_DpOT0_", [Callable][Weak]), ("_transpose_3D_f32", [Callable]), ("_transpose_3D_f64", [Callable]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE13__lower_boundIiEENS_15__tree_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEERKT_SI_PNS_15__tree_end_nodeIPNS_16__tree_node_baseISG_EEEE", [Callable][Weak]), ("__ZNSt3__116__insertion_sortINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIdE10Coo3DTupleEEEvT1_S8_T0_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE7destroyEPNS_11__tree_nodeIS5_PvEE", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE14__erase_uniqueIiEEmRKT_", [Callable][Weak]), ("__ZNSt3__111__introsortINS_17_ClassicAlgPolicyERPFb5coo_tS2_EPS2_EEvT1_S7_T0_NS_15iterator_traitsIS7_E15difference_typeE", [Callable][Weak]), ("__ZNSt3__119__merge_move_assignINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIdES6_S6_EEvT1_S7_T2_S8_T3_T0_", [Callable][Weak]), ("__ZNSt3__116__insertion_sortINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIfE10Coo3DTupleEEEvT1_S8_T0_", [Callable][Weak]), ("__ZNSt3__119__merge_move_assignINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIfES6_S6_EEvT1_S7_T2_S8_T3_T0_", [Callable][Weak]), ("__ZNSt3__119__merge_move_assignINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIfES6_S6_EEvT1_S7_T2_S8_T3_T0_", [Callable][Weak]), ("__ZNSt3__119__merge_move_assignINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIdES6_S6_EEvT1_S7_T2_S8_T3_T0_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE7destroyEPNS_11__tree_nodeIS5_PvEE", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE25__emplace_unique_key_argsIiJRKNS_21piecewise_construct_tENS_5tupleIJRKiEEENSH_IJEEEEEENS_4pairINS_15__tree_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEEbEERKT_DpOT0_", [Callable][Weak]), ("_print_range", [Callable]), ("__ZNSt3__16vectorIiNS_9allocatorIiEEE18__construct_at_endIPiEENS_9enable_ifIXsr27__is_cpp17_forward_iteratorIT_EE5valueEvE4typeES7_S7_m", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE14__erase_uniqueIiEEmRKT_", [Callable][Weak]), ("__ZNSt3__127__tree_balance_after_insertIPNS_16__tree_node_baseIPvEEEEvT_S5_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE14__erase_uniqueIiEEmRKT_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE13__lower_boundIiEENS_15__tree_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEERKT_SI_PNS_15__tree_end_nodeIPNS_16__tree_node_baseISG_EEEE", [Callable][Weak]), ("__ZNSt3__16vectorI5coo_tNS_9allocatorIS1_EEE18__construct_at_endEm", [Callable][Weak]), ("__ZNSt3__127__insertion_sort_incompleteIRPFb5coo_tS1_EPS1_EEbT0_S6_T_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE7destroyEPNS_11__tree_nodeIS5_PvEE", [Callable][Weak]), ("__Z19printMemRefMetaDataINSt3__113basic_ostreamIcNS0_11char_traitsIcEEEEdLi2EEvRT_R17StridedMemRefTypeIT0_XT1_EE", [Callable][Weak]), ("__ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_PKc", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE16__construct_nodeIJRKNS_21piecewise_construct_tENS_5tupleIJRKiEEENSH_IJEEEEEENS_10unique_ptrINS_11__tree_nodeIS5_PvEENS_22__tree_node_destructorINSA_ISP_EEEEEEDpOT_", [Callable][Weak]), ("_print_space", [Callable]), ("__ZNSt3__17__sort4INS_17_ClassicAlgPolicyERPFb5coo_tS2_EPS2_EEjT1_S7_S7_S7_T0_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE7destroyEPNS_11__tree_nodeIS5_PvEE", [Callable][Weak]), ("__ZNSt3__120__half_inplace_mergeINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIfE10Coo3DTupleES7_S7_S7_S7_EEvT1_T2_T3_T4_T5_OT0_", [Callable][Weak]), ("__Z12radix_bucketRNSt3__16vectorI5coo_tNS_9allocatorIS1_EEEEi", [Callable]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE16__construct_nodeIJRKNS_21piecewise_construct_tENS_5tupleIJRKiEEENSH_IJEEEEEENS_10unique_ptrINS_11__tree_nodeIS5_PvEENS_22__tree_node_destructorINSA_ISP_EEEEEEDpOT_", [Callable][Weak]), ("__ZNSt3__116__insertion_sortINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIfEEEvT1_S7_T0_", [Callable][Weak]), ("_quick_sort", [Callable]), ("_print_f64", [Callable]), ("__Z11count_radixRNSt3__16vectorI5coo_tNS_9allocatorIS1_EEEEii", [Callable]), ("__ZNSt3__116__insertion_sortINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIdEEEvT1_S7_T0_", [Callable][Weak]), ("__ZNSt3__119__merge_move_assignINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIfE10Coo3DTupleES7_S7_EEvT1_S8_T2_S9_T3_T0_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE5eraseENS_21__tree_const_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEE", [Callable][Weak]), ("__Z10quick_sortRNSt3__16vectorI5coo_tNS_9allocatorIS1_EEEEiii", [Callable]), ("__ZNSt3__119__merge_move_assignINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIdE10Coo3DTupleES7_S7_EEvT1_S8_T2_S9_T3_T0_", [Callable][Weak]), ("__ZNSt3__16vectorI6bucketNS_9allocatorIS1_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS1_RS3_EE", [Callable][Weak]), ("__ZNSt3__122__merge_move_constructINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIfES6_EEvT1_S7_T2_S8_PNS_15iterator_traitsIS7_E10value_typeET0_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE5eraseENS_21__tree_const_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEE", [Callable][Weak]), ("_get_cpu_name", [Callable]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE4findIiEENS_15__tree_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEERKT_", [Callable][Weak]), ("__ZNSt3__122__merge_move_constructINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIdES6_EEvT1_S7_T2_S8_PNS_15iterator_traitsIS7_E10value_typeET0_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE25__emplace_unique_key_argsIiJRKNS_21piecewise_construct_tENS_5tupleIJRKiEEENSH_IJEEEEEENS_4pairINS_15__tree_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEEbEERKT_DpOT0_", [Callable][Weak]), ("__ZNSt3__124__put_character_sequenceIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_PKS4_m", [Callable][Weak]), ("_vpu_count", [Callable]), ("__ZNSt3__122__merge_move_constructINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIdES6_EEvT1_S7_T2_S8_PNS_15iterator_traitsIS7_E10value_typeET0_", [Callable][Weak]), ("__ZNSt3__16vectorIiNS_9allocatorIiEEE6assignIPiEENS_9enable_ifIXaasr27__is_cpp17_forward_iteratorIT_EE5valuesr16is_constructibleIiNS_15iterator_traitsIS7_E9referenceEEE5valueEvE4typeES7_S7_", [Callable][Weak]), ("__Z19printMemRefMetaDataIdNSt3__113basic_ostreamIcNS0_11char_traitsIcEEEEEvRT0_RK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZNSt3__16vectorIiNS_9allocatorIiEEE13__vdeallocateEv", [Callable][Weak]), ("__ZNSt3__121__insertion_sort_moveINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIfEEEvT1_S7_PNS_15iterator_traitsIS7_E10value_typeET0_", [Callable][Weak]), ("_print_f32", [Callable]), ("__ZNSt3__120get_temporary_bufferI8CooTupleIfEEENS_4pairIPT_lEEl", [Callable][Weak]), ("__ZNSt3__121__insertion_sort_moveINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIdEEEvT1_S7_PNS_15iterator_traitsIS7_E10value_typeET0_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE13__lower_boundIiEENS_15__tree_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEERKT_SI_PNS_15__tree_end_nodeIPNS_16__tree_node_baseISG_EEEE", [Callable][Weak]), ("__ZNSt3__16vectorI6bucketNS_9allocatorIS1_EEE13shrink_to_fitEv", [Callable][Weak]), ("__ZNSt3__121__insertion_sort_moveINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIfEEEvT1_S7_PNS_15iterator_traitsIS7_E10value_typeET0_", [Callable][Weak]), ("__ZNSt3__116__insertion_sortINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIfEEEvT1_S7_T0_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE14__erase_uniqueIiEEmRKT_", [Callable][Weak]), ("__ZNSt3__16vectorIiNS_9allocatorIiEEE18__construct_at_endEm", [Callable][Weak]), ("__ZNSt3__121__insertion_sort_moveINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIdEEEvT1_S7_PNS_15iterator_traitsIS7_E10value_typeET0_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE16__construct_nodeIJRKNS_21piecewise_construct_tENS_5tupleIJRKiEEENSH_IJEEEEEENS_10unique_ptrINS_11__tree_nodeIS5_PvEENS_22__tree_node_destructorINSA_ISP_EEEEEEDpOT_", [Callable][Weak]), ("__ZNSt3__116__insertion_sortINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIdEEEvT1_S7_T0_", [Callable][Weak]), ("__ZNSt3__122__merge_move_constructINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIfES6_EEvT1_S7_T2_S8_PNS_15iterator_traitsIS7_E10value_typeET0_", [Callable][Weak]), ("__mlir_ciface_linalg_matmul_viewsxsxf64_viewsxsxf64_viewsxsxf64", [Callable]), ("__ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIfEEEvT1_S7_T0_NS_15iterator_traitsIS7_E15difference_typeEPNSA_10value_typeEl", [Callable][Weak]), ("__ZNSt3__120get_temporary_bufferIN11Coo3DTensorIdE10Coo3DTupleEEENS_4pairIPT_lEEl", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE13__lower_boundIiEENS_15__tree_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEERKT_SI_PNS_15__tree_end_nodeIPNS_16__tree_node_baseISG_EEEE", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE4findIiEENS_15__tree_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEERKT_", [Callable][Weak]), ("__ZNSt3__120get_temporary_bufferIN11Coo3DTensorIfE10Coo3DTupleEEENS_4pairIPT_lEEl", [Callable][Weak]), ("__ZNSt3__124__buffered_inplace_mergeINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIdEEEvT1_S7_S7_OT0_NS_15iterator_traitsIS7_E15difference_typeESC_PNSB_10value_typeE", [Callable][Weak]), ("__Z10cometPrintIdEvRK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZNSt3__118__tree_left_rotateIPNS_16__tree_node_baseIPvEEEEvT_", [Callable][Weak]), ("__ZNSt3__124__buffered_inplace_mergeINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIfEEEvT1_S7_S7_OT0_NS_15iterator_traitsIS7_E15difference_typeESC_PNSB_10value_typeE", [Callable][Weak]), ("__ZNSt3__120get_temporary_bufferI8CooTupleIdEEENS_4pairIPT_lEEl", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE5eraseENS_21__tree_const_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEE", [Callable][Weak]), ("__ZNSt3__118__stable_sort_moveINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIdEEEvT1_S7_T0_NS_15iterator_traitsIS7_E15difference_typeEPNSA_10value_typeE", [Callable][Weak]), ("__Z11cometMemsetIbEvR18UnrankedMemRefTypeIT_E", [Callable][Weak]), ("__ZNSt3__113__tree_removeIPNS_16__tree_node_baseIPvEEEEvT_S5_", [Callable][Weak]), ("__ZNSt3__118__stable_sort_moveINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIfEEEvT1_S7_T0_NS_15iterator_traitsIS7_E15difference_typeEPNSA_10value_typeE", [Callable][Weak]), ("__Z10cometPrintIxEvRK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZNSt3__13mapIiP11Coo3DTensorIdENS_4lessIiEENS_9allocatorINS_4pairIKiS3_EEEEEixERS8_", [Callable][Weak]), ("__ZNSt3__13mapIiP11Coo3DTensorIfENS_4lessIiEENS_9allocatorINS_4pairIKiS3_EEEEEixERS8_", [Callable][Weak]), ("_bli_cpuid_is_bulldozer", [Callable]), ("__ZNSt3__118__stable_sort_moveINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIdEEEvT1_S7_T0_NS_15iterator_traitsIS7_E15difference_typeEPNSA_10value_typeE", [Callable][Weak]), ("__Z11cometMemsetIxEvR18UnrankedMemRefTypeIT_E", [Callable][Weak]), ("__ZNKSt3__16vectorI6bucketNS_9allocatorIS1_EEE8max_sizeEv", [Callable][Weak]), ("__ZNSt3__121__insertion_sort_moveINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIfE10Coo3DTupleEEEvT1_S8_PNS_15iterator_traitsIS8_E10value_typeET0_", [Callable][Weak]), ("__ZNSt3__13mapIiP9CooMatrixIdENS_4lessIiEENS_9allocatorINS_4pairIKiS3_EEEEEixERS8_", [Callable][Weak]), ("__Z11cometMemsetIdEvR18UnrankedMemRefTypeIT_E", [Callable][Weak]), ("__ZNSt3__111__tree_nextIPNS_16__tree_node_baseIPvEEEET_S5_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSH_SH_", [Callable][Weak]), ("__Z14getNumNonZerosIfEiP9CooMatrixIT_Ei", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE4findIiEENS_15__tree_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEERKT_", [Callable][Weak]), ("__ZNSt3__16vectorIiNS_9allocatorIiEEE13__move_assignERS3_NS_17integral_constantIbLb1EEE", [Callable][Weak]), ("__Z9partitionRNSt3__16vectorI5coo_tNS_9allocatorIS1_EEEEiii", [Callable]), ("__Z14getNumNonZerosIdEiP9CooMatrixIT_Ei", [Callable][Weak]), ("__ZNSt3__13mapIiP9CooMatrixIfENS_4lessIiEENS_9allocatorINS_4pairIKiS3_EEEEEixERS8_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE5eraseENS_21__tree_const_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEE", [Callable][Weak]), ("__Z19read_input_sizes_2DIfEviiiiiiPvi", [Callable][Weak]), ("__Z13read_input_3DIdEviiiiiPviS0_iS0_iS0_iS0_iS0_iS0_i", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE4findIiEENS_15__tree_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEERKT_", [Callable][Weak]), ("__ZNSt3__122__merge_move_constructINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIdE10Coo3DTupleES7_EEvT1_S8_T2_S9_PNS_15iterator_traitsIS8_E10value_typeET0_", [Callable][Weak]), ("__Z19read_input_sizes_2DIdEviiiiiiPvi", [Callable][Weak]), ("__ZNSt3__118__stable_sort_moveINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIfEEEvT1_S7_T0_NS_15iterator_traitsIS7_E15difference_typeEPNSA_10value_typeE", [Callable][Weak]), ("__Z16cometPrintMemRefIdEvR18UnrankedMemRefTypeIT_E", [Callable][Weak]), ("__ZNSt3__122__merge_move_constructINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIfE10Coo3DTupleES7_EEvT1_S8_T2_S9_PNS_15iterator_traitsIS8_E10value_typeET0_", [Callable][Weak]), ("__Z19read_input_sizes_3DIfEviiiiiPvi", [Callable][Weak]), ("__ZNSt3__120__half_inplace_mergeINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIdE10Coo3DTupleES7_S7_S7_S7_EEvT1_T2_T3_T4_T5_OT0_", [Callable][Weak]), ("__Z19read_input_sizes_3DIdEviiiiiPvi", [Callable][Weak]), ("__Z13read_input_2DIdEviiiiiiPviS0_iS0_iS0_iS0_iS0_iS0_iS0_iS0_i", [Callable][Weak]), ("__ZNKSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE14__count_uniqueIiEEmRKT_", [Callable][Weak]), ("__Z20sort_compare_coord_05coo_tS_", [Callable]), ("__Z12transpose_2DIfEviiiPviS0_iS0_iS0_iS0_iiiS0_iS0_iS0_iS0_iS0_iS0_", [Callable][Weak]), ("__Z19sort_compare_coords5coo_tS_", [Callable]), ("__ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIfE10Coo3DTupleEEEvT1_S8_S8_OT0_NS_15iterator_traitsIS8_E15difference_typeESD_PNSC_10value_typeEl", [Callable][Weak]), ("__ZNSt3__16vectorIiNS_9allocatorIiEEE26__swap_out_circular_bufferERNS_14__split_bufferIiRS2_EE", [Callable][Weak]), ("__Z20sort_compare_coord_25coo_tS_", [Callable]), ("__ZNKSt3__16__treeINS_12__value_typeIiP9CooMatrixIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE14__count_uniqueIiEEmRKT_", [Callable][Weak]), ("__ZNSt3__118__stable_sort_moveINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIdE10Coo3DTupleEEEvT1_S8_T0_NS_15iterator_traitsIS8_E15difference_typeEPNSB_10value_typeE", [Callable][Weak]), ("__Z14transpose_sortiRNSt3__16vectorI5coo_tNS_9allocatorIS1_EEEEiii", [Callable]), ("__Z20sort_compare_coord_15coo_tS_", [Callable]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE25__emplace_unique_key_argsIiJRKNS_21piecewise_construct_tENS_5tupleIJRKiEEENSH_IJEEEEEENS_4pairINS_15__tree_iteratorIS5_PNS_11__tree_nodeIS5_PvEElEEbEERKT_DpOT0_", [Callable][Weak]), ("__Z9printDataIxEvRNSt3__113basic_ostreamIcNS0_11char_traitsIcEEEEPT_xxxPKxS9_", [Callable][Weak]), ("__Z8RTmemsetIbEvRK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__Z23dgemm_generic_noopt_mxnxxxPdS_S_S_S_xx", [Callable]), ("__Z9printDataIdEvRNSt3__113basic_ostreamIcNS0_11char_traitsIcEEEEPT_xxxPKxS9_", [Callable][Weak]), ("__ZNSt3__118__stable_sort_moveINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIfE10Coo3DTupleEEEvT1_S8_T0_NS_15iterator_traitsIS8_E15difference_typeEPNSB_10value_typeE", [Callable][Weak]), ("_bli_arch_set_logging", [Callable]), ("__Z8RTmemsetIxEvRK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZNSt3__119__tree_right_rotateIPNS_16__tree_node_baseIPvEEEEvT_", [Callable][Weak]), ("_bli_arch_set_id_once", [Callable]), ("__Z8RTmemsetIdEvRK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZNKSt3__16__treeINS_12__value_typeIiP9CooMatrixIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE14__count_uniqueIiEEmRKT_", [Callable][Weak]), ("__ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIdEEEvT1_S7_T0_NS_15iterator_traitsIS7_E15difference_typeEPNSA_10value_typeEl", [Callable][Weak]), ("__mlir_ciface_comet_print_memref_f64", [Callable]), ("__ZNSt3__124__buffered_inplace_mergeINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIdEEEvT1_S7_S7_OT0_NS_15iterator_traitsIS7_E15difference_typeESC_PNSB_10value_typeE", [Callable][Weak]), ("__ZNSt3__16__sortIRPFb5coo_tS1_EPS1_EEvT0_S6_T_", [Callable][Weak]), ("_bli_arch_string", [Callable]), ("_bli_cgemm_haswell_asm_3x8", [Callable]), ("__ZNSt3__124__buffered_inplace_mergeINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIfEEEvT1_S7_S7_OT0_NS_15iterator_traitsIS7_E15difference_typeESC_PNSB_10value_typeE", [Callable][Weak]), ("_getTime", [Callable]), ("__ZNSt3__120__half_inplace_mergeINS_17_ClassicAlgPolicyENS_8__invertIR21Coo3DTensorComparatorEENS_16reverse_iteratorIPN11Coo3DTensorIdE10Coo3DTupleEEESB_SB_SB_SB_EEvT1_T2_T3_T4_T5_OT0_", [Callable][Weak]), ("__Z13read_input_2DIfEviiiiiiPviS0_iS0_iS0_iS0_iS0_iS0_iS0_iS0_i", [Callable][Weak]), ("__mlir_ciface_comet_print_memref_i64", [Callable]), ("__Z10count_sortRNSt3__16vectorI5coo_tNS_9allocatorIS1_EEEEii", [Callable]), ("_print_i32", [Callable]), ("__ZNSt3__120__half_inplace_mergeINS_17_ClassicAlgPolicyENS_8__invertIR21Coo3DTensorComparatorEENS_16reverse_iteratorIPN11Coo3DTensorIfE10Coo3DTupleEEESB_SB_SB_SB_EEvT1_T2_T3_T4_T5_OT0_", [Callable][Weak]), ("_bli_arch_log", [Callable]), ("__ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIfEEEvT1_S7_T0_NS_15iterator_traitsIS7_E15difference_typeEPNSA_10value_typeEl", [Callable][Weak]), ("__Z12transpose_2DIdEviiiPviS0_iS0_iS0_iS0_iiiS0_iS0_iS0_iS0_iS0_iS0_", [Callable][Weak]), ("__Z11count_quickRNSt3__16vectorI5coo_tNS_9allocatorIS1_EEEEii", [Callable]), ("__ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIdEEEvT1_S7_T0_NS_15iterator_traitsIS7_E15difference_typeEPNSA_10value_typeEl", [Callable][Weak]), ("_bli_cpuid_is_haswell", [Callable]), ("__ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIfEEEvT1_S7_S7_OT0_NS_15iterator_traitsIS7_E15difference_typeESC_PNSB_10value_typeEl", [Callable][Weak]), ("_bli_cpuid_is_excavator", [Callable]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE12__find_equalIiEERPNS_16__tree_node_baseIPvEERPNS_15__tree_end_nodeISH_EERKT_", [Callable][Weak]), ("_bli_cpuid_is_piledriver", [Callable]), ("_bli_cpuid_is_knl", [Callable]), ("_bli_cpuid_is_penryn", [Callable]), ("__ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIdEEEvT1_S7_S7_OT0_NS_15iterator_traitsIS7_E15difference_typeESC_PNSB_10value_typeEl", [Callable][Weak]), ("_bli_cpuid_is_skx", [Callable]), ("_bli_cpuid_is_steamroller", [Callable]), ("_bli_cpuid_is_sandybridge", [Callable]), ("_bli_cpuid_is_zen2", [Callable]), ("__ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIdE10Coo3DTupleEEEvT1_S8_T0_NS_15iterator_traitsIS8_E15difference_typeEPNSB_10value_typeEl", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSH_SH_", [Callable][Weak]), ("__ZNKSt3__16vectorIiNS_9allocatorIiEEE8max_sizeEv", [Callable][Weak]), ("__ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyER16CooComparatorRowP8CooTupleIfEEEvT1_S7_S7_OT0_NS_15iterator_traitsIS7_E15difference_typeESC_PNSB_10value_typeEl", [Callable][Weak]), ("_bli_cpuid_is_zen", [Callable]), ("_bli_arch_query_id", [Callable]), ("_bli_arch_get_logging", [Callable]), ("_bli_arch_set_id", [Callable]), ("__mlir_ciface_comet_memset_i1", [Callable]), ("__ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIfE10Coo3DTupleEEEvT1_S8_T0_NS_15iterator_traitsIS8_E15difference_typeEPNSB_10value_typeEl", [Callable][Weak]), ("__ZNSt3__124__buffered_inplace_mergeINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIdE10Coo3DTupleEEEvT1_S8_S8_OT0_NS_15iterator_traitsIS8_E15difference_typeESD_PNSC_10value_typeE", [Callable][Weak]), ("__mlir_ciface_comet_memset_i64", [Callable]), ("__Z10qsort_compPKvS0_", [Callable]), ("__mlir_ciface_comet_memset_f64", [Callable]), ("__ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIdE10Coo3DTupleEEEvT1_S8_S8_OT0_NS_15iterator_traitsIS8_E15difference_typeESD_PNSC_10value_typeEl", [Callable][Weak]), ("__Z19getMatrixReadOptioni", [Callable]), ("__Z4swapP5coo_tS0_", [Callable]), ("__ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyER16CooComparatorColP8CooTupleIdEEEvT1_S7_S7_OT0_NS_15iterator_traitsIS7_E15difference_typeESC_PNSB_10value_typeEl", [Callable][Weak]), ("__ZNKSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE14__count_uniqueIiEEmRKT_", [Callable][Weak]), ("__Z20qsort_compare_coordsPKvS0_", [Callable]), ("__Z16cometPrintMemRefIxEvR18UnrankedMemRefTypeIT_E", [Callable][Weak]), ("__Z11getSortTypeRi", [Callable]), ("__ZNSt3__124__buffered_inplace_mergeINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIfE10Coo3DTupleEEEvT1_S8_S8_OT0_NS_15iterator_traitsIS8_E15difference_typeESD_PNSC_10value_typeE", [Callable][Weak]), ("_read_input_2D_f64", [Callable]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE12__find_equalIiEERPNS_16__tree_node_baseIPvEERPNS_15__tree_end_nodeISH_EERKT_", [Callable][Weak]), ("__ZNSt3__120__half_inplace_mergeINS_17_ClassicAlgPolicyENS_8__invertIR16CooComparatorRowEENS_16reverse_iteratorIP8CooTupleIdEEESA_SA_SA_SA_EEvT1_T2_T3_T4_T5_OT0_", [Callable][Weak]), ("_read_input_2D_f32", [Callable]), ("_printElapsedTime", [Callable]), ("_read_input_3D_f64", [Callable]), ("_read_input_3D_f32", [Callable]), ("__ZNSt3__120__half_inplace_mergeINS_17_ClassicAlgPolicyENS_8__invertIR16CooComparatorRowEENS_16reverse_iteratorIP8CooTupleIfEEESA_SA_SA_SA_EEvT1_T2_T3_T4_T5_OT0_", [Callable][Weak]), ("_read_input_sizes_3D_f32", [Callable]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIdEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSH_SH_", [Callable][Weak]), ("_read_input_sizes_2D_f64", [Callable]), ("_read_input_sizes_2D_f32", [Callable]), ("_transpose_2D_f64", [Callable]), ("__Z12transpose_3DIdEviiiiiiPviS0_iS0_iS0_iS0_iS0_iS0_iiiiS0_iS0_iS0_iS0_iS0_iS0_iS0_iS0_", [Callable][Weak]), ("__ZNSt3__121__insertion_sort_moveINS_17_ClassicAlgPolicyER21Coo3DTensorComparatorPN11Coo3DTensorIdE10Coo3DTupleEEEvT1_S8_PNS_15iterator_traitsIS8_E10value_typeET0_", [Callable][Weak]), ("_transpose_2D_f32", [Callable]), ("__ZNSt3__16__treeINS_12__value_typeIiP9CooMatrixIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE12__find_equalIiEERPNS_16__tree_node_baseIPvEERPNS_15__tree_end_nodeISH_EERKT_", [Callable][Weak]), ("_read_input_sizes_3D_f64", [Callable]), ("_bli_cpuid_query_id", [Callable]), ("__Z12transpose_3DIfEviiiiiiPviS0_iS0_iS0_iS0_iS0_iS0_iiiiS0_iS0_iS0_iS0_iS0_iS0_iS0_iS0_", [Callable][Weak]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE12__find_equalIiEERPNS_16__tree_node_baseIPvEERPNS_15__tree_end_nodeISH_EERKT_", [Callable][Weak]), ("_bli_cpuid_query", [Callable]), ("_bli_cpuid_is_zen3", [Callable]), ("_bli_zgemm_haswell_asm_3x4", [Callable]), ("__Z16generate_bucketsRNSt3__16vectorI5coo_tNS_9allocatorIS1_EEEEiRNS0_I6bucketNS2_IS6_EEEE", [Callable]), ("__ZNSt3__120__half_inplace_mergeINS_17_ClassicAlgPolicyENS_8__invertIR16CooComparatorColEENS_16reverse_iteratorIP8CooTupleIdEEESA_SA_SA_SA_EEvT1_T2_T3_T4_T5_OT0_", [Callable][Weak]), ("_bli_sgemm_haswell_asm_6x16", [Callable]), ("_bli_dgemm_haswell_asm_6x8", [Callable]), ("__ZNSt3__114__partial_sortINS_17_ClassicAlgPolicyERPFb5coo_tS2_EPS2_S6_EET1_S7_S7_T2_RT0_", [Callable][Weak]), ("__ZNSt3__118__insertion_sort_3INS_17_ClassicAlgPolicyERPFb5coo_tS2_EPS2_EEvT1_S7_T0_", [Callable][Weak]), ("_comet_memset_f64", [Callable]), ("__ZNSt3__16__treeINS_12__value_typeIiP11Coo3DTensorIfEEENS_19__map_value_compareIiS5_NS_4lessIiEELb1EEENS_9allocatorIS5_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSH_SH_", [Callable][Weak]), ("__Z13read_input_3DIfEviiiiiPviS0_iS0_iS0_iS0_iS0_iS0_i", [Callable][Weak]), ("_comet_print_memref_i64", [Callable]), ("__ZNSt3__120__half_inplace_mergeINS_17_ClassicAlgPolicyENS_8__invertIR16CooComparatorColEENS_16reverse_iteratorIP8CooTupleIfEEESA_SA_SA_SA_EEvT1_T2_T3_T4_T5_OT0_", [Callable][Weak]), ("__ZNSt3__119__partial_sort_implINS_17_ClassicAlgPolicyERPFb5coo_tS2_EPS2_S6_EET1_S7_S7_T2_OT0_", [Callable][Weak]), ("__ZNKSt3__16vectorI5coo_tNS_9allocatorIS1_EEE8max_sizeEv", [Callable][Weak]), ("_comet_memset_i64", [Callable]) }
Defining MU /Users/flyn908/Projects/COMET/llvm/build/lib/libmlir_runner_utils.dylib for /Users/flyn908/Projects/COMET/llvm/build/lib/libmlir_runner_utils.dylib (tracker: default)  { ("__mlir_ciface_nanoTime", [Callable]), ("__ZN4impl12verifyMemRefIiEExRK17DynamicMemRefTypeIT_ES5_", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterIyE9printLastERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPyxxxPKxSA_", [Callable][Weak]), ("__mlir_ciface_printMemref0dF32", [Callable]), ("__mlir_ciface_printMemref1dC64", [Callable]), ("__ZN4impl12verifyMemRefIiEExR18UnrankedMemRefTypeIT_ES4_", [Callable][Weak]), ("__mlir_ciface_printMemref1dF32", [Callable]), ("__ZN4impl17VectorDataPrinterIfLi4EJEE5printERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEERK6VectorIfLi4EJEE", [Callable][Weak]), ("__ZN4impl12verifyMemRefIfEExRK17DynamicMemRefTypeIT_ES5_", [Callable][Weak]), ("__mlir_ciface_printMemref1dC32", [Callable]), ("__mlir_ciface_printMemrefF32", [Callable]), ("__mlir_ciface_printMemrefF64", [Callable]), ("__ZN4impl17MemRefDataPrinterIyE10printFirstERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPyxxxPKxSA_", [Callable][Weak]), ("__ZN4impl18MemRefDataVerifierIdE25verifyRelErrorSmallerThanEddd", [Callable][Weak]), ("__mlir_ciface_printMemrefI32", [Callable]), ("__ZN4impl12verifyMemRefIyEExRK17DynamicMemRefTypeIT_ES5_", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterIyE5printERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPyxxxPKxSA_", [Callable][Weak]), ("__mlir_ciface_printMemrefC32", [Callable]), ("__mlir_ciface_printMemrefC64", [Callable]), ("__mlir_ciface_printMemref1dF64", [Callable]), ("__ZN4impl12verifyMemRefIyEExR18UnrankedMemRefTypeIT_ES4_", [Callable][Weak]), ("__Z19printMemRefMetaDataINSt3__17complexIdEENS0_13basic_ostreamIcNS0_11char_traitsIcEEEEEvRT0_RK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterIxE5printERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPxxxxPKxSA_", [Callable][Weak]), ("__mlir_ciface_printMemref4dF32", [Callable]), ("_printMemrefI64", [Callable]), ("__mlir_ciface_printMemref3dF32", [Callable]), ("__Z19printMemRefMetaDataI6VectorIfLi4EJLi4EEENSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEEvRT0_RK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterIxE9printLastERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPxxxxPKxSA_", [Callable][Weak]), ("__ZN4impl18MemRefDataVerifierIfE25verifyRelErrorSmallerThanEfff", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterIiE9printLastERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPixxxPKxSA_", [Callable][Weak]), ("__mlir_ciface_printMemref1dI64", [Callable]), ("__mlir_ciface_printMemref1dI32", [Callable]), ("__Z19printMemRefMetaDataINSt3__17complexIfEENS0_13basic_ostreamIcNS0_11char_traitsIcEEEEEvRT0_RK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZNSt3__1lsIdcNS_11char_traitsIcEEEERNS_13basic_ostreamIT0_T1_EES7_RKNS_7complexIT_EE", [Callable][Weak]), ("__mlir_ciface_printMemref2dF32", [Callable]), ("__ZN4impl17MemRefDataPrinterIxE10printFirstERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPxxxxPKxSA_", [Callable][Weak]), ("__mlir_ciface_printMemref1dInd", [Callable]), ("_printMemrefC32", [Callable]), ("__mlir_ciface_printMemref1dI8", [Callable]), ("_verifyMemRefInd", [Callable]), ("__ZN4impl17MemRefDataPrinterIiE10printFirstERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPixxxPKxSA_", [Callable][Weak]), ("__ZNSt3__1lsIfcNS_11char_traitsIcEEEERNS_13basic_ostreamIT0_T1_EES7_RKNS_7complexIT_EE", [Callable][Weak]), ("_verifyMemRefI32", [Callable]), ("__ZN4impl11printMemRefIiEEvRK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterIiE5printERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPixxxPKxSA_", [Callable][Weak]), ("__ZN4impl11printMemRefIiEEvR18UnrankedMemRefTypeIT_E", [Callable][Weak]), ("_verifyMemRefF32", [Callable]), ("__ZN4impl11printMemRefIfLi4EEEvR17StridedMemRefTypeIT_XT0_EE", [Callable][Weak]), ("_verifyMemRefF64", [Callable]), ("__ZN4impl17MemRefDataPrinterIfE5printERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPfxxxPKxSA_", [Callable][Weak]), ("__ZN4impl11printMemRefIxLi1EEEvR17StridedMemRefTypeIT_XT0_EE", [Callable][Weak]), ("__ZN4impl11printMemRefIxEEvRK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl11printMemRefIxEEvR18UnrankedMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterIfE9printLastERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPfxxxPKxSA_", [Callable][Weak]), ("__ZN4impl11printMemRefIiLi1EEEvR17StridedMemRefTypeIT_XT0_EE", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterIdE9printLastERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPdxxxPKxSA_", [Callable][Weak]), ("__mlir_ciface_verifyMemRefC32", [Callable]), ("__ZN4impl11printMemRefIyLi1EEEvR17StridedMemRefTypeIT_XT0_EE", [Callable][Weak]), ("__ZN4impl11printMemRefIyEEvRK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__mlir_ciface_verifyMemRefC64", [Callable]), ("__ZN4impl17MemRefDataPrinterIfE10printFirstERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPfxxxPKxSA_", [Callable][Weak]), ("__ZN4impl11printMemRefIyEEvR18UnrankedMemRefTypeIT_E", [Callable][Weak]), ("__mlir_ciface_printMemrefI64", [Callable]), ("__mlir_ciface_printMemrefInd", [Callable]), ("__mlir_ciface_printMemrefI8", [Callable]), ("__ZN4impl12verifyMemRefIfEExR18UnrankedMemRefTypeIT_ES4_", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterIdE10printFirstERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPdxxxPKxSA_", [Callable][Weak]), ("__mlir_ciface_verifyMemRefInd", [Callable]), ("__ZN4impl12verifyMemRefIdEExRK17DynamicMemRefTypeIT_ES5_", [Callable][Weak]), ("_verifyMemRefC32", [Callable]), ("__ZN4impl17MemRefDataPrinterIdE5printERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPdxxxPKxSA_", [Callable][Weak]), ("__mlir_ciface_verifyMemRefF64", [Callable]), ("__mlir_ciface_verifyMemRefF32", [Callable]), ("__ZN4impl18MemRefDataVerifierIyE10verifyElemEyy", [Callable][Weak]), ("__mlir_ciface_verifyMemRefI32", [Callable]), ("__ZN4impl12verifyMemRefIdEExR18UnrankedMemRefTypeIT_ES4_", [Callable][Weak]), ("__ZN4impl18MemRefDataVerifierIiE10verifyElemEii", [Callable][Weak]), ("__ZN4impl11printMemRefIaEEvRK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl17VectorDataPrinterIfLi4EJLi4EEE5printERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEERK6VectorIfLi4EJLi4EEE", [Callable][Weak]), ("__mlir_ciface_printMemrefShapeF32", [Callable]), ("__mlir_ciface_printMemrefShapeF64", [Callable]), ("__ZN4impl11printMemRefINSt3__17complexIdEEEEvR18UnrankedMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl11printMemRefIaLi1EEEvR17StridedMemRefTypeIT_XT0_EE", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterIaE10printFirstERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPaxxxPKxSA_", [Callable][Weak]), ("__mlir_ciface_printMemrefShapeC32", [Callable]), ("__ZN4impl11printMemRefI6VectorIfLi4EJLi4EEEEEvRK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl18MemRefDataVerifierINSt3__17complexIdEEE6verifyERNS1_13basic_ostreamIcNS1_11char_traitsIcEEEEPS3_SA_xxPKxSC_Rx", [Callable][Weak]), ("__mlir_ciface_printMemrefShapeC64", [Callable]), ("__Z19printMemRefMetaDataIyNSt3__113basic_ostreamIcNS0_11char_traitsIcEEEEEvRT0_RK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl11printMemRefI6VectorIfLi4EJLi4EEELi2EEEvR17StridedMemRefTypeIT_XT0_EE", [Callable][Weak]), ("__ZN4impl11printMemRefINSt3__17complexIdEELi1EEEvR17StridedMemRefTypeIT_XT0_EE", [Callable][Weak]), ("__ZN4impl11printMemRefIaEEvR18UnrankedMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl11printMemRefIdEEvRK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl11printMemRefIdLi1EEEvR17StridedMemRefTypeIT_XT0_EE", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterINSt3__17complexIfEEE5printERNS1_13basic_ostreamIcNS1_11char_traitsIcEEEEPS3_xxxPKxSC_", [Callable][Weak]), ("__mlir_ciface_printMemrefShapeI8", [Callable]), ("__ZN4impl11printMemRefINSt3__17complexIfEEEEvR18UnrankedMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterIaE9printLastERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPaxxxPKxSA_", [Callable][Weak]), ("__mlir_ciface_printMemrefShapeI32", [Callable]), ("__mlir_ciface_printMemrefShapeInd", [Callable]), ("__ZN4impl11printMemRefINSt3__17complexIdEEEEvRK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterINSt3__17complexIfEEE9printLastERNS1_13basic_ostreamIcNS1_11char_traitsIcEEEEPS3_xxxPKxSC_", [Callable][Weak]), ("__mlir_ciface_printMemrefShapeI64", [Callable]), ("__ZN4impl11printMemRefIdEEvR18UnrankedMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterIaE5printERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPaxxxPKxSA_", [Callable][Weak]), ("_printCString", [Callable]), ("_printMemrefInd", [Callable]), ("__ZN4impl11printMemRefIfEEvRK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("_printMemrefF32", [Callable]), ("__Z19printMemRefMetaDataIfNSt3__113basic_ostreamIcNS0_11char_traitsIcEEEEEvRT0_RK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl11printMemRefIfLi0EEEvR17StridedMemRefTypeIT_XT0_EE", [Callable][Weak]), ("__ZN4impl11printMemRefIfEEvR18UnrankedMemRefTypeIT_E", [Callable][Weak]), ("__mlir_ciface_printMemrefVector4x4xf32", [Callable]), ("_verifyMemRefC64", [Callable]), ("__Z19printMemRefMetaDataIaNSt3__113basic_ostreamIcNS0_11char_traitsIcEEEEEvRT0_RK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_PKc", [Callable][Weak]), ("__Z19printMemRefMetaDataIxNSt3__113basic_ostreamIcNS0_11char_traitsIcEEEEEvRT0_RK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl11printMemRefIfLi3EEEvR17StridedMemRefTypeIT_XT0_EE", [Callable][Weak]), ("__ZN4impl18MemRefDataVerifierINSt3__17complexIfEEE6verifyERNS1_13basic_ostreamIcNS1_11char_traitsIcEEEEPS3_SA_xxPKxSC_Rx", [Callable][Weak]), ("__ZN4impl11printMemRefIfLi1EEEvR17StridedMemRefTypeIT_XT0_EE", [Callable][Weak]), ("__ZN4impl11printMemRefIfLi2EEEvR17StridedMemRefTypeIT_XT0_EE", [Callable][Weak]), ("__Z19printMemRefMetaDataIiNSt3__113basic_ostreamIcNS0_11char_traitsIcEEEEEvRT0_RK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZNSt3__1lsIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS_13basic_ostreamIT_T0_EES9_RKNS_12basic_stringIS6_S7_T1_EE", [Callable][Weak]), ("_printMemrefC64", [Callable]), ("__ZN4impl17MemRefDataPrinterI6VectorIfLi4EJLi4EEEE9printLastERNSt3__113basic_ostreamIcNS4_11char_traitsIcEEEEPS2_xxxPKxSC_", [Callable][Weak]), ("__ZN4impl18MemRefDataVerifierINSt3__17complexIdEEE10verifyElemES3_S3_", [Callable][Weak]), ("__ZN4impl18MemRefDataVerifierINSt3__17complexIfEEE10verifyElemES3_S3_", [Callable][Weak]), ("__ZN4impl12verifyMemRefINSt3__17complexIfEEEExRK17DynamicMemRefTypeIT_ES8_", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterINSt3__17complexIdEEE10printFirstERNS1_13basic_ostreamIcNS1_11char_traitsIcEEEEPS3_xxxPKxSC_", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterI6VectorIfLi4EJLi4EEEE10printFirstERNSt3__113basic_ostreamIcNS4_11char_traitsIcEEEEPS2_xxxPKxSC_", [Callable][Weak]), ("__ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_c", [Callable][Weak]), ("__ZN4impllsIfLi4EJEEERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEES6_RK6VectorIT_XT0_EJXspT1_EEE", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterI6VectorIfLi4EJLi4EEEE5printERNSt3__113basic_ostreamIcNS4_11char_traitsIcEEEEPS2_xxxPKxSC_", [Callable][Weak]), ("_printMemrefF64", [Callable]), ("__ZN4impllsIfLi4EJLi4EEEERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEES6_RK6VectorIT_XT0_EJXspT1_EEE", [Callable][Weak]), ("__ZNSt3__124__put_character_sequenceIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_PKS4_m", [Callable][Weak]), ("__ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_a", [Callable][Weak]), ("__ZN4impl11printMemRefINSt3__17complexIfEELi1EEEvR17StridedMemRefTypeIT_XT0_EE", [Callable][Weak]), ("__Z19printMemRefMetaDataIdNSt3__113basic_ostreamIcNS0_11char_traitsIcEEEEEvRT0_RK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl18MemRefDataVerifierIiE6verifyERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPiS8_xxPKxSA_Rx", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterINSt3__17complexIfEEE10printFirstERNS1_13basic_ostreamIcNS1_11char_traitsIcEEEEPS3_xxxPKxSC_", [Callable][Weak]), ("__ZN4impl18MemRefDataVerifierIyE6verifyERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPyS8_xxPKxSA_Rx", [Callable][Weak]), ("__ZN4impl11printMemRefINSt3__17complexIfEEEEvRK17DynamicMemRefTypeIT_E", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterINSt3__17complexIdEEE5printERNS1_13basic_ostreamIcNS1_11char_traitsIcEEEEPS3_xxxPKxSC_", [Callable][Weak]), ("__ZN4impl18MemRefDataVerifierIdE6verifyERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPdS8_xxPKxSA_Rx", [Callable][Weak]), ("__ZN4impl12verifyMemRefINSt3__17complexIfEEEExR18UnrankedMemRefTypeIT_ES7_", [Callable][Weak]), ("_printMemrefI32", [Callable]), ("__ZN4impl12verifyMemRefINSt3__17complexIdEEEExR18UnrankedMemRefTypeIT_ES7_", [Callable][Weak]), ("__ZN4impl12verifyMemRefINSt3__17complexIdEEEExRK17DynamicMemRefTypeIT_ES8_", [Callable][Weak]), ("__ZN4impl18MemRefDataVerifierIfE6verifyERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPfS8_xxPKxSA_Rx", [Callable][Weak]), ("__ZN4impl17MemRefDataPrinterINSt3__17complexIdEEE9printLastERNS1_13basic_ostreamIcNS1_11char_traitsIcEEEEPS3_xxxPKxSC_", [Callable][Weak]) }
Setting up GenericLLVMIRPlatform support for LLJIT
Defining MU <Absolute Symbols> for main (tracker: 0x0, default will be used)
  { ("___lljit.cxa_atexit_helper", [Data][Hidden]), ("___lljit.platform_support_instance", [Data]) }
Defining MU <Absolute Symbols> for main (tracker: 0x0, default will be used)
  { ("___lljit.atexit_helper", [Data][Hidden]), ("___lljit.run_atexits_helper", [Data][Hidden]) }
Defining MU __standard_lib for main (tracker: default)  { ("___lljit_run_atexits", [Callable][Hidden]), ("_atexit", [Callable][Hidden]), ("___dso_handle", [Data]) }
Defining MU __standard_lib for main (tracker: default)  { ("___cxa_atexit", [Callable]) }

Features:+64bit-mode,-32bit-mode,-16bit-mode,+sse2,+xsaves,+sse2,-hreset,-avx512cd,-sha,+xsaveopt,-kl,-avxvnni,-mwaitx,-clzero,+sse4.2,+bmi,-cldemote,-widekl,-avx512f,-raoint,+xsavec,+lzcnt,-serialize,-avxvnniint8,+fsgsbase,+aes,+sse,-sse4a,-rdpru,-tbm,-avx512bf16,-rtm,+fma,-waitpkg,-amx-fp16,-avx512ifma,-avx512vp2intersect,+popcnt,-vaes,-prefetchi,+f16c,+avx2,+sahf,+xsave,-uintr,+fxsr,+sgx,-pconfig,-avx512er,-avx512fp16,-gfni,+rdseed,+bmi2,-movdir64b,-avx512vl,-pku,-xop,-avx512bw,-avx512vbmi,+prfchw,-rdpid,+sse3,+cx16,-vpclmulqdq,-avx512vbmi2,-enqcmd,-amx-bf16,+64bit,-amx-int8,-avx512pf,-ptwrite,-amx-tile,-lwp,-avx512vpopcntdq,-avx512dq,-avxneconvert,+mmx,-fma4,-avx512vnni,-avxifma,+avx,+cmov,+sse4.1,+movbe,+invpcid,+adx,-clwb,-prefetchwt1,-cmpccxadd,+ssse3,+cx8,+clflushopt,-tsxldtrk,+pclmul,+crc32,+rdrnd,-avx512bitalg,-shstk,-movdiri,-wbnoinvd
CPU:skylake
TuneCPU:skylake

Subtarget features: SSELevel 8, 3DNowLevel 1, 64bit 1
G_ADD (opcode 46): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SUB (opcode 47): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MUL (opcode 48): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIV (opcode 49): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_UDIV (opcode 50): 1 type index, 0 imm indices
.. opcode 50 is aliased to 49
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_SREM (opcode 51): 1 type index, 0 imm indices
.. opcode 51 is aliased to 49
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_UREM (opcode 52): 1 type index, 0 imm indices
.. opcode 52 is aliased to 49
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_SDIVREM (opcode 53): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVREM (opcode 54): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_AND (opcode 55): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_OR (opcode 56): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_XOR (opcode 57): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_IMPLICIT_DEF (opcode 58): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PHI (opcode 59): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FRAME_INDEX (opcode 60): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_GLOBAL_VALUE (opcode 61): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CONSTANT_POOL (opcode 62): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_EXTRACT (opcode 63): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UNMERGE_VALUES (opcode 64): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INSERT (opcode 65): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MERGE_VALUES (opcode 66): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BUILD_VECTOR (opcode 67): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BUILD_VECTOR_TRUNC (opcode 68): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CONCAT_VECTORS (opcode 69): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTRTOINT (opcode 70): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_INTTOPTR (opcode 71): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_BITCAST (opcode 72): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FREEZE (opcode 73): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_FPTRUNC_ROUND (opcode 74): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_TRUNC (opcode 75): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_ROUND (opcode 76): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_LRINT (opcode 77): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_ROUNDEVEN (opcode 78): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_READCYCLECOUNTER (opcode 79): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_LOAD (opcode 80): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SEXTLOAD (opcode 81): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ZEXTLOAD (opcode 82): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_LOAD (opcode 83): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_SEXTLOAD (opcode 84): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_ZEXTLOAD (opcode 85): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STORE (opcode 86): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_STORE (opcode 87): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG_WITH_SUCCESS (opcode 88): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG (opcode 89): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XCHG (opcode 90): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_ADD (opcode 91): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_SUB (opcode 92): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_AND (opcode 93): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_NAND (opcode 94): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_OR (opcode 95): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XOR (opcode 96): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MAX (opcode 97): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MIN (opcode 98): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMAX (opcode 99): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMIN (opcode 100): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FADD (opcode 101): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FSUB (opcode 102): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FMAX (opcode 103): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FMIN (opcode 104): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UINC_WRAP (opcode 105): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UDEC_WRAP (opcode 106): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FENCE (opcode 107): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRCOND (opcode 108): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRINDIRECT (opcode 109): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INVOKE_REGION_START (opcode 110): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC (opcode 111): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_W_SIDE_EFFECTS (opcode 112): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ANYEXT (opcode 113): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_TRUNC (opcode 114): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CONSTANT (opcode 115): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCONSTANT (opcode 116): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VASTART (opcode 117): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VAARG (opcode 118): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SEXT (opcode 119): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SEXT_INREG (opcode 120): 1 type index, 1 imm index
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_ZEXT (opcode 121): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SHL (opcode 122): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_LSHR (opcode 123): 2 type indices, 0 imm indices
.. opcode 123 is aliased to 122
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_ASHR (opcode 124): 2 type indices, 0 imm indices
.. opcode 124 is aliased to 122
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FSHL (opcode 125): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSHR (opcode 126): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ROTR (opcode 127): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ROTL (opcode 128): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ICMP (opcode 129): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FCMP (opcode 130): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_SELECT (opcode 131): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDO (opcode 132): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDE (opcode 133): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBO (opcode 134): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBE (opcode 135): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDO (opcode 136): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDE (opcode 137): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBO (opcode 138): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBE (opcode 139): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULO (opcode 140): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULO (opcode 141): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULH (opcode 142): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULH (opcode 143): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDSAT (opcode 144): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDSAT (opcode 145): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBSAT (opcode 146): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBSAT (opcode 147): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USHLSAT (opcode 148): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSHLSAT (opcode 149): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULFIX (opcode 150): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULFIX (opcode 151): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULFIXSAT (opcode 152): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULFIXSAT (opcode 153): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIVFIX (opcode 154): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVFIX (opcode 155): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIVFIXSAT (opcode 156): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVFIXSAT (opcode 157): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FADD (opcode 158): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSUB (opcode 159): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMUL (opcode 160): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMA (opcode 161): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAD (opcode 162): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FDIV (opcode 163): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FREM (opcode 164): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPOW (opcode 165): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPOWI (opcode 166): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FEXP (opcode 167): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FEXP2 (opcode 168): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG (opcode 169): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG2 (opcode 170): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG10 (opcode 171): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FNEG (opcode 172): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPEXT (opcode 173): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPTRUNC (opcode 174): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPTOSI (opcode 175): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FPTOUI (opcode 176): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SITOFP (opcode 177): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_UITOFP (opcode 178): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FABS (opcode 179): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCOPYSIGN (opcode 180): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_IS_FPCLASS (opcode 181): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCANONICALIZE (opcode 182): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINNUM (opcode 183): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXNUM (opcode 184): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINNUM_IEEE (opcode 185): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXNUM_IEEE (opcode 186): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINIMUM (opcode 187): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXIMUM (opcode 188): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTR_ADD (opcode 189): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTRMASK (opcode 190): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMIN (opcode 191): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMAX (opcode 192): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMIN (opcode 193): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMAX (opcode 194): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ABS (opcode 195): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_LROUND (opcode 196): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_LLROUND (opcode 197): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BR (opcode 198): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRJT (opcode 199): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INSERT_VECTOR_ELT (opcode 200): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_EXTRACT_VECTOR_ELT (opcode 201): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SHUFFLE_VECTOR (opcode 202): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTTZ (opcode 203): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTTZ_ZERO_UNDEF (opcode 204): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTLZ (opcode 205): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTLZ_ZERO_UNDEF (opcode 206): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTPOP (opcode 207): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BSWAP (opcode 208): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BITREVERSE (opcode 209): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCEIL (opcode 210): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCOS (opcode 211): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSIN (opcode 212): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSQRT (opcode 213): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FFLOOR (opcode 214): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FRINT (opcode 215): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FNEARBYINT (opcode 216): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ADDRSPACE_CAST (opcode 217): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BLOCK_ADDR (opcode 218): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_JUMP_TABLE (opcode 219): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_DYN_STACKALLOC (opcode 220): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FADD (opcode 221): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FSUB (opcode 222): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FMUL (opcode 223): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FDIV (opcode 224): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FREM (opcode 225): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FMA (opcode 226): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FSQRT (opcode 227): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_READ_REGISTER (opcode 228): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_WRITE_REGISTER (opcode 229): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MEMCPY (opcode 230): 3 type indices, 1 imm index
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_MEMCPY_INLINE (opcode 231): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MEMMOVE (opcode 232): 3 type indices, 1 imm index
.. opcode 232 is aliased to 230
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_MEMSET (opcode 233): 3 type indices, 1 imm index
.. opcode 233 is aliased to 230
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_BZERO (opcode 234): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SEQ_FADD (opcode 235): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SEQ_FMUL (opcode 236): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FADD (opcode 237): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMUL (opcode 238): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMAX (opcode 239): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMIN (opcode 240): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_ADD (opcode 241): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_MUL (opcode 242): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_AND (opcode 243): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_OR (opcode 244): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_XOR (opcode 245): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SMAX (opcode 246): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SMIN (opcode 247): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_UMAX (opcode 248): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_UMIN (opcode 249): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SBFX (opcode 250): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UBFX (opcode 251): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
SROA function: main
SROA alloca:   %7 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  Rewriting FCA loads and stores...
    original:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %6, ptr %7, align 8
          to:   store ptr %.fca.0.extract, ptr %.fca.0.gep, align 8
          to:   store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
          to:   store i64 %.fca.2.extract, ptr %.fca.2.gep, align 8
          to:   store i64 %.fca.3.0.extract, ptr %.fca.3.0.gep, align 8
          to:   store i64 %.fca.4.0.extract, ptr %.fca.4.0.gep, align 8
Can't analyze slices for alloca:   %7 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  A pointer to this alloca escaped by:
    %8 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %7, 1
EarlyCSE Simplify:   %.fca.0.extract = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %6, 0  to:   %1 = call ptr @malloc(i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 7) to i64))
EarlyCSE Simplify:   %.fca.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 0  to:   %7 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
EarlyCSE Simplify:   %.fca.1.extract = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %6, 1  to:   %1 = call ptr @malloc(i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 7) to i64))
EarlyCSE Simplify:   %.fca.2.extract = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %6, 2  to: i64 0
EarlyCSE Simplify:   %.fca.3.0.extract = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %6, 3, 0  to: i64 7
EarlyCSE Simplify:   %.fca.4.0.extract = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %6, 4, 0  to: i64 1
EarlyCSE DCE:   %8 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %7, 1
EarlyCSE Simplify:   %8 = getelementptr i64, ptr %1, i64 0  to:   %1 = call ptr @malloc(i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 7) to i64))
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE DCE:   %41 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %40, 1
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE DCE:   %57 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %56, 1
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE DCE:   %73 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %72, 1
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE DCE:   %89 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %88, 1
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE DCE:   %105 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %104, 1
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE DCE:   %121 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %120, 1
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE DCE:   %137 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %136, 1
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE DCE:   %153 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %152, 1
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE DCE:   %169 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %168, 1
SROA function: _mlir_main
Visiting   %34 = phi i64 [ %38, %36 ], [ 0, %0 ]
Rename Stack is empty
Current DFS numbers are (1,54)
Rename Stack is empty
Current DFS numbers are (2,3)
Rename Stack Top DFS numbers are (2,3)
Current DFS numbers are (2,3)
Found replacement   %.0 = call i64 @llvm.ssa.copy.i64(i64 %34) for   %34 = phi i64 [ %38, %36 ], [ 0, %0 ] in   %37 = getelementptr i64, ptr %27, i64 %34
Rename Stack Top DFS numbers are (2,3)
Current DFS numbers are (2,3)
Found replacement   %.0 = call i64 @llvm.ssa.copy.i64(i64 %34) for   %34 = phi i64 [ %38, %36 ], [ 0, %0 ] in   %38 = add i64 %34, 1
Rename Stack Top DFS numbers are (2,3)
Current DFS numbers are (4,53)
Visiting   %8 = load i64, ptr %1, align 4
Rename Stack is empty
Current DFS numbers are (0,55)
Rename Stack is empty
Current DFS numbers are (0,55)
Rename Stack is empty
Current DFS numbers are (1,54)
Rename Stack is empty
Current DFS numbers are (2,3)
Rename Stack Top DFS numbers are (2,3)
Current DFS numbers are (4,53)
Visiting   %50 = phi i64 [ %54, %52 ], [ 0, %39 ]
Rename Stack is empty
Current DFS numbers are (5,52)
Rename Stack is empty
Current DFS numbers are (6,7)
Rename Stack Top DFS numbers are (6,7)
Current DFS numbers are (6,7)
Found replacement   %.01 = call i64 @llvm.ssa.copy.i64(i64 %50) for   %50 = phi i64 [ %54, %52 ], [ 0, %39 ] in   %53 = getelementptr i64, ptr %43, i64 %50
Rename Stack Top DFS numbers are (6,7)
Current DFS numbers are (6,7)
Found replacement   %.01 = call i64 @llvm.ssa.copy.i64(i64 %50) for   %50 = phi i64 [ %54, %52 ], [ 0, %39 ] in   %54 = add i64 %50, 1
Rename Stack Top DFS numbers are (6,7)
Current DFS numbers are (8,51)
Visiting   %10 = load i64, ptr %9, align 4
Rename Stack is empty
Current DFS numbers are (4,53)
Rename Stack is empty
Current DFS numbers are (4,53)
Rename Stack is empty
Current DFS numbers are (5,52)
Rename Stack is empty
Current DFS numbers are (6,7)
Rename Stack Top DFS numbers are (6,7)
Current DFS numbers are (8,51)
Visiting   %66 = phi i64 [ %70, %68 ], [ 0, %55 ]
Rename Stack is empty
Current DFS numbers are (9,50)
Rename Stack is empty
Current DFS numbers are (10,11)
Rename Stack Top DFS numbers are (10,11)
Current DFS numbers are (10,11)
Found replacement   %.02 = call i64 @llvm.ssa.copy.i64(i64 %66) for   %66 = phi i64 [ %70, %68 ], [ 0, %55 ] in   %69 = getelementptr i64, ptr %59, i64 %66
Rename Stack Top DFS numbers are (10,11)
Current DFS numbers are (10,11)
Found replacement   %.02 = call i64 @llvm.ssa.copy.i64(i64 %66) for   %66 = phi i64 [ %70, %68 ], [ 0, %55 ] in   %70 = add i64 %66, 1
Rename Stack Top DFS numbers are (10,11)
Current DFS numbers are (12,49)
Visiting   %12 = load i64, ptr %11, align 4
Rename Stack is empty
Current DFS numbers are (8,51)
Rename Stack is empty
Current DFS numbers are (8,51)
Rename Stack is empty
Current DFS numbers are (9,50)
Rename Stack is empty
Current DFS numbers are (10,11)
Rename Stack Top DFS numbers are (10,11)
Current DFS numbers are (12,49)
Visiting   %82 = phi i64 [ %86, %84 ], [ 0, %71 ]
Rename Stack is empty
Current DFS numbers are (13,48)
Rename Stack is empty
Current DFS numbers are (14,15)
Rename Stack Top DFS numbers are (14,15)
Current DFS numbers are (14,15)
Found replacement   %.03 = call i64 @llvm.ssa.copy.i64(i64 %82) for   %82 = phi i64 [ %86, %84 ], [ 0, %71 ] in   %85 = getelementptr i64, ptr %75, i64 %82
Rename Stack Top DFS numbers are (14,15)
Current DFS numbers are (14,15)
Found replacement   %.03 = call i64 @llvm.ssa.copy.i64(i64 %82) for   %82 = phi i64 [ %86, %84 ], [ 0, %71 ] in   %86 = add i64 %82, 1
Rename Stack Top DFS numbers are (14,15)
Current DFS numbers are (16,47)
Visiting   %14 = load i64, ptr %13, align 4
Rename Stack is empty
Current DFS numbers are (12,49)
Rename Stack is empty
Current DFS numbers are (12,49)
Rename Stack is empty
Current DFS numbers are (13,48)
Rename Stack is empty
Current DFS numbers are (14,15)
Rename Stack Top DFS numbers are (14,15)
Current DFS numbers are (16,47)
Visiting   %98 = phi i64 [ %102, %100 ], [ 0, %87 ]
Rename Stack is empty
Current DFS numbers are (17,46)
Rename Stack is empty
Current DFS numbers are (18,19)
Rename Stack Top DFS numbers are (18,19)
Current DFS numbers are (18,19)
Found replacement   %.04 = call i64 @llvm.ssa.copy.i64(i64 %98) for   %98 = phi i64 [ %102, %100 ], [ 0, %87 ] in   %101 = getelementptr i64, ptr %91, i64 %98
Rename Stack Top DFS numbers are (18,19)
Current DFS numbers are (18,19)
Found replacement   %.04 = call i64 @llvm.ssa.copy.i64(i64 %98) for   %98 = phi i64 [ %102, %100 ], [ 0, %87 ] in   %102 = add i64 %98, 1
Rename Stack Top DFS numbers are (18,19)
Current DFS numbers are (20,45)
Visiting   %16 = load i64, ptr %15, align 4
Rename Stack is empty
Current DFS numbers are (16,47)
Rename Stack is empty
Current DFS numbers are (16,47)
Rename Stack is empty
Current DFS numbers are (17,46)
Rename Stack is empty
Current DFS numbers are (18,19)
Rename Stack Top DFS numbers are (18,19)
Current DFS numbers are (20,45)
Visiting   %114 = phi i64 [ %118, %116 ], [ 0, %103 ]
Rename Stack is empty
Current DFS numbers are (21,44)
Rename Stack is empty
Current DFS numbers are (22,23)
Rename Stack Top DFS numbers are (22,23)
Current DFS numbers are (22,23)
Found replacement   %.05 = call i64 @llvm.ssa.copy.i64(i64 %114) for   %114 = phi i64 [ %118, %116 ], [ 0, %103 ] in   %117 = getelementptr i64, ptr %107, i64 %114
Rename Stack Top DFS numbers are (22,23)
Current DFS numbers are (22,23)
Found replacement   %.05 = call i64 @llvm.ssa.copy.i64(i64 %114) for   %114 = phi i64 [ %118, %116 ], [ 0, %103 ] in   %118 = add i64 %114, 1
Rename Stack Top DFS numbers are (22,23)
Current DFS numbers are (24,43)
Visiting   %18 = load i64, ptr %17, align 4
Rename Stack is empty
Current DFS numbers are (20,45)
Rename Stack is empty
Current DFS numbers are (20,45)
Rename Stack is empty
Current DFS numbers are (21,44)
Rename Stack is empty
Current DFS numbers are (22,23)
Rename Stack Top DFS numbers are (22,23)
Current DFS numbers are (24,43)
Visiting   %130 = phi i64 [ %134, %132 ], [ 0, %119 ]
Rename Stack is empty
Current DFS numbers are (25,42)
Rename Stack is empty
Current DFS numbers are (26,27)
Rename Stack Top DFS numbers are (26,27)
Current DFS numbers are (26,27)
Found replacement   %.06 = call i64 @llvm.ssa.copy.i64(i64 %130) for   %130 = phi i64 [ %134, %132 ], [ 0, %119 ] in   %133 = getelementptr i64, ptr %123, i64 %130
Rename Stack Top DFS numbers are (26,27)
Current DFS numbers are (26,27)
Found replacement   %.06 = call i64 @llvm.ssa.copy.i64(i64 %130) for   %130 = phi i64 [ %134, %132 ], [ 0, %119 ] in   %134 = add i64 %130, 1
Rename Stack Top DFS numbers are (26,27)
Current DFS numbers are (28,41)
Visiting   %20 = load i64, ptr %19, align 4
Rename Stack is empty
Current DFS numbers are (24,43)
Rename Stack is empty
Current DFS numbers are (24,43)
Rename Stack is empty
Current DFS numbers are (25,42)
Rename Stack is empty
Current DFS numbers are (26,27)
Rename Stack Top DFS numbers are (26,27)
Current DFS numbers are (28,41)
Visiting   %146 = phi i64 [ %150, %148 ], [ 0, %135 ]
Rename Stack is empty
Current DFS numbers are (29,40)
Rename Stack is empty
Current DFS numbers are (30,31)
Rename Stack Top DFS numbers are (30,31)
Current DFS numbers are (30,31)
Found replacement   %.07 = call i64 @llvm.ssa.copy.i64(i64 %146) for   %146 = phi i64 [ %150, %148 ], [ 0, %135 ] in   %149 = getelementptr i64, ptr %139, i64 %146
Rename Stack Top DFS numbers are (30,31)
Current DFS numbers are (30,31)
Found replacement   %.07 = call i64 @llvm.ssa.copy.i64(i64 %146) for   %146 = phi i64 [ %150, %148 ], [ 0, %135 ] in   %150 = add i64 %146, 1
Rename Stack Top DFS numbers are (30,31)
Current DFS numbers are (32,39)
Visiting   %22 = load i64, ptr %21, align 4
Rename Stack is empty
Current DFS numbers are (28,41)
Rename Stack is empty
Current DFS numbers are (28,41)
Rename Stack is empty
Current DFS numbers are (29,40)
Rename Stack is empty
Current DFS numbers are (30,31)
Rename Stack Top DFS numbers are (30,31)
Current DFS numbers are (32,39)
Visiting   %162 = phi i64 [ %166, %164 ], [ 0, %151 ]
Rename Stack is empty
Current DFS numbers are (33,38)
Rename Stack is empty
Current DFS numbers are (34,35)
Rename Stack Top DFS numbers are (34,35)
Current DFS numbers are (34,35)
Found replacement   %.08 = call i64 @llvm.ssa.copy.i64(i64 %162) for   %162 = phi i64 [ %166, %164 ], [ 0, %151 ] in   %165 = getelementptr double, ptr %155, i64 %162
Rename Stack Top DFS numbers are (34,35)
Current DFS numbers are (34,35)
Found replacement   %.08 = call i64 @llvm.ssa.copy.i64(i64 %162) for   %162 = phi i64 [ %166, %164 ], [ 0, %151 ] in   %166 = add i64 %162, 1
Rename Stack Top DFS numbers are (34,35)
Current DFS numbers are (36,37)
Visiting   %24 = load i64, ptr %23, align 4
Rename Stack is empty
Current DFS numbers are (32,39)
Rename Stack is empty
Current DFS numbers are (32,39)
Rename Stack is empty
Current DFS numbers are (33,38)
Rename Stack is empty
Current DFS numbers are (34,35)
Rename Stack Top DFS numbers are (34,35)
Current DFS numbers are (36,37)
Marking Block Executable: 
Marking Block Executable: 
markOverdefined: ptr %0

Popped off OI-WL: ptr %0

Popped off BBWL: 
  call void @main()
  ret void


Popped off BBWL: 
  %1 = call ptr @malloc(i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 7) to i64))
  %2 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %1, 0
  %3 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %2, ptr %1, 1
  %4 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %3, i64 0, 2
  %5 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %4, i64 7, 3, 0
  %6 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %5, i64 1, 4, 0
  %7 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store ptr %1, ptr %7, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 1
  store ptr %1, ptr %.fca.1.gep, align 8
  %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 2
  store i64 0, ptr %.fca.2.gep, align 8
  %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 3, i32 0
  store i64 7, ptr %.fca.3.0.gep, align 8
  %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 4, i32 0
  store i64 1, ptr %.fca.4.0.gep, align 8
  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr %7, i32 1)
  %8 = load i64, ptr %1, align 4
  %9 = getelementptr i64, ptr %1, i64 1
  %10 = load i64, ptr %9, align 4
  %11 = getelementptr i64, ptr %1, i64 2
  %12 = load i64, ptr %11, align 4
  %13 = getelementptr i64, ptr %1, i64 3
  %14 = load i64, ptr %13, align 4
  %15 = getelementptr i64, ptr %1, i64 4
  %16 = load i64, ptr %15, align 4
  %17 = getelementptr i64, ptr %1, i64 5
  %18 = load i64, ptr %17, align 4
  %19 = getelementptr i64, ptr %1, i64 6
  %20 = load i64, ptr %19, align 4
  %21 = getelementptr i64, ptr %1, i64 7
  %22 = load i64, ptr %21, align 4
  %23 = getelementptr i64, ptr %1, i64 8
  %24 = load i64, ptr %23, align 4
  %25 = getelementptr i64, ptr null, i64 %8
  %26 = ptrtoint ptr %25 to i64
  %27 = call ptr @malloc(i64 %26)
  %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %27, 0
  %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, ptr %27, 1
  %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %29, i64 0, 2
  %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, i64 %8, 3, 0
  %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 1, 4, 0
  br label %33

Merged overdefined into   %1 = call ptr @malloc(i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 7) to i64)) : overdefined
Merged overdefined into   %2 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %1, 0 : overdefined
Merged undef into   %2 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %1, 0 : undef
Merged undef into   %2 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %1, 0 : undef
Merged undef into   %2 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %1, 0 : undef
Merged undef into   %2 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %1, 0 : undef
Merged overdefined into   %3 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %2, ptr %1, 1 : overdefined
Merged overdefined into   %3 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %2, ptr %1, 1 : overdefined
Merged undef into   %3 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %2, ptr %1, 1 : undef
Merged undef into   %3 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %2, ptr %1, 1 : undef
Merged undef into   %3 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %2, ptr %1, 1 : undef
Merged overdefined into   %4 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %3, i64 0, 2 : overdefined
Merged overdefined into   %4 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %3, i64 0, 2 : overdefined
Merged constantrange<0, 1> into   %4 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %3, i64 0, 2 : constantrange<0, 1>
Merged undef into   %4 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %3, i64 0, 2 : undef
Merged undef into   %4 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %3, i64 0, 2 : undef
markOverdefined:   %5 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %4, i64 7, 3, 0
markOverdefined:   %5 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %4, i64 7, 3, 0
markOverdefined:   %5 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %4, i64 7, 3, 0
markOverdefined:   %5 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %4, i64 7, 3, 0
markOverdefined:   %5 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %4, i64 7, 3, 0
markOverdefined:   %6 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %5, i64 1, 4, 0
markOverdefined:   %6 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %5, i64 1, 4, 0
markOverdefined:   %6 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %5, i64 1, 4, 0
markOverdefined:   %6 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %5, i64 1, 4, 0
markOverdefined:   %6 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %5, i64 1, 4, 0
SCCP: Don't know how to handle:   %7 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %7 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 1
markOverdefined:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 2
markOverdefined:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 3, i32 0
markOverdefined:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 4, i32 0
Merged overdefined into   %8 = load i64, ptr %1, align 4 : overdefined
markOverdefined:   %9 = getelementptr i64, ptr %1, i64 1
Merged overdefined into   %10 = load i64, ptr %9, align 4 : overdefined
markOverdefined:   %11 = getelementptr i64, ptr %1, i64 2
Merged overdefined into   %12 = load i64, ptr %11, align 4 : overdefined
markOverdefined:   %13 = getelementptr i64, ptr %1, i64 3
Merged overdefined into   %14 = load i64, ptr %13, align 4 : overdefined
markOverdefined:   %15 = getelementptr i64, ptr %1, i64 4
Merged overdefined into   %16 = load i64, ptr %15, align 4 : overdefined
markOverdefined:   %17 = getelementptr i64, ptr %1, i64 5
Merged overdefined into   %18 = load i64, ptr %17, align 4 : overdefined
markOverdefined:   %19 = getelementptr i64, ptr %1, i64 6
Merged overdefined into   %20 = load i64, ptr %19, align 4 : overdefined
markOverdefined:   %21 = getelementptr i64, ptr %1, i64 7
Merged overdefined into   %22 = load i64, ptr %21, align 4 : overdefined
markOverdefined:   %23 = getelementptr i64, ptr %1, i64 8
Merged overdefined into   %24 = load i64, ptr %23, align 4 : overdefined
markOverdefined:   %25 = getelementptr i64, ptr null, i64 %8
markOverdefined:   %26 = ptrtoint ptr %25 to i64
Merged overdefined into   %27 = call ptr @malloc(i64 %26) : overdefined
Merged overdefined into   %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %27, 0 : overdefined
Merged undef into   %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %27, 0 : undef
Merged undef into   %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %27, 0 : undef
Merged undef into   %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %27, 0 : undef
Merged undef into   %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %27, 0 : undef
Merged overdefined into   %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, ptr %27, 1 : overdefined
Merged overdefined into   %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, ptr %27, 1 : overdefined
Merged undef into   %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, ptr %27, 1 : undef
Merged undef into   %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, ptr %27, 1 : undef
Merged undef into   %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, ptr %27, 1 : undef
Merged overdefined into   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %29, i64 0, 2 : overdefined
Merged overdefined into   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %29, i64 0, 2 : overdefined
Merged constantrange<0, 1> into   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %29, i64 0, 2 : constantrange<0, 1>
Merged undef into   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %29, i64 0, 2 : undef
Merged undef into   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %29, i64 0, 2 : undef
markOverdefined:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, i64 %8, 3, 0
markOverdefined:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, i64 %8, 3, 0
markOverdefined:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, i64 %8, 3, 0
markOverdefined:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, i64 %8, 3, 0
markOverdefined:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, i64 %8, 3, 0
markOverdefined:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 1, 4, 0
markOverdefined:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 1, 4, 0
markOverdefined:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 1, 4, 0
markOverdefined:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 1, 4, 0
markOverdefined:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 1, 4, 0
Marking Block Executable: 

Popped off BBWL: 
33:                                               ; preds = %36, %0
  %34 = phi i64 [ %38, %36 ], [ 0, %0 ]
  %35 = icmp slt i64 %34, %8
  %.0 = call i64 @llvm.ssa.copy.i64(i64 %34)
  br i1 %35, label %36, label %39

Merged constantrange<0, 1> into   %34 = phi i64 [ %38, %36 ], [ 0, %0 ] : constantrange<0, 1>
markOverdefined:   %35 = icmp slt i64 %34, %8
Merged constantrange<0, 1> into   %.0 = call i64 @llvm.ssa.copy.i64(i64 %34) : constantrange<0, 1>
Marking Block Executable: 
Marking Block Executable: 

Popped off BBWL: 
39:                                               ; preds = %33
  %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, ptr %40, align 8
  %41 = getelementptr i64, ptr null, i64 %10
  %42 = ptrtoint ptr %41 to i64
  %43 = call ptr @malloc(i64 %42)
  %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %43, 0
  %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, ptr %43, 1
  %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 0, 2
  %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, i64 %10, 3, 0
  %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 1, 4, 0
  br label %49

SCCP: Don't know how to handle:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %41 = getelementptr i64, ptr null, i64 %10
markOverdefined:   %42 = ptrtoint ptr %41 to i64
Merged overdefined into   %43 = call ptr @malloc(i64 %42) : overdefined
Merged overdefined into   %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %43, 0 : overdefined
Merged undef into   %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %43, 0 : undef
Merged undef into   %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %43, 0 : undef
Merged undef into   %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %43, 0 : undef
Merged undef into   %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %43, 0 : undef
Merged overdefined into   %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, ptr %43, 1 : overdefined
Merged overdefined into   %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, ptr %43, 1 : overdefined
Merged undef into   %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, ptr %43, 1 : undef
Merged undef into   %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, ptr %43, 1 : undef
Merged undef into   %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, ptr %43, 1 : undef
Merged overdefined into   %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 0, 2 : overdefined
Merged overdefined into   %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 0, 2 : overdefined
Merged constantrange<0, 1> into   %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 0, 2 : constantrange<0, 1>
Merged undef into   %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 0, 2 : undef
Merged undef into   %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 0, 2 : undef
markOverdefined:   %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, i64 %10, 3, 0
markOverdefined:   %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, i64 %10, 3, 0
markOverdefined:   %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, i64 %10, 3, 0
markOverdefined:   %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, i64 %10, 3, 0
markOverdefined:   %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, i64 %10, 3, 0
markOverdefined:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 1, 4, 0
markOverdefined:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 1, 4, 0
markOverdefined:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 1, 4, 0
markOverdefined:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 1, 4, 0
markOverdefined:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 1, 4, 0
Marking Block Executable: 

Popped off BBWL: 
49:                                               ; preds = %52, %39
  %50 = phi i64 [ %54, %52 ], [ 0, %39 ]
  %51 = icmp slt i64 %50, %10
  %.01 = call i64 @llvm.ssa.copy.i64(i64 %50)
  br i1 %51, label %52, label %55

Merged constantrange<0, 1> into   %50 = phi i64 [ %54, %52 ], [ 0, %39 ] : constantrange<0, 1>
markOverdefined:   %51 = icmp slt i64 %50, %10
Merged constantrange<0, 1> into   %.01 = call i64 @llvm.ssa.copy.i64(i64 %50) : constantrange<0, 1>
Marking Block Executable: 
Marking Block Executable: 

Popped off BBWL: 
55:                                               ; preds = %49
  %56 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, ptr %56, align 8
  %57 = getelementptr i64, ptr null, i64 %12
  %58 = ptrtoint ptr %57 to i64
  %59 = call ptr @malloc(i64 %58)
  %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %59, 0
  %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, ptr %59, 1
  %62 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, i64 0, 2
  %63 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %62, i64 %12, 3, 0
  %64 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %63, i64 1, 4, 0
  br label %65

SCCP: Don't know how to handle:   %56 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %56 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %57 = getelementptr i64, ptr null, i64 %12
markOverdefined:   %58 = ptrtoint ptr %57 to i64
Merged overdefined into   %59 = call ptr @malloc(i64 %58) : overdefined
Merged overdefined into   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %59, 0 : overdefined
Merged undef into   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %59, 0 : undef
Merged undef into   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %59, 0 : undef
Merged undef into   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %59, 0 : undef
Merged undef into   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %59, 0 : undef
Merged overdefined into   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, ptr %59, 1 : overdefined
Merged overdefined into   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, ptr %59, 1 : overdefined
Merged undef into   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, ptr %59, 1 : undef
Merged undef into   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, ptr %59, 1 : undef
Merged undef into   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, ptr %59, 1 : undef
Merged overdefined into   %62 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, i64 0, 2 : overdefined
Merged overdefined into   %62 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, i64 0, 2 : overdefined
Merged constantrange<0, 1> into   %62 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, i64 0, 2 : constantrange<0, 1>
Merged undef into   %62 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, i64 0, 2 : undef
Merged undef into   %62 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, i64 0, 2 : undef
markOverdefined:   %63 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %62, i64 %12, 3, 0
markOverdefined:   %63 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %62, i64 %12, 3, 0
markOverdefined:   %63 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %62, i64 %12, 3, 0
markOverdefined:   %63 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %62, i64 %12, 3, 0
markOverdefined:   %63 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %62, i64 %12, 3, 0
markOverdefined:   %64 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %63, i64 1, 4, 0
markOverdefined:   %64 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %63, i64 1, 4, 0
markOverdefined:   %64 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %63, i64 1, 4, 0
markOverdefined:   %64 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %63, i64 1, 4, 0
markOverdefined:   %64 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %63, i64 1, 4, 0
Marking Block Executable: 

Popped off BBWL: 
65:                                               ; preds = %68, %55
  %66 = phi i64 [ %70, %68 ], [ 0, %55 ]
  %67 = icmp slt i64 %66, %12
  %.02 = call i64 @llvm.ssa.copy.i64(i64 %66)
  br i1 %67, label %68, label %71

Merged constantrange<0, 1> into   %66 = phi i64 [ %70, %68 ], [ 0, %55 ] : constantrange<0, 1>
markOverdefined:   %67 = icmp slt i64 %66, %12
Merged constantrange<0, 1> into   %.02 = call i64 @llvm.ssa.copy.i64(i64 %66) : constantrange<0, 1>
Marking Block Executable: 
Marking Block Executable: 

Popped off BBWL: 
71:                                               ; preds = %65
  %72 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %64, ptr %72, align 8
  %73 = getelementptr i64, ptr null, i64 %14
  %74 = ptrtoint ptr %73 to i64
  %75 = call ptr @malloc(i64 %74)
  %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %75, 0
  %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, ptr %75, 1
  %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 0, 2
  %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 %14, 3, 0
  %80 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, i64 1, 4, 0
  br label %81

SCCP: Don't know how to handle:   %72 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %72 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %73 = getelementptr i64, ptr null, i64 %14
markOverdefined:   %74 = ptrtoint ptr %73 to i64
Merged overdefined into   %75 = call ptr @malloc(i64 %74) : overdefined
Merged overdefined into   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %75, 0 : overdefined
Merged undef into   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %75, 0 : undef
Merged undef into   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %75, 0 : undef
Merged undef into   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %75, 0 : undef
Merged undef into   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %75, 0 : undef
Merged overdefined into   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, ptr %75, 1 : overdefined
Merged overdefined into   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, ptr %75, 1 : overdefined
Merged undef into   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, ptr %75, 1 : undef
Merged undef into   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, ptr %75, 1 : undef
Merged undef into   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, ptr %75, 1 : undef
Merged overdefined into   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 0, 2 : overdefined
Merged overdefined into   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 0, 2 : overdefined
Merged constantrange<0, 1> into   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 0, 2 : constantrange<0, 1>
Merged undef into   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 0, 2 : undef
Merged undef into   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 0, 2 : undef
markOverdefined:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 %14, 3, 0
markOverdefined:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 %14, 3, 0
markOverdefined:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 %14, 3, 0
markOverdefined:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 %14, 3, 0
markOverdefined:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 %14, 3, 0
markOverdefined:   %80 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, i64 1, 4, 0
markOverdefined:   %80 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, i64 1, 4, 0
markOverdefined:   %80 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, i64 1, 4, 0
markOverdefined:   %80 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, i64 1, 4, 0
markOverdefined:   %80 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, i64 1, 4, 0
Marking Block Executable: 

Popped off BBWL: 
81:                                               ; preds = %84, %71
  %82 = phi i64 [ %86, %84 ], [ 0, %71 ]
  %83 = icmp slt i64 %82, %14
  %.03 = call i64 @llvm.ssa.copy.i64(i64 %82)
  br i1 %83, label %84, label %87

Merged constantrange<0, 1> into   %82 = phi i64 [ %86, %84 ], [ 0, %71 ] : constantrange<0, 1>
markOverdefined:   %83 = icmp slt i64 %82, %14
Merged constantrange<0, 1> into   %.03 = call i64 @llvm.ssa.copy.i64(i64 %82) : constantrange<0, 1>
Marking Block Executable: 
Marking Block Executable: 

Popped off BBWL: 
87:                                               ; preds = %81
  %88 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %80, ptr %88, align 8
  %89 = getelementptr i64, ptr null, i64 %16
  %90 = ptrtoint ptr %89 to i64
  %91 = call ptr @malloc(i64 %90)
  %92 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %91, 0
  %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %92, ptr %91, 1
  %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, i64 0, 2
  %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 %16, 3, 0
  %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 1, 4, 0
  br label %97

SCCP: Don't know how to handle:   %88 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %88 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %89 = getelementptr i64, ptr null, i64 %16
markOverdefined:   %90 = ptrtoint ptr %89 to i64
Merged overdefined into   %91 = call ptr @malloc(i64 %90) : overdefined
Merged overdefined into   %92 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %91, 0 : overdefined
Merged undef into   %92 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %91, 0 : undef
Merged undef into   %92 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %91, 0 : undef
Merged undef into   %92 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %91, 0 : undef
Merged undef into   %92 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %91, 0 : undef
Merged overdefined into   %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %92, ptr %91, 1 : overdefined
Merged overdefined into   %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %92, ptr %91, 1 : overdefined
Merged undef into   %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %92, ptr %91, 1 : undef
Merged undef into   %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %92, ptr %91, 1 : undef
Merged undef into   %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %92, ptr %91, 1 : undef
Merged overdefined into   %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, i64 0, 2 : overdefined
Merged overdefined into   %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, i64 0, 2 : overdefined
Merged constantrange<0, 1> into   %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, i64 0, 2 : constantrange<0, 1>
Merged undef into   %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, i64 0, 2 : undef
Merged undef into   %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, i64 0, 2 : undef
markOverdefined:   %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 %16, 3, 0
markOverdefined:   %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 %16, 3, 0
markOverdefined:   %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 %16, 3, 0
markOverdefined:   %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 %16, 3, 0
markOverdefined:   %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 %16, 3, 0
markOverdefined:   %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 1, 4, 0
markOverdefined:   %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 1, 4, 0
markOverdefined:   %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 1, 4, 0
markOverdefined:   %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 1, 4, 0
markOverdefined:   %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 1, 4, 0
Marking Block Executable: 

Popped off BBWL: 
97:                                               ; preds = %100, %87
  %98 = phi i64 [ %102, %100 ], [ 0, %87 ]
  %99 = icmp slt i64 %98, %16
  %.04 = call i64 @llvm.ssa.copy.i64(i64 %98)
  br i1 %99, label %100, label %103

Merged constantrange<0, 1> into   %98 = phi i64 [ %102, %100 ], [ 0, %87 ] : constantrange<0, 1>
markOverdefined:   %99 = icmp slt i64 %98, %16
Merged constantrange<0, 1> into   %.04 = call i64 @llvm.ssa.copy.i64(i64 %98) : constantrange<0, 1>
Marking Block Executable: 
Marking Block Executable: 

Popped off BBWL: 
103:                                              ; preds = %97
  %104 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %96, ptr %104, align 8
  %105 = getelementptr i64, ptr null, i64 %18
  %106 = ptrtoint ptr %105 to i64
  %107 = call ptr @malloc(i64 %106)
  %108 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %107, 0
  %109 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %108, ptr %107, 1
  %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %109, i64 0, 2
  %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, i64 %18, 3, 0
  %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 1, 4, 0
  br label %113

SCCP: Don't know how to handle:   %104 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %104 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %105 = getelementptr i64, ptr null, i64 %18
markOverdefined:   %106 = ptrtoint ptr %105 to i64
Merged overdefined into   %107 = call ptr @malloc(i64 %106) : overdefined
Merged overdefined into   %108 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %107, 0 : overdefined
Merged undef into   %108 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %107, 0 : undef
Merged undef into   %108 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %107, 0 : undef
Merged undef into   %108 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %107, 0 : undef
Merged undef into   %108 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %107, 0 : undef
Merged overdefined into   %109 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %108, ptr %107, 1 : overdefined
Merged overdefined into   %109 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %108, ptr %107, 1 : overdefined
Merged undef into   %109 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %108, ptr %107, 1 : undef
Merged undef into   %109 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %108, ptr %107, 1 : undef
Merged undef into   %109 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %108, ptr %107, 1 : undef
Merged overdefined into   %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %109, i64 0, 2 : overdefined
Merged overdefined into   %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %109, i64 0, 2 : overdefined
Merged constantrange<0, 1> into   %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %109, i64 0, 2 : constantrange<0, 1>
Merged undef into   %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %109, i64 0, 2 : undef
Merged undef into   %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %109, i64 0, 2 : undef
markOverdefined:   %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, i64 %18, 3, 0
markOverdefined:   %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, i64 %18, 3, 0
markOverdefined:   %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, i64 %18, 3, 0
markOverdefined:   %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, i64 %18, 3, 0
markOverdefined:   %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, i64 %18, 3, 0
markOverdefined:   %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 1, 4, 0
markOverdefined:   %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 1, 4, 0
markOverdefined:   %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 1, 4, 0
markOverdefined:   %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 1, 4, 0
markOverdefined:   %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 1, 4, 0
Marking Block Executable: 

Popped off BBWL: 
113:                                              ; preds = %116, %103
  %114 = phi i64 [ %118, %116 ], [ 0, %103 ]
  %115 = icmp slt i64 %114, %18
  %.05 = call i64 @llvm.ssa.copy.i64(i64 %114)
  br i1 %115, label %116, label %119

Merged constantrange<0, 1> into   %114 = phi i64 [ %118, %116 ], [ 0, %103 ] : constantrange<0, 1>
markOverdefined:   %115 = icmp slt i64 %114, %18
Merged constantrange<0, 1> into   %.05 = call i64 @llvm.ssa.copy.i64(i64 %114) : constantrange<0, 1>
Marking Block Executable: 
Marking Block Executable: 

Popped off BBWL: 
119:                                              ; preds = %113
  %120 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %112, ptr %120, align 8
  %121 = getelementptr i64, ptr null, i64 %20
  %122 = ptrtoint ptr %121 to i64
  %123 = call ptr @malloc(i64 %122)
  %124 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %123, 0
  %125 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %124, ptr %123, 1
  %126 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %125, i64 0, 2
  %127 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %126, i64 %20, 3, 0
  %128 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %127, i64 1, 4, 0
  br label %129

SCCP: Don't know how to handle:   %120 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %120 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %121 = getelementptr i64, ptr null, i64 %20
markOverdefined:   %122 = ptrtoint ptr %121 to i64
Merged overdefined into   %123 = call ptr @malloc(i64 %122) : overdefined
Merged overdefined into   %124 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %123, 0 : overdefined
Merged undef into   %124 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %123, 0 : undef
Merged undef into   %124 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %123, 0 : undef
Merged undef into   %124 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %123, 0 : undef
Merged undef into   %124 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %123, 0 : undef
Merged overdefined into   %125 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %124, ptr %123, 1 : overdefined
Merged overdefined into   %125 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %124, ptr %123, 1 : overdefined
Merged undef into   %125 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %124, ptr %123, 1 : undef
Merged undef into   %125 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %124, ptr %123, 1 : undef
Merged undef into   %125 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %124, ptr %123, 1 : undef
Merged overdefined into   %126 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %125, i64 0, 2 : overdefined
Merged overdefined into   %126 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %125, i64 0, 2 : overdefined
Merged constantrange<0, 1> into   %126 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %125, i64 0, 2 : constantrange<0, 1>
Merged undef into   %126 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %125, i64 0, 2 : undef
Merged undef into   %126 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %125, i64 0, 2 : undef
markOverdefined:   %127 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %126, i64 %20, 3, 0
markOverdefined:   %127 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %126, i64 %20, 3, 0
markOverdefined:   %127 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %126, i64 %20, 3, 0
markOverdefined:   %127 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %126, i64 %20, 3, 0
markOverdefined:   %127 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %126, i64 %20, 3, 0
markOverdefined:   %128 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %127, i64 1, 4, 0
markOverdefined:   %128 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %127, i64 1, 4, 0
markOverdefined:   %128 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %127, i64 1, 4, 0
markOverdefined:   %128 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %127, i64 1, 4, 0
markOverdefined:   %128 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %127, i64 1, 4, 0
Marking Block Executable: 

Popped off BBWL: 
129:                                              ; preds = %132, %119
  %130 = phi i64 [ %134, %132 ], [ 0, %119 ]
  %131 = icmp slt i64 %130, %20
  %.06 = call i64 @llvm.ssa.copy.i64(i64 %130)
  br i1 %131, label %132, label %135

Merged constantrange<0, 1> into   %130 = phi i64 [ %134, %132 ], [ 0, %119 ] : constantrange<0, 1>
markOverdefined:   %131 = icmp slt i64 %130, %20
Merged constantrange<0, 1> into   %.06 = call i64 @llvm.ssa.copy.i64(i64 %130) : constantrange<0, 1>
Marking Block Executable: 
Marking Block Executable: 

Popped off BBWL: 
135:                                              ; preds = %129
  %136 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %128, ptr %136, align 8
  %137 = getelementptr i64, ptr null, i64 %22
  %138 = ptrtoint ptr %137 to i64
  %139 = call ptr @malloc(i64 %138)
  %140 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %139, 0
  %141 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %140, ptr %139, 1
  %142 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %141, i64 0, 2
  %143 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %142, i64 %22, 3, 0
  %144 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %143, i64 1, 4, 0
  br label %145

SCCP: Don't know how to handle:   %136 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %136 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %137 = getelementptr i64, ptr null, i64 %22
markOverdefined:   %138 = ptrtoint ptr %137 to i64
Merged overdefined into   %139 = call ptr @malloc(i64 %138) : overdefined
Merged overdefined into   %140 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %139, 0 : overdefined
Merged undef into   %140 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %139, 0 : undef
Merged undef into   %140 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %139, 0 : undef
Merged undef into   %140 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %139, 0 : undef
Merged undef into   %140 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %139, 0 : undef
Merged overdefined into   %141 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %140, ptr %139, 1 : overdefined
Merged overdefined into   %141 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %140, ptr %139, 1 : overdefined
Merged undef into   %141 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %140, ptr %139, 1 : undef
Merged undef into   %141 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %140, ptr %139, 1 : undef
Merged undef into   %141 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %140, ptr %139, 1 : undef
Merged overdefined into   %142 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %141, i64 0, 2 : overdefined
Merged overdefined into   %142 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %141, i64 0, 2 : overdefined
Merged constantrange<0, 1> into   %142 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %141, i64 0, 2 : constantrange<0, 1>
Merged undef into   %142 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %141, i64 0, 2 : undef
Merged undef into   %142 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %141, i64 0, 2 : undef
markOverdefined:   %143 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %142, i64 %22, 3, 0
markOverdefined:   %143 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %142, i64 %22, 3, 0
markOverdefined:   %143 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %142, i64 %22, 3, 0
markOverdefined:   %143 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %142, i64 %22, 3, 0
markOverdefined:   %143 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %142, i64 %22, 3, 0
markOverdefined:   %144 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %143, i64 1, 4, 0
markOverdefined:   %144 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %143, i64 1, 4, 0
markOverdefined:   %144 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %143, i64 1, 4, 0
markOverdefined:   %144 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %143, i64 1, 4, 0
markOverdefined:   %144 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %143, i64 1, 4, 0
Marking Block Executable: 

Popped off BBWL: 
145:                                              ; preds = %148, %135
  %146 = phi i64 [ %150, %148 ], [ 0, %135 ]
  %147 = icmp slt i64 %146, %22
  %.07 = call i64 @llvm.ssa.copy.i64(i64 %146)
  br i1 %147, label %148, label %151

Merged constantrange<0, 1> into   %146 = phi i64 [ %150, %148 ], [ 0, %135 ] : constantrange<0, 1>
markOverdefined:   %147 = icmp slt i64 %146, %22
Merged constantrange<0, 1> into   %.07 = call i64 @llvm.ssa.copy.i64(i64 %146) : constantrange<0, 1>
Marking Block Executable: 
Marking Block Executable: 

Popped off BBWL: 
151:                                              ; preds = %145
  %152 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %144, ptr %152, align 8
  %153 = getelementptr double, ptr null, i64 %24
  %154 = ptrtoint ptr %153 to i64
  %155 = call ptr @malloc(i64 %154)
  %156 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %155, 0
  %157 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %156, ptr %155, 1
  %158 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %157, i64 0, 2
  %159 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %158, i64 %24, 3, 0
  %160 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %159, i64 1, 4, 0
  br label %161

SCCP: Don't know how to handle:   %152 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %152 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %153 = getelementptr double, ptr null, i64 %24
markOverdefined:   %154 = ptrtoint ptr %153 to i64
Merged overdefined into   %155 = call ptr @malloc(i64 %154) : overdefined
Merged overdefined into   %156 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %155, 0 : overdefined
Merged undef into   %156 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %155, 0 : undef
Merged undef into   %156 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %155, 0 : undef
Merged undef into   %156 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %155, 0 : undef
Merged undef into   %156 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %155, 0 : undef
Merged overdefined into   %157 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %156, ptr %155, 1 : overdefined
Merged overdefined into   %157 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %156, ptr %155, 1 : overdefined
Merged undef into   %157 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %156, ptr %155, 1 : undef
Merged undef into   %157 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %156, ptr %155, 1 : undef
Merged undef into   %157 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %156, ptr %155, 1 : undef
Merged overdefined into   %158 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %157, i64 0, 2 : overdefined
Merged overdefined into   %158 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %157, i64 0, 2 : overdefined
Merged constantrange<0, 1> into   %158 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %157, i64 0, 2 : constantrange<0, 1>
Merged undef into   %158 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %157, i64 0, 2 : undef
Merged undef into   %158 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %157, i64 0, 2 : undef
markOverdefined:   %159 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %158, i64 %24, 3, 0
markOverdefined:   %159 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %158, i64 %24, 3, 0
markOverdefined:   %159 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %158, i64 %24, 3, 0
markOverdefined:   %159 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %158, i64 %24, 3, 0
markOverdefined:   %159 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %158, i64 %24, 3, 0
markOverdefined:   %160 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %159, i64 1, 4, 0
markOverdefined:   %160 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %159, i64 1, 4, 0
markOverdefined:   %160 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %159, i64 1, 4, 0
markOverdefined:   %160 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %159, i64 1, 4, 0
markOverdefined:   %160 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %159, i64 1, 4, 0
Marking Block Executable: 

Popped off BBWL: 
161:                                              ; preds = %164, %151
  %162 = phi i64 [ %166, %164 ], [ 0, %151 ]
  %163 = icmp slt i64 %162, %24
  %.08 = call i64 @llvm.ssa.copy.i64(i64 %162)
  br i1 %163, label %164, label %167

Merged constantrange<0, 1> into   %162 = phi i64 [ %166, %164 ], [ 0, %151 ] : constantrange<0, 1>
markOverdefined:   %163 = icmp slt i64 %162, %24
Merged constantrange<0, 1> into   %.08 = call i64 @llvm.ssa.copy.i64(i64 %162) : constantrange<0, 1>
Marking Block Executable: 
Marking Block Executable: 

Popped off BBWL: 
167:                                              ; preds = %161
  %168 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %160, ptr %168, align 8
  call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr %40, i64 1, ptr %56, i64 1, ptr %72, i64 1, ptr %88, i64 1, ptr %104, i64 1, ptr %120, i64 1, ptr %136, i64 1, ptr %152, i64 1, ptr %168, i32 1)
  call void @comet_print_memref_i64(i64 1, ptr %40)
  call void @comet_print_memref_i64(i64 1, ptr %56)
  call void @comet_print_memref_i64(i64 1, ptr %72)
  call void @comet_print_memref_i64(i64 1, ptr %88)
  call void @comet_print_memref_i64(i64 1, ptr %104)
  call void @comet_print_memref_i64(i64 1, ptr %120)
  call void @comet_print_memref_i64(i64 1, ptr %136)
  call void @comet_print_memref_i64(i64 1, ptr %152)
  call void @comet_print_memref_f64(i64 1, ptr %168)
  ret void

SCCP: Don't know how to handle:   %168 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
markOverdefined:   %168 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off BBWL: 
164:                                              ; preds = %161
  %165 = getelementptr double, ptr %155, i64 %.08
  store double 0.000000e+00, ptr %165, align 8
  %166 = add i64 %.08, 1
  br label %161

markOverdefined:   %165 = getelementptr double, ptr %155, i64 %.08
Merged constantrange<1, 2> into   %166 = add i64 %.08, 1 : constantrange<1, 2>
Marking Edge Executable:  -> 
Merged constantrange<0, 2> into   %162 = phi i64 [ %166, %164 ], [ 0, %151 ] : constantrange<0, 2>

Popped off BBWL: 
148:                                              ; preds = %145
  %149 = getelementptr i64, ptr %139, i64 %.07
  store i64 0, ptr %149, align 4
  %150 = add i64 %.07, 1
  br label %145

markOverdefined:   %149 = getelementptr i64, ptr %139, i64 %.07
Merged constantrange<1, 2> into   %150 = add i64 %.07, 1 : constantrange<1, 2>
Marking Edge Executable:  -> 
Merged constantrange<0, 2> into   %146 = phi i64 [ %150, %148 ], [ 0, %135 ] : constantrange<0, 2>

Popped off BBWL: 
132:                                              ; preds = %129
  %133 = getelementptr i64, ptr %123, i64 %.06
  store i64 0, ptr %133, align 4
  %134 = add i64 %.06, 1
  br label %129

markOverdefined:   %133 = getelementptr i64, ptr %123, i64 %.06
Merged constantrange<1, 2> into   %134 = add i64 %.06, 1 : constantrange<1, 2>
Marking Edge Executable:  -> 
Merged constantrange<0, 2> into   %130 = phi i64 [ %134, %132 ], [ 0, %119 ] : constantrange<0, 2>

Popped off BBWL: 
116:                                              ; preds = %113
  %117 = getelementptr i64, ptr %107, i64 %.05
  store i64 0, ptr %117, align 4
  %118 = add i64 %.05, 1
  br label %113

markOverdefined:   %117 = getelementptr i64, ptr %107, i64 %.05
Merged constantrange<1, 2> into   %118 = add i64 %.05, 1 : constantrange<1, 2>
Marking Edge Executable:  -> 
Merged constantrange<0, 2> into   %114 = phi i64 [ %118, %116 ], [ 0, %103 ] : constantrange<0, 2>

Popped off BBWL: 
100:                                              ; preds = %97
  %101 = getelementptr i64, ptr %91, i64 %.04
  store i64 0, ptr %101, align 4
  %102 = add i64 %.04, 1
  br label %97

markOverdefined:   %101 = getelementptr i64, ptr %91, i64 %.04
Merged constantrange<1, 2> into   %102 = add i64 %.04, 1 : constantrange<1, 2>
Marking Edge Executable:  -> 
Merged constantrange<0, 2> into   %98 = phi i64 [ %102, %100 ], [ 0, %87 ] : constantrange<0, 2>

Popped off BBWL: 
84:                                               ; preds = %81
  %85 = getelementptr i64, ptr %75, i64 %.03
  store i64 0, ptr %85, align 4
  %86 = add i64 %.03, 1
  br label %81

markOverdefined:   %85 = getelementptr i64, ptr %75, i64 %.03
Merged constantrange<1, 2> into   %86 = add i64 %.03, 1 : constantrange<1, 2>
Marking Edge Executable:  -> 
Merged constantrange<0, 2> into   %82 = phi i64 [ %86, %84 ], [ 0, %71 ] : constantrange<0, 2>

Popped off BBWL: 
68:                                               ; preds = %65
  %69 = getelementptr i64, ptr %59, i64 %.02
  store i64 0, ptr %69, align 4
  %70 = add i64 %.02, 1
  br label %65

markOverdefined:   %69 = getelementptr i64, ptr %59, i64 %.02
Merged constantrange<1, 2> into   %70 = add i64 %.02, 1 : constantrange<1, 2>
Marking Edge Executable:  -> 
Merged constantrange<0, 2> into   %66 = phi i64 [ %70, %68 ], [ 0, %55 ] : constantrange<0, 2>

Popped off BBWL: 
52:                                               ; preds = %49
  %53 = getelementptr i64, ptr %43, i64 %.01
  store i64 0, ptr %53, align 4
  %54 = add i64 %.01, 1
  br label %49

markOverdefined:   %53 = getelementptr i64, ptr %43, i64 %.01
Merged constantrange<1, 2> into   %54 = add i64 %.01, 1 : constantrange<1, 2>
Marking Edge Executable:  -> 
Merged constantrange<0, 2> into   %50 = phi i64 [ %54, %52 ], [ 0, %39 ] : constantrange<0, 2>

Popped off BBWL: 
36:                                               ; preds = %33
  %37 = getelementptr i64, ptr %27, i64 %.0
  store i64 0, ptr %37, align 4
  %38 = add i64 %.0, 1
  br label %33

markOverdefined:   %37 = getelementptr i64, ptr %27, i64 %.0
Merged constantrange<1, 2> into   %38 = add i64 %.0, 1 : constantrange<1, 2>
Marking Edge Executable:  -> 
Merged constantrange<0, 2> into   %34 = phi i64 [ %38, %36 ], [ 0, %0 ] : constantrange<0, 2>

Popped off OI-WL:   %37 = getelementptr i64, ptr %27, i64 %.0

Popped off OI-WL:   %53 = getelementptr i64, ptr %43, i64 %.01

Popped off OI-WL:   %69 = getelementptr i64, ptr %59, i64 %.02

Popped off OI-WL:   %85 = getelementptr i64, ptr %75, i64 %.03

Popped off OI-WL:   %101 = getelementptr i64, ptr %91, i64 %.04

Popped off OI-WL:   %117 = getelementptr i64, ptr %107, i64 %.05

Popped off OI-WL:   %133 = getelementptr i64, ptr %123, i64 %.06

Popped off OI-WL:   %149 = getelementptr i64, ptr %139, i64 %.07

Popped off OI-WL:   %165 = getelementptr double, ptr %155, i64 %.08

Popped off OI-WL:   %168 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off OI-WL:   %163 = icmp slt i64 %162, %24

Popped off OI-WL:   %160 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %159, i64 1, 4, 0

Popped off OI-WL:   %160 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %159, i64 1, 4, 0

Popped off OI-WL:   %160 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %159, i64 1, 4, 0

Popped off OI-WL:   %160 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %159, i64 1, 4, 0

Popped off OI-WL:   %160 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %159, i64 1, 4, 0

Popped off OI-WL:   %159 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %158, i64 %24, 3, 0

Popped off OI-WL:   %159 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %158, i64 %24, 3, 0

Popped off OI-WL:   %159 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %158, i64 %24, 3, 0

Popped off OI-WL:   %159 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %158, i64 %24, 3, 0

Popped off OI-WL:   %159 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %158, i64 %24, 3, 0

Popped off OI-WL:   %158 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %157, i64 0, 2

Popped off OI-WL:   %158 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %157, i64 0, 2

Popped off OI-WL:   %157 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %156, ptr %155, 1

Popped off OI-WL:   %157 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %156, ptr %155, 1

Popped off OI-WL:   %156 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %155, 0

Popped off OI-WL:   %155 = call ptr @malloc(i64 %154)

Popped off OI-WL:   %154 = ptrtoint ptr %153 to i64

Popped off OI-WL:   %153 = getelementptr double, ptr null, i64 %24

Popped off OI-WL:   %152 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off OI-WL:   %147 = icmp slt i64 %146, %22

Popped off OI-WL:   %144 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %143, i64 1, 4, 0

Popped off OI-WL:   %144 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %143, i64 1, 4, 0

Popped off OI-WL:   %144 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %143, i64 1, 4, 0

Popped off OI-WL:   %144 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %143, i64 1, 4, 0

Popped off OI-WL:   %144 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %143, i64 1, 4, 0

Popped off OI-WL:   %143 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %142, i64 %22, 3, 0

Popped off OI-WL:   %143 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %142, i64 %22, 3, 0

Popped off OI-WL:   %143 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %142, i64 %22, 3, 0

Popped off OI-WL:   %143 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %142, i64 %22, 3, 0

Popped off OI-WL:   %143 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %142, i64 %22, 3, 0

Popped off OI-WL:   %142 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %141, i64 0, 2

Popped off OI-WL:   %142 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %141, i64 0, 2

Popped off OI-WL:   %141 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %140, ptr %139, 1

Popped off OI-WL:   %141 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %140, ptr %139, 1

Popped off OI-WL:   %140 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %139, 0

Popped off OI-WL:   %139 = call ptr @malloc(i64 %138)

Popped off OI-WL:   %138 = ptrtoint ptr %137 to i64

Popped off OI-WL:   %137 = getelementptr i64, ptr null, i64 %22

Popped off OI-WL:   %136 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off OI-WL:   %131 = icmp slt i64 %130, %20

Popped off OI-WL:   %128 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %127, i64 1, 4, 0

Popped off OI-WL:   %128 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %127, i64 1, 4, 0

Popped off OI-WL:   %128 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %127, i64 1, 4, 0

Popped off OI-WL:   %128 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %127, i64 1, 4, 0

Popped off OI-WL:   %128 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %127, i64 1, 4, 0

Popped off OI-WL:   %127 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %126, i64 %20, 3, 0

Popped off OI-WL:   %127 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %126, i64 %20, 3, 0

Popped off OI-WL:   %127 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %126, i64 %20, 3, 0

Popped off OI-WL:   %127 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %126, i64 %20, 3, 0

Popped off OI-WL:   %127 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %126, i64 %20, 3, 0

Popped off OI-WL:   %126 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %125, i64 0, 2

Popped off OI-WL:   %126 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %125, i64 0, 2

Popped off OI-WL:   %125 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %124, ptr %123, 1

Popped off OI-WL:   %125 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %124, ptr %123, 1

Popped off OI-WL:   %124 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %123, 0

Popped off OI-WL:   %123 = call ptr @malloc(i64 %122)

Popped off OI-WL:   %122 = ptrtoint ptr %121 to i64

Popped off OI-WL:   %121 = getelementptr i64, ptr null, i64 %20

Popped off OI-WL:   %120 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off OI-WL:   %115 = icmp slt i64 %114, %18

Popped off OI-WL:   %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 1, 4, 0

Popped off OI-WL:   %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 1, 4, 0

Popped off OI-WL:   %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 1, 4, 0

Popped off OI-WL:   %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 1, 4, 0

Popped off OI-WL:   %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 1, 4, 0

Popped off OI-WL:   %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, i64 %18, 3, 0

Popped off OI-WL:   %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, i64 %18, 3, 0

Popped off OI-WL:   %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, i64 %18, 3, 0

Popped off OI-WL:   %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, i64 %18, 3, 0

Popped off OI-WL:   %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, i64 %18, 3, 0

Popped off OI-WL:   %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %109, i64 0, 2

Popped off OI-WL:   %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %109, i64 0, 2

Popped off OI-WL:   %109 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %108, ptr %107, 1

Popped off OI-WL:   %109 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %108, ptr %107, 1

Popped off OI-WL:   %108 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %107, 0

Popped off OI-WL:   %107 = call ptr @malloc(i64 %106)

Popped off OI-WL:   %106 = ptrtoint ptr %105 to i64

Popped off OI-WL:   %105 = getelementptr i64, ptr null, i64 %18

Popped off OI-WL:   %104 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off OI-WL:   %99 = icmp slt i64 %98, %16

Popped off OI-WL:   %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 1, 4, 0

Popped off OI-WL:   %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 1, 4, 0

Popped off OI-WL:   %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 1, 4, 0

Popped off OI-WL:   %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 1, 4, 0

Popped off OI-WL:   %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 1, 4, 0

Popped off OI-WL:   %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 %16, 3, 0

Popped off OI-WL:   %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 %16, 3, 0

Popped off OI-WL:   %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 %16, 3, 0

Popped off OI-WL:   %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 %16, 3, 0

Popped off OI-WL:   %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 %16, 3, 0

Popped off OI-WL:   %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, i64 0, 2

Popped off OI-WL:   %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, i64 0, 2

Popped off OI-WL:   %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %92, ptr %91, 1

Popped off OI-WL:   %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %92, ptr %91, 1

Popped off OI-WL:   %92 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %91, 0

Popped off OI-WL:   %91 = call ptr @malloc(i64 %90)

Popped off OI-WL:   %90 = ptrtoint ptr %89 to i64

Popped off OI-WL:   %89 = getelementptr i64, ptr null, i64 %16

Popped off OI-WL:   %88 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off OI-WL:   %83 = icmp slt i64 %82, %14

Popped off OI-WL:   %80 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, i64 1, 4, 0

Popped off OI-WL:   %80 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, i64 1, 4, 0

Popped off OI-WL:   %80 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, i64 1, 4, 0

Popped off OI-WL:   %80 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, i64 1, 4, 0

Popped off OI-WL:   %80 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, i64 1, 4, 0

Popped off OI-WL:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 %14, 3, 0

Popped off OI-WL:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 %14, 3, 0

Popped off OI-WL:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 %14, 3, 0

Popped off OI-WL:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 %14, 3, 0

Popped off OI-WL:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 %14, 3, 0

Popped off OI-WL:   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 0, 2

Popped off OI-WL:   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 0, 2

Popped off OI-WL:   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, ptr %75, 1

Popped off OI-WL:   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, ptr %75, 1

Popped off OI-WL:   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %75, 0

Popped off OI-WL:   %75 = call ptr @malloc(i64 %74)

Popped off OI-WL:   %74 = ptrtoint ptr %73 to i64

Popped off OI-WL:   %73 = getelementptr i64, ptr null, i64 %14

Popped off OI-WL:   %72 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off OI-WL:   %67 = icmp slt i64 %66, %12

Popped off OI-WL:   %64 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %63, i64 1, 4, 0

Popped off OI-WL:   %64 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %63, i64 1, 4, 0

Popped off OI-WL:   %64 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %63, i64 1, 4, 0

Popped off OI-WL:   %64 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %63, i64 1, 4, 0

Popped off OI-WL:   %64 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %63, i64 1, 4, 0

Popped off OI-WL:   %63 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %62, i64 %12, 3, 0

Popped off OI-WL:   %63 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %62, i64 %12, 3, 0

Popped off OI-WL:   %63 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %62, i64 %12, 3, 0

Popped off OI-WL:   %63 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %62, i64 %12, 3, 0

Popped off OI-WL:   %63 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %62, i64 %12, 3, 0

Popped off OI-WL:   %62 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, i64 0, 2

Popped off OI-WL:   %62 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, i64 0, 2

Popped off OI-WL:   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, ptr %59, 1

Popped off OI-WL:   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, ptr %59, 1

Popped off OI-WL:   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %59, 0

Popped off OI-WL:   %59 = call ptr @malloc(i64 %58)

Popped off OI-WL:   %58 = ptrtoint ptr %57 to i64

Popped off OI-WL:   %57 = getelementptr i64, ptr null, i64 %12

Popped off OI-WL:   %56 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off OI-WL:   %51 = icmp slt i64 %50, %10

Popped off OI-WL:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 1, 4, 0

Popped off OI-WL:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 1, 4, 0

Popped off OI-WL:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 1, 4, 0

Popped off OI-WL:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 1, 4, 0

Popped off OI-WL:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 1, 4, 0

Popped off OI-WL:   %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, i64 %10, 3, 0

Popped off OI-WL:   %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, i64 %10, 3, 0

Popped off OI-WL:   %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, i64 %10, 3, 0

Popped off OI-WL:   %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, i64 %10, 3, 0

Popped off OI-WL:   %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, i64 %10, 3, 0

Popped off OI-WL:   %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 0, 2

Popped off OI-WL:   %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 0, 2

Popped off OI-WL:   %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, ptr %43, 1

Popped off OI-WL:   %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, ptr %43, 1

Popped off OI-WL:   %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %43, 0

Popped off OI-WL:   %43 = call ptr @malloc(i64 %42)

Popped off OI-WL:   %42 = ptrtoint ptr %41 to i64

Popped off OI-WL:   %41 = getelementptr i64, ptr null, i64 %10

Popped off OI-WL:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off OI-WL:   %35 = icmp slt i64 %34, %8

Popped off OI-WL:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 1, 4, 0

Popped off OI-WL:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 1, 4, 0

Popped off OI-WL:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 1, 4, 0

Popped off OI-WL:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 1, 4, 0

Popped off OI-WL:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 1, 4, 0

Popped off OI-WL:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, i64 %8, 3, 0

Popped off OI-WL:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, i64 %8, 3, 0

Popped off OI-WL:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, i64 %8, 3, 0

Popped off OI-WL:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, i64 %8, 3, 0

Popped off OI-WL:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, i64 %8, 3, 0

Popped off OI-WL:   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %29, i64 0, 2

Popped off OI-WL:   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %29, i64 0, 2

Popped off OI-WL:   %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, ptr %27, 1

Popped off OI-WL:   %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, ptr %27, 1

Popped off OI-WL:   %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %27, 0

Popped off OI-WL:   %27 = call ptr @malloc(i64 %26)

Popped off OI-WL:   %26 = ptrtoint ptr %25 to i64

Popped off OI-WL:   %25 = getelementptr i64, ptr null, i64 %8

Popped off OI-WL:   %24 = load i64, ptr %23, align 4
Merged constantrange<0, 2> into   %.08 = call i64 @llvm.ssa.copy.i64(i64 %162) : constantrange<0, 2>

Popped off OI-WL:   %23 = getelementptr i64, ptr %1, i64 8

Popped off OI-WL:   %22 = load i64, ptr %21, align 4
Merged constantrange<0, 2> into   %.07 = call i64 @llvm.ssa.copy.i64(i64 %146) : constantrange<0, 2>

Popped off OI-WL:   %21 = getelementptr i64, ptr %1, i64 7

Popped off OI-WL:   %20 = load i64, ptr %19, align 4
Merged constantrange<0, 2> into   %.06 = call i64 @llvm.ssa.copy.i64(i64 %130) : constantrange<0, 2>

Popped off OI-WL:   %19 = getelementptr i64, ptr %1, i64 6

Popped off OI-WL:   %18 = load i64, ptr %17, align 4
Merged constantrange<0, 2> into   %.05 = call i64 @llvm.ssa.copy.i64(i64 %114) : constantrange<0, 2>

Popped off OI-WL:   %17 = getelementptr i64, ptr %1, i64 5

Popped off OI-WL:   %16 = load i64, ptr %15, align 4
Merged constantrange<0, 2> into   %.04 = call i64 @llvm.ssa.copy.i64(i64 %98) : constantrange<0, 2>

Popped off OI-WL:   %15 = getelementptr i64, ptr %1, i64 4

Popped off OI-WL:   %14 = load i64, ptr %13, align 4
Merged constantrange<0, 2> into   %.03 = call i64 @llvm.ssa.copy.i64(i64 %82) : constantrange<0, 2>

Popped off OI-WL:   %13 = getelementptr i64, ptr %1, i64 3

Popped off OI-WL:   %12 = load i64, ptr %11, align 4
Merged constantrange<0, 2> into   %.02 = call i64 @llvm.ssa.copy.i64(i64 %66) : constantrange<0, 2>

Popped off OI-WL:   %11 = getelementptr i64, ptr %1, i64 2

Popped off OI-WL:   %10 = load i64, ptr %9, align 4
Merged constantrange<0, 2> into   %.01 = call i64 @llvm.ssa.copy.i64(i64 %50) : constantrange<0, 2>

Popped off OI-WL:   %9 = getelementptr i64, ptr %1, i64 1

Popped off OI-WL:   %8 = load i64, ptr %1, align 4
Merged constantrange<0, 2> into   %.0 = call i64 @llvm.ssa.copy.i64(i64 %34) : constantrange<0, 2>

Popped off OI-WL:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 4, i32 0

Popped off OI-WL:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 3, i32 0

Popped off OI-WL:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 2

Popped off OI-WL:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 1

Popped off OI-WL:   %7 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off OI-WL:   %6 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %5, i64 1, 4, 0

Popped off OI-WL:   %6 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %5, i64 1, 4, 0

Popped off OI-WL:   %6 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %5, i64 1, 4, 0

Popped off OI-WL:   %6 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %5, i64 1, 4, 0

Popped off OI-WL:   %6 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %5, i64 1, 4, 0

Popped off OI-WL:   %5 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %4, i64 7, 3, 0

Popped off OI-WL:   %5 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %4, i64 7, 3, 0

Popped off OI-WL:   %5 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %4, i64 7, 3, 0

Popped off OI-WL:   %5 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %4, i64 7, 3, 0

Popped off OI-WL:   %5 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %4, i64 7, 3, 0

Popped off OI-WL:   %4 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %3, i64 0, 2

Popped off OI-WL:   %4 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %3, i64 0, 2

Popped off OI-WL:   %3 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %2, ptr %1, 1

Popped off OI-WL:   %3 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %2, ptr %1, 1

Popped off OI-WL:   %2 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %1, 0

Popped off OI-WL:   %1 = call ptr @malloc(i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 7) to i64))

Popped off I-WL:   %.0 = call i64 @llvm.ssa.copy.i64(i64 %34)
Merged constantrange<1, 3> into   %38 = add i64 %.0, 1 : constantrange<1, 3>

Popped off I-WL:   %38 = add i64 %.0, 1
Merged constantrange<0, 3> into   %34 = phi i64 [ %38, %36 ], [ 0, %0 ] : constantrange<0, 3>

Popped off I-WL:   %34 = phi i64 [ %38, %36 ], [ 0, %0 ]
Merged constantrange<0, 3> into   %.0 = call i64 @llvm.ssa.copy.i64(i64 %34) : constantrange<0, 3>

Popped off I-WL:   %.0 = call i64 @llvm.ssa.copy.i64(i64 %34)
Merged constantrange<1, 4> into   %38 = add i64 %.0, 1 : constantrange<1, 4>

Popped off I-WL:   %38 = add i64 %.0, 1
Merged constantrange<0, 4> into   %34 = phi i64 [ %38, %36 ], [ 0, %0 ] : overdefined

Popped off I-WL:   %.01 = call i64 @llvm.ssa.copy.i64(i64 %50)
Merged constantrange<1, 3> into   %54 = add i64 %.01, 1 : constantrange<1, 3>

Popped off I-WL:   %54 = add i64 %.01, 1
Merged constantrange<0, 3> into   %50 = phi i64 [ %54, %52 ], [ 0, %39 ] : constantrange<0, 3>

Popped off I-WL:   %50 = phi i64 [ %54, %52 ], [ 0, %39 ]
Merged constantrange<0, 3> into   %.01 = call i64 @llvm.ssa.copy.i64(i64 %50) : constantrange<0, 3>

Popped off I-WL:   %.01 = call i64 @llvm.ssa.copy.i64(i64 %50)
Merged constantrange<1, 4> into   %54 = add i64 %.01, 1 : constantrange<1, 4>

Popped off I-WL:   %54 = add i64 %.01, 1
Merged constantrange<0, 4> into   %50 = phi i64 [ %54, %52 ], [ 0, %39 ] : overdefined

Popped off I-WL:   %.02 = call i64 @llvm.ssa.copy.i64(i64 %66)
Merged constantrange<1, 3> into   %70 = add i64 %.02, 1 : constantrange<1, 3>

Popped off I-WL:   %70 = add i64 %.02, 1
Merged constantrange<0, 3> into   %66 = phi i64 [ %70, %68 ], [ 0, %55 ] : constantrange<0, 3>

Popped off I-WL:   %66 = phi i64 [ %70, %68 ], [ 0, %55 ]
Merged constantrange<0, 3> into   %.02 = call i64 @llvm.ssa.copy.i64(i64 %66) : constantrange<0, 3>

Popped off I-WL:   %.02 = call i64 @llvm.ssa.copy.i64(i64 %66)
Merged constantrange<1, 4> into   %70 = add i64 %.02, 1 : constantrange<1, 4>

Popped off I-WL:   %70 = add i64 %.02, 1
Merged constantrange<0, 4> into   %66 = phi i64 [ %70, %68 ], [ 0, %55 ] : overdefined

Popped off I-WL:   %.03 = call i64 @llvm.ssa.copy.i64(i64 %82)
Merged constantrange<1, 3> into   %86 = add i64 %.03, 1 : constantrange<1, 3>

Popped off I-WL:   %86 = add i64 %.03, 1
Merged constantrange<0, 3> into   %82 = phi i64 [ %86, %84 ], [ 0, %71 ] : constantrange<0, 3>

Popped off I-WL:   %82 = phi i64 [ %86, %84 ], [ 0, %71 ]
Merged constantrange<0, 3> into   %.03 = call i64 @llvm.ssa.copy.i64(i64 %82) : constantrange<0, 3>

Popped off I-WL:   %.03 = call i64 @llvm.ssa.copy.i64(i64 %82)
Merged constantrange<1, 4> into   %86 = add i64 %.03, 1 : constantrange<1, 4>

Popped off I-WL:   %86 = add i64 %.03, 1
Merged constantrange<0, 4> into   %82 = phi i64 [ %86, %84 ], [ 0, %71 ] : overdefined

Popped off I-WL:   %.04 = call i64 @llvm.ssa.copy.i64(i64 %98)
Merged constantrange<1, 3> into   %102 = add i64 %.04, 1 : constantrange<1, 3>

Popped off I-WL:   %102 = add i64 %.04, 1
Merged constantrange<0, 3> into   %98 = phi i64 [ %102, %100 ], [ 0, %87 ] : constantrange<0, 3>

Popped off I-WL:   %98 = phi i64 [ %102, %100 ], [ 0, %87 ]
Merged constantrange<0, 3> into   %.04 = call i64 @llvm.ssa.copy.i64(i64 %98) : constantrange<0, 3>

Popped off I-WL:   %.04 = call i64 @llvm.ssa.copy.i64(i64 %98)
Merged constantrange<1, 4> into   %102 = add i64 %.04, 1 : constantrange<1, 4>

Popped off I-WL:   %102 = add i64 %.04, 1
Merged constantrange<0, 4> into   %98 = phi i64 [ %102, %100 ], [ 0, %87 ] : overdefined

Popped off I-WL:   %.05 = call i64 @llvm.ssa.copy.i64(i64 %114)
Merged constantrange<1, 3> into   %118 = add i64 %.05, 1 : constantrange<1, 3>

Popped off I-WL:   %118 = add i64 %.05, 1
Merged constantrange<0, 3> into   %114 = phi i64 [ %118, %116 ], [ 0, %103 ] : constantrange<0, 3>

Popped off I-WL:   %114 = phi i64 [ %118, %116 ], [ 0, %103 ]
Merged constantrange<0, 3> into   %.05 = call i64 @llvm.ssa.copy.i64(i64 %114) : constantrange<0, 3>

Popped off I-WL:   %.05 = call i64 @llvm.ssa.copy.i64(i64 %114)
Merged constantrange<1, 4> into   %118 = add i64 %.05, 1 : constantrange<1, 4>

Popped off I-WL:   %118 = add i64 %.05, 1
Merged constantrange<0, 4> into   %114 = phi i64 [ %118, %116 ], [ 0, %103 ] : overdefined

Popped off I-WL:   %.06 = call i64 @llvm.ssa.copy.i64(i64 %130)
Merged constantrange<1, 3> into   %134 = add i64 %.06, 1 : constantrange<1, 3>

Popped off I-WL:   %134 = add i64 %.06, 1
Merged constantrange<0, 3> into   %130 = phi i64 [ %134, %132 ], [ 0, %119 ] : constantrange<0, 3>

Popped off I-WL:   %130 = phi i64 [ %134, %132 ], [ 0, %119 ]
Merged constantrange<0, 3> into   %.06 = call i64 @llvm.ssa.copy.i64(i64 %130) : constantrange<0, 3>

Popped off I-WL:   %.06 = call i64 @llvm.ssa.copy.i64(i64 %130)
Merged constantrange<1, 4> into   %134 = add i64 %.06, 1 : constantrange<1, 4>

Popped off I-WL:   %134 = add i64 %.06, 1
Merged constantrange<0, 4> into   %130 = phi i64 [ %134, %132 ], [ 0, %119 ] : overdefined

Popped off I-WL:   %.07 = call i64 @llvm.ssa.copy.i64(i64 %146)
Merged constantrange<1, 3> into   %150 = add i64 %.07, 1 : constantrange<1, 3>

Popped off I-WL:   %150 = add i64 %.07, 1
Merged constantrange<0, 3> into   %146 = phi i64 [ %150, %148 ], [ 0, %135 ] : constantrange<0, 3>

Popped off I-WL:   %146 = phi i64 [ %150, %148 ], [ 0, %135 ]
Merged constantrange<0, 3> into   %.07 = call i64 @llvm.ssa.copy.i64(i64 %146) : constantrange<0, 3>

Popped off I-WL:   %.07 = call i64 @llvm.ssa.copy.i64(i64 %146)
Merged constantrange<1, 4> into   %150 = add i64 %.07, 1 : constantrange<1, 4>

Popped off I-WL:   %150 = add i64 %.07, 1
Merged constantrange<0, 4> into   %146 = phi i64 [ %150, %148 ], [ 0, %135 ] : overdefined

Popped off I-WL:   %.08 = call i64 @llvm.ssa.copy.i64(i64 %162)
Merged constantrange<1, 3> into   %166 = add i64 %.08, 1 : constantrange<1, 3>

Popped off I-WL:   %166 = add i64 %.08, 1
Merged constantrange<0, 3> into   %162 = phi i64 [ %166, %164 ], [ 0, %151 ] : constantrange<0, 3>

Popped off I-WL:   %162 = phi i64 [ %166, %164 ], [ 0, %151 ]
Merged constantrange<0, 3> into   %.08 = call i64 @llvm.ssa.copy.i64(i64 %162) : constantrange<0, 3>

Popped off I-WL:   %.08 = call i64 @llvm.ssa.copy.i64(i64 %162)
Merged constantrange<1, 4> into   %166 = add i64 %.08, 1 : constantrange<1, 4>

Popped off I-WL:   %166 = add i64 %.08, 1
Merged constantrange<0, 4> into   %162 = phi i64 [ %166, %164 ], [ 0, %151 ] : overdefined

Popped off I-WL:   %34 = phi i64 [ %38, %36 ], [ 0, %0 ]

Popped off I-WL:   %38 = add i64 %.0, 1

Popped off I-WL:   %50 = phi i64 [ %54, %52 ], [ 0, %39 ]

Popped off I-WL:   %54 = add i64 %.01, 1

Popped off I-WL:   %66 = phi i64 [ %70, %68 ], [ 0, %55 ]

Popped off I-WL:   %70 = add i64 %.02, 1

Popped off I-WL:   %82 = phi i64 [ %86, %84 ], [ 0, %71 ]

Popped off I-WL:   %86 = add i64 %.03, 1

Popped off I-WL:   %98 = phi i64 [ %102, %100 ], [ 0, %87 ]

Popped off I-WL:   %102 = add i64 %.04, 1

Popped off I-WL:   %114 = phi i64 [ %118, %116 ], [ 0, %103 ]

Popped off I-WL:   %118 = add i64 %.05, 1

Popped off I-WL:   %130 = phi i64 [ %134, %132 ], [ 0, %119 ]

Popped off I-WL:   %134 = add i64 %.06, 1

Popped off I-WL:   %146 = phi i64 [ %150, %148 ], [ 0, %135 ]

Popped off I-WL:   %150 = add i64 %.07, 1

Popped off I-WL:   %162 = phi i64 [ %166, %164 ], [ 0, %151 ]

Popped off I-WL:   %166 = add i64 %.08, 1

Popped off I-WL:   %.08 = call i64 @llvm.ssa.copy.i64(i64 %162)

Popped off I-WL:   %162 = phi i64 [ %166, %164 ], [ 0, %151 ]

Popped off I-WL:   %158 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %157, i64 0, 2

Popped off I-WL:   %158 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %157, i64 0, 2

Popped off I-WL:   %158 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %157, i64 0, 2

Popped off I-WL:   %157 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %156, ptr %155, 1

Popped off I-WL:   %157 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %156, ptr %155, 1

Popped off I-WL:   %157 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %156, ptr %155, 1

Popped off I-WL:   %156 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %155, 0

Popped off I-WL:   %156 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %155, 0

Popped off I-WL:   %156 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %155, 0

Popped off I-WL:   %156 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %155, 0

Popped off I-WL:   %.07 = call i64 @llvm.ssa.copy.i64(i64 %146)

Popped off I-WL:   %146 = phi i64 [ %150, %148 ], [ 0, %135 ]

Popped off I-WL:   %142 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %141, i64 0, 2

Popped off I-WL:   %142 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %141, i64 0, 2

Popped off I-WL:   %142 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %141, i64 0, 2

Popped off I-WL:   %141 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %140, ptr %139, 1

Popped off I-WL:   %141 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %140, ptr %139, 1

Popped off I-WL:   %141 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %140, ptr %139, 1

Popped off I-WL:   %140 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %139, 0

Popped off I-WL:   %140 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %139, 0

Popped off I-WL:   %140 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %139, 0

Popped off I-WL:   %140 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %139, 0

Popped off I-WL:   %.06 = call i64 @llvm.ssa.copy.i64(i64 %130)

Popped off I-WL:   %130 = phi i64 [ %134, %132 ], [ 0, %119 ]

Popped off I-WL:   %126 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %125, i64 0, 2

Popped off I-WL:   %126 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %125, i64 0, 2

Popped off I-WL:   %126 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %125, i64 0, 2

Popped off I-WL:   %125 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %124, ptr %123, 1

Popped off I-WL:   %125 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %124, ptr %123, 1

Popped off I-WL:   %125 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %124, ptr %123, 1

Popped off I-WL:   %124 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %123, 0

Popped off I-WL:   %124 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %123, 0

Popped off I-WL:   %124 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %123, 0

Popped off I-WL:   %124 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %123, 0

Popped off I-WL:   %.05 = call i64 @llvm.ssa.copy.i64(i64 %114)

Popped off I-WL:   %114 = phi i64 [ %118, %116 ], [ 0, %103 ]

Popped off I-WL:   %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %109, i64 0, 2

Popped off I-WL:   %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %109, i64 0, 2

Popped off I-WL:   %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %109, i64 0, 2

Popped off I-WL:   %109 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %108, ptr %107, 1

Popped off I-WL:   %109 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %108, ptr %107, 1

Popped off I-WL:   %109 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %108, ptr %107, 1

Popped off I-WL:   %108 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %107, 0

Popped off I-WL:   %108 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %107, 0

Popped off I-WL:   %108 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %107, 0

Popped off I-WL:   %108 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %107, 0

Popped off I-WL:   %.04 = call i64 @llvm.ssa.copy.i64(i64 %98)

Popped off I-WL:   %98 = phi i64 [ %102, %100 ], [ 0, %87 ]

Popped off I-WL:   %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, i64 0, 2

Popped off I-WL:   %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, i64 0, 2

Popped off I-WL:   %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, i64 0, 2

Popped off I-WL:   %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %92, ptr %91, 1

Popped off I-WL:   %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %92, ptr %91, 1

Popped off I-WL:   %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %92, ptr %91, 1

Popped off I-WL:   %92 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %91, 0

Popped off I-WL:   %92 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %91, 0

Popped off I-WL:   %92 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %91, 0

Popped off I-WL:   %92 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %91, 0

Popped off I-WL:   %.03 = call i64 @llvm.ssa.copy.i64(i64 %82)

Popped off I-WL:   %82 = phi i64 [ %86, %84 ], [ 0, %71 ]

Popped off I-WL:   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 0, 2

Popped off I-WL:   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 0, 2

Popped off I-WL:   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 0, 2

Popped off I-WL:   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, ptr %75, 1

Popped off I-WL:   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, ptr %75, 1

Popped off I-WL:   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, ptr %75, 1

Popped off I-WL:   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %75, 0

Popped off I-WL:   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %75, 0

Popped off I-WL:   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %75, 0

Popped off I-WL:   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %75, 0

Popped off I-WL:   %.02 = call i64 @llvm.ssa.copy.i64(i64 %66)

Popped off I-WL:   %66 = phi i64 [ %70, %68 ], [ 0, %55 ]

Popped off I-WL:   %62 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, i64 0, 2

Popped off I-WL:   %62 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, i64 0, 2

Popped off I-WL:   %62 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, i64 0, 2

Popped off I-WL:   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, ptr %59, 1

Popped off I-WL:   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, ptr %59, 1

Popped off I-WL:   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, ptr %59, 1

Popped off I-WL:   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %59, 0

Popped off I-WL:   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %59, 0

Popped off I-WL:   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %59, 0

Popped off I-WL:   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %59, 0

Popped off I-WL:   %.01 = call i64 @llvm.ssa.copy.i64(i64 %50)

Popped off I-WL:   %50 = phi i64 [ %54, %52 ], [ 0, %39 ]

Popped off I-WL:   %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 0, 2

Popped off I-WL:   %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 0, 2

Popped off I-WL:   %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 0, 2

Popped off I-WL:   %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, ptr %43, 1

Popped off I-WL:   %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, ptr %43, 1

Popped off I-WL:   %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, ptr %43, 1

Popped off I-WL:   %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %43, 0

Popped off I-WL:   %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %43, 0

Popped off I-WL:   %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %43, 0

Popped off I-WL:   %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %43, 0

Popped off I-WL:   %.0 = call i64 @llvm.ssa.copy.i64(i64 %34)

Popped off I-WL:   %34 = phi i64 [ %38, %36 ], [ 0, %0 ]

Popped off I-WL:   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %29, i64 0, 2

Popped off I-WL:   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %29, i64 0, 2

Popped off I-WL:   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %29, i64 0, 2

Popped off I-WL:   %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, ptr %27, 1

Popped off I-WL:   %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, ptr %27, 1

Popped off I-WL:   %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, ptr %27, 1

Popped off I-WL:   %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %27, 0

Popped off I-WL:   %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %27, 0

Popped off I-WL:   %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %27, 0

Popped off I-WL:   %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %27, 0

Popped off I-WL:   %4 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %3, i64 0, 2

Popped off I-WL:   %4 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %3, i64 0, 2

Popped off I-WL:   %4 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %3, i64 0, 2

Popped off I-WL:   %3 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %2, ptr %1, 1

Popped off I-WL:   %3 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %2, ptr %1, 1

Popped off I-WL:   %3 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %2, ptr %1, 1

Popped off I-WL:   %2 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %1, 0

Popped off I-WL:   %2 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %1, 0

Popped off I-WL:   %2 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %1, 0

Popped off I-WL:   %2 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %1, 0

Popped off OI-WL:   %162 = phi i64 [ %166, %164 ], [ 0, %151 ]
Merged overdefined into   %.08 = call i64 @llvm.ssa.copy.i64(i64 %162) : overdefined

Popped off OI-WL:   %.08 = call i64 @llvm.ssa.copy.i64(i64 %162)
Merged overdefined into   %166 = add i64 %.08, 1 : overdefined

Popped off OI-WL:   %166 = add i64 %.08, 1

Popped off OI-WL:   %146 = phi i64 [ %150, %148 ], [ 0, %135 ]
Merged overdefined into   %.07 = call i64 @llvm.ssa.copy.i64(i64 %146) : overdefined

Popped off OI-WL:   %.07 = call i64 @llvm.ssa.copy.i64(i64 %146)
Merged overdefined into   %150 = add i64 %.07, 1 : overdefined

Popped off OI-WL:   %150 = add i64 %.07, 1

Popped off OI-WL:   %130 = phi i64 [ %134, %132 ], [ 0, %119 ]
Merged overdefined into   %.06 = call i64 @llvm.ssa.copy.i64(i64 %130) : overdefined

Popped off OI-WL:   %.06 = call i64 @llvm.ssa.copy.i64(i64 %130)
Merged overdefined into   %134 = add i64 %.06, 1 : overdefined

Popped off OI-WL:   %134 = add i64 %.06, 1

Popped off OI-WL:   %114 = phi i64 [ %118, %116 ], [ 0, %103 ]
Merged overdefined into   %.05 = call i64 @llvm.ssa.copy.i64(i64 %114) : overdefined

Popped off OI-WL:   %.05 = call i64 @llvm.ssa.copy.i64(i64 %114)
Merged overdefined into   %118 = add i64 %.05, 1 : overdefined

Popped off OI-WL:   %118 = add i64 %.05, 1

Popped off OI-WL:   %98 = phi i64 [ %102, %100 ], [ 0, %87 ]
Merged overdefined into   %.04 = call i64 @llvm.ssa.copy.i64(i64 %98) : overdefined

Popped off OI-WL:   %.04 = call i64 @llvm.ssa.copy.i64(i64 %98)
Merged overdefined into   %102 = add i64 %.04, 1 : overdefined

Popped off OI-WL:   %102 = add i64 %.04, 1

Popped off OI-WL:   %82 = phi i64 [ %86, %84 ], [ 0, %71 ]
Merged overdefined into   %.03 = call i64 @llvm.ssa.copy.i64(i64 %82) : overdefined

Popped off OI-WL:   %.03 = call i64 @llvm.ssa.copy.i64(i64 %82)
Merged overdefined into   %86 = add i64 %.03, 1 : overdefined

Popped off OI-WL:   %86 = add i64 %.03, 1

Popped off OI-WL:   %66 = phi i64 [ %70, %68 ], [ 0, %55 ]
Merged overdefined into   %.02 = call i64 @llvm.ssa.copy.i64(i64 %66) : overdefined

Popped off OI-WL:   %.02 = call i64 @llvm.ssa.copy.i64(i64 %66)
Merged overdefined into   %70 = add i64 %.02, 1 : overdefined

Popped off OI-WL:   %70 = add i64 %.02, 1

Popped off OI-WL:   %50 = phi i64 [ %54, %52 ], [ 0, %39 ]
Merged overdefined into   %.01 = call i64 @llvm.ssa.copy.i64(i64 %50) : overdefined

Popped off OI-WL:   %.01 = call i64 @llvm.ssa.copy.i64(i64 %50)
Merged overdefined into   %54 = add i64 %.01, 1 : overdefined

Popped off OI-WL:   %54 = add i64 %.01, 1

Popped off OI-WL:   %34 = phi i64 [ %38, %36 ], [ 0, %0 ]
Merged overdefined into   %.0 = call i64 @llvm.ssa.copy.i64(i64 %34) : overdefined

Popped off OI-WL:   %.0 = call i64 @llvm.ssa.copy.i64(i64 %34)
Merged overdefined into   %38 = add i64 %.0, 1 : overdefined

Popped off OI-WL:   %38 = add i64 %.0, 1
FnSpecialization: No possible specializations found in module
Marking Block Executable: 
Marking Block Executable: 

Popped off BBWL: 
  call void @main()
  ret void

Popped off BBWL: 
  %1 = call ptr @malloc(i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 7) to i64))
  %2 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %1, 0
  %3 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %2, ptr %1, 1
  %4 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %3, i64 0, 2
  %5 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %4, i64 7, 3, 0
  %6 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %5, i64 1, 4, 0
  %7 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store ptr %1, ptr %7, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 1
  store ptr %1, ptr %.fca.1.gep, align 8
  %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 2
  store i64 0, ptr %.fca.2.gep, align 8
  %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 3, i32 0
  store i64 7, ptr %.fca.3.0.gep, align 8
  %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 4, i32 0
  store i64 1, ptr %.fca.4.0.gep, align 8
  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr %7, i32 1)
  %8 = load i64, ptr %1, align 4
  %9 = getelementptr i64, ptr %1, i64 1
  %10 = load i64, ptr %9, align 4
  %11 = getelementptr i64, ptr %1, i64 2
  %12 = load i64, ptr %11, align 4
  %13 = getelementptr i64, ptr %1, i64 3
  %14 = load i64, ptr %13, align 4
  %15 = getelementptr i64, ptr %1, i64 4
  %16 = load i64, ptr %15, align 4
  %17 = getelementptr i64, ptr %1, i64 5
  %18 = load i64, ptr %17, align 4
  %19 = getelementptr i64, ptr %1, i64 6
  %20 = load i64, ptr %19, align 4
  %21 = getelementptr i64, ptr %1, i64 7
  %22 = load i64, ptr %21, align 4
  %23 = getelementptr i64, ptr %1, i64 8
  %24 = load i64, ptr %23, align 4
  %25 = getelementptr i64, ptr null, i64 %8
  %26 = ptrtoint ptr %25 to i64
  %27 = call ptr @malloc(i64 %26)
  %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %27, 0
  %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, ptr %27, 1
  %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %29, i64 0, 2
  %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, i64 %8, 3, 0
  %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 1, 4, 0
  br label %33
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
33:                                               ; preds = %36, %0
  %34 = phi i64 [ %38, %36 ], [ 0, %0 ]
  %35 = icmp slt i64 %34, %8
  br i1 %35, label %36, label %39
Marking Edge Executable:  -> 
Marking Block Executable: 
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
39:                                               ; preds = %33
  %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, ptr %40, align 8
  %41 = getelementptr i64, ptr null, i64 %10
  %42 = ptrtoint ptr %41 to i64
  %43 = call ptr @malloc(i64 %42)
  %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %43, 0
  %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, ptr %43, 1
  %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 0, 2
  %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, i64 %10, 3, 0
  %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 1, 4, 0
  br label %49
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
49:                                               ; preds = %52, %39
  %50 = phi i64 [ %54, %52 ], [ 0, %39 ]
  %51 = icmp slt i64 %50, %10
  br i1 %51, label %52, label %55
Marking Edge Executable:  -> 
Marking Block Executable: 
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
55:                                               ; preds = %49
  %56 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, ptr %56, align 8
  %57 = getelementptr i64, ptr null, i64 %12
  %58 = ptrtoint ptr %57 to i64
  %59 = call ptr @malloc(i64 %58)
  %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %59, 0
  %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, ptr %59, 1
  %62 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, i64 0, 2
  %63 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %62, i64 %12, 3, 0
  %64 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %63, i64 1, 4, 0
  br label %65
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
65:                                               ; preds = %68, %55
  %66 = phi i64 [ %70, %68 ], [ 0, %55 ]
  %67 = icmp slt i64 %66, %12
  br i1 %67, label %68, label %71
Marking Edge Executable:  -> 
Marking Block Executable: 
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
71:                                               ; preds = %65
  %72 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %64, ptr %72, align 8
  %73 = getelementptr i64, ptr null, i64 %14
  %74 = ptrtoint ptr %73 to i64
  %75 = call ptr @malloc(i64 %74)
  %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %75, 0
  %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, ptr %75, 1
  %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 0, 2
  %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 %14, 3, 0
  %80 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, i64 1, 4, 0
  br label %81
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
81:                                               ; preds = %84, %71
  %82 = phi i64 [ %86, %84 ], [ 0, %71 ]
  %83 = icmp slt i64 %82, %14
  br i1 %83, label %84, label %87
Marking Edge Executable:  -> 
Marking Block Executable: 
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
87:                                               ; preds = %81
  %88 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %80, ptr %88, align 8
  %89 = getelementptr i64, ptr null, i64 %16
  %90 = ptrtoint ptr %89 to i64
  %91 = call ptr @malloc(i64 %90)
  %92 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %91, 0
  %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %92, ptr %91, 1
  %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, i64 0, 2
  %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 %16, 3, 0
  %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 1, 4, 0
  br label %97
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
97:                                               ; preds = %100, %87
  %98 = phi i64 [ %102, %100 ], [ 0, %87 ]
  %99 = icmp slt i64 %98, %16
  br i1 %99, label %100, label %103
Marking Edge Executable:  -> 
Marking Block Executable: 
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
103:                                              ; preds = %97
  %104 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %96, ptr %104, align 8
  %105 = getelementptr i64, ptr null, i64 %18
  %106 = ptrtoint ptr %105 to i64
  %107 = call ptr @malloc(i64 %106)
  %108 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %107, 0
  %109 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %108, ptr %107, 1
  %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %109, i64 0, 2
  %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, i64 %18, 3, 0
  %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 1, 4, 0
  br label %113
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
113:                                              ; preds = %116, %103
  %114 = phi i64 [ %118, %116 ], [ 0, %103 ]
  %115 = icmp slt i64 %114, %18
  br i1 %115, label %116, label %119
Marking Edge Executable:  -> 
Marking Block Executable: 
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
119:                                              ; preds = %113
  %120 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %112, ptr %120, align 8
  %121 = getelementptr i64, ptr null, i64 %20
  %122 = ptrtoint ptr %121 to i64
  %123 = call ptr @malloc(i64 %122)
  %124 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %123, 0
  %125 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %124, ptr %123, 1
  %126 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %125, i64 0, 2
  %127 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %126, i64 %20, 3, 0
  %128 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %127, i64 1, 4, 0
  br label %129
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
129:                                              ; preds = %132, %119
  %130 = phi i64 [ %134, %132 ], [ 0, %119 ]
  %131 = icmp slt i64 %130, %20
  br i1 %131, label %132, label %135
Marking Edge Executable:  -> 
Marking Block Executable: 
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
135:                                              ; preds = %129
  %136 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %128, ptr %136, align 8
  %137 = getelementptr i64, ptr null, i64 %22
  %138 = ptrtoint ptr %137 to i64
  %139 = call ptr @malloc(i64 %138)
  %140 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %139, 0
  %141 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %140, ptr %139, 1
  %142 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %141, i64 0, 2
  %143 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %142, i64 %22, 3, 0
  %144 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %143, i64 1, 4, 0
  br label %145
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
145:                                              ; preds = %148, %135
  %146 = phi i64 [ %150, %148 ], [ 0, %135 ]
  %147 = icmp slt i64 %146, %22
  br i1 %147, label %148, label %151
Marking Edge Executable:  -> 
Marking Block Executable: 
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
151:                                              ; preds = %145
  %152 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %144, ptr %152, align 8
  %153 = getelementptr double, ptr null, i64 %24
  %154 = ptrtoint ptr %153 to i64
  %155 = call ptr @malloc(i64 %154)
  %156 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %155, 0
  %157 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %156, ptr %155, 1
  %158 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %157, i64 0, 2
  %159 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %158, i64 %24, 3, 0
  %160 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %159, i64 1, 4, 0
  br label %161
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
161:                                              ; preds = %164, %151
  %162 = phi i64 [ %166, %164 ], [ 0, %151 ]
  %163 = icmp slt i64 %162, %24
  br i1 %163, label %164, label %167
Marking Edge Executable:  -> 
Marking Block Executable: 
Marking Edge Executable:  -> 
Marking Block Executable: 

Popped off BBWL: 
167:                                              ; preds = %161
  %168 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %160, ptr %168, align 8
  call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr %40, i64 1, ptr %56, i64 1, ptr %72, i64 1, ptr %88, i64 1, ptr %104, i64 1, ptr %120, i64 1, ptr %136, i64 1, ptr %152, i64 1, ptr %168, i32 1)
  call void @comet_print_memref_i64(i64 1, ptr %40)
  call void @comet_print_memref_i64(i64 1, ptr %56)
  call void @comet_print_memref_i64(i64 1, ptr %72)
  call void @comet_print_memref_i64(i64 1, ptr %88)
  call void @comet_print_memref_i64(i64 1, ptr %104)
  call void @comet_print_memref_i64(i64 1, ptr %120)
  call void @comet_print_memref_i64(i64 1, ptr %136)
  call void @comet_print_memref_i64(i64 1, ptr %152)
  call void @comet_print_memref_f64(i64 1, ptr %168)
  ret void

Popped off BBWL: 
164:                                              ; preds = %161
  %165 = getelementptr double, ptr %155, i64 %162
  store double 0.000000e+00, ptr %165, align 8
  %166 = add i64 %162, 1
  br label %161
Marking Edge Executable:  -> 

Popped off BBWL: 
148:                                              ; preds = %145
  %149 = getelementptr i64, ptr %139, i64 %146
  store i64 0, ptr %149, align 4
  %150 = add i64 %146, 1
  br label %145
Marking Edge Executable:  -> 

Popped off BBWL: 
132:                                              ; preds = %129
  %133 = getelementptr i64, ptr %123, i64 %130
  store i64 0, ptr %133, align 4
  %134 = add i64 %130, 1
  br label %129
Marking Edge Executable:  -> 

Popped off BBWL: 
116:                                              ; preds = %113
  %117 = getelementptr i64, ptr %107, i64 %114
  store i64 0, ptr %117, align 4
  %118 = add i64 %114, 1
  br label %113
Marking Edge Executable:  -> 

Popped off BBWL: 
100:                                              ; preds = %97
  %101 = getelementptr i64, ptr %91, i64 %98
  store i64 0, ptr %101, align 4
  %102 = add i64 %98, 1
  br label %97
Marking Edge Executable:  -> 

Popped off BBWL: 
84:                                               ; preds = %81
  %85 = getelementptr i64, ptr %75, i64 %82
  store i64 0, ptr %85, align 4
  %86 = add i64 %82, 1
  br label %81
Marking Edge Executable:  -> 

Popped off BBWL: 
68:                                               ; preds = %65
  %69 = getelementptr i64, ptr %59, i64 %66
  store i64 0, ptr %69, align 4
  %70 = add i64 %66, 1
  br label %65
Marking Edge Executable:  -> 

Popped off BBWL: 
52:                                               ; preds = %49
  %53 = getelementptr i64, ptr %43, i64 %50
  store i64 0, ptr %53, align 4
  %54 = add i64 %50, 1
  br label %49
Marking Edge Executable:  -> 

Popped off BBWL: 
36:                                               ; preds = %33
  %37 = getelementptr i64, ptr %27, i64 %34
  store i64 0, ptr %37, align 4
  %38 = add i64 %34, 1
  br label %33
Marking Edge Executable:  -> 

Popped off V-WL:   %38 = add i64 %34, 1

Popped off V-WL:   %37 = getelementptr i64, ptr %27, i64 %34

Popped off V-WL:   %54 = add i64 %50, 1

Popped off V-WL:   %53 = getelementptr i64, ptr %43, i64 %50

Popped off V-WL:   %70 = add i64 %66, 1

Popped off V-WL:   %69 = getelementptr i64, ptr %59, i64 %66

Popped off V-WL:   %86 = add i64 %82, 1

Popped off V-WL:   %85 = getelementptr i64, ptr %75, i64 %82

Popped off V-WL:   %102 = add i64 %98, 1

Popped off V-WL:   %101 = getelementptr i64, ptr %91, i64 %98

Popped off V-WL:   %118 = add i64 %114, 1

Popped off V-WL:   %117 = getelementptr i64, ptr %107, i64 %114

Popped off V-WL:   %134 = add i64 %130, 1

Popped off V-WL:   %133 = getelementptr i64, ptr %123, i64 %130

Popped off V-WL:   %150 = add i64 %146, 1

Popped off V-WL:   %149 = getelementptr i64, ptr %139, i64 %146

Popped off V-WL:   %166 = add i64 %162, 1

Popped off V-WL:   %165 = getelementptr double, ptr %155, i64 %162

Popped off V-WL:   %168 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off V-WL:   %163 = icmp slt i64 %162, %24

Popped off V-WL:   %162 = phi i64 [ %166, %164 ], [ 0, %151 ]

Popped off V-WL:   %160 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %159, i64 1, 4, 0

Popped off V-WL:   %159 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %158, i64 %24, 3, 0

Popped off V-WL:   %158 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %157, i64 0, 2

Popped off V-WL:   %157 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %156, ptr %155, 1

Popped off V-WL:   %156 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %155, 0

Popped off V-WL:   %155 = call ptr @malloc(i64 %154)

Popped off V-WL:   %154 = ptrtoint ptr %153 to i64

Popped off V-WL:   %153 = getelementptr double, ptr null, i64 %24

Popped off V-WL:   %152 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off V-WL:   %147 = icmp slt i64 %146, %22

Popped off V-WL:   %146 = phi i64 [ %150, %148 ], [ 0, %135 ]

Popped off V-WL:   %144 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %143, i64 1, 4, 0

Popped off V-WL:   %143 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %142, i64 %22, 3, 0

Popped off V-WL:   %142 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %141, i64 0, 2

Popped off V-WL:   %141 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %140, ptr %139, 1

Popped off V-WL:   %140 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %139, 0

Popped off V-WL:   %139 = call ptr @malloc(i64 %138)

Popped off V-WL:   %138 = ptrtoint ptr %137 to i64

Popped off V-WL:   %137 = getelementptr i64, ptr null, i64 %22

Popped off V-WL:   %136 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off V-WL:   %131 = icmp slt i64 %130, %20

Popped off V-WL:   %130 = phi i64 [ %134, %132 ], [ 0, %119 ]

Popped off V-WL:   %128 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %127, i64 1, 4, 0

Popped off V-WL:   %127 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %126, i64 %20, 3, 0

Popped off V-WL:   %126 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %125, i64 0, 2

Popped off V-WL:   %125 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %124, ptr %123, 1

Popped off V-WL:   %124 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %123, 0

Popped off V-WL:   %123 = call ptr @malloc(i64 %122)

Popped off V-WL:   %122 = ptrtoint ptr %121 to i64

Popped off V-WL:   %121 = getelementptr i64, ptr null, i64 %20

Popped off V-WL:   %120 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off V-WL:   %115 = icmp slt i64 %114, %18

Popped off V-WL:   %114 = phi i64 [ %118, %116 ], [ 0, %103 ]

Popped off V-WL:   %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 1, 4, 0

Popped off V-WL:   %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, i64 %18, 3, 0

Popped off V-WL:   %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %109, i64 0, 2

Popped off V-WL:   %109 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %108, ptr %107, 1

Popped off V-WL:   %108 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %107, 0

Popped off V-WL:   %107 = call ptr @malloc(i64 %106)

Popped off V-WL:   %106 = ptrtoint ptr %105 to i64

Popped off V-WL:   %105 = getelementptr i64, ptr null, i64 %18

Popped off V-WL:   %104 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off V-WL:   %99 = icmp slt i64 %98, %16

Popped off V-WL:   %98 = phi i64 [ %102, %100 ], [ 0, %87 ]

Popped off V-WL:   %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 1, 4, 0

Popped off V-WL:   %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 %16, 3, 0

Popped off V-WL:   %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, i64 0, 2

Popped off V-WL:   %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %92, ptr %91, 1

Popped off V-WL:   %92 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %91, 0

Popped off V-WL:   %91 = call ptr @malloc(i64 %90)

Popped off V-WL:   %90 = ptrtoint ptr %89 to i64

Popped off V-WL:   %89 = getelementptr i64, ptr null, i64 %16

Popped off V-WL:   %88 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off V-WL:   %83 = icmp slt i64 %82, %14

Popped off V-WL:   %82 = phi i64 [ %86, %84 ], [ 0, %71 ]

Popped off V-WL:   %80 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, i64 1, 4, 0

Popped off V-WL:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 %14, 3, 0

Popped off V-WL:   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 0, 2

Popped off V-WL:   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, ptr %75, 1

Popped off V-WL:   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %75, 0

Popped off V-WL:   %75 = call ptr @malloc(i64 %74)

Popped off V-WL:   %74 = ptrtoint ptr %73 to i64

Popped off V-WL:   %73 = getelementptr i64, ptr null, i64 %14

Popped off V-WL:   %72 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off V-WL:   %67 = icmp slt i64 %66, %12

Popped off V-WL:   %66 = phi i64 [ %70, %68 ], [ 0, %55 ]

Popped off V-WL:   %64 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %63, i64 1, 4, 0

Popped off V-WL:   %63 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %62, i64 %12, 3, 0

Popped off V-WL:   %62 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, i64 0, 2

Popped off V-WL:   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, ptr %59, 1

Popped off V-WL:   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %59, 0

Popped off V-WL:   %59 = call ptr @malloc(i64 %58)

Popped off V-WL:   %58 = ptrtoint ptr %57 to i64

Popped off V-WL:   %57 = getelementptr i64, ptr null, i64 %12

Popped off V-WL:   %56 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off V-WL:   %51 = icmp slt i64 %50, %10

Popped off V-WL:   %50 = phi i64 [ %54, %52 ], [ 0, %39 ]

Popped off V-WL:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 1, 4, 0

Popped off V-WL:   %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, i64 %10, 3, 0

Popped off V-WL:   %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 0, 2

Popped off V-WL:   %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, ptr %43, 1

Popped off V-WL:   %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %43, 0

Popped off V-WL:   %43 = call ptr @malloc(i64 %42)

Popped off V-WL:   %42 = ptrtoint ptr %41 to i64

Popped off V-WL:   %41 = getelementptr i64, ptr null, i64 %10

Popped off V-WL:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off V-WL:   %35 = icmp slt i64 %34, %8

Popped off V-WL:   %34 = phi i64 [ %38, %36 ], [ 0, %0 ]

Popped off V-WL:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 1, 4, 0

Popped off V-WL:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, i64 %8, 3, 0

Popped off V-WL:   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %29, i64 0, 2

Popped off V-WL:   %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, ptr %27, 1

Popped off V-WL:   %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %27, 0

Popped off V-WL:   %27 = call ptr @malloc(i64 %26)

Popped off V-WL:   %26 = ptrtoint ptr %25 to i64

Popped off V-WL:   %25 = getelementptr i64, ptr null, i64 %8

Popped off V-WL:   %24 = load i64, ptr %23, align 4

Popped off V-WL:   %23 = getelementptr i64, ptr %1, i64 8

Popped off V-WL:   %22 = load i64, ptr %21, align 4

Popped off V-WL:   %21 = getelementptr i64, ptr %1, i64 7

Popped off V-WL:   %20 = load i64, ptr %19, align 4

Popped off V-WL:   %19 = getelementptr i64, ptr %1, i64 6

Popped off V-WL:   %18 = load i64, ptr %17, align 4

Popped off V-WL:   %17 = getelementptr i64, ptr %1, i64 5

Popped off V-WL:   %16 = load i64, ptr %15, align 4

Popped off V-WL:   %15 = getelementptr i64, ptr %1, i64 4

Popped off V-WL:   %14 = load i64, ptr %13, align 4

Popped off V-WL:   %13 = getelementptr i64, ptr %1, i64 3

Popped off V-WL:   %12 = load i64, ptr %11, align 4

Popped off V-WL:   %11 = getelementptr i64, ptr %1, i64 2

Popped off V-WL:   %10 = load i64, ptr %9, align 4

Popped off V-WL:   %9 = getelementptr i64, ptr %1, i64 1

Popped off V-WL:   %8 = load i64, ptr %1, align 4

Popped off V-WL:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 4, i32 0

Popped off V-WL:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 3, i32 0

Popped off V-WL:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 2

Popped off V-WL:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 1

Popped off V-WL:   %7 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8

Popped off V-WL:   %5 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %4, i64 7, 3, 0

Popped off V-WL:   %4 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %3, i64 0, 2

Popped off V-WL:   %3 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %2, ptr %1, 1

Popped off V-WL:   %2 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %1, 0

Popped off V-WL:   %1 = call ptr @malloc(i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 7) to i64))
GLOBAL DEAD: ; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) #1

GLOBAL DEAD: declare void @quick_sort(i64, ptr, i64)



INSTCOMBINE ITERATION #1 on main
IC: ConstFold operand of:   %1 = call ptr @malloc(i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 7) to i64))
    Old = i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 7) to i64)
    New = i64 56
ADD:   br label %33
ADD:   %38 = add i64 %34, 1
ADD:   store i64 0, ptr %37, align 4
ADD:   %37 = getelementptr i64, ptr %27, i64 %34
ADD:   br label %49
ADD:   %54 = add i64 %50, 1
ADD:   store i64 0, ptr %53, align 4
ADD:   %53 = getelementptr i64, ptr %43, i64 %50
ADD:   br label %65
ADD:   %70 = add i64 %66, 1
ADD:   store i64 0, ptr %69, align 4
ADD:   %69 = getelementptr i64, ptr %59, i64 %66
ADD:   br label %81
ADD:   %86 = add i64 %82, 1
ADD:   store i64 0, ptr %85, align 4
ADD:   %85 = getelementptr i64, ptr %75, i64 %82
ADD:   br label %97
ADD:   %102 = add i64 %98, 1
ADD:   store i64 0, ptr %101, align 4
ADD:   %101 = getelementptr i64, ptr %91, i64 %98
ADD:   br label %113
ADD:   %118 = add i64 %114, 1
ADD:   store i64 0, ptr %117, align 4
ADD:   %117 = getelementptr i64, ptr %107, i64 %114
ADD:   br label %129
ADD:   %134 = add i64 %130, 1
ADD:   store i64 0, ptr %133, align 4
ADD:   %133 = getelementptr i64, ptr %123, i64 %130
ADD:   br label %145
ADD:   %150 = add i64 %146, 1
ADD:   store i64 0, ptr %149, align 4
ADD:   %149 = getelementptr i64, ptr %139, i64 %146
ADD:   br label %161
ADD:   %166 = add i64 %162, 1
ADD:   store double 0.000000e+00, ptr %165, align 8
ADD:   %165 = getelementptr double, ptr %155, i64 %162
ADD:   ret void
ADD:   call void @comet_print_memref_f64(i64 1, ptr %168)
ADD:   call void @comet_print_memref_i64(i64 1, ptr %152)
ADD:   call void @comet_print_memref_i64(i64 1, ptr %136)
ADD:   call void @comet_print_memref_i64(i64 1, ptr %120)
ADD:   call void @comet_print_memref_i64(i64 1, ptr %104)
ADD:   call void @comet_print_memref_i64(i64 1, ptr %88)
ADD:   call void @comet_print_memref_i64(i64 1, ptr %72)
ADD:   call void @comet_print_memref_i64(i64 1, ptr %56)
ADD:   call void @comet_print_memref_i64(i64 1, ptr %40)
ADD:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr %40, i64 1, ptr %56, i64 1, ptr %72, i64 1, ptr %88, i64 1, ptr %104, i64 1, ptr %120, i64 1, ptr %136, i64 1, ptr %152, i64 1, ptr %168, i32 1)
ADD:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %160, ptr %168, align 8
ADD:   %168 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
ADD:   br i1 %163, label %164, label %167
ADD:   %163 = icmp slt i64 %162, %24
ADD:   %162 = phi i64 [ %166, %164 ], [ 0, %151 ]
ADD:   br label %161
ADD:   %160 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %159, i64 1, 4, 0
ADD:   %159 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %158, i64 %24, 3, 0
ADD:   %158 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %157, i64 0, 2
ADD:   %157 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %156, ptr %155, 1
ADD:   %156 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %155, 0
ADD:   %155 = call ptr @malloc(i64 %154)
ADD:   %154 = ptrtoint ptr %153 to i64
ADD:   %153 = getelementptr double, ptr null, i64 %24
ADD:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %144, ptr %152, align 8
ADD:   %152 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
ADD:   br i1 %147, label %148, label %151
ADD:   %147 = icmp slt i64 %146, %22
ADD:   %146 = phi i64 [ %150, %148 ], [ 0, %135 ]
ADD:   br label %145
ADD:   %144 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %143, i64 1, 4, 0
ADD:   %143 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %142, i64 %22, 3, 0
ADD:   %142 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %141, i64 0, 2
ADD:   %141 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %140, ptr %139, 1
ADD:   %140 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %139, 0
ADD:   %139 = call ptr @malloc(i64 %138)
ADD:   %138 = ptrtoint ptr %137 to i64
ADD:   %137 = getelementptr i64, ptr null, i64 %22
ADD:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %128, ptr %136, align 8
ADD:   %136 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
ADD:   br i1 %131, label %132, label %135
ADD:   %131 = icmp slt i64 %130, %20
ADD:   %130 = phi i64 [ %134, %132 ], [ 0, %119 ]
ADD:   br label %129
ADD:   %128 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %127, i64 1, 4, 0
ADD:   %127 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %126, i64 %20, 3, 0
ADD:   %126 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %125, i64 0, 2
ADD:   %125 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %124, ptr %123, 1
ADD:   %124 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %123, 0
ADD:   %123 = call ptr @malloc(i64 %122)
ADD:   %122 = ptrtoint ptr %121 to i64
ADD:   %121 = getelementptr i64, ptr null, i64 %20
ADD:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %112, ptr %120, align 8
ADD:   %120 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
ADD:   br i1 %115, label %116, label %119
ADD:   %115 = icmp slt i64 %114, %18
ADD:   %114 = phi i64 [ %118, %116 ], [ 0, %103 ]
ADD:   br label %113
ADD:   %112 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %111, i64 1, 4, 0
ADD:   %111 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %110, i64 %18, 3, 0
ADD:   %110 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %109, i64 0, 2
ADD:   %109 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %108, ptr %107, 1
ADD:   %108 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %107, 0
ADD:   %107 = call ptr @malloc(i64 %106)
ADD:   %106 = ptrtoint ptr %105 to i64
ADD:   %105 = getelementptr i64, ptr null, i64 %18
ADD:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %96, ptr %104, align 8
ADD:   %104 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
ADD:   br i1 %99, label %100, label %103
ADD:   %99 = icmp slt i64 %98, %16
ADD:   %98 = phi i64 [ %102, %100 ], [ 0, %87 ]
ADD:   br label %97
ADD:   %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 1, 4, 0
ADD:   %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 %16, 3, 0
ADD:   %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, i64 0, 2
ADD:   %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %92, ptr %91, 1
ADD:   %92 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %91, 0
ADD:   %91 = call ptr @malloc(i64 %90)
ADD:   %90 = ptrtoint ptr %89 to i64
ADD:   %89 = getelementptr i64, ptr null, i64 %16
ADD:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %80, ptr %88, align 8
ADD:   %88 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
ADD:   br i1 %83, label %84, label %87
ADD:   %83 = icmp slt i64 %82, %14
ADD:   %82 = phi i64 [ %86, %84 ], [ 0, %71 ]
ADD:   br label %81
ADD:   %80 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, i64 1, 4, 0
ADD:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 %14, 3, 0
ADD:   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 0, 2
ADD:   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, ptr %75, 1
ADD:   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %75, 0
ADD:   %75 = call ptr @malloc(i64 %74)
ADD:   %74 = ptrtoint ptr %73 to i64
ADD:   %73 = getelementptr i64, ptr null, i64 %14
ADD:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %64, ptr %72, align 8
ADD:   %72 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
ADD:   br i1 %67, label %68, label %71
ADD:   %67 = icmp slt i64 %66, %12
ADD:   %66 = phi i64 [ %70, %68 ], [ 0, %55 ]
ADD:   br label %65
ADD:   %64 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %63, i64 1, 4, 0
ADD:   %63 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %62, i64 %12, 3, 0
ADD:   %62 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, i64 0, 2
ADD:   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, ptr %59, 1
ADD:   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %59, 0
ADD:   %59 = call ptr @malloc(i64 %58)
ADD:   %58 = ptrtoint ptr %57 to i64
ADD:   %57 = getelementptr i64, ptr null, i64 %12
ADD:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, ptr %56, align 8
ADD:   %56 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
ADD:   br i1 %51, label %52, label %55
ADD:   %51 = icmp slt i64 %50, %10
ADD:   %50 = phi i64 [ %54, %52 ], [ 0, %39 ]
ADD:   br label %49
ADD:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 1, 4, 0
ADD:   %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, i64 %10, 3, 0
ADD:   %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 0, 2
ADD:   %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, ptr %43, 1
ADD:   %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %43, 0
ADD:   %43 = call ptr @malloc(i64 %42)
ADD:   %42 = ptrtoint ptr %41 to i64
ADD:   %41 = getelementptr i64, ptr null, i64 %10
ADD:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, ptr %40, align 8
ADD:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
ADD:   br i1 %35, label %36, label %39
ADD:   %35 = icmp slt i64 %34, %8
ADD:   %34 = phi i64 [ %38, %36 ], [ 0, %0 ]
ADD:   br label %33
ADD:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 1, 4, 0
ADD:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, i64 %8, 3, 0
ADD:   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %29, i64 0, 2
ADD:   %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, ptr %27, 1
ADD:   %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %27, 0
ADD:   %27 = call ptr @malloc(i64 %26)
ADD:   %26 = ptrtoint ptr %25 to i64
ADD:   %25 = getelementptr i64, ptr null, i64 %8
ADD:   %24 = load i64, ptr %23, align 4
ADD:   %23 = getelementptr i64, ptr %1, i64 8
ADD:   %22 = load i64, ptr %21, align 4
ADD:   %21 = getelementptr i64, ptr %1, i64 7
ADD:   %20 = load i64, ptr %19, align 4
ADD:   %19 = getelementptr i64, ptr %1, i64 6
ADD:   %18 = load i64, ptr %17, align 4
ADD:   %17 = getelementptr i64, ptr %1, i64 5
ADD:   %16 = load i64, ptr %15, align 4
ADD:   %15 = getelementptr i64, ptr %1, i64 4
ADD:   %14 = load i64, ptr %13, align 4
ADD:   %13 = getelementptr i64, ptr %1, i64 3
ADD:   %12 = load i64, ptr %11, align 4
ADD:   %11 = getelementptr i64, ptr %1, i64 2
ADD:   %10 = load i64, ptr %9, align 4
ADD:   %9 = getelementptr i64, ptr %1, i64 1
ADD:   %8 = load i64, ptr %1, align 4
ADD:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr %7, i32 1)
ADD:   store i64 1, ptr %.fca.4.0.gep, align 8
ADD:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 4, i32 0
ADD:   store i64 7, ptr %.fca.3.0.gep, align 8
ADD:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 3, i32 0
ADD:   store i64 0, ptr %.fca.2.gep, align 8
ADD:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 2
ADD:   store ptr %1, ptr %.fca.1.gep, align 8
ADD:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %7, i32 0, i32 1
ADD:   store ptr %1, ptr %7, align 8
ADD:   %7 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
IC: DCE:   %6 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %5, i64 1, 4, 0
IC: DCE:   %5 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %4, i64 7, 3, 0
IC: DCE:   %4 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %3, i64 0, 2
IC: DCE:   %3 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %2, ptr %1, 1
IC: DCE:   %2 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %1, 0
ADD:   %1 = call ptr @malloc(i64 56)
IC: Visiting:   %1 = call ptr @malloc(i64 56)
IC: Visiting:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
IC: Mod =   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
    New =   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %1, ptr %2, align 8
IC: Visiting:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i32 0, i32 1
IC: Mod =   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i32 0, i32 1
    New =   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
ADD:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
IC: Visiting:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
IC: Visiting:   store ptr %1, ptr %.fca.1.gep, align 8
IC: Visiting:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i32 0, i32 2
IC: Mod =   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i32 0, i32 2
    New =   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
ADD:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
IC: Visiting:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.fca.2.gep, align 8
IC: Visiting:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i32 0, i32 3, i32 0
IC: Mod =   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i32 0, i32 3, i32 0
    New =   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
ADD:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
IC: Visiting:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
IC: Visiting:   store i64 7, ptr %.fca.3.0.gep, align 8
IC: Visiting:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i32 0, i32 4, i32 0
IC: Mod =   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i32 0, i32 4, i32 0
    New =   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
ADD:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
IC: Visiting:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
IC: Visiting:   store i64 1, ptr %.fca.4.0.gep, align 8
IC: Visiting:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr %2, i32 1)
IC: Mod =   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr %2, i32 1)
    New =   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
ADD:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
IC: Visiting:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
IC: Visiting:   %3 = load i64, ptr %1, align 4
IC: Visiting:   %4 = getelementptr i64, ptr %1, i64 1
IC: Visiting:   %5 = load i64, ptr %4, align 4
IC: Visiting:   %6 = getelementptr i64, ptr %1, i64 2
IC: Visiting:   %7 = load i64, ptr %6, align 4
IC: Visiting:   %8 = getelementptr i64, ptr %1, i64 3
IC: Visiting:   %9 = load i64, ptr %8, align 4
IC: Visiting:   %10 = getelementptr i64, ptr %1, i64 4
IC: Visiting:   %11 = load i64, ptr %10, align 4
IC: Visiting:   %12 = getelementptr i64, ptr %1, i64 5
IC: Visiting:   %13 = load i64, ptr %12, align 4
IC: Visiting:   %14 = getelementptr i64, ptr %1, i64 6
IC: Visiting:   %15 = load i64, ptr %14, align 4
IC: Visiting:   %16 = getelementptr i64, ptr %1, i64 7
IC: Visiting:   %17 = load i64, ptr %16, align 4
IC: Visiting:   %18 = getelementptr i64, ptr %1, i64 8
IC: Visiting:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %20 = getelementptr i64, ptr null, i64 %3
IC: Visiting:   %21 = ptrtoint ptr %20 to i64
ADD DEFERRED:   %.idx = mul i64 %3, 8
IC: Replacing   %21 = ptrtoint ptr %20 to i64
    with   %.idx = mul i64 %3, 8
IC: Mod =   %21 = ptrtoint ptr %20 to i64
    New =   %21 = ptrtoint ptr %20 to i64
IC: ERASE   %21 = ptrtoint ptr %20 to i64
ADD DEFERRED:   %20 = getelementptr i64, ptr null, i64 %3
IC: ERASE   %20 = getelementptr i64, ptr null, i64 %3
ADD DEFERRED:   %3 = load i64, ptr %1, align 4
ADD:   %3 = load i64, ptr %1, align 4
ADD:   %.idx = mul i64 %3, 8
IC: Visiting:   %.idx = mul i64 %3, 8
IC: Old =   %.idx = mul i64 %3, 8
    New =   <badref> = shl i64 %3, 3
ADD:   %.idx = shl i64 %3, 3
IC: ERASE   %20 = mul i64 %3, 8
ADD DEFERRED:   %3 = load i64, ptr %1, align 4
IC: Visiting:   %.idx = shl i64 %3, 3
IC: Visiting:   %3 = load i64, ptr %1, align 4
IC: Visiting:   %20 = call ptr @malloc(i64 %.idx)
IC: Visiting:   %21 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %20, 0
IC: Visiting:   %22 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, ptr %20, 1
IC: Visiting:   %23 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, i64 0, 2
IC: Visiting:   %24 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, i64 %3, 3, 0
IC: Visiting:   %25 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, i64 1, 4, 0
IC: Visiting:   br label %26
IC: Visiting:   %27 = phi i64 [ %31, %29 ], [ 0, %0 ]
IC: Visiting:   %28 = icmp slt i64 %27, %3
IC: Visiting:   br i1 %28, label %29, label %32
IC: Visiting:   %33 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
IC: Mod =   %33 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
    New =   %33 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %33 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %33 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, ptr %33, align 8
ADD DEFERRED:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 0
ADD DEFERRED:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 0
ADD DEFERRED:   store ptr %.elt, ptr %.repack, align 8
ADD DEFERRED:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 1
ADD DEFERRED:   %.elt10 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 1
ADD DEFERRED:   store ptr %.elt10, ptr %.repack9, align 8
ADD DEFERRED:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 2
ADD DEFERRED:   %.elt12 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 2
ADD DEFERRED:   store i64 %.elt12, ptr %.repack11, align 8
ADD DEFERRED:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 3
ADD DEFERRED:   %.elt14 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 3
ADD DEFERRED:   store [1 x i64] %.elt14, ptr %.repack13, align 8
ADD DEFERRED:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 4
ADD DEFERRED:   %.elt16 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 4
ADD DEFERRED:   store [1 x i64] %.elt16, ptr %.repack15, align 8
IC: ERASE   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, ptr %33, align 8
ADD DEFERRED:   %25 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, i64 1, 4, 0
ADD DEFERRED:   %33 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %33 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %25 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, i64 1, 4, 0
ADD:   store [1 x i64] %.elt16, ptr %.repack15, align 8
ADD:   %.elt16 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 4
ADD:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 4
ADD:   store [1 x i64] %.elt14, ptr %.repack13, align 8
ADD:   %.elt14 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 3
ADD:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 3
ADD:   store i64 %.elt12, ptr %.repack11, align 8
ADD:   %.elt12 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 2
ADD:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 2
ADD:   store ptr %.elt10, ptr %.repack9, align 8
ADD:   %.elt10 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 1
ADD:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 1
ADD:   store ptr %.elt, ptr %.repack, align 8
ADD:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 0
ADD:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 0
IC: Visiting:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 0
IC: Replacing   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 0
    with   %33 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Mod =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 0
    New =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 0
IC: ERASE   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 0
ADD DEFERRED:   %33 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 0
IC: Replacing   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 0
    with   %20 = call ptr @malloc(i64 %.idx)
IC: Mod =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 0
    New =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 0
IC: ERASE   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 0
ADD DEFERRED:   %25 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, i64 1, 4, 0
IC: Visiting:   store ptr %20, ptr %33, align 8
IC: Visiting:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 1
IC: Mod =   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 1
    New =   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 1
ADD:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 1
IC: Visiting:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 1
IC: Visiting:   %.elt10 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 1
IC: Replacing   %.elt10 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 1
    with   %20 = call ptr @malloc(i64 %.idx)
IC: Mod =   %.elt10 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 1
    New =   %.elt10 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 1
IC: ERASE   %.elt10 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 1
ADD DEFERRED:   %25 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, i64 1, 4, 0
IC: Visiting:   store ptr %20, ptr %.repack9, align 8
IC: Visiting:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 2
IC: Mod =   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 2
    New =   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 2
ADD:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 2
IC: Visiting:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 2
IC: Visiting:   %.elt12 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 2
IC: Replacing   %.elt12 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 2
    with i64 0
IC: Mod =   %.elt12 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 2
    New =   %.elt12 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 2
IC: ERASE   %.elt12 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 2
ADD DEFERRED:   %25 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, i64 1, 4, 0
IC: Visiting:   store i64 0, ptr %.repack11, align 8
IC: Visiting:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 3
IC: Mod =   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 3
    New =   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 3
ADD:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 3
IC: Visiting:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 3
IC: Visiting:   %.elt14 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 3
IC: Old =   %.elt14 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, 3
ADD:   %.elt14 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, 3
IC: ERASE   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 3
ADD DEFERRED:   %25 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, i64 1, 4, 0
IC: Visiting:   %.elt14 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, 3
ADD DEFERRED:   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, 3
IC: Old =   %.elt14 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, 3
    New =   <badref> = insertvalue [1 x i64] %34, i64 %3, 0
ADD:   %.elt14 = insertvalue [1 x i64] %34, i64 %3, 0
IC: ERASE   %35 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, 3
ADD DEFERRED:   %24 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, i64 %3, 3, 0
ADD:   %24 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, i64 %3, 3, 0
ADD:   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, 3
IC: Visiting:   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, 3
IC: Old =   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, 3
ADD:   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, 3
IC: ERASE   %35 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, 3
ADD DEFERRED:   %23 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, i64 0, 2
ADD:   %23 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, i64 0, 2
IC: Visiting:   %23 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, i64 0, 2
IC: Visiting:   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, 3
IC: Old =   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, 3
ADD:   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, 3
IC: ERASE   %35 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, 3
ADD DEFERRED:   %22 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, ptr %20, 1
ADD:   %22 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, ptr %20, 1
IC: Visiting:   %22 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, ptr %20, 1
IC: Visiting:   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, 3
IC: Old =   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
ADD:   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: ERASE   %35 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, 3
ADD DEFERRED:   %21 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %20, 0
ADD:   %21 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %20, 0
IC: Visiting:   %21 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %20, 0
IC: ConstFold to: [1 x i64] undef from:   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Replacing   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
    with [1 x i64] undef
IC: ERASE   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Visiting:   %24 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, i64 %3, 3, 0
IC: Visiting:   %.elt14 = insertvalue [1 x i64] undef, i64 %3, 0
IC: Visiting:   store [1 x i64] %.elt14, ptr %.repack13, align 8
ADD DEFERRED:   %34 = extractvalue [1 x i64] %.elt14, 0
ADD DEFERRED:   store i64 %34, ptr %.repack13, align 8
IC: ERASE   store [1 x i64] %.elt14, ptr %.repack13, align 8
ADD DEFERRED:   %.elt14 = insertvalue [1 x i64] undef, i64 %3, 0
ADD DEFERRED:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 3
ADD:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 3
ADD:   %.elt14 = insertvalue [1 x i64] undef, i64 %3, 0
ADD:   store i64 %34, ptr %.repack13, align 8
ADD:   %34 = extractvalue [1 x i64] %.elt14, 0
IC: Visiting:   %34 = extractvalue [1 x i64] %.elt14, 0
IC: Replacing   %34 = extractvalue [1 x i64] %.elt14, 0
    with   %3 = load i64, ptr %1, align 4
IC: Mod =   %34 = extractvalue [1 x i64] %.elt14, 0
    New =   %34 = extractvalue [1 x i64] %.elt14, 0
IC: ERASE   %34 = extractvalue [1 x i64] %.elt14, 0
ADD DEFERRED:   %.elt14 = insertvalue [1 x i64] undef, i64 %3, 0
IC: ERASE   %.elt14 = insertvalue [1 x i64] undef, i64 %3, 0
ADD DEFERRED:   %3 = load i64, ptr %1, align 4
ADD:   %3 = load i64, ptr %1, align 4
IC: Visiting:   %3 = load i64, ptr %1, align 4
IC: Visiting:   store i64 %3, ptr %.repack13, align 8
IC: Visiting:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 3
IC: Visiting:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 4
IC: Mod =   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i32 0, i32 4
    New =   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 4
ADD:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 4
IC: Visiting:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 4
IC: Visiting:   %.elt16 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 4
ADD DEFERRED:   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, 4
IC: Old =   %.elt16 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 4
    New =   <badref> = insertvalue [1 x i64] %34, i64 1, 0
ADD:   %.elt16 = insertvalue [1 x i64] %34, i64 1, 0
IC: ERASE   %35 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, 4
ADD DEFERRED:   %25 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, i64 1, 4, 0
IC: ERASE   %25 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, i64 1, 4, 0
ADD DEFERRED:   %24 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, i64 %3, 3, 0
ADD:   %24 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, i64 %3, 3, 0
ADD:   %33 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, 4
IC: Visiting:   %33 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, 4
IC: Old =   %33 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, 4
ADD:   %33 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, 4
IC: ERASE   %34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %24, 4
ADD DEFERRED:   %24 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, i64 %3, 3, 0
IC: ERASE   %24 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, i64 %3, 3, 0
ADD DEFERRED:   %23 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, i64 0, 2
ADD DEFERRED:   %3 = load i64, ptr %1, align 4
ADD:   %3 = load i64, ptr %1, align 4
ADD:   %23 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, i64 0, 2
IC: Visiting:   %23 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, i64 0, 2
IC: Visiting:   %3 = load i64, ptr %1, align 4
IC: Visiting:   %32 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, 4
IC: Old =   %32 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, 4
ADD:   %32 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, 4
IC: ERASE   %33 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %23, 4
ADD DEFERRED:   %23 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, i64 0, 2
IC: ERASE   %23 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, i64 0, 2
ADD DEFERRED:   %22 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, ptr %20, 1
ADD:   %22 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, ptr %20, 1
IC: Visiting:   %22 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, ptr %20, 1
IC: Visiting:   %31 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, 4
IC: Old =   %31 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, 4
ADD:   %31 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, 4
IC: ERASE   %32 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %22, 4
ADD DEFERRED:   %22 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, ptr %20, 1
IC: ERASE   %22 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, ptr %20, 1
ADD DEFERRED:   %21 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %20, 0
ADD DEFERRED:   %20 = call ptr @malloc(i64 %.idx)
ADD:   %20 = call ptr @malloc(i64 %.idx)
ADD:   %21 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %20, 0
IC: Visiting:   %21 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %20, 0
IC: Visiting:   %20 = call ptr @malloc(i64 %.idx)
IC: Visiting:   %30 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, 4
IC: Old =   %30 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
ADD:   %30 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ERASE   %31 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %21, 4
ADD DEFERRED:   %21 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %20, 0
IC: ERASE   %21 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %20, 0
ADD DEFERRED:   %20 = call ptr @malloc(i64 %.idx)
ADD:   %20 = call ptr @malloc(i64 %.idx)
IC: Visiting:   %20 = call ptr @malloc(i64 %.idx)
IC: ConstFold to: [1 x i64] undef from:   %29 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: Replacing   %29 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
    with [1 x i64] undef
IC: ERASE   %29 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ConstFold to: [1 x i64] [i64 1] from:   %.elt16 = insertvalue [1 x i64] undef, i64 1, 0
IC: Replacing   %.elt16 = insertvalue [1 x i64] undef, i64 1, 0
    with [1 x i64] [i64 1]
IC: ERASE   %.elt16 = insertvalue [1 x i64] undef, i64 1, 0
IC: Visiting:   store [1 x i64] [i64 1], ptr %.repack15, align 8
ADD DEFERRED:   store i64 1, ptr %.repack15, align 8
IC: ERASE   store [1 x i64] [i64 1], ptr %.repack15, align 8
ADD DEFERRED:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
ADD:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
ADD:   store i64 1, ptr %.repack15, align 8
IC: Visiting:   store i64 1, ptr %.repack15, align 8
IC: Visiting:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
IC: Visiting:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %29 = getelementptr i64, ptr null, i64 %5
IC: Visiting:   %30 = ptrtoint ptr %29 to i64
ADD DEFERRED:   %.idx17 = mul i64 %5, 8
IC: Replacing   %30 = ptrtoint ptr %29 to i64
    with   %.idx17 = mul i64 %5, 8
IC: Mod =   %30 = ptrtoint ptr %29 to i64
    New =   %30 = ptrtoint ptr %29 to i64
IC: ERASE   %30 = ptrtoint ptr %29 to i64
ADD DEFERRED:   %29 = getelementptr i64, ptr null, i64 %5
IC: ERASE   %29 = getelementptr i64, ptr null, i64 %5
ADD DEFERRED:   %5 = load i64, ptr %4, align 4
ADD:   %5 = load i64, ptr %4, align 4
ADD:   %.idx17 = mul i64 %5, 8
IC: Visiting:   %.idx17 = mul i64 %5, 8
IC: Old =   %.idx17 = mul i64 %5, 8
    New =   <badref> = shl i64 %5, 3
ADD:   %.idx17 = shl i64 %5, 3
IC: ERASE   %29 = mul i64 %5, 8
ADD DEFERRED:   %5 = load i64, ptr %4, align 4
IC: Visiting:   %.idx17 = shl i64 %5, 3
IC: Visiting:   %5 = load i64, ptr %4, align 4
IC: Visiting:   %29 = call ptr @malloc(i64 %.idx17)
IC: Visiting:   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %29, 0
IC: Visiting:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, ptr %29, 1
IC: Visiting:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 0, 2
IC: Visiting:   %33 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, i64 %5, 3, 0
IC: Visiting:   %34 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, i64 1, 4, 0
IC: Visiting:   br label %35
IC: Visiting:   %36 = phi i64 [ %40, %38 ], [ 0, %27 ]
IC: Visiting:   %37 = icmp slt i64 %36, %5
IC: Visiting:   br i1 %37, label %38, label %41
IC: Visiting:   %42 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
IC: Mod =   %42 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
    New =   %42 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %42 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %42 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, ptr %42, align 8
ADD DEFERRED:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 0
ADD DEFERRED:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 0
ADD DEFERRED:   store ptr %.elt, ptr %.repack, align 8
ADD DEFERRED:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 1
ADD DEFERRED:   %.elt19 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 1
ADD DEFERRED:   store ptr %.elt19, ptr %.repack18, align 8
ADD DEFERRED:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 2
ADD DEFERRED:   %.elt21 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 2
ADD DEFERRED:   store i64 %.elt21, ptr %.repack20, align 8
ADD DEFERRED:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 3
ADD DEFERRED:   %.elt23 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 3
ADD DEFERRED:   store [1 x i64] %.elt23, ptr %.repack22, align 8
ADD DEFERRED:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 4
ADD DEFERRED:   %.elt25 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 4
ADD DEFERRED:   store [1 x i64] %.elt25, ptr %.repack24, align 8
IC: ERASE   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, ptr %42, align 8
ADD DEFERRED:   %34 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, i64 1, 4, 0
ADD DEFERRED:   %42 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %42 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %34 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, i64 1, 4, 0
ADD:   store [1 x i64] %.elt25, ptr %.repack24, align 8
ADD:   %.elt25 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 4
ADD:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 4
ADD:   store [1 x i64] %.elt23, ptr %.repack22, align 8
ADD:   %.elt23 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 3
ADD:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 3
ADD:   store i64 %.elt21, ptr %.repack20, align 8
ADD:   %.elt21 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 2
ADD:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 2
ADD:   store ptr %.elt19, ptr %.repack18, align 8
ADD:   %.elt19 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 1
ADD:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 1
ADD:   store ptr %.elt, ptr %.repack, align 8
ADD:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 0
ADD:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 0
IC: Visiting:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 0
IC: Replacing   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 0
    with   %42 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Mod =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 0
    New =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 0
IC: ERASE   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 0
ADD DEFERRED:   %42 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 0
IC: Replacing   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 0
    with   %29 = call ptr @malloc(i64 %.idx17)
IC: Mod =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 0
    New =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 0
IC: ERASE   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 0
ADD DEFERRED:   %34 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, i64 1, 4, 0
IC: Visiting:   store ptr %29, ptr %42, align 8
IC: Visiting:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 1
IC: Mod =   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 1
    New =   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i64 0, i32 1
ADD:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i64 0, i32 1
IC: Visiting:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i64 0, i32 1
IC: Visiting:   %.elt19 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 1
IC: Replacing   %.elt19 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 1
    with   %29 = call ptr @malloc(i64 %.idx17)
IC: Mod =   %.elt19 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 1
    New =   %.elt19 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 1
IC: ERASE   %.elt19 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 1
ADD DEFERRED:   %34 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, i64 1, 4, 0
IC: Visiting:   store ptr %29, ptr %.repack18, align 8
IC: Visiting:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 2
IC: Mod =   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 2
    New =   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i64 0, i32 2
ADD:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i64 0, i32 2
IC: Visiting:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i64 0, i32 2
IC: Visiting:   %.elt21 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 2
IC: Replacing   %.elt21 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 2
    with i64 0
IC: Mod =   %.elt21 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 2
    New =   %.elt21 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 2
IC: ERASE   %.elt21 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 2
ADD DEFERRED:   %34 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, i64 1, 4, 0
IC: Visiting:   store i64 0, ptr %.repack20, align 8
IC: Visiting:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 3
IC: Mod =   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 3
    New =   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i64 0, i32 3
ADD:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i64 0, i32 3
IC: Visiting:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i64 0, i32 3
IC: Visiting:   %.elt23 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 3
IC: Old =   %.elt23 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, 3
ADD:   %.elt23 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, 3
IC: ERASE   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 3
ADD DEFERRED:   %34 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, i64 1, 4, 0
IC: Visiting:   %.elt23 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, 3
ADD DEFERRED:   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, 3
IC: Old =   %.elt23 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, 3
    New =   <badref> = insertvalue [1 x i64] %43, i64 %5, 0
ADD:   %.elt23 = insertvalue [1 x i64] %43, i64 %5, 0
IC: ERASE   %44 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, 3
ADD DEFERRED:   %33 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, i64 %5, 3, 0
ADD:   %33 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, i64 %5, 3, 0
ADD:   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, 3
IC: Visiting:   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, 3
IC: Old =   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, 3
ADD:   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, 3
IC: ERASE   %44 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, 3
ADD DEFERRED:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 0, 2
ADD:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 0, 2
IC: Visiting:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 0, 2
IC: Visiting:   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, 3
IC: Old =   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, 3
ADD:   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, 3
IC: ERASE   %44 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, 3
ADD DEFERRED:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, ptr %29, 1
ADD:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, ptr %29, 1
IC: Visiting:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, ptr %29, 1
IC: Visiting:   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, 3
IC: Old =   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
ADD:   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: ERASE   %44 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, 3
ADD DEFERRED:   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %29, 0
ADD:   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %29, 0
IC: Visiting:   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %29, 0
IC: ConstFold to: [1 x i64] undef from:   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Replacing   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
    with [1 x i64] undef
IC: ERASE   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Visiting:   %33 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, i64 %5, 3, 0
IC: Visiting:   %.elt23 = insertvalue [1 x i64] undef, i64 %5, 0
IC: Visiting:   store [1 x i64] %.elt23, ptr %.repack22, align 8
ADD DEFERRED:   %43 = extractvalue [1 x i64] %.elt23, 0
ADD DEFERRED:   store i64 %43, ptr %.repack22, align 8
IC: ERASE   store [1 x i64] %.elt23, ptr %.repack22, align 8
ADD DEFERRED:   %.elt23 = insertvalue [1 x i64] undef, i64 %5, 0
ADD DEFERRED:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i64 0, i32 3
ADD:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i64 0, i32 3
ADD:   %.elt23 = insertvalue [1 x i64] undef, i64 %5, 0
ADD:   store i64 %43, ptr %.repack22, align 8
ADD:   %43 = extractvalue [1 x i64] %.elt23, 0
IC: Visiting:   %43 = extractvalue [1 x i64] %.elt23, 0
IC: Replacing   %43 = extractvalue [1 x i64] %.elt23, 0
    with   %5 = load i64, ptr %4, align 4
IC: Mod =   %43 = extractvalue [1 x i64] %.elt23, 0
    New =   %43 = extractvalue [1 x i64] %.elt23, 0
IC: ERASE   %43 = extractvalue [1 x i64] %.elt23, 0
ADD DEFERRED:   %.elt23 = insertvalue [1 x i64] undef, i64 %5, 0
IC: ERASE   %.elt23 = insertvalue [1 x i64] undef, i64 %5, 0
ADD DEFERRED:   %5 = load i64, ptr %4, align 4
ADD:   %5 = load i64, ptr %4, align 4
IC: Visiting:   %5 = load i64, ptr %4, align 4
IC: Visiting:   store i64 %5, ptr %.repack22, align 8
IC: Visiting:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i64 0, i32 3
IC: Visiting:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 4
IC: Mod =   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i32 0, i32 4
    New =   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i64 0, i32 4
ADD:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i64 0, i32 4
IC: Visiting:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %42, i64 0, i32 4
IC: Visiting:   %.elt25 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 4
ADD DEFERRED:   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, 4
IC: Old =   %.elt25 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 4
    New =   <badref> = insertvalue [1 x i64] %43, i64 1, 0
ADD:   %.elt25 = insertvalue [1 x i64] %43, i64 1, 0
IC: ERASE   %44 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, 4
ADD DEFERRED:   %34 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, i64 1, 4, 0
IC: ERASE   %34 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, i64 1, 4, 0
ADD DEFERRED:   %33 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, i64 %5, 3, 0
ADD:   %33 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, i64 %5, 3, 0
ADD:   %42 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, 4
IC: Visiting:   %42 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, 4
IC: Old =   %42 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, 4
ADD:   %42 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, 4
IC: ERASE   %43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, 4
ADD DEFERRED:   %33 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, i64 %5, 3, 0
IC: ERASE   %33 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, i64 %5, 3, 0
ADD DEFERRED:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 0, 2
ADD DEFERRED:   %5 = load i64, ptr %4, align 4
ADD:   %5 = load i64, ptr %4, align 4
ADD:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 0, 2
IC: Visiting:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 0, 2
IC: Visiting:   %5 = load i64, ptr %4, align 4
IC: Visiting:   %41 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, 4
IC: Old =   %41 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, 4
ADD:   %41 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, 4
IC: ERASE   %42 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, 4
ADD DEFERRED:   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 0, 2
IC: ERASE   %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, i64 0, 2
ADD DEFERRED:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, ptr %29, 1
ADD:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, ptr %29, 1
IC: Visiting:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, ptr %29, 1
IC: Visiting:   %40 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, 4
IC: Old =   %40 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, 4
ADD:   %40 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, 4
IC: ERASE   %41 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, 4
ADD DEFERRED:   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, ptr %29, 1
IC: ERASE   %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, ptr %29, 1
ADD DEFERRED:   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %29, 0
ADD DEFERRED:   %29 = call ptr @malloc(i64 %.idx17)
ADD:   %29 = call ptr @malloc(i64 %.idx17)
ADD:   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %29, 0
IC: Visiting:   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %29, 0
IC: Visiting:   %29 = call ptr @malloc(i64 %.idx17)
IC: Visiting:   %39 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, 4
IC: Old =   %39 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
ADD:   %39 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ERASE   %40 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %30, 4
ADD DEFERRED:   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %29, 0
IC: ERASE   %30 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %29, 0
ADD DEFERRED:   %29 = call ptr @malloc(i64 %.idx17)
ADD:   %29 = call ptr @malloc(i64 %.idx17)
IC: Visiting:   %29 = call ptr @malloc(i64 %.idx17)
IC: ConstFold to: [1 x i64] undef from:   %38 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: Replacing   %38 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
    with [1 x i64] undef
IC: ERASE   %38 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ConstFold to: [1 x i64] [i64 1] from:   %.elt25 = insertvalue [1 x i64] undef, i64 1, 0
IC: Replacing   %.elt25 = insertvalue [1 x i64] undef, i64 1, 0
    with [1 x i64] [i64 1]
IC: ERASE   %.elt25 = insertvalue [1 x i64] undef, i64 1, 0
IC: Visiting:   store [1 x i64] [i64 1], ptr %.repack24, align 8
ADD DEFERRED:   store i64 1, ptr %.repack24, align 8
IC: ERASE   store [1 x i64] [i64 1], ptr %.repack24, align 8
ADD DEFERRED:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
ADD:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
ADD:   store i64 1, ptr %.repack24, align 8
IC: Visiting:   store i64 1, ptr %.repack24, align 8
IC: Visiting:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
IC: Visiting:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %38 = getelementptr i64, ptr null, i64 %7
IC: Visiting:   %39 = ptrtoint ptr %38 to i64
ADD DEFERRED:   %.idx26 = mul i64 %7, 8
IC: Replacing   %39 = ptrtoint ptr %38 to i64
    with   %.idx26 = mul i64 %7, 8
IC: Mod =   %39 = ptrtoint ptr %38 to i64
    New =   %39 = ptrtoint ptr %38 to i64
IC: ERASE   %39 = ptrtoint ptr %38 to i64
ADD DEFERRED:   %38 = getelementptr i64, ptr null, i64 %7
IC: ERASE   %38 = getelementptr i64, ptr null, i64 %7
ADD DEFERRED:   %7 = load i64, ptr %6, align 4
ADD:   %7 = load i64, ptr %6, align 4
ADD:   %.idx26 = mul i64 %7, 8
IC: Visiting:   %.idx26 = mul i64 %7, 8
IC: Old =   %.idx26 = mul i64 %7, 8
    New =   <badref> = shl i64 %7, 3
ADD:   %.idx26 = shl i64 %7, 3
IC: ERASE   %38 = mul i64 %7, 8
ADD DEFERRED:   %7 = load i64, ptr %6, align 4
IC: Visiting:   %.idx26 = shl i64 %7, 3
IC: Visiting:   %7 = load i64, ptr %6, align 4
IC: Visiting:   %38 = call ptr @malloc(i64 %.idx26)
IC: Visiting:   %39 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %38, 0
IC: Visiting:   %40 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, ptr %38, 1
IC: Visiting:   %41 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, i64 0, 2
IC: Visiting:   %42 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, i64 %7, 3, 0
IC: Visiting:   %43 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, i64 1, 4, 0
IC: Visiting:   br label %44
IC: Visiting:   %45 = phi i64 [ %49, %47 ], [ 0, %36 ]
IC: Visiting:   %46 = icmp slt i64 %45, %7
IC: Visiting:   br i1 %46, label %47, label %50
IC: Visiting:   %51 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
IC: Mod =   %51 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
    New =   %51 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %51 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %51 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, ptr %51, align 8
ADD DEFERRED:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 0
ADD DEFERRED:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 0
ADD DEFERRED:   store ptr %.elt, ptr %.repack, align 8
ADD DEFERRED:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 1
ADD DEFERRED:   %.elt28 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 1
ADD DEFERRED:   store ptr %.elt28, ptr %.repack27, align 8
ADD DEFERRED:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 2
ADD DEFERRED:   %.elt30 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 2
ADD DEFERRED:   store i64 %.elt30, ptr %.repack29, align 8
ADD DEFERRED:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 3
ADD DEFERRED:   %.elt32 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 3
ADD DEFERRED:   store [1 x i64] %.elt32, ptr %.repack31, align 8
ADD DEFERRED:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 4
ADD DEFERRED:   %.elt34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 4
ADD DEFERRED:   store [1 x i64] %.elt34, ptr %.repack33, align 8
IC: ERASE   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, ptr %51, align 8
ADD DEFERRED:   %43 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, i64 1, 4, 0
ADD DEFERRED:   %51 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %51 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %43 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, i64 1, 4, 0
ADD:   store [1 x i64] %.elt34, ptr %.repack33, align 8
ADD:   %.elt34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 4
ADD:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 4
ADD:   store [1 x i64] %.elt32, ptr %.repack31, align 8
ADD:   %.elt32 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 3
ADD:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 3
ADD:   store i64 %.elt30, ptr %.repack29, align 8
ADD:   %.elt30 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 2
ADD:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 2
ADD:   store ptr %.elt28, ptr %.repack27, align 8
ADD:   %.elt28 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 1
ADD:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 1
ADD:   store ptr %.elt, ptr %.repack, align 8
ADD:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 0
ADD:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 0
IC: Visiting:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 0
IC: Replacing   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 0
    with   %51 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Mod =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 0
    New =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 0
IC: ERASE   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 0
ADD DEFERRED:   %51 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 0
IC: Replacing   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 0
    with   %38 = call ptr @malloc(i64 %.idx26)
IC: Mod =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 0
    New =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 0
IC: ERASE   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 0
ADD DEFERRED:   %43 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, i64 1, 4, 0
IC: Visiting:   store ptr %38, ptr %51, align 8
IC: Visiting:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 1
IC: Mod =   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 1
    New =   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i64 0, i32 1
ADD:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i64 0, i32 1
IC: Visiting:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i64 0, i32 1
IC: Visiting:   %.elt28 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 1
IC: Replacing   %.elt28 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 1
    with   %38 = call ptr @malloc(i64 %.idx26)
IC: Mod =   %.elt28 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 1
    New =   %.elt28 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 1
IC: ERASE   %.elt28 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 1
ADD DEFERRED:   %43 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, i64 1, 4, 0
IC: Visiting:   store ptr %38, ptr %.repack27, align 8
IC: Visiting:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 2
IC: Mod =   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 2
    New =   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i64 0, i32 2
ADD:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i64 0, i32 2
IC: Visiting:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i64 0, i32 2
IC: Visiting:   %.elt30 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 2
IC: Replacing   %.elt30 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 2
    with i64 0
IC: Mod =   %.elt30 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 2
    New =   %.elt30 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 2
IC: ERASE   %.elt30 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 2
ADD DEFERRED:   %43 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, i64 1, 4, 0
IC: Visiting:   store i64 0, ptr %.repack29, align 8
IC: Visiting:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 3
IC: Mod =   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 3
    New =   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i64 0, i32 3
ADD:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i64 0, i32 3
IC: Visiting:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i64 0, i32 3
IC: Visiting:   %.elt32 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 3
IC: Old =   %.elt32 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, 3
ADD:   %.elt32 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, 3
IC: ERASE   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 3
ADD DEFERRED:   %43 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, i64 1, 4, 0
IC: Visiting:   %.elt32 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, 3
ADD DEFERRED:   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, 3
IC: Old =   %.elt32 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, 3
    New =   <badref> = insertvalue [1 x i64] %52, i64 %7, 0
ADD:   %.elt32 = insertvalue [1 x i64] %52, i64 %7, 0
IC: ERASE   %53 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, 3
ADD DEFERRED:   %42 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, i64 %7, 3, 0
ADD:   %42 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, i64 %7, 3, 0
ADD:   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, 3
IC: Visiting:   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, 3
IC: Old =   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, 3
ADD:   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, 3
IC: ERASE   %53 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, 3
ADD DEFERRED:   %41 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, i64 0, 2
ADD:   %41 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, i64 0, 2
IC: Visiting:   %41 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, i64 0, 2
IC: Visiting:   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, 3
IC: Old =   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, 3
ADD:   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, 3
IC: ERASE   %53 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, 3
ADD DEFERRED:   %40 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, ptr %38, 1
ADD:   %40 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, ptr %38, 1
IC: Visiting:   %40 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, ptr %38, 1
IC: Visiting:   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, 3
IC: Old =   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
ADD:   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: ERASE   %53 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, 3
ADD DEFERRED:   %39 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %38, 0
ADD:   %39 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %38, 0
IC: Visiting:   %39 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %38, 0
IC: ConstFold to: [1 x i64] undef from:   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Replacing   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
    with [1 x i64] undef
IC: ERASE   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Visiting:   %42 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, i64 %7, 3, 0
IC: Visiting:   %.elt32 = insertvalue [1 x i64] undef, i64 %7, 0
IC: Visiting:   store [1 x i64] %.elt32, ptr %.repack31, align 8
ADD DEFERRED:   %52 = extractvalue [1 x i64] %.elt32, 0
ADD DEFERRED:   store i64 %52, ptr %.repack31, align 8
IC: ERASE   store [1 x i64] %.elt32, ptr %.repack31, align 8
ADD DEFERRED:   %.elt32 = insertvalue [1 x i64] undef, i64 %7, 0
ADD DEFERRED:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i64 0, i32 3
ADD:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i64 0, i32 3
ADD:   %.elt32 = insertvalue [1 x i64] undef, i64 %7, 0
ADD:   store i64 %52, ptr %.repack31, align 8
ADD:   %52 = extractvalue [1 x i64] %.elt32, 0
IC: Visiting:   %52 = extractvalue [1 x i64] %.elt32, 0
IC: Replacing   %52 = extractvalue [1 x i64] %.elt32, 0
    with   %7 = load i64, ptr %6, align 4
IC: Mod =   %52 = extractvalue [1 x i64] %.elt32, 0
    New =   %52 = extractvalue [1 x i64] %.elt32, 0
IC: ERASE   %52 = extractvalue [1 x i64] %.elt32, 0
ADD DEFERRED:   %.elt32 = insertvalue [1 x i64] undef, i64 %7, 0
IC: ERASE   %.elt32 = insertvalue [1 x i64] undef, i64 %7, 0
ADD DEFERRED:   %7 = load i64, ptr %6, align 4
ADD:   %7 = load i64, ptr %6, align 4
IC: Visiting:   %7 = load i64, ptr %6, align 4
IC: Visiting:   store i64 %7, ptr %.repack31, align 8
IC: Visiting:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i64 0, i32 3
IC: Visiting:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 4
IC: Mod =   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i32 0, i32 4
    New =   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i64 0, i32 4
ADD:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i64 0, i32 4
IC: Visiting:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %51, i64 0, i32 4
IC: Visiting:   %.elt34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 4
ADD DEFERRED:   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, 4
IC: Old =   %.elt34 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 4
    New =   <badref> = insertvalue [1 x i64] %52, i64 1, 0
ADD:   %.elt34 = insertvalue [1 x i64] %52, i64 1, 0
IC: ERASE   %53 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %43, 4
ADD DEFERRED:   %43 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, i64 1, 4, 0
IC: ERASE   %43 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, i64 1, 4, 0
ADD DEFERRED:   %42 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, i64 %7, 3, 0
ADD:   %42 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, i64 %7, 3, 0
ADD:   %51 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, 4
IC: Visiting:   %51 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, 4
IC: Old =   %51 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, 4
ADD:   %51 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, 4
IC: ERASE   %52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %42, 4
ADD DEFERRED:   %42 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, i64 %7, 3, 0
IC: ERASE   %42 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, i64 %7, 3, 0
ADD DEFERRED:   %41 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, i64 0, 2
ADD DEFERRED:   %7 = load i64, ptr %6, align 4
ADD:   %7 = load i64, ptr %6, align 4
ADD:   %41 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, i64 0, 2
IC: Visiting:   %41 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, i64 0, 2
IC: Visiting:   %7 = load i64, ptr %6, align 4
IC: Visiting:   %50 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, 4
IC: Old =   %50 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, 4
ADD:   %50 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, 4
IC: ERASE   %51 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %41, 4
ADD DEFERRED:   %41 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, i64 0, 2
IC: ERASE   %41 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, i64 0, 2
ADD DEFERRED:   %40 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, ptr %38, 1
ADD:   %40 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, ptr %38, 1
IC: Visiting:   %40 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, ptr %38, 1
IC: Visiting:   %49 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, 4
IC: Old =   %49 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, 4
ADD:   %49 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, 4
IC: ERASE   %50 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %40, 4
ADD DEFERRED:   %40 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, ptr %38, 1
IC: ERASE   %40 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, ptr %38, 1
ADD DEFERRED:   %39 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %38, 0
ADD DEFERRED:   %38 = call ptr @malloc(i64 %.idx26)
ADD:   %38 = call ptr @malloc(i64 %.idx26)
ADD:   %39 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %38, 0
IC: Visiting:   %39 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %38, 0
IC: Visiting:   %38 = call ptr @malloc(i64 %.idx26)
IC: Visiting:   %48 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, 4
IC: Old =   %48 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
ADD:   %48 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ERASE   %49 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %39, 4
ADD DEFERRED:   %39 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %38, 0
IC: ERASE   %39 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %38, 0
ADD DEFERRED:   %38 = call ptr @malloc(i64 %.idx26)
ADD:   %38 = call ptr @malloc(i64 %.idx26)
IC: Visiting:   %38 = call ptr @malloc(i64 %.idx26)
IC: ConstFold to: [1 x i64] undef from:   %47 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: Replacing   %47 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
    with [1 x i64] undef
IC: ERASE   %47 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ConstFold to: [1 x i64] [i64 1] from:   %.elt34 = insertvalue [1 x i64] undef, i64 1, 0
IC: Replacing   %.elt34 = insertvalue [1 x i64] undef, i64 1, 0
    with [1 x i64] [i64 1]
IC: ERASE   %.elt34 = insertvalue [1 x i64] undef, i64 1, 0
IC: Visiting:   store [1 x i64] [i64 1], ptr %.repack33, align 8
ADD DEFERRED:   store i64 1, ptr %.repack33, align 8
IC: ERASE   store [1 x i64] [i64 1], ptr %.repack33, align 8
ADD DEFERRED:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
ADD:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
ADD:   store i64 1, ptr %.repack33, align 8
IC: Visiting:   store i64 1, ptr %.repack33, align 8
IC: Visiting:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
IC: Visiting:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %47 = getelementptr i64, ptr null, i64 %9
IC: Visiting:   %48 = ptrtoint ptr %47 to i64
ADD DEFERRED:   %.idx35 = mul i64 %9, 8
IC: Replacing   %48 = ptrtoint ptr %47 to i64
    with   %.idx35 = mul i64 %9, 8
IC: Mod =   %48 = ptrtoint ptr %47 to i64
    New =   %48 = ptrtoint ptr %47 to i64
IC: ERASE   %48 = ptrtoint ptr %47 to i64
ADD DEFERRED:   %47 = getelementptr i64, ptr null, i64 %9
IC: ERASE   %47 = getelementptr i64, ptr null, i64 %9
ADD DEFERRED:   %9 = load i64, ptr %8, align 4
ADD:   %9 = load i64, ptr %8, align 4
ADD:   %.idx35 = mul i64 %9, 8
IC: Visiting:   %.idx35 = mul i64 %9, 8
IC: Old =   %.idx35 = mul i64 %9, 8
    New =   <badref> = shl i64 %9, 3
ADD:   %.idx35 = shl i64 %9, 3
IC: ERASE   %47 = mul i64 %9, 8
ADD DEFERRED:   %9 = load i64, ptr %8, align 4
IC: Visiting:   %.idx35 = shl i64 %9, 3
IC: Visiting:   %9 = load i64, ptr %8, align 4
IC: Visiting:   %47 = call ptr @malloc(i64 %.idx35)
IC: Visiting:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %47, 0
IC: Visiting:   %49 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, ptr %47, 1
IC: Visiting:   %50 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, i64 0, 2
IC: Visiting:   %51 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, i64 %9, 3, 0
IC: Visiting:   %52 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, i64 1, 4, 0
IC: Visiting:   br label %53
IC: Visiting:   %54 = phi i64 [ %58, %56 ], [ 0, %45 ]
IC: Visiting:   %55 = icmp slt i64 %54, %9
IC: Visiting:   br i1 %55, label %56, label %59
IC: Visiting:   %60 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
IC: Mod =   %60 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
    New =   %60 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %60 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %60 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, ptr %60, align 8
ADD DEFERRED:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 0
ADD DEFERRED:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 0
ADD DEFERRED:   store ptr %.elt, ptr %.repack, align 8
ADD DEFERRED:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 1
ADD DEFERRED:   %.elt37 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 1
ADD DEFERRED:   store ptr %.elt37, ptr %.repack36, align 8
ADD DEFERRED:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 2
ADD DEFERRED:   %.elt39 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 2
ADD DEFERRED:   store i64 %.elt39, ptr %.repack38, align 8
ADD DEFERRED:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 3
ADD DEFERRED:   %.elt41 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 3
ADD DEFERRED:   store [1 x i64] %.elt41, ptr %.repack40, align 8
ADD DEFERRED:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 4
ADD DEFERRED:   %.elt43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 4
ADD DEFERRED:   store [1 x i64] %.elt43, ptr %.repack42, align 8
IC: ERASE   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, ptr %60, align 8
ADD DEFERRED:   %52 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, i64 1, 4, 0
ADD DEFERRED:   %60 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %60 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %52 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, i64 1, 4, 0
ADD:   store [1 x i64] %.elt43, ptr %.repack42, align 8
ADD:   %.elt43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 4
ADD:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 4
ADD:   store [1 x i64] %.elt41, ptr %.repack40, align 8
ADD:   %.elt41 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 3
ADD:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 3
ADD:   store i64 %.elt39, ptr %.repack38, align 8
ADD:   %.elt39 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 2
ADD:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 2
ADD:   store ptr %.elt37, ptr %.repack36, align 8
ADD:   %.elt37 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 1
ADD:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 1
ADD:   store ptr %.elt, ptr %.repack, align 8
ADD:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 0
ADD:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 0
IC: Visiting:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 0
IC: Replacing   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 0
    with   %60 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Mod =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 0
    New =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 0
IC: ERASE   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 0
ADD DEFERRED:   %60 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 0
IC: Replacing   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 0
    with   %47 = call ptr @malloc(i64 %.idx35)
IC: Mod =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 0
    New =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 0
IC: ERASE   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 0
ADD DEFERRED:   %52 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, i64 1, 4, 0
IC: Visiting:   store ptr %47, ptr %60, align 8
IC: Visiting:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 1
IC: Mod =   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 1
    New =   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i64 0, i32 1
ADD:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i64 0, i32 1
IC: Visiting:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i64 0, i32 1
IC: Visiting:   %.elt37 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 1
IC: Replacing   %.elt37 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 1
    with   %47 = call ptr @malloc(i64 %.idx35)
IC: Mod =   %.elt37 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 1
    New =   %.elt37 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 1
IC: ERASE   %.elt37 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 1
ADD DEFERRED:   %52 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, i64 1, 4, 0
IC: Visiting:   store ptr %47, ptr %.repack36, align 8
IC: Visiting:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 2
IC: Mod =   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 2
    New =   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i64 0, i32 2
ADD:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i64 0, i32 2
IC: Visiting:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i64 0, i32 2
IC: Visiting:   %.elt39 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 2
IC: Replacing   %.elt39 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 2
    with i64 0
IC: Mod =   %.elt39 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 2
    New =   %.elt39 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 2
IC: ERASE   %.elt39 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 2
ADD DEFERRED:   %52 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, i64 1, 4, 0
IC: Visiting:   store i64 0, ptr %.repack38, align 8
IC: Visiting:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 3
IC: Mod =   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 3
    New =   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i64 0, i32 3
ADD:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i64 0, i32 3
IC: Visiting:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i64 0, i32 3
IC: Visiting:   %.elt41 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 3
IC: Old =   %.elt41 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, 3
ADD:   %.elt41 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, 3
IC: ERASE   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 3
ADD DEFERRED:   %52 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, i64 1, 4, 0
IC: Visiting:   %.elt41 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, 3
ADD DEFERRED:   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, 3
IC: Old =   %.elt41 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, 3
    New =   <badref> = insertvalue [1 x i64] %61, i64 %9, 0
ADD:   %.elt41 = insertvalue [1 x i64] %61, i64 %9, 0
IC: ERASE   %62 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, 3
ADD DEFERRED:   %51 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, i64 %9, 3, 0
ADD:   %51 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, i64 %9, 3, 0
ADD:   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, 3
IC: Visiting:   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, 3
IC: Old =   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, 3
ADD:   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, 3
IC: ERASE   %62 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, 3
ADD DEFERRED:   %50 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, i64 0, 2
ADD:   %50 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, i64 0, 2
IC: Visiting:   %50 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, i64 0, 2
IC: Visiting:   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, 3
IC: Old =   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, 3
ADD:   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, 3
IC: ERASE   %62 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, 3
ADD DEFERRED:   %49 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, ptr %47, 1
ADD:   %49 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, ptr %47, 1
IC: Visiting:   %49 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, ptr %47, 1
IC: Visiting:   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, 3
IC: Old =   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
ADD:   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: ERASE   %62 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, 3
ADD DEFERRED:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %47, 0
ADD:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %47, 0
IC: Visiting:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %47, 0
IC: ConstFold to: [1 x i64] undef from:   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Replacing   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
    with [1 x i64] undef
IC: ERASE   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Visiting:   %51 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, i64 %9, 3, 0
IC: Visiting:   %.elt41 = insertvalue [1 x i64] undef, i64 %9, 0
IC: Visiting:   store [1 x i64] %.elt41, ptr %.repack40, align 8
ADD DEFERRED:   %61 = extractvalue [1 x i64] %.elt41, 0
ADD DEFERRED:   store i64 %61, ptr %.repack40, align 8
IC: ERASE   store [1 x i64] %.elt41, ptr %.repack40, align 8
ADD DEFERRED:   %.elt41 = insertvalue [1 x i64] undef, i64 %9, 0
ADD DEFERRED:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i64 0, i32 3
ADD:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i64 0, i32 3
ADD:   %.elt41 = insertvalue [1 x i64] undef, i64 %9, 0
ADD:   store i64 %61, ptr %.repack40, align 8
ADD:   %61 = extractvalue [1 x i64] %.elt41, 0
IC: Visiting:   %61 = extractvalue [1 x i64] %.elt41, 0
IC: Replacing   %61 = extractvalue [1 x i64] %.elt41, 0
    with   %9 = load i64, ptr %8, align 4
IC: Mod =   %61 = extractvalue [1 x i64] %.elt41, 0
    New =   %61 = extractvalue [1 x i64] %.elt41, 0
IC: ERASE   %61 = extractvalue [1 x i64] %.elt41, 0
ADD DEFERRED:   %.elt41 = insertvalue [1 x i64] undef, i64 %9, 0
IC: ERASE   %.elt41 = insertvalue [1 x i64] undef, i64 %9, 0
ADD DEFERRED:   %9 = load i64, ptr %8, align 4
ADD:   %9 = load i64, ptr %8, align 4
IC: Visiting:   %9 = load i64, ptr %8, align 4
IC: Visiting:   store i64 %9, ptr %.repack40, align 8
IC: Visiting:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i64 0, i32 3
IC: Visiting:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 4
IC: Mod =   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i32 0, i32 4
    New =   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i64 0, i32 4
ADD:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i64 0, i32 4
IC: Visiting:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %60, i64 0, i32 4
IC: Visiting:   %.elt43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 4
ADD DEFERRED:   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, 4
IC: Old =   %.elt43 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 4
    New =   <badref> = insertvalue [1 x i64] %61, i64 1, 0
ADD:   %.elt43 = insertvalue [1 x i64] %61, i64 1, 0
IC: ERASE   %62 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, 4
ADD DEFERRED:   %52 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, i64 1, 4, 0
IC: ERASE   %52 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, i64 1, 4, 0
ADD DEFERRED:   %51 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, i64 %9, 3, 0
ADD:   %51 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, i64 %9, 3, 0
ADD:   %60 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, 4
IC: Visiting:   %60 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, 4
IC: Old =   %60 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, 4
ADD:   %60 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, 4
IC: ERASE   %61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, 4
ADD DEFERRED:   %51 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, i64 %9, 3, 0
IC: ERASE   %51 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, i64 %9, 3, 0
ADD DEFERRED:   %50 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, i64 0, 2
ADD DEFERRED:   %9 = load i64, ptr %8, align 4
ADD:   %9 = load i64, ptr %8, align 4
ADD:   %50 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, i64 0, 2
IC: Visiting:   %50 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, i64 0, 2
IC: Visiting:   %9 = load i64, ptr %8, align 4
IC: Visiting:   %59 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, 4
IC: Old =   %59 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, 4
ADD:   %59 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, 4
IC: ERASE   %60 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, 4
ADD DEFERRED:   %50 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, i64 0, 2
IC: ERASE   %50 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, i64 0, 2
ADD DEFERRED:   %49 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, ptr %47, 1
ADD:   %49 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, ptr %47, 1
IC: Visiting:   %49 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, ptr %47, 1
IC: Visiting:   %58 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, 4
IC: Old =   %58 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, 4
ADD:   %58 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, 4
IC: ERASE   %59 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, 4
ADD DEFERRED:   %49 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, ptr %47, 1
IC: ERASE   %49 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, ptr %47, 1
ADD DEFERRED:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %47, 0
ADD DEFERRED:   %47 = call ptr @malloc(i64 %.idx35)
ADD:   %47 = call ptr @malloc(i64 %.idx35)
ADD:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %47, 0
IC: Visiting:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %47, 0
IC: Visiting:   %47 = call ptr @malloc(i64 %.idx35)
IC: Visiting:   %57 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, 4
IC: Old =   %57 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
ADD:   %57 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ERASE   %58 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, 4
ADD DEFERRED:   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %47, 0
IC: ERASE   %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %47, 0
ADD DEFERRED:   %47 = call ptr @malloc(i64 %.idx35)
ADD:   %47 = call ptr @malloc(i64 %.idx35)
IC: Visiting:   %47 = call ptr @malloc(i64 %.idx35)
IC: ConstFold to: [1 x i64] undef from:   %56 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: Replacing   %56 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
    with [1 x i64] undef
IC: ERASE   %56 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ConstFold to: [1 x i64] [i64 1] from:   %.elt43 = insertvalue [1 x i64] undef, i64 1, 0
IC: Replacing   %.elt43 = insertvalue [1 x i64] undef, i64 1, 0
    with [1 x i64] [i64 1]
IC: ERASE   %.elt43 = insertvalue [1 x i64] undef, i64 1, 0
IC: Visiting:   store [1 x i64] [i64 1], ptr %.repack42, align 8
ADD DEFERRED:   store i64 1, ptr %.repack42, align 8
IC: ERASE   store [1 x i64] [i64 1], ptr %.repack42, align 8
ADD DEFERRED:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 4
ADD:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 4
ADD:   store i64 1, ptr %.repack42, align 8
IC: Visiting:   store i64 1, ptr %.repack42, align 8
IC: Visiting:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 4
IC: Visiting:   %55 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %56 = getelementptr i64, ptr null, i64 %11
IC: Visiting:   %57 = ptrtoint ptr %56 to i64
ADD DEFERRED:   %.idx44 = mul i64 %11, 8
IC: Replacing   %57 = ptrtoint ptr %56 to i64
    with   %.idx44 = mul i64 %11, 8
IC: Mod =   %57 = ptrtoint ptr %56 to i64
    New =   %57 = ptrtoint ptr %56 to i64
IC: ERASE   %57 = ptrtoint ptr %56 to i64
ADD DEFERRED:   %56 = getelementptr i64, ptr null, i64 %11
IC: ERASE   %56 = getelementptr i64, ptr null, i64 %11
ADD DEFERRED:   %11 = load i64, ptr %10, align 4
ADD:   %11 = load i64, ptr %10, align 4
ADD:   %.idx44 = mul i64 %11, 8
IC: Visiting:   %.idx44 = mul i64 %11, 8
IC: Old =   %.idx44 = mul i64 %11, 8
    New =   <badref> = shl i64 %11, 3
ADD:   %.idx44 = shl i64 %11, 3
IC: ERASE   %56 = mul i64 %11, 8
ADD DEFERRED:   %11 = load i64, ptr %10, align 4
IC: Visiting:   %.idx44 = shl i64 %11, 3
IC: Visiting:   %11 = load i64, ptr %10, align 4
IC: Visiting:   %56 = call ptr @malloc(i64 %.idx44)
IC: Visiting:   %57 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %56, 0
IC: Visiting:   %58 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, ptr %56, 1
IC: Visiting:   %59 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, i64 0, 2
IC: Visiting:   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, i64 %11, 3, 0
IC: Visiting:   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, i64 1, 4, 0
IC: Visiting:   br label %62
IC: Visiting:   %63 = phi i64 [ %67, %65 ], [ 0, %54 ]
IC: Visiting:   %64 = icmp slt i64 %63, %11
IC: Visiting:   br i1 %64, label %65, label %68
IC: Visiting:   %69 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
IC: Mod =   %69 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
    New =   %69 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %69 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %69 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, ptr %69, align 8
ADD DEFERRED:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 0
ADD DEFERRED:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 0
ADD DEFERRED:   store ptr %.elt, ptr %.repack, align 8
ADD DEFERRED:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 1
ADD DEFERRED:   %.elt46 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 1
ADD DEFERRED:   store ptr %.elt46, ptr %.repack45, align 8
ADD DEFERRED:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 2
ADD DEFERRED:   %.elt48 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 2
ADD DEFERRED:   store i64 %.elt48, ptr %.repack47, align 8
ADD DEFERRED:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 3
ADD DEFERRED:   %.elt50 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 3
ADD DEFERRED:   store [1 x i64] %.elt50, ptr %.repack49, align 8
ADD DEFERRED:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 4
ADD DEFERRED:   %.elt52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 4
ADD DEFERRED:   store [1 x i64] %.elt52, ptr %.repack51, align 8
IC: ERASE   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, ptr %69, align 8
ADD DEFERRED:   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, i64 1, 4, 0
ADD DEFERRED:   %69 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %69 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, i64 1, 4, 0
ADD:   store [1 x i64] %.elt52, ptr %.repack51, align 8
ADD:   %.elt52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 4
ADD:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 4
ADD:   store [1 x i64] %.elt50, ptr %.repack49, align 8
ADD:   %.elt50 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 3
ADD:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 3
ADD:   store i64 %.elt48, ptr %.repack47, align 8
ADD:   %.elt48 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 2
ADD:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 2
ADD:   store ptr %.elt46, ptr %.repack45, align 8
ADD:   %.elt46 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 1
ADD:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 1
ADD:   store ptr %.elt, ptr %.repack, align 8
ADD:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 0
ADD:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 0
IC: Visiting:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 0
IC: Replacing   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 0
    with   %69 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Mod =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 0
    New =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 0
IC: ERASE   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 0
ADD DEFERRED:   %69 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 0
IC: Replacing   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 0
    with   %56 = call ptr @malloc(i64 %.idx44)
IC: Mod =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 0
    New =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 0
IC: ERASE   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 0
ADD DEFERRED:   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, i64 1, 4, 0
IC: Visiting:   store ptr %56, ptr %69, align 8
IC: Visiting:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 1
IC: Mod =   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 1
    New =   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i64 0, i32 1
ADD:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i64 0, i32 1
IC: Visiting:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i64 0, i32 1
IC: Visiting:   %.elt46 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 1
IC: Replacing   %.elt46 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 1
    with   %56 = call ptr @malloc(i64 %.idx44)
IC: Mod =   %.elt46 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 1
    New =   %.elt46 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 1
IC: ERASE   %.elt46 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 1
ADD DEFERRED:   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, i64 1, 4, 0
IC: Visiting:   store ptr %56, ptr %.repack45, align 8
IC: Visiting:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 2
IC: Mod =   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 2
    New =   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i64 0, i32 2
ADD:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i64 0, i32 2
IC: Visiting:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i64 0, i32 2
IC: Visiting:   %.elt48 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 2
IC: Replacing   %.elt48 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 2
    with i64 0
IC: Mod =   %.elt48 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 2
    New =   %.elt48 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 2
IC: ERASE   %.elt48 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 2
ADD DEFERRED:   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, i64 1, 4, 0
IC: Visiting:   store i64 0, ptr %.repack47, align 8
IC: Visiting:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 3
IC: Mod =   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 3
    New =   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i64 0, i32 3
ADD:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i64 0, i32 3
IC: Visiting:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i64 0, i32 3
IC: Visiting:   %.elt50 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 3
IC: Old =   %.elt50 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, 3
ADD:   %.elt50 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, 3
IC: ERASE   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 3
ADD DEFERRED:   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, i64 1, 4, 0
IC: Visiting:   %.elt50 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, 3
ADD DEFERRED:   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, 3
IC: Old =   %.elt50 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, 3
    New =   <badref> = insertvalue [1 x i64] %70, i64 %11, 0
ADD:   %.elt50 = insertvalue [1 x i64] %70, i64 %11, 0
IC: ERASE   %71 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, 3
ADD DEFERRED:   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, i64 %11, 3, 0
ADD:   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, i64 %11, 3, 0
ADD:   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, 3
IC: Visiting:   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, 3
IC: Old =   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, 3
ADD:   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, 3
IC: ERASE   %71 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, 3
ADD DEFERRED:   %59 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, i64 0, 2
ADD:   %59 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, i64 0, 2
IC: Visiting:   %59 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, i64 0, 2
IC: Visiting:   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, 3
IC: Old =   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, 3
ADD:   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, 3
IC: ERASE   %71 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, 3
ADD DEFERRED:   %58 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, ptr %56, 1
ADD:   %58 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, ptr %56, 1
IC: Visiting:   %58 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, ptr %56, 1
IC: Visiting:   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, 3
IC: Old =   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
ADD:   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: ERASE   %71 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, 3
ADD DEFERRED:   %57 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %56, 0
ADD:   %57 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %56, 0
IC: Visiting:   %57 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %56, 0
IC: ConstFold to: [1 x i64] undef from:   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Replacing   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
    with [1 x i64] undef
IC: ERASE   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Visiting:   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, i64 %11, 3, 0
IC: Visiting:   %.elt50 = insertvalue [1 x i64] undef, i64 %11, 0
IC: Visiting:   store [1 x i64] %.elt50, ptr %.repack49, align 8
ADD DEFERRED:   %70 = extractvalue [1 x i64] %.elt50, 0
ADD DEFERRED:   store i64 %70, ptr %.repack49, align 8
IC: ERASE   store [1 x i64] %.elt50, ptr %.repack49, align 8
ADD DEFERRED:   %.elt50 = insertvalue [1 x i64] undef, i64 %11, 0
ADD DEFERRED:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i64 0, i32 3
ADD:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i64 0, i32 3
ADD:   %.elt50 = insertvalue [1 x i64] undef, i64 %11, 0
ADD:   store i64 %70, ptr %.repack49, align 8
ADD:   %70 = extractvalue [1 x i64] %.elt50, 0
IC: Visiting:   %70 = extractvalue [1 x i64] %.elt50, 0
IC: Replacing   %70 = extractvalue [1 x i64] %.elt50, 0
    with   %11 = load i64, ptr %10, align 4
IC: Mod =   %70 = extractvalue [1 x i64] %.elt50, 0
    New =   %70 = extractvalue [1 x i64] %.elt50, 0
IC: ERASE   %70 = extractvalue [1 x i64] %.elt50, 0
ADD DEFERRED:   %.elt50 = insertvalue [1 x i64] undef, i64 %11, 0
IC: ERASE   %.elt50 = insertvalue [1 x i64] undef, i64 %11, 0
ADD DEFERRED:   %11 = load i64, ptr %10, align 4
ADD:   %11 = load i64, ptr %10, align 4
IC: Visiting:   %11 = load i64, ptr %10, align 4
IC: Visiting:   store i64 %11, ptr %.repack49, align 8
IC: Visiting:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i64 0, i32 3
IC: Visiting:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 4
IC: Mod =   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i32 0, i32 4
    New =   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i64 0, i32 4
ADD:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i64 0, i32 4
IC: Visiting:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %69, i64 0, i32 4
IC: Visiting:   %.elt52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 4
ADD DEFERRED:   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, 4
IC: Old =   %.elt52 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 4
    New =   <badref> = insertvalue [1 x i64] %70, i64 1, 0
ADD:   %.elt52 = insertvalue [1 x i64] %70, i64 1, 0
IC: ERASE   %71 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %61, 4
ADD DEFERRED:   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, i64 1, 4, 0
IC: ERASE   %61 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, i64 1, 4, 0
ADD DEFERRED:   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, i64 %11, 3, 0
ADD:   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, i64 %11, 3, 0
ADD:   %69 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, 4
IC: Visiting:   %69 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, 4
IC: Old =   %69 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, 4
ADD:   %69 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, 4
IC: ERASE   %70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %60, 4
ADD DEFERRED:   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, i64 %11, 3, 0
IC: ERASE   %60 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, i64 %11, 3, 0
ADD DEFERRED:   %59 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, i64 0, 2
ADD DEFERRED:   %11 = load i64, ptr %10, align 4
ADD:   %11 = load i64, ptr %10, align 4
ADD:   %59 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, i64 0, 2
IC: Visiting:   %59 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, i64 0, 2
IC: Visiting:   %11 = load i64, ptr %10, align 4
IC: Visiting:   %68 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, 4
IC: Old =   %68 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, 4
ADD:   %68 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, 4
IC: ERASE   %69 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %59, 4
ADD DEFERRED:   %59 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, i64 0, 2
IC: ERASE   %59 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, i64 0, 2
ADD DEFERRED:   %58 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, ptr %56, 1
ADD:   %58 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, ptr %56, 1
IC: Visiting:   %58 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, ptr %56, 1
IC: Visiting:   %67 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, 4
IC: Old =   %67 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, 4
ADD:   %67 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, 4
IC: ERASE   %68 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %58, 4
ADD DEFERRED:   %58 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, ptr %56, 1
IC: ERASE   %58 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, ptr %56, 1
ADD DEFERRED:   %57 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %56, 0
ADD DEFERRED:   %56 = call ptr @malloc(i64 %.idx44)
ADD:   %56 = call ptr @malloc(i64 %.idx44)
ADD:   %57 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %56, 0
IC: Visiting:   %57 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %56, 0
IC: Visiting:   %56 = call ptr @malloc(i64 %.idx44)
IC: Visiting:   %66 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, 4
IC: Old =   %66 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
ADD:   %66 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ERASE   %67 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %57, 4
ADD DEFERRED:   %57 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %56, 0
IC: ERASE   %57 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %56, 0
ADD DEFERRED:   %56 = call ptr @malloc(i64 %.idx44)
ADD:   %56 = call ptr @malloc(i64 %.idx44)
IC: Visiting:   %56 = call ptr @malloc(i64 %.idx44)
IC: ConstFold to: [1 x i64] undef from:   %65 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: Replacing   %65 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
    with [1 x i64] undef
IC: ERASE   %65 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ConstFold to: [1 x i64] [i64 1] from:   %.elt52 = insertvalue [1 x i64] undef, i64 1, 0
IC: Replacing   %.elt52 = insertvalue [1 x i64] undef, i64 1, 0
    with [1 x i64] [i64 1]
IC: ERASE   %.elt52 = insertvalue [1 x i64] undef, i64 1, 0
IC: Visiting:   store [1 x i64] [i64 1], ptr %.repack51, align 8
ADD DEFERRED:   store i64 1, ptr %.repack51, align 8
IC: ERASE   store [1 x i64] [i64 1], ptr %.repack51, align 8
ADD DEFERRED:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 4
ADD:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 4
ADD:   store i64 1, ptr %.repack51, align 8
IC: Visiting:   store i64 1, ptr %.repack51, align 8
IC: Visiting:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 4
IC: Visiting:   %64 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %65 = getelementptr i64, ptr null, i64 %13
IC: Visiting:   %66 = ptrtoint ptr %65 to i64
ADD DEFERRED:   %.idx53 = mul i64 %13, 8
IC: Replacing   %66 = ptrtoint ptr %65 to i64
    with   %.idx53 = mul i64 %13, 8
IC: Mod =   %66 = ptrtoint ptr %65 to i64
    New =   %66 = ptrtoint ptr %65 to i64
IC: ERASE   %66 = ptrtoint ptr %65 to i64
ADD DEFERRED:   %65 = getelementptr i64, ptr null, i64 %13
IC: ERASE   %65 = getelementptr i64, ptr null, i64 %13
ADD DEFERRED:   %13 = load i64, ptr %12, align 4
ADD:   %13 = load i64, ptr %12, align 4
ADD:   %.idx53 = mul i64 %13, 8
IC: Visiting:   %.idx53 = mul i64 %13, 8
IC: Old =   %.idx53 = mul i64 %13, 8
    New =   <badref> = shl i64 %13, 3
ADD:   %.idx53 = shl i64 %13, 3
IC: ERASE   %65 = mul i64 %13, 8
ADD DEFERRED:   %13 = load i64, ptr %12, align 4
IC: Visiting:   %.idx53 = shl i64 %13, 3
IC: Visiting:   %13 = load i64, ptr %12, align 4
IC: Visiting:   %65 = call ptr @malloc(i64 %.idx53)
IC: Visiting:   %66 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %65, 0
IC: Visiting:   %67 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, ptr %65, 1
IC: Visiting:   %68 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, i64 0, 2
IC: Visiting:   %69 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, i64 %13, 3, 0
IC: Visiting:   %70 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, i64 1, 4, 0
IC: Visiting:   br label %71
IC: Visiting:   %72 = phi i64 [ %76, %74 ], [ 0, %63 ]
IC: Visiting:   %73 = icmp slt i64 %72, %13
IC: Visiting:   br i1 %73, label %74, label %77
IC: Visiting:   %78 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
IC: Mod =   %78 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
    New =   %78 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %78 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %78 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, ptr %78, align 8
ADD DEFERRED:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 0
ADD DEFERRED:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 0
ADD DEFERRED:   store ptr %.elt, ptr %.repack, align 8
ADD DEFERRED:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 1
ADD DEFERRED:   %.elt55 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 1
ADD DEFERRED:   store ptr %.elt55, ptr %.repack54, align 8
ADD DEFERRED:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 2
ADD DEFERRED:   %.elt57 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 2
ADD DEFERRED:   store i64 %.elt57, ptr %.repack56, align 8
ADD DEFERRED:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 3
ADD DEFERRED:   %.elt59 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 3
ADD DEFERRED:   store [1 x i64] %.elt59, ptr %.repack58, align 8
ADD DEFERRED:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 4
ADD DEFERRED:   %.elt61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 4
ADD DEFERRED:   store [1 x i64] %.elt61, ptr %.repack60, align 8
IC: ERASE   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, ptr %78, align 8
ADD DEFERRED:   %70 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, i64 1, 4, 0
ADD DEFERRED:   %78 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %78 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %70 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, i64 1, 4, 0
ADD:   store [1 x i64] %.elt61, ptr %.repack60, align 8
ADD:   %.elt61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 4
ADD:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 4
ADD:   store [1 x i64] %.elt59, ptr %.repack58, align 8
ADD:   %.elt59 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 3
ADD:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 3
ADD:   store i64 %.elt57, ptr %.repack56, align 8
ADD:   %.elt57 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 2
ADD:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 2
ADD:   store ptr %.elt55, ptr %.repack54, align 8
ADD:   %.elt55 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 1
ADD:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 1
ADD:   store ptr %.elt, ptr %.repack, align 8
ADD:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 0
ADD:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 0
IC: Visiting:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 0
IC: Replacing   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 0
    with   %78 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Mod =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 0
    New =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 0
IC: ERASE   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 0
ADD DEFERRED:   %78 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 0
IC: Replacing   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 0
    with   %65 = call ptr @malloc(i64 %.idx53)
IC: Mod =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 0
    New =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 0
IC: ERASE   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 0
ADD DEFERRED:   %70 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, i64 1, 4, 0
IC: Visiting:   store ptr %65, ptr %78, align 8
IC: Visiting:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 1
IC: Mod =   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 1
    New =   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i64 0, i32 1
ADD:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i64 0, i32 1
IC: Visiting:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i64 0, i32 1
IC: Visiting:   %.elt55 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 1
IC: Replacing   %.elt55 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 1
    with   %65 = call ptr @malloc(i64 %.idx53)
IC: Mod =   %.elt55 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 1
    New =   %.elt55 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 1
IC: ERASE   %.elt55 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 1
ADD DEFERRED:   %70 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, i64 1, 4, 0
IC: Visiting:   store ptr %65, ptr %.repack54, align 8
IC: Visiting:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 2
IC: Mod =   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 2
    New =   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i64 0, i32 2
ADD:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i64 0, i32 2
IC: Visiting:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i64 0, i32 2
IC: Visiting:   %.elt57 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 2
IC: Replacing   %.elt57 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 2
    with i64 0
IC: Mod =   %.elt57 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 2
    New =   %.elt57 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 2
IC: ERASE   %.elt57 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 2
ADD DEFERRED:   %70 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, i64 1, 4, 0
IC: Visiting:   store i64 0, ptr %.repack56, align 8
IC: Visiting:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 3
IC: Mod =   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 3
    New =   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i64 0, i32 3
ADD:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i64 0, i32 3
IC: Visiting:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i64 0, i32 3
IC: Visiting:   %.elt59 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 3
IC: Old =   %.elt59 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, 3
ADD:   %.elt59 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, 3
IC: ERASE   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 3
ADD DEFERRED:   %70 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, i64 1, 4, 0
IC: Visiting:   %.elt59 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, 3
ADD DEFERRED:   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, 3
IC: Old =   %.elt59 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, 3
    New =   <badref> = insertvalue [1 x i64] %79, i64 %13, 0
ADD:   %.elt59 = insertvalue [1 x i64] %79, i64 %13, 0
IC: ERASE   %80 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, 3
ADD DEFERRED:   %69 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, i64 %13, 3, 0
ADD:   %69 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, i64 %13, 3, 0
ADD:   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, 3
IC: Visiting:   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, 3
IC: Old =   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, 3
ADD:   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, 3
IC: ERASE   %80 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, 3
ADD DEFERRED:   %68 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, i64 0, 2
ADD:   %68 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, i64 0, 2
IC: Visiting:   %68 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, i64 0, 2
IC: Visiting:   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, 3
IC: Old =   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, 3
ADD:   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, 3
IC: ERASE   %80 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, 3
ADD DEFERRED:   %67 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, ptr %65, 1
ADD:   %67 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, ptr %65, 1
IC: Visiting:   %67 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, ptr %65, 1
IC: Visiting:   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, 3
IC: Old =   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
ADD:   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: ERASE   %80 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, 3
ADD DEFERRED:   %66 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %65, 0
ADD:   %66 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %65, 0
IC: Visiting:   %66 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %65, 0
IC: ConstFold to: [1 x i64] undef from:   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Replacing   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
    with [1 x i64] undef
IC: ERASE   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Visiting:   %69 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, i64 %13, 3, 0
IC: Visiting:   %.elt59 = insertvalue [1 x i64] undef, i64 %13, 0
IC: Visiting:   store [1 x i64] %.elt59, ptr %.repack58, align 8
ADD DEFERRED:   %79 = extractvalue [1 x i64] %.elt59, 0
ADD DEFERRED:   store i64 %79, ptr %.repack58, align 8
IC: ERASE   store [1 x i64] %.elt59, ptr %.repack58, align 8
ADD DEFERRED:   %.elt59 = insertvalue [1 x i64] undef, i64 %13, 0
ADD DEFERRED:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i64 0, i32 3
ADD:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i64 0, i32 3
ADD:   %.elt59 = insertvalue [1 x i64] undef, i64 %13, 0
ADD:   store i64 %79, ptr %.repack58, align 8
ADD:   %79 = extractvalue [1 x i64] %.elt59, 0
IC: Visiting:   %79 = extractvalue [1 x i64] %.elt59, 0
IC: Replacing   %79 = extractvalue [1 x i64] %.elt59, 0
    with   %13 = load i64, ptr %12, align 4
IC: Mod =   %79 = extractvalue [1 x i64] %.elt59, 0
    New =   %79 = extractvalue [1 x i64] %.elt59, 0
IC: ERASE   %79 = extractvalue [1 x i64] %.elt59, 0
ADD DEFERRED:   %.elt59 = insertvalue [1 x i64] undef, i64 %13, 0
IC: ERASE   %.elt59 = insertvalue [1 x i64] undef, i64 %13, 0
ADD DEFERRED:   %13 = load i64, ptr %12, align 4
ADD:   %13 = load i64, ptr %12, align 4
IC: Visiting:   %13 = load i64, ptr %12, align 4
IC: Visiting:   store i64 %13, ptr %.repack58, align 8
IC: Visiting:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i64 0, i32 3
IC: Visiting:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 4
IC: Mod =   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i32 0, i32 4
    New =   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i64 0, i32 4
ADD:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i64 0, i32 4
IC: Visiting:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %78, i64 0, i32 4
IC: Visiting:   %.elt61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 4
ADD DEFERRED:   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, 4
IC: Old =   %.elt61 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 4
    New =   <badref> = insertvalue [1 x i64] %79, i64 1, 0
ADD:   %.elt61 = insertvalue [1 x i64] %79, i64 1, 0
IC: ERASE   %80 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %70, 4
ADD DEFERRED:   %70 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, i64 1, 4, 0
IC: ERASE   %70 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, i64 1, 4, 0
ADD DEFERRED:   %69 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, i64 %13, 3, 0
ADD:   %69 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, i64 %13, 3, 0
ADD:   %78 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, 4
IC: Visiting:   %78 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, 4
IC: Old =   %78 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, 4
ADD:   %78 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, 4
IC: ERASE   %79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %69, 4
ADD DEFERRED:   %69 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, i64 %13, 3, 0
IC: ERASE   %69 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, i64 %13, 3, 0
ADD DEFERRED:   %68 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, i64 0, 2
ADD DEFERRED:   %13 = load i64, ptr %12, align 4
ADD:   %13 = load i64, ptr %12, align 4
ADD:   %68 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, i64 0, 2
IC: Visiting:   %68 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, i64 0, 2
IC: Visiting:   %13 = load i64, ptr %12, align 4
IC: Visiting:   %77 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, 4
IC: Old =   %77 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, 4
ADD:   %77 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, 4
IC: ERASE   %78 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, 4
ADD DEFERRED:   %68 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, i64 0, 2
IC: ERASE   %68 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, i64 0, 2
ADD DEFERRED:   %67 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, ptr %65, 1
ADD:   %67 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, ptr %65, 1
IC: Visiting:   %67 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, ptr %65, 1
IC: Visiting:   %76 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, 4
IC: Old =   %76 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, 4
ADD:   %76 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, 4
IC: ERASE   %77 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, 4
ADD DEFERRED:   %67 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, ptr %65, 1
IC: ERASE   %67 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, ptr %65, 1
ADD DEFERRED:   %66 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %65, 0
ADD DEFERRED:   %65 = call ptr @malloc(i64 %.idx53)
ADD:   %65 = call ptr @malloc(i64 %.idx53)
ADD:   %66 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %65, 0
IC: Visiting:   %66 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %65, 0
IC: Visiting:   %65 = call ptr @malloc(i64 %.idx53)
IC: Visiting:   %75 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, 4
IC: Old =   %75 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
ADD:   %75 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ERASE   %76 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, 4
ADD DEFERRED:   %66 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %65, 0
IC: ERASE   %66 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %65, 0
ADD DEFERRED:   %65 = call ptr @malloc(i64 %.idx53)
ADD:   %65 = call ptr @malloc(i64 %.idx53)
IC: Visiting:   %65 = call ptr @malloc(i64 %.idx53)
IC: ConstFold to: [1 x i64] undef from:   %74 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: Replacing   %74 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
    with [1 x i64] undef
IC: ERASE   %74 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ConstFold to: [1 x i64] [i64 1] from:   %.elt61 = insertvalue [1 x i64] undef, i64 1, 0
IC: Replacing   %.elt61 = insertvalue [1 x i64] undef, i64 1, 0
    with [1 x i64] [i64 1]
IC: ERASE   %.elt61 = insertvalue [1 x i64] undef, i64 1, 0
IC: Visiting:   store [1 x i64] [i64 1], ptr %.repack60, align 8
ADD DEFERRED:   store i64 1, ptr %.repack60, align 8
IC: ERASE   store [1 x i64] [i64 1], ptr %.repack60, align 8
ADD DEFERRED:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 4
ADD:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 4
ADD:   store i64 1, ptr %.repack60, align 8
IC: Visiting:   store i64 1, ptr %.repack60, align 8
IC: Visiting:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 4
IC: Visiting:   %73 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %74 = getelementptr i64, ptr null, i64 %15
IC: Visiting:   %75 = ptrtoint ptr %74 to i64
ADD DEFERRED:   %.idx62 = mul i64 %15, 8
IC: Replacing   %75 = ptrtoint ptr %74 to i64
    with   %.idx62 = mul i64 %15, 8
IC: Mod =   %75 = ptrtoint ptr %74 to i64
    New =   %75 = ptrtoint ptr %74 to i64
IC: ERASE   %75 = ptrtoint ptr %74 to i64
ADD DEFERRED:   %74 = getelementptr i64, ptr null, i64 %15
IC: ERASE   %74 = getelementptr i64, ptr null, i64 %15
ADD DEFERRED:   %15 = load i64, ptr %14, align 4
ADD:   %15 = load i64, ptr %14, align 4
ADD:   %.idx62 = mul i64 %15, 8
IC: Visiting:   %.idx62 = mul i64 %15, 8
IC: Old =   %.idx62 = mul i64 %15, 8
    New =   <badref> = shl i64 %15, 3
ADD:   %.idx62 = shl i64 %15, 3
IC: ERASE   %74 = mul i64 %15, 8
ADD DEFERRED:   %15 = load i64, ptr %14, align 4
IC: Visiting:   %.idx62 = shl i64 %15, 3
IC: Visiting:   %15 = load i64, ptr %14, align 4
IC: Visiting:   %74 = call ptr @malloc(i64 %.idx62)
IC: Visiting:   %75 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %74, 0
IC: Visiting:   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, ptr %74, 1
IC: Visiting:   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, i64 0, 2
IC: Visiting:   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 %15, 3, 0
IC: Visiting:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 1, 4, 0
IC: Visiting:   br label %80
IC: Visiting:   %81 = phi i64 [ %85, %83 ], [ 0, %72 ]
IC: Visiting:   %82 = icmp slt i64 %81, %15
IC: Visiting:   br i1 %82, label %83, label %86
IC: Visiting:   %87 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
IC: Mod =   %87 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
    New =   %87 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %87 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %87 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, ptr %87, align 8
ADD DEFERRED:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 0
ADD DEFERRED:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 0
ADD DEFERRED:   store ptr %.elt, ptr %.repack, align 8
ADD DEFERRED:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 1
ADD DEFERRED:   %.elt64 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 1
ADD DEFERRED:   store ptr %.elt64, ptr %.repack63, align 8
ADD DEFERRED:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 2
ADD DEFERRED:   %.elt66 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 2
ADD DEFERRED:   store i64 %.elt66, ptr %.repack65, align 8
ADD DEFERRED:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 3
ADD DEFERRED:   %.elt68 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 3
ADD DEFERRED:   store [1 x i64] %.elt68, ptr %.repack67, align 8
ADD DEFERRED:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 4
ADD DEFERRED:   %.elt70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 4
ADD DEFERRED:   store [1 x i64] %.elt70, ptr %.repack69, align 8
IC: ERASE   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, ptr %87, align 8
ADD DEFERRED:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 1, 4, 0
ADD DEFERRED:   %87 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %87 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 1, 4, 0
ADD:   store [1 x i64] %.elt70, ptr %.repack69, align 8
ADD:   %.elt70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 4
ADD:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 4
ADD:   store [1 x i64] %.elt68, ptr %.repack67, align 8
ADD:   %.elt68 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 3
ADD:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 3
ADD:   store i64 %.elt66, ptr %.repack65, align 8
ADD:   %.elt66 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 2
ADD:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 2
ADD:   store ptr %.elt64, ptr %.repack63, align 8
ADD:   %.elt64 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 1
ADD:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 1
ADD:   store ptr %.elt, ptr %.repack, align 8
ADD:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 0
ADD:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 0
IC: Visiting:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 0
IC: Replacing   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 0
    with   %87 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Mod =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 0
    New =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 0
IC: ERASE   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 0
ADD DEFERRED:   %87 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 0
IC: Replacing   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 0
    with   %74 = call ptr @malloc(i64 %.idx62)
IC: Mod =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 0
    New =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 0
IC: ERASE   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 0
ADD DEFERRED:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 1, 4, 0
IC: Visiting:   store ptr %74, ptr %87, align 8
IC: Visiting:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 1
IC: Mod =   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 1
    New =   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i64 0, i32 1
ADD:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i64 0, i32 1
IC: Visiting:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i64 0, i32 1
IC: Visiting:   %.elt64 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 1
IC: Replacing   %.elt64 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 1
    with   %74 = call ptr @malloc(i64 %.idx62)
IC: Mod =   %.elt64 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 1
    New =   %.elt64 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 1
IC: ERASE   %.elt64 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 1
ADD DEFERRED:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 1, 4, 0
IC: Visiting:   store ptr %74, ptr %.repack63, align 8
IC: Visiting:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 2
IC: Mod =   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 2
    New =   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i64 0, i32 2
ADD:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i64 0, i32 2
IC: Visiting:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i64 0, i32 2
IC: Visiting:   %.elt66 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 2
IC: Replacing   %.elt66 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 2
    with i64 0
IC: Mod =   %.elt66 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 2
    New =   %.elt66 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 2
IC: ERASE   %.elt66 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 2
ADD DEFERRED:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 1, 4, 0
IC: Visiting:   store i64 0, ptr %.repack65, align 8
IC: Visiting:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 3
IC: Mod =   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 3
    New =   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i64 0, i32 3
ADD:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i64 0, i32 3
IC: Visiting:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i64 0, i32 3
IC: Visiting:   %.elt68 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 3
IC: Old =   %.elt68 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, 3
ADD:   %.elt68 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, 3
IC: ERASE   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 3
ADD DEFERRED:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 1, 4, 0
IC: Visiting:   %.elt68 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, 3
ADD DEFERRED:   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, 3
IC: Old =   %.elt68 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, 3
    New =   <badref> = insertvalue [1 x i64] %88, i64 %15, 0
ADD:   %.elt68 = insertvalue [1 x i64] %88, i64 %15, 0
IC: ERASE   %89 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, 3
ADD DEFERRED:   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 %15, 3, 0
ADD:   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 %15, 3, 0
ADD:   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, 3
IC: Visiting:   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, 3
IC: Old =   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, 3
ADD:   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, 3
IC: ERASE   %89 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, 3
ADD DEFERRED:   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, i64 0, 2
ADD:   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, i64 0, 2
IC: Visiting:   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, i64 0, 2
IC: Visiting:   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, 3
IC: Old =   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, 3
ADD:   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, 3
IC: ERASE   %89 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, 3
ADD DEFERRED:   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, ptr %74, 1
ADD:   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, ptr %74, 1
IC: Visiting:   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, ptr %74, 1
IC: Visiting:   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, 3
IC: Old =   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
ADD:   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: ERASE   %89 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, 3
ADD DEFERRED:   %75 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %74, 0
ADD:   %75 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %74, 0
IC: Visiting:   %75 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %74, 0
IC: ConstFold to: [1 x i64] undef from:   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Replacing   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
    with [1 x i64] undef
IC: ERASE   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Visiting:   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 %15, 3, 0
IC: Visiting:   %.elt68 = insertvalue [1 x i64] undef, i64 %15, 0
IC: Visiting:   store [1 x i64] %.elt68, ptr %.repack67, align 8
ADD DEFERRED:   %88 = extractvalue [1 x i64] %.elt68, 0
ADD DEFERRED:   store i64 %88, ptr %.repack67, align 8
IC: ERASE   store [1 x i64] %.elt68, ptr %.repack67, align 8
ADD DEFERRED:   %.elt68 = insertvalue [1 x i64] undef, i64 %15, 0
ADD DEFERRED:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i64 0, i32 3
ADD:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i64 0, i32 3
ADD:   %.elt68 = insertvalue [1 x i64] undef, i64 %15, 0
ADD:   store i64 %88, ptr %.repack67, align 8
ADD:   %88 = extractvalue [1 x i64] %.elt68, 0
IC: Visiting:   %88 = extractvalue [1 x i64] %.elt68, 0
IC: Replacing   %88 = extractvalue [1 x i64] %.elt68, 0
    with   %15 = load i64, ptr %14, align 4
IC: Mod =   %88 = extractvalue [1 x i64] %.elt68, 0
    New =   %88 = extractvalue [1 x i64] %.elt68, 0
IC: ERASE   %88 = extractvalue [1 x i64] %.elt68, 0
ADD DEFERRED:   %.elt68 = insertvalue [1 x i64] undef, i64 %15, 0
IC: ERASE   %.elt68 = insertvalue [1 x i64] undef, i64 %15, 0
ADD DEFERRED:   %15 = load i64, ptr %14, align 4
ADD:   %15 = load i64, ptr %14, align 4
IC: Visiting:   %15 = load i64, ptr %14, align 4
IC: Visiting:   store i64 %15, ptr %.repack67, align 8
IC: Visiting:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i64 0, i32 3
IC: Visiting:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 4
IC: Mod =   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i32 0, i32 4
    New =   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i64 0, i32 4
ADD:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i64 0, i32 4
IC: Visiting:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %87, i64 0, i32 4
IC: Visiting:   %.elt70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 4
ADD DEFERRED:   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, 4
IC: Old =   %.elt70 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 4
    New =   <badref> = insertvalue [1 x i64] %88, i64 1, 0
ADD:   %.elt70 = insertvalue [1 x i64] %88, i64 1, 0
IC: ERASE   %89 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %79, 4
ADD DEFERRED:   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 1, 4, 0
IC: ERASE   %79 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, i64 1, 4, 0
ADD DEFERRED:   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 %15, 3, 0
ADD:   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 %15, 3, 0
ADD:   %87 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, 4
IC: Visiting:   %87 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, 4
IC: Old =   %87 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, 4
ADD:   %87 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, 4
IC: ERASE   %88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %78, 4
ADD DEFERRED:   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 %15, 3, 0
IC: ERASE   %78 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, i64 %15, 3, 0
ADD DEFERRED:   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, i64 0, 2
ADD DEFERRED:   %15 = load i64, ptr %14, align 4
ADD:   %15 = load i64, ptr %14, align 4
ADD:   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, i64 0, 2
IC: Visiting:   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, i64 0, 2
IC: Visiting:   %15 = load i64, ptr %14, align 4
IC: Visiting:   %86 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, 4
IC: Old =   %86 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, 4
ADD:   %86 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, 4
IC: ERASE   %87 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %77, 4
ADD DEFERRED:   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, i64 0, 2
IC: ERASE   %77 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, i64 0, 2
ADD DEFERRED:   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, ptr %74, 1
ADD:   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, ptr %74, 1
IC: Visiting:   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, ptr %74, 1
IC: Visiting:   %85 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, 4
IC: Old =   %85 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, 4
ADD:   %85 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, 4
IC: ERASE   %86 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %76, 4
ADD DEFERRED:   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, ptr %74, 1
IC: ERASE   %76 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, ptr %74, 1
ADD DEFERRED:   %75 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %74, 0
ADD DEFERRED:   %74 = call ptr @malloc(i64 %.idx62)
ADD:   %74 = call ptr @malloc(i64 %.idx62)
ADD:   %75 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %74, 0
IC: Visiting:   %75 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %74, 0
IC: Visiting:   %74 = call ptr @malloc(i64 %.idx62)
IC: Visiting:   %84 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, 4
IC: Old =   %84 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
ADD:   %84 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ERASE   %85 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %75, 4
ADD DEFERRED:   %75 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %74, 0
IC: ERASE   %75 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %74, 0
ADD DEFERRED:   %74 = call ptr @malloc(i64 %.idx62)
ADD:   %74 = call ptr @malloc(i64 %.idx62)
IC: Visiting:   %74 = call ptr @malloc(i64 %.idx62)
IC: ConstFold to: [1 x i64] undef from:   %83 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: Replacing   %83 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
    with [1 x i64] undef
IC: ERASE   %83 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ConstFold to: [1 x i64] [i64 1] from:   %.elt70 = insertvalue [1 x i64] undef, i64 1, 0
IC: Replacing   %.elt70 = insertvalue [1 x i64] undef, i64 1, 0
    with [1 x i64] [i64 1]
IC: ERASE   %.elt70 = insertvalue [1 x i64] undef, i64 1, 0
IC: Visiting:   store [1 x i64] [i64 1], ptr %.repack69, align 8
ADD DEFERRED:   store i64 1, ptr %.repack69, align 8
IC: ERASE   store [1 x i64] [i64 1], ptr %.repack69, align 8
ADD DEFERRED:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4
ADD:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4
ADD:   store i64 1, ptr %.repack69, align 8
IC: Visiting:   store i64 1, ptr %.repack69, align 8
IC: Visiting:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4
IC: Visiting:   %82 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %83 = getelementptr i64, ptr null, i64 %17
IC: Visiting:   %84 = ptrtoint ptr %83 to i64
ADD DEFERRED:   %.idx71 = mul i64 %17, 8
IC: Replacing   %84 = ptrtoint ptr %83 to i64
    with   %.idx71 = mul i64 %17, 8
IC: Mod =   %84 = ptrtoint ptr %83 to i64
    New =   %84 = ptrtoint ptr %83 to i64
IC: ERASE   %84 = ptrtoint ptr %83 to i64
ADD DEFERRED:   %83 = getelementptr i64, ptr null, i64 %17
IC: ERASE   %83 = getelementptr i64, ptr null, i64 %17
ADD DEFERRED:   %17 = load i64, ptr %16, align 4
ADD:   %17 = load i64, ptr %16, align 4
ADD:   %.idx71 = mul i64 %17, 8
IC: Visiting:   %.idx71 = mul i64 %17, 8
IC: Old =   %.idx71 = mul i64 %17, 8
    New =   <badref> = shl i64 %17, 3
ADD:   %.idx71 = shl i64 %17, 3
IC: ERASE   %83 = mul i64 %17, 8
ADD DEFERRED:   %17 = load i64, ptr %16, align 4
IC: Visiting:   %.idx71 = shl i64 %17, 3
IC: Visiting:   %17 = load i64, ptr %16, align 4
IC: Visiting:   %83 = call ptr @malloc(i64 %.idx71)
IC: Visiting:   %84 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %83, 0
IC: Visiting:   %85 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, ptr %83, 1
IC: Visiting:   %86 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, i64 0, 2
IC: Visiting:   %87 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, i64 %17, 3, 0
IC: Visiting:   %88 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, i64 1, 4, 0
IC: Visiting:   br label %89
IC: Visiting:   %90 = phi i64 [ %94, %92 ], [ 0, %81 ]
IC: Visiting:   %91 = icmp slt i64 %90, %17
IC: Visiting:   br i1 %91, label %92, label %95
IC: Visiting:   %96 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
IC: Mod =   %96 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
    New =   %96 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %96 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %96 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, ptr %96, align 8
ADD DEFERRED:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 0
ADD DEFERRED:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 0
ADD DEFERRED:   store ptr %.elt, ptr %.repack, align 8
ADD DEFERRED:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 1
ADD DEFERRED:   %.elt73 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 1
ADD DEFERRED:   store ptr %.elt73, ptr %.repack72, align 8
ADD DEFERRED:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 2
ADD DEFERRED:   %.elt75 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 2
ADD DEFERRED:   store i64 %.elt75, ptr %.repack74, align 8
ADD DEFERRED:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 3
ADD DEFERRED:   %.elt77 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 3
ADD DEFERRED:   store [1 x i64] %.elt77, ptr %.repack76, align 8
ADD DEFERRED:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 4
ADD DEFERRED:   %.elt79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 4
ADD DEFERRED:   store [1 x i64] %.elt79, ptr %.repack78, align 8
IC: ERASE   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, ptr %96, align 8
ADD DEFERRED:   %88 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, i64 1, 4, 0
ADD DEFERRED:   %96 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %96 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %88 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, i64 1, 4, 0
ADD:   store [1 x i64] %.elt79, ptr %.repack78, align 8
ADD:   %.elt79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 4
ADD:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 4
ADD:   store [1 x i64] %.elt77, ptr %.repack76, align 8
ADD:   %.elt77 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 3
ADD:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 3
ADD:   store i64 %.elt75, ptr %.repack74, align 8
ADD:   %.elt75 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 2
ADD:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 2
ADD:   store ptr %.elt73, ptr %.repack72, align 8
ADD:   %.elt73 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 1
ADD:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 1
ADD:   store ptr %.elt, ptr %.repack, align 8
ADD:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 0
ADD:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 0
IC: Visiting:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 0
IC: Replacing   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 0
    with   %96 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Mod =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 0
    New =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 0
IC: ERASE   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 0
ADD DEFERRED:   %96 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 0
IC: Replacing   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 0
    with   %83 = call ptr @malloc(i64 %.idx71)
IC: Mod =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 0
    New =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 0
IC: ERASE   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 0
ADD DEFERRED:   %88 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, i64 1, 4, 0
IC: Visiting:   store ptr %83, ptr %96, align 8
IC: Visiting:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 1
IC: Mod =   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 1
    New =   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i64 0, i32 1
ADD:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i64 0, i32 1
IC: Visiting:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i64 0, i32 1
IC: Visiting:   %.elt73 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 1
IC: Replacing   %.elt73 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 1
    with   %83 = call ptr @malloc(i64 %.idx71)
IC: Mod =   %.elt73 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 1
    New =   %.elt73 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 1
IC: ERASE   %.elt73 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 1
ADD DEFERRED:   %88 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, i64 1, 4, 0
IC: Visiting:   store ptr %83, ptr %.repack72, align 8
IC: Visiting:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 2
IC: Mod =   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 2
    New =   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i64 0, i32 2
ADD:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i64 0, i32 2
IC: Visiting:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i64 0, i32 2
IC: Visiting:   %.elt75 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 2
IC: Replacing   %.elt75 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 2
    with i64 0
IC: Mod =   %.elt75 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 2
    New =   %.elt75 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 2
IC: ERASE   %.elt75 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 2
ADD DEFERRED:   %88 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, i64 1, 4, 0
IC: Visiting:   store i64 0, ptr %.repack74, align 8
IC: Visiting:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 3
IC: Mod =   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 3
    New =   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i64 0, i32 3
ADD:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i64 0, i32 3
IC: Visiting:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i64 0, i32 3
IC: Visiting:   %.elt77 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 3
IC: Old =   %.elt77 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, 3
ADD:   %.elt77 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, 3
IC: ERASE   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 3
ADD DEFERRED:   %88 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, i64 1, 4, 0
IC: Visiting:   %.elt77 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, 3
ADD DEFERRED:   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, 3
IC: Old =   %.elt77 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, 3
    New =   <badref> = insertvalue [1 x i64] %97, i64 %17, 0
ADD:   %.elt77 = insertvalue [1 x i64] %97, i64 %17, 0
IC: ERASE   %98 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, 3
ADD DEFERRED:   %87 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, i64 %17, 3, 0
ADD:   %87 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, i64 %17, 3, 0
ADD:   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, 3
IC: Visiting:   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, 3
IC: Old =   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, 3
ADD:   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, 3
IC: ERASE   %98 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, 3
ADD DEFERRED:   %86 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, i64 0, 2
ADD:   %86 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, i64 0, 2
IC: Visiting:   %86 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, i64 0, 2
IC: Visiting:   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, 3
IC: Old =   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, 3
ADD:   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, 3
IC: ERASE   %98 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, 3
ADD DEFERRED:   %85 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, ptr %83, 1
ADD:   %85 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, ptr %83, 1
IC: Visiting:   %85 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, ptr %83, 1
IC: Visiting:   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, 3
IC: Old =   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
ADD:   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: ERASE   %98 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, 3
ADD DEFERRED:   %84 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %83, 0
ADD:   %84 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %83, 0
IC: Visiting:   %84 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %83, 0
IC: ConstFold to: [1 x i64] undef from:   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Replacing   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
    with [1 x i64] undef
IC: ERASE   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Visiting:   %87 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, i64 %17, 3, 0
IC: Visiting:   %.elt77 = insertvalue [1 x i64] undef, i64 %17, 0
IC: Visiting:   store [1 x i64] %.elt77, ptr %.repack76, align 8
ADD DEFERRED:   %97 = extractvalue [1 x i64] %.elt77, 0
ADD DEFERRED:   store i64 %97, ptr %.repack76, align 8
IC: ERASE   store [1 x i64] %.elt77, ptr %.repack76, align 8
ADD DEFERRED:   %.elt77 = insertvalue [1 x i64] undef, i64 %17, 0
ADD DEFERRED:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i64 0, i32 3
ADD:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i64 0, i32 3
ADD:   %.elt77 = insertvalue [1 x i64] undef, i64 %17, 0
ADD:   store i64 %97, ptr %.repack76, align 8
ADD:   %97 = extractvalue [1 x i64] %.elt77, 0
IC: Visiting:   %97 = extractvalue [1 x i64] %.elt77, 0
IC: Replacing   %97 = extractvalue [1 x i64] %.elt77, 0
    with   %17 = load i64, ptr %16, align 4
IC: Mod =   %97 = extractvalue [1 x i64] %.elt77, 0
    New =   %97 = extractvalue [1 x i64] %.elt77, 0
IC: ERASE   %97 = extractvalue [1 x i64] %.elt77, 0
ADD DEFERRED:   %.elt77 = insertvalue [1 x i64] undef, i64 %17, 0
IC: ERASE   %.elt77 = insertvalue [1 x i64] undef, i64 %17, 0
ADD DEFERRED:   %17 = load i64, ptr %16, align 4
ADD:   %17 = load i64, ptr %16, align 4
IC: Visiting:   %17 = load i64, ptr %16, align 4
IC: Visiting:   store i64 %17, ptr %.repack76, align 8
IC: Visiting:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i64 0, i32 3
IC: Visiting:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 4
IC: Mod =   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i32 0, i32 4
    New =   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i64 0, i32 4
ADD:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i64 0, i32 4
IC: Visiting:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %96, i64 0, i32 4
IC: Visiting:   %.elt79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 4
ADD DEFERRED:   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, 4
IC: Old =   %.elt79 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 4
    New =   <badref> = insertvalue [1 x i64] %97, i64 1, 0
ADD:   %.elt79 = insertvalue [1 x i64] %97, i64 1, 0
IC: ERASE   %98 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, 4
ADD DEFERRED:   %88 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, i64 1, 4, 0
IC: ERASE   %88 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, i64 1, 4, 0
ADD DEFERRED:   %87 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, i64 %17, 3, 0
ADD:   %87 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, i64 %17, 3, 0
ADD:   %96 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, 4
IC: Visiting:   %96 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, 4
IC: Old =   %96 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, 4
ADD:   %96 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, 4
IC: ERASE   %97 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, 4
ADD DEFERRED:   %87 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, i64 %17, 3, 0
IC: ERASE   %87 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, i64 %17, 3, 0
ADD DEFERRED:   %86 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, i64 0, 2
ADD DEFERRED:   %17 = load i64, ptr %16, align 4
ADD:   %17 = load i64, ptr %16, align 4
ADD:   %86 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, i64 0, 2
IC: Visiting:   %86 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, i64 0, 2
IC: Visiting:   %17 = load i64, ptr %16, align 4
IC: Visiting:   %95 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, 4
IC: Old =   %95 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, 4
ADD:   %95 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, 4
IC: ERASE   %96 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, 4
ADD DEFERRED:   %86 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, i64 0, 2
IC: ERASE   %86 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, i64 0, 2
ADD DEFERRED:   %85 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, ptr %83, 1
ADD:   %85 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, ptr %83, 1
IC: Visiting:   %85 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, ptr %83, 1
IC: Visiting:   %94 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, 4
IC: Old =   %94 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, 4
ADD:   %94 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, 4
IC: ERASE   %95 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, 4
ADD DEFERRED:   %85 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, ptr %83, 1
IC: ERASE   %85 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, ptr %83, 1
ADD DEFERRED:   %84 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %83, 0
ADD DEFERRED:   %83 = call ptr @malloc(i64 %.idx71)
ADD:   %83 = call ptr @malloc(i64 %.idx71)
ADD:   %84 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %83, 0
IC: Visiting:   %84 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %83, 0
IC: Visiting:   %83 = call ptr @malloc(i64 %.idx71)
IC: Visiting:   %93 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, 4
IC: Old =   %93 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
ADD:   %93 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ERASE   %94 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, 4
ADD DEFERRED:   %84 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %83, 0
IC: ERASE   %84 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %83, 0
ADD DEFERRED:   %83 = call ptr @malloc(i64 %.idx71)
ADD:   %83 = call ptr @malloc(i64 %.idx71)
IC: Visiting:   %83 = call ptr @malloc(i64 %.idx71)
IC: ConstFold to: [1 x i64] undef from:   %92 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: Replacing   %92 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
    with [1 x i64] undef
IC: ERASE   %92 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ConstFold to: [1 x i64] [i64 1] from:   %.elt79 = insertvalue [1 x i64] undef, i64 1, 0
IC: Replacing   %.elt79 = insertvalue [1 x i64] undef, i64 1, 0
    with [1 x i64] [i64 1]
IC: ERASE   %.elt79 = insertvalue [1 x i64] undef, i64 1, 0
IC: Visiting:   store [1 x i64] [i64 1], ptr %.repack78, align 8
ADD DEFERRED:   store i64 1, ptr %.repack78, align 8
IC: ERASE   store [1 x i64] [i64 1], ptr %.repack78, align 8
ADD DEFERRED:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 4
ADD:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 4
ADD:   store i64 1, ptr %.repack78, align 8
IC: Visiting:   store i64 1, ptr %.repack78, align 8
IC: Visiting:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 4
IC: Visiting:   %91 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %92 = getelementptr double, ptr null, i64 %19
IC: Visiting:   %93 = ptrtoint ptr %92 to i64
ADD DEFERRED:   %.idx80 = mul i64 %19, 8
IC: Replacing   %93 = ptrtoint ptr %92 to i64
    with   %.idx80 = mul i64 %19, 8
IC: Mod =   %93 = ptrtoint ptr %92 to i64
    New =   %93 = ptrtoint ptr %92 to i64
IC: ERASE   %93 = ptrtoint ptr %92 to i64
ADD DEFERRED:   %92 = getelementptr double, ptr null, i64 %19
IC: ERASE   %92 = getelementptr double, ptr null, i64 %19
ADD DEFERRED:   %19 = load i64, ptr %18, align 4
ADD:   %19 = load i64, ptr %18, align 4
ADD:   %.idx80 = mul i64 %19, 8
IC: Visiting:   %.idx80 = mul i64 %19, 8
IC: Old =   %.idx80 = mul i64 %19, 8
    New =   <badref> = shl i64 %19, 3
ADD:   %.idx80 = shl i64 %19, 3
IC: ERASE   %92 = mul i64 %19, 8
ADD DEFERRED:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %.idx80 = shl i64 %19, 3
IC: Visiting:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %92 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %92, 0
IC: Visiting:   %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, ptr %92, 1
IC: Visiting:   %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 0, 2
IC: Visiting:   %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 %19, 3, 0
IC: Sink:   %104 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %96, i64 1, 4, 0
ADD:   %96 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 %19, 3, 0
IC: Visiting:   %104 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %96, i64 1, 4, 0
IC: Sink:   %103 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 %19, 3, 0
ADD:   %95 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 0, 2
ADD:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %103 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %95, i64 %19, 3, 0
IC: Visiting:   %19 = load i64, ptr %18, align 4
IC: Sink:   %102 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 0, 2
ADD:   %94 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, ptr %92, 1
IC: Visiting:   %102 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %94, i64 0, 2
IC: Sink:   %101 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, ptr %92, 1
ADD:   %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %92, 0
ADD:   %92 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   %101 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, ptr %92, 1
IC: Visiting:   %92 = call ptr @malloc(i64 %.idx80)
IC: Sink:   %100 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %92, 0
ADD:   %92 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   %100 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %92, 0
IC: Visiting:   %92 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   br label %93
IC: Visiting:   %94 = phi i64 [ %98, %96 ], [ 0, %90 ]
IC: Visiting:   %95 = icmp slt i64 %94, %19
IC: Visiting:   br i1 %95, label %96, label %99
IC: Visiting:   %105 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
IC: Mod =   %105 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
    New =   %105 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %105 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %105 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, ptr %105, align 8
ADD DEFERRED:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 0
ADD DEFERRED:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 0
ADD DEFERRED:   store ptr %.elt, ptr %.repack, align 8
ADD DEFERRED:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 1
ADD DEFERRED:   %.elt82 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 1
ADD DEFERRED:   store ptr %.elt82, ptr %.repack81, align 8
ADD DEFERRED:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 2
ADD DEFERRED:   %.elt84 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 2
ADD DEFERRED:   store i64 %.elt84, ptr %.repack83, align 8
ADD DEFERRED:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 3
ADD DEFERRED:   %.elt86 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 3
ADD DEFERRED:   store [1 x i64] %.elt86, ptr %.repack85, align 8
ADD DEFERRED:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 4
ADD DEFERRED:   %.elt88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 4
ADD DEFERRED:   store [1 x i64] %.elt88, ptr %.repack87, align 8
IC: ERASE   store { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, ptr %105, align 8
ADD DEFERRED:   %104 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, i64 1, 4, 0
ADD DEFERRED:   %105 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %105 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %104 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, i64 1, 4, 0
ADD:   store [1 x i64] %.elt88, ptr %.repack87, align 8
ADD:   %.elt88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 4
ADD:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 4
ADD:   store [1 x i64] %.elt86, ptr %.repack85, align 8
ADD:   %.elt86 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 3
ADD:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 3
ADD:   store i64 %.elt84, ptr %.repack83, align 8
ADD:   %.elt84 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 2
ADD:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 2
ADD:   store ptr %.elt82, ptr %.repack81, align 8
ADD:   %.elt82 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 1
ADD:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 1
ADD:   store ptr %.elt, ptr %.repack, align 8
ADD:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 0
ADD:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 0
IC: Visiting:   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 0
IC: Replacing   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 0
    with   %105 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Mod =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 0
    New =   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 0
IC: ERASE   %.repack = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 0
ADD DEFERRED:   %105 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 0
IC: Replacing   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 0
    with   %92 = call ptr @malloc(i64 %.idx80)
IC: Mod =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 0
    New =   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 0
IC: ERASE   %.elt = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 0
ADD DEFERRED:   %104 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, i64 1, 4, 0
IC: Visiting:   store ptr %92, ptr %105, align 8
IC: Visiting:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 1
IC: Mod =   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 1
    New =   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i64 0, i32 1
ADD:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i64 0, i32 1
IC: Visiting:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i64 0, i32 1
IC: Visiting:   %.elt82 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 1
IC: Replacing   %.elt82 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 1
    with   %92 = call ptr @malloc(i64 %.idx80)
IC: Mod =   %.elt82 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 1
    New =   %.elt82 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 1
IC: ERASE   %.elt82 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 1
ADD DEFERRED:   %104 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, i64 1, 4, 0
IC: Visiting:   store ptr %92, ptr %.repack81, align 8
IC: Visiting:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 2
IC: Mod =   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 2
    New =   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i64 0, i32 2
ADD:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i64 0, i32 2
IC: Visiting:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i64 0, i32 2
IC: Visiting:   %.elt84 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 2
IC: Replacing   %.elt84 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 2
    with i64 0
IC: Mod =   %.elt84 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 2
    New =   %.elt84 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 2
IC: ERASE   %.elt84 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 2
ADD DEFERRED:   %104 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, i64 1, 4, 0
IC: Visiting:   store i64 0, ptr %.repack83, align 8
IC: Visiting:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 3
IC: Mod =   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 3
    New =   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i64 0, i32 3
ADD:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i64 0, i32 3
IC: Visiting:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i64 0, i32 3
IC: Visiting:   %.elt86 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 3
IC: Old =   %.elt86 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, 3
ADD:   %.elt86 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, 3
IC: ERASE   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 3
ADD DEFERRED:   %104 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, i64 1, 4, 0
IC: Visiting:   %.elt86 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, 3
ADD DEFERRED:   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, 3
IC: Old =   %.elt86 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, 3
    New =   <badref> = insertvalue [1 x i64] %106, i64 %19, 0
ADD:   %.elt86 = insertvalue [1 x i64] %106, i64 %19, 0
IC: ERASE   %107 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, 3
ADD DEFERRED:   %103 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, i64 %19, 3, 0
ADD:   %103 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, i64 %19, 3, 0
ADD:   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, 3
IC: Visiting:   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, 3
IC: Old =   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, 3
ADD:   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, 3
IC: ERASE   %107 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, 3
ADD DEFERRED:   %102 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, i64 0, 2
ADD:   %102 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, i64 0, 2
IC: Visiting:   %102 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, i64 0, 2
IC: Visiting:   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, 3
IC: Old =   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, 3
ADD:   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, 3
IC: ERASE   %107 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, 3
ADD DEFERRED:   %101 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, ptr %92, 1
ADD:   %101 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, ptr %92, 1
IC: Visiting:   %101 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, ptr %92, 1
IC: Visiting:   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, 3
IC: Old =   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, 3
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
ADD:   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: ERASE   %107 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, 3
ADD DEFERRED:   %100 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %92, 0
ADD:   %100 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %92, 0
IC: Visiting:   %100 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %92, 0
IC: ConstFold to: [1 x i64] undef from:   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Replacing   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
    with [1 x i64] undef
IC: ERASE   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 3
IC: Visiting:   %103 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, i64 %19, 3, 0
IC: Visiting:   %.elt86 = insertvalue [1 x i64] undef, i64 %19, 0
IC: Visiting:   store [1 x i64] %.elt86, ptr %.repack85, align 8
ADD DEFERRED:   %106 = extractvalue [1 x i64] %.elt86, 0
ADD DEFERRED:   store i64 %106, ptr %.repack85, align 8
IC: ERASE   store [1 x i64] %.elt86, ptr %.repack85, align 8
ADD DEFERRED:   %.elt86 = insertvalue [1 x i64] undef, i64 %19, 0
ADD DEFERRED:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i64 0, i32 3
ADD:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i64 0, i32 3
ADD:   %.elt86 = insertvalue [1 x i64] undef, i64 %19, 0
ADD:   store i64 %106, ptr %.repack85, align 8
ADD:   %106 = extractvalue [1 x i64] %.elt86, 0
IC: Visiting:   %106 = extractvalue [1 x i64] %.elt86, 0
IC: Replacing   %106 = extractvalue [1 x i64] %.elt86, 0
    with   %19 = load i64, ptr %18, align 4
IC: Mod =   %106 = extractvalue [1 x i64] %.elt86, 0
    New =   %106 = extractvalue [1 x i64] %.elt86, 0
IC: ERASE   %106 = extractvalue [1 x i64] %.elt86, 0
ADD DEFERRED:   %.elt86 = insertvalue [1 x i64] undef, i64 %19, 0
IC: ERASE   %.elt86 = insertvalue [1 x i64] undef, i64 %19, 0
ADD DEFERRED:   %19 = load i64, ptr %18, align 4
ADD:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %19 = load i64, ptr %18, align 4
IC: Visiting:   store i64 %19, ptr %.repack85, align 8
IC: Visiting:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i64 0, i32 3
IC: Visiting:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 4
IC: Mod =   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i32 0, i32 4
    New =   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i64 0, i32 4
ADD:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i64 0, i32 4
IC: Visiting:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %105, i64 0, i32 4
IC: Visiting:   %.elt88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 4
ADD DEFERRED:   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, 4
IC: Old =   %.elt88 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 4
    New =   <badref> = insertvalue [1 x i64] %106, i64 1, 0
ADD:   %.elt88 = insertvalue [1 x i64] %106, i64 1, 0
IC: ERASE   %107 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %104, 4
ADD DEFERRED:   %104 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, i64 1, 4, 0
IC: ERASE   %104 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, i64 1, 4, 0
ADD DEFERRED:   %103 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, i64 %19, 3, 0
ADD:   %103 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, i64 %19, 3, 0
ADD:   %105 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, 4
IC: Visiting:   %105 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, 4
IC: Old =   %105 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, 4
ADD:   %105 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, 4
IC: ERASE   %106 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %103, 4
ADD DEFERRED:   %103 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, i64 %19, 3, 0
IC: ERASE   %103 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, i64 %19, 3, 0
ADD DEFERRED:   %102 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, i64 0, 2
ADD DEFERRED:   %19 = load i64, ptr %18, align 4
ADD:   %19 = load i64, ptr %18, align 4
ADD:   %102 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, i64 0, 2
IC: Visiting:   %102 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, i64 0, 2
IC: Visiting:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %104 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, 4
IC: Old =   %104 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, 4
ADD:   %104 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, 4
IC: ERASE   %105 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %102, 4
ADD DEFERRED:   %102 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, i64 0, 2
IC: ERASE   %102 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, i64 0, 2
ADD DEFERRED:   %101 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, ptr %92, 1
ADD:   %101 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, ptr %92, 1
IC: Visiting:   %101 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, ptr %92, 1
IC: Visiting:   %103 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, 4
IC: Old =   %103 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, 4
ADD:   %103 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, 4
IC: ERASE   %104 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %101, 4
ADD DEFERRED:   %101 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, ptr %92, 1
IC: ERASE   %101 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, ptr %92, 1
ADD DEFERRED:   %100 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %92, 0
ADD DEFERRED:   %92 = call ptr @malloc(i64 %.idx80)
ADD:   %92 = call ptr @malloc(i64 %.idx80)
ADD:   %100 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %92, 0
IC: Visiting:   %100 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %92, 0
IC: Visiting:   %92 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   %102 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, 4
IC: Old =   %102 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, 4
    New =   <badref> = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
ADD:   %102 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ERASE   %103 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %100, 4
ADD DEFERRED:   %100 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %92, 0
IC: ERASE   %100 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %92, 0
ADD DEFERRED:   %92 = call ptr @malloc(i64 %.idx80)
ADD:   %92 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   %92 = call ptr @malloc(i64 %.idx80)
IC: ConstFold to: [1 x i64] undef from:   %101 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: Replacing   %101 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
    with [1 x i64] undef
IC: ERASE   %101 = extractvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, 4
IC: ConstFold to: [1 x i64] [i64 1] from:   %.elt88 = insertvalue [1 x i64] undef, i64 1, 0
IC: Replacing   %.elt88 = insertvalue [1 x i64] undef, i64 1, 0
    with [1 x i64] [i64 1]
IC: ERASE   %.elt88 = insertvalue [1 x i64] undef, i64 1, 0
IC: Visiting:   store [1 x i64] [i64 1], ptr %.repack87, align 8
ADD DEFERRED:   store i64 1, ptr %.repack87, align 8
IC: ERASE   store [1 x i64] [i64 1], ptr %.repack87, align 8
ADD DEFERRED:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 4
ADD:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 4
ADD:   store i64 1, ptr %.repack87, align 8
IC: Visiting:   store i64 1, ptr %.repack87, align 8
IC: Visiting:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 4
IC: Visiting:   %100 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr %28, i64 1, ptr %37, i64 1, ptr %46, i64 1, ptr %55, i64 1, ptr %64, i64 1, ptr %73, i64 1, ptr %82, i64 1, ptr %91, i64 1, ptr %100, i32 1)
IC: Mod =   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr %28, i64 1, ptr %37, i64 1, ptr %46, i64 1, ptr %55, i64 1, ptr %64, i64 1, ptr %73, i64 1, ptr %82, i64 1, ptr %91, i64 1, ptr %100, i32 1)
    New =   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %28, i64 1, ptr nonnull %37, i64 1, ptr nonnull %46, i64 1, ptr nonnull %55, i64 1, ptr nonnull %64, i64 1, ptr nonnull %73, i64 1, ptr nonnull %82, i64 1, ptr nonnull %91, i64 1, ptr nonnull %100, i32 1)
ADD:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %28, i64 1, ptr nonnull %37, i64 1, ptr nonnull %46, i64 1, ptr nonnull %55, i64 1, ptr nonnull %64, i64 1, ptr nonnull %73, i64 1, ptr nonnull %82, i64 1, ptr nonnull %91, i64 1, ptr nonnull %100, i32 1)
IC: Visiting:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %28, i64 1, ptr nonnull %37, i64 1, ptr nonnull %46, i64 1, ptr nonnull %55, i64 1, ptr nonnull %64, i64 1, ptr nonnull %73, i64 1, ptr nonnull %82, i64 1, ptr nonnull %91, i64 1, ptr nonnull %100, i32 1)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr %28)
IC: Mod =   call void @comet_print_memref_i64(i64 1, ptr %28)
    New =   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr %37)
IC: Mod =   call void @comet_print_memref_i64(i64 1, ptr %37)
    New =   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr %46)
IC: Mod =   call void @comet_print_memref_i64(i64 1, ptr %46)
    New =   call void @comet_print_memref_i64(i64 1, ptr nonnull %46)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %46)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %46)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr %55)
IC: Mod =   call void @comet_print_memref_i64(i64 1, ptr %55)
    New =   call void @comet_print_memref_i64(i64 1, ptr nonnull %55)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %55)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %55)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr %64)
IC: Mod =   call void @comet_print_memref_i64(i64 1, ptr %64)
    New =   call void @comet_print_memref_i64(i64 1, ptr nonnull %64)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %64)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %64)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr %73)
IC: Mod =   call void @comet_print_memref_i64(i64 1, ptr %73)
    New =   call void @comet_print_memref_i64(i64 1, ptr nonnull %73)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %73)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %73)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr %82)
IC: Mod =   call void @comet_print_memref_i64(i64 1, ptr %82)
    New =   call void @comet_print_memref_i64(i64 1, ptr nonnull %82)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %82)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %82)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr %91)
IC: Mod =   call void @comet_print_memref_i64(i64 1, ptr %91)
    New =   call void @comet_print_memref_i64(i64 1, ptr nonnull %91)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %91)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %91)
IC: Visiting:   call void @comet_print_memref_f64(i64 1, ptr %100)
IC: Mod =   call void @comet_print_memref_f64(i64 1, ptr %100)
    New =   call void @comet_print_memref_f64(i64 1, ptr nonnull %100)
ADD:   call void @comet_print_memref_f64(i64 1, ptr nonnull %100)
IC: Visiting:   call void @comet_print_memref_f64(i64 1, ptr nonnull %100)
IC: Visiting:   ret void
IC: Visiting:   %97 = getelementptr double, ptr %92, i64 %94
IC: Visiting:   store double 0.000000e+00, ptr %97, align 8
IC: Visiting:   %98 = add i64 %94, 1
IC: Visiting:   br label %93
IC: Visiting:   %88 = getelementptr i64, ptr %83, i64 %85
IC: Visiting:   store i64 0, ptr %88, align 4
IC: Visiting:   %89 = add i64 %85, 1
IC: Visiting:   br label %84
IC: Visiting:   %79 = getelementptr i64, ptr %74, i64 %76
IC: Visiting:   store i64 0, ptr %79, align 4
IC: Visiting:   %80 = add i64 %76, 1
IC: Visiting:   br label %75
IC: Visiting:   %70 = getelementptr i64, ptr %65, i64 %67
IC: Visiting:   store i64 0, ptr %70, align 4
IC: Visiting:   %71 = add i64 %67, 1
IC: Visiting:   br label %66
IC: Visiting:   %61 = getelementptr i64, ptr %56, i64 %58
IC: Visiting:   store i64 0, ptr %61, align 4
IC: Visiting:   %62 = add i64 %58, 1
IC: Visiting:   br label %57
IC: Visiting:   %52 = getelementptr i64, ptr %47, i64 %49
IC: Visiting:   store i64 0, ptr %52, align 4
IC: Visiting:   %53 = add i64 %49, 1
IC: Visiting:   br label %48
IC: Visiting:   %43 = getelementptr i64, ptr %38, i64 %40
IC: Visiting:   store i64 0, ptr %43, align 4
IC: Visiting:   %44 = add i64 %40, 1
IC: Visiting:   br label %39
IC: Visiting:   %34 = getelementptr i64, ptr %29, i64 %31
IC: Visiting:   store i64 0, ptr %34, align 4
IC: Visiting:   %35 = add i64 %31, 1
IC: Visiting:   br label %30
IC: Visiting:   %25 = getelementptr i64, ptr %20, i64 %22
IC: Visiting:   store i64 0, ptr %25, align 4
IC: Visiting:   %26 = add i64 %22, 1
IC: Visiting:   br label %21


INSTCOMBINE ITERATION #2 on main
ADD:   br label %21
ADD:   %26 = add i64 %22, 1
ADD:   store i64 0, ptr %25, align 4
ADD:   %25 = getelementptr i64, ptr %20, i64 %22
ADD:   br label %30
ADD:   %35 = add i64 %31, 1
ADD:   store i64 0, ptr %34, align 4
ADD:   %34 = getelementptr i64, ptr %29, i64 %31
ADD:   br label %39
ADD:   %44 = add i64 %40, 1
ADD:   store i64 0, ptr %43, align 4
ADD:   %43 = getelementptr i64, ptr %38, i64 %40
ADD:   br label %48
ADD:   %53 = add i64 %49, 1
ADD:   store i64 0, ptr %52, align 4
ADD:   %52 = getelementptr i64, ptr %47, i64 %49
ADD:   br label %57
ADD:   %62 = add i64 %58, 1
ADD:   store i64 0, ptr %61, align 4
ADD:   %61 = getelementptr i64, ptr %56, i64 %58
ADD:   br label %66
ADD:   %71 = add i64 %67, 1
ADD:   store i64 0, ptr %70, align 4
ADD:   %70 = getelementptr i64, ptr %65, i64 %67
ADD:   br label %75
ADD:   %80 = add i64 %76, 1
ADD:   store i64 0, ptr %79, align 4
ADD:   %79 = getelementptr i64, ptr %74, i64 %76
ADD:   br label %84
ADD:   %89 = add i64 %85, 1
ADD:   store i64 0, ptr %88, align 4
ADD:   %88 = getelementptr i64, ptr %83, i64 %85
ADD:   br label %93
ADD:   %98 = add i64 %94, 1
ADD:   store double 0.000000e+00, ptr %97, align 8
ADD:   %97 = getelementptr double, ptr %92, i64 %94
ADD:   ret void
ADD:   call void @comet_print_memref_f64(i64 1, ptr nonnull %100)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %91)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %82)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %73)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %64)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %55)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %46)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
ADD:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %28, i64 1, ptr nonnull %37, i64 1, ptr nonnull %46, i64 1, ptr nonnull %55, i64 1, ptr nonnull %64, i64 1, ptr nonnull %73, i64 1, ptr nonnull %82, i64 1, ptr nonnull %91, i64 1, ptr nonnull %100, i32 1)
ADD:   store i64 1, ptr %.repack87, align 8
ADD:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 4
ADD:   store i64 %19, ptr %.repack85, align 8
ADD:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 3
ADD:   store i64 0, ptr %.repack83, align 8
ADD:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 2
ADD:   store ptr %92, ptr %.repack81, align 8
ADD:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 1
ADD:   store ptr %92, ptr %100, align 8
ADD:   %100 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %95, label %96, label %99
ADD:   %95 = icmp slt i64 %94, %19
ADD:   %94 = phi i64 [ %98, %96 ], [ 0, %90 ]
ADD:   br label %93
ADD:   %92 = call ptr @malloc(i64 %.idx80)
ADD:   %.idx80 = shl i64 %19, 3
ADD:   store i64 1, ptr %.repack78, align 8
ADD:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 4
ADD:   store i64 %17, ptr %.repack76, align 8
ADD:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 3
ADD:   store i64 0, ptr %.repack74, align 8
ADD:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 2
ADD:   store ptr %83, ptr %.repack72, align 8
ADD:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 1
ADD:   store ptr %83, ptr %91, align 8
ADD:   %91 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %86, label %87, label %90
ADD:   %86 = icmp slt i64 %85, %17
ADD:   %85 = phi i64 [ %89, %87 ], [ 0, %81 ]
ADD:   br label %84
ADD:   %83 = call ptr @malloc(i64 %.idx71)
ADD:   %.idx71 = shl i64 %17, 3
ADD:   store i64 1, ptr %.repack69, align 8
ADD:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4
ADD:   store i64 %15, ptr %.repack67, align 8
ADD:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 3
ADD:   store i64 0, ptr %.repack65, align 8
ADD:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 2
ADD:   store ptr %74, ptr %.repack63, align 8
ADD:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 1
ADD:   store ptr %74, ptr %82, align 8
ADD:   %82 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %77, label %78, label %81
ADD:   %77 = icmp slt i64 %76, %15
ADD:   %76 = phi i64 [ %80, %78 ], [ 0, %72 ]
ADD:   br label %75
ADD:   %74 = call ptr @malloc(i64 %.idx62)
ADD:   %.idx62 = shl i64 %15, 3
ADD:   store i64 1, ptr %.repack60, align 8
ADD:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 4
ADD:   store i64 %13, ptr %.repack58, align 8
ADD:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 3
ADD:   store i64 0, ptr %.repack56, align 8
ADD:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 2
ADD:   store ptr %65, ptr %.repack54, align 8
ADD:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 1
ADD:   store ptr %65, ptr %73, align 8
ADD:   %73 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %68, label %69, label %72
ADD:   %68 = icmp slt i64 %67, %13
ADD:   %67 = phi i64 [ %71, %69 ], [ 0, %63 ]
ADD:   br label %66
ADD:   %65 = call ptr @malloc(i64 %.idx53)
ADD:   %.idx53 = shl i64 %13, 3
ADD:   store i64 1, ptr %.repack51, align 8
ADD:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 4
ADD:   store i64 %11, ptr %.repack49, align 8
ADD:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 3
ADD:   store i64 0, ptr %.repack47, align 8
ADD:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 2
ADD:   store ptr %56, ptr %.repack45, align 8
ADD:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 1
ADD:   store ptr %56, ptr %64, align 8
ADD:   %64 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %59, label %60, label %63
ADD:   %59 = icmp slt i64 %58, %11
ADD:   %58 = phi i64 [ %62, %60 ], [ 0, %54 ]
ADD:   br label %57
ADD:   %56 = call ptr @malloc(i64 %.idx44)
ADD:   %.idx44 = shl i64 %11, 3
ADD:   store i64 1, ptr %.repack42, align 8
ADD:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 4
ADD:   store i64 %9, ptr %.repack40, align 8
ADD:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 3
ADD:   store i64 0, ptr %.repack38, align 8
ADD:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 2
ADD:   store ptr %47, ptr %.repack36, align 8
ADD:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 1
ADD:   store ptr %47, ptr %55, align 8
ADD:   %55 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %50, label %51, label %54
ADD:   %50 = icmp slt i64 %49, %9
ADD:   %49 = phi i64 [ %53, %51 ], [ 0, %45 ]
ADD:   br label %48
ADD:   %47 = call ptr @malloc(i64 %.idx35)
ADD:   %.idx35 = shl i64 %9, 3
ADD:   store i64 1, ptr %.repack33, align 8
ADD:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
ADD:   store i64 %7, ptr %.repack31, align 8
ADD:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
ADD:   store i64 0, ptr %.repack29, align 8
ADD:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
ADD:   store ptr %38, ptr %.repack27, align 8
ADD:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
ADD:   store ptr %38, ptr %46, align 8
ADD:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %41, label %42, label %45
ADD:   %41 = icmp slt i64 %40, %7
ADD:   %40 = phi i64 [ %44, %42 ], [ 0, %36 ]
ADD:   br label %39
ADD:   %38 = call ptr @malloc(i64 %.idx26)
ADD:   %.idx26 = shl i64 %7, 3
ADD:   store i64 1, ptr %.repack24, align 8
ADD:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
ADD:   store i64 %5, ptr %.repack22, align 8
ADD:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
ADD:   store i64 0, ptr %.repack20, align 8
ADD:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
ADD:   store ptr %29, ptr %.repack18, align 8
ADD:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
ADD:   store ptr %29, ptr %37, align 8
ADD:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %32, label %33, label %36
ADD:   %32 = icmp slt i64 %31, %5
ADD:   %31 = phi i64 [ %35, %33 ], [ 0, %27 ]
ADD:   br label %30
ADD:   %29 = call ptr @malloc(i64 %.idx17)
ADD:   %.idx17 = shl i64 %5, 3
ADD:   store i64 1, ptr %.repack15, align 8
ADD:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
ADD:   store i64 %3, ptr %.repack13, align 8
ADD:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
ADD:   store i64 0, ptr %.repack11, align 8
ADD:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
ADD:   store ptr %20, ptr %.repack9, align 8
ADD:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
ADD:   store ptr %20, ptr %28, align 8
ADD:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %23, label %24, label %27
ADD:   %23 = icmp slt i64 %22, %3
ADD:   %22 = phi i64 [ %26, %24 ], [ 0, %0 ]
ADD:   br label %21
ADD:   %20 = call ptr @malloc(i64 %.idx)
ADD:   %.idx = shl i64 %3, 3
ADD:   %19 = load i64, ptr %18, align 4
ADD:   %18 = getelementptr i64, ptr %1, i64 8
ADD:   %17 = load i64, ptr %16, align 4
ADD:   %16 = getelementptr i64, ptr %1, i64 7
ADD:   %15 = load i64, ptr %14, align 4
ADD:   %14 = getelementptr i64, ptr %1, i64 6
ADD:   %13 = load i64, ptr %12, align 4
ADD:   %12 = getelementptr i64, ptr %1, i64 5
ADD:   %11 = load i64, ptr %10, align 4
ADD:   %10 = getelementptr i64, ptr %1, i64 4
ADD:   %9 = load i64, ptr %8, align 4
ADD:   %8 = getelementptr i64, ptr %1, i64 3
ADD:   %7 = load i64, ptr %6, align 4
ADD:   %6 = getelementptr i64, ptr %1, i64 2
ADD:   %5 = load i64, ptr %4, align 4
ADD:   %4 = getelementptr i64, ptr %1, i64 1
ADD:   %3 = load i64, ptr %1, align 4
ADD:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
ADD:   store i64 1, ptr %.fca.4.0.gep, align 8
ADD:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
ADD:   store i64 7, ptr %.fca.3.0.gep, align 8
ADD:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
ADD:   store i64 0, ptr %.fca.2.gep, align 8
ADD:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
ADD:   store ptr %1, ptr %.fca.1.gep, align 8
ADD:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
ADD:   store ptr %1, ptr %2, align 8
ADD:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %1 = call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %1 = call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %1, ptr %2, align 8
IC: Visiting:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
IC: Visiting:   store ptr %1, ptr %.fca.1.gep, align 8
IC: Visiting:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.fca.2.gep, align 8
IC: Visiting:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
IC: Visiting:   store i64 7, ptr %.fca.3.0.gep, align 8
IC: Visiting:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
IC: Visiting:   store i64 1, ptr %.fca.4.0.gep, align 8
IC: Visiting:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
IC: Visiting:   %3 = load i64, ptr %1, align 4
IC: Visiting:   %4 = getelementptr i64, ptr %1, i64 1
IC: Visiting:   %5 = load i64, ptr %4, align 4
IC: Visiting:   %6 = getelementptr i64, ptr %1, i64 2
IC: Visiting:   %7 = load i64, ptr %6, align 4
IC: Visiting:   %8 = getelementptr i64, ptr %1, i64 3
IC: Visiting:   %9 = load i64, ptr %8, align 4
IC: Visiting:   %10 = getelementptr i64, ptr %1, i64 4
IC: Visiting:   %11 = load i64, ptr %10, align 4
IC: Visiting:   %12 = getelementptr i64, ptr %1, i64 5
IC: Visiting:   %13 = load i64, ptr %12, align 4
IC: Visiting:   %14 = getelementptr i64, ptr %1, i64 6
IC: Visiting:   %15 = load i64, ptr %14, align 4
IC: Visiting:   %16 = getelementptr i64, ptr %1, i64 7
IC: Visiting:   %17 = load i64, ptr %16, align 4
IC: Visiting:   %18 = getelementptr i64, ptr %1, i64 8
IC: Visiting:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %.idx = shl i64 %3, 3
IC: Visiting:   %20 = call ptr @malloc(i64 %.idx)
IC: Visiting:   br label %21
IC: Visiting:   %22 = phi i64 [ %26, %24 ], [ 0, %0 ]
IC: Visiting:   %23 = icmp slt i64 %22, %3
IC: Visiting:   br i1 %23, label %24, label %27
IC: Visiting:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %20, ptr %28, align 8
IC: Visiting:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
IC: Visiting:   store ptr %20, ptr %.repack9, align 8
IC: Visiting:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack11, align 8
IC: Visiting:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
IC: Visiting:   store i64 %3, ptr %.repack13, align 8
IC: Visiting:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack15, align 8
IC: Visiting:   %.idx17 = shl i64 %5, 3
IC: Visiting:   %29 = call ptr @malloc(i64 %.idx17)
IC: Visiting:   br label %30
IC: Visiting:   %31 = phi i64 [ %35, %33 ], [ 0, %27 ]
IC: Visiting:   %32 = icmp slt i64 %31, %5
IC: Visiting:   br i1 %32, label %33, label %36
IC: Visiting:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %29, ptr %37, align 8
IC: Visiting:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
IC: Visiting:   store ptr %29, ptr %.repack18, align 8
IC: Visiting:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack20, align 8
IC: Visiting:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
IC: Visiting:   store i64 %5, ptr %.repack22, align 8
IC: Visiting:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack24, align 8
IC: Visiting:   %.idx26 = shl i64 %7, 3
IC: Visiting:   %38 = call ptr @malloc(i64 %.idx26)
IC: Visiting:   br label %39
IC: Visiting:   %40 = phi i64 [ %44, %42 ], [ 0, %36 ]
IC: Visiting:   %41 = icmp slt i64 %40, %7
IC: Visiting:   br i1 %41, label %42, label %45
IC: Visiting:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %38, ptr %46, align 8
IC: Visiting:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
IC: Visiting:   store ptr %38, ptr %.repack27, align 8
IC: Visiting:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack29, align 8
IC: Visiting:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
IC: Visiting:   store i64 %7, ptr %.repack31, align 8
IC: Visiting:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack33, align 8
IC: Visiting:   %.idx35 = shl i64 %9, 3
IC: Visiting:   %47 = call ptr @malloc(i64 %.idx35)
IC: Visiting:   br label %48
IC: Visiting:   %49 = phi i64 [ %53, %51 ], [ 0, %45 ]
IC: Visiting:   %50 = icmp slt i64 %49, %9
IC: Visiting:   br i1 %50, label %51, label %54
IC: Visiting:   %55 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %47, ptr %55, align 8
IC: Visiting:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 1
IC: Visiting:   store ptr %47, ptr %.repack36, align 8
IC: Visiting:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack38, align 8
IC: Visiting:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 3
IC: Visiting:   store i64 %9, ptr %.repack40, align 8
IC: Visiting:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack42, align 8
IC: Visiting:   %.idx44 = shl i64 %11, 3
IC: Visiting:   %56 = call ptr @malloc(i64 %.idx44)
IC: Visiting:   br label %57
IC: Visiting:   %58 = phi i64 [ %62, %60 ], [ 0, %54 ]
IC: Visiting:   %59 = icmp slt i64 %58, %11
IC: Visiting:   br i1 %59, label %60, label %63
IC: Visiting:   %64 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %56, ptr %64, align 8
IC: Visiting:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 1
IC: Visiting:   store ptr %56, ptr %.repack45, align 8
IC: Visiting:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack47, align 8
IC: Visiting:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 3
IC: Visiting:   store i64 %11, ptr %.repack49, align 8
IC: Visiting:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack51, align 8
IC: Visiting:   %.idx53 = shl i64 %13, 3
IC: Visiting:   %65 = call ptr @malloc(i64 %.idx53)
IC: Visiting:   br label %66
IC: Visiting:   %67 = phi i64 [ %71, %69 ], [ 0, %63 ]
IC: Visiting:   %68 = icmp slt i64 %67, %13
IC: Visiting:   br i1 %68, label %69, label %72
IC: Visiting:   %73 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %65, ptr %73, align 8
IC: Visiting:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 1
IC: Visiting:   store ptr %65, ptr %.repack54, align 8
IC: Visiting:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack56, align 8
IC: Visiting:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 3
IC: Visiting:   store i64 %13, ptr %.repack58, align 8
IC: Visiting:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack60, align 8
IC: Visiting:   %.idx62 = shl i64 %15, 3
IC: Visiting:   %74 = call ptr @malloc(i64 %.idx62)
IC: Visiting:   br label %75
IC: Visiting:   %76 = phi i64 [ %80, %78 ], [ 0, %72 ]
IC: Visiting:   %77 = icmp slt i64 %76, %15
IC: Visiting:   br i1 %77, label %78, label %81
IC: Visiting:   %82 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %74, ptr %82, align 8
IC: Visiting:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 1
IC: Visiting:   store ptr %74, ptr %.repack63, align 8
IC: Visiting:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack65, align 8
IC: Visiting:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 3
IC: Visiting:   store i64 %15, ptr %.repack67, align 8
IC: Visiting:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack69, align 8
IC: Visiting:   %.idx71 = shl i64 %17, 3
IC: Visiting:   %83 = call ptr @malloc(i64 %.idx71)
IC: Visiting:   br label %84
IC: Visiting:   %85 = phi i64 [ %89, %87 ], [ 0, %81 ]
IC: Visiting:   %86 = icmp slt i64 %85, %17
IC: Visiting:   br i1 %86, label %87, label %90
IC: Visiting:   %91 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %83, ptr %91, align 8
IC: Visiting:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 1
IC: Visiting:   store ptr %83, ptr %.repack72, align 8
IC: Visiting:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack74, align 8
IC: Visiting:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 3
IC: Visiting:   store i64 %17, ptr %.repack76, align 8
IC: Visiting:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack78, align 8
IC: Visiting:   %.idx80 = shl i64 %19, 3
IC: Visiting:   %92 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   br label %93
IC: Visiting:   %94 = phi i64 [ %98, %96 ], [ 0, %90 ]
IC: Visiting:   %95 = icmp slt i64 %94, %19
IC: Visiting:   br i1 %95, label %96, label %99
IC: Visiting:   %100 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %92, ptr %100, align 8
IC: Visiting:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 1
IC: Visiting:   store ptr %92, ptr %.repack81, align 8
IC: Visiting:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack83, align 8
IC: Visiting:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 3
IC: Visiting:   store i64 %19, ptr %.repack85, align 8
IC: Visiting:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack87, align 8
IC: Visiting:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %28, i64 1, ptr nonnull %37, i64 1, ptr nonnull %46, i64 1, ptr nonnull %55, i64 1, ptr nonnull %64, i64 1, ptr nonnull %73, i64 1, ptr nonnull %82, i64 1, ptr nonnull %91, i64 1, ptr nonnull %100, i32 1)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %46)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %55)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %64)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %73)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %82)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %91)
IC: Visiting:   call void @comet_print_memref_f64(i64 1, ptr nonnull %100)
IC: Visiting:   ret void
IC: Visiting:   %97 = getelementptr double, ptr %92, i64 %94
IC: Visiting:   store double 0.000000e+00, ptr %97, align 8
IC: Visiting:   %98 = add i64 %94, 1
IC: Visiting:   br label %93
IC: Visiting:   %88 = getelementptr i64, ptr %83, i64 %85
IC: Visiting:   store i64 0, ptr %88, align 4
IC: Visiting:   %89 = add i64 %85, 1
IC: Visiting:   br label %84
IC: Visiting:   %79 = getelementptr i64, ptr %74, i64 %76
IC: Visiting:   store i64 0, ptr %79, align 4
IC: Visiting:   %80 = add i64 %76, 1
IC: Visiting:   br label %75
IC: Visiting:   %70 = getelementptr i64, ptr %65, i64 %67
IC: Visiting:   store i64 0, ptr %70, align 4
IC: Visiting:   %71 = add i64 %67, 1
IC: Visiting:   br label %66
IC: Visiting:   %61 = getelementptr i64, ptr %56, i64 %58
IC: Visiting:   store i64 0, ptr %61, align 4
IC: Visiting:   %62 = add i64 %58, 1
IC: Visiting:   br label %57
IC: Visiting:   %52 = getelementptr i64, ptr %47, i64 %49
IC: Visiting:   store i64 0, ptr %52, align 4
IC: Visiting:   %53 = add i64 %49, 1
IC: Visiting:   br label %48
IC: Visiting:   %43 = getelementptr i64, ptr %38, i64 %40
IC: Visiting:   store i64 0, ptr %43, align 4
IC: Visiting:   %44 = add i64 %40, 1
IC: Visiting:   br label %39
IC: Visiting:   %34 = getelementptr i64, ptr %29, i64 %31
IC: Visiting:   store i64 0, ptr %34, align 4
IC: Visiting:   %35 = add i64 %31, 1
IC: Visiting:   br label %30
IC: Visiting:   %25 = getelementptr i64, ptr %20, i64 %22
IC: Visiting:   store i64 0, ptr %25, align 4
IC: Visiting:   %26 = add i64 %22, 1
IC: Visiting:   br label %21


INSTCOMBINE ITERATION #1 on _mlir_main
ADD:   ret void
ADD:   call void @main()
IC: Visiting:   call void @main()
IC: Visiting:   ret void
Using default inliner heuristic.
Building CG for module: LLVMDialectModule
  Adding 'main' to entry set of the graph.
    Added callable function: main
  Adding '_mlir_main' to entry set of the graph.
    Added callable function: _mlir_main
  Adding functions referenced by global initializers to the entry set.
  Adding functions called by 'main' to the graph.
  Adding functions called by '_mlir_main' to the graph.
    Added callable function: main
Running an SCC pass across the RefSCC: [(main)]
Running function passes across an SCC: (main)
SROA function: main
SROA alloca:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  Rewriting FCA loads and stores...
Can't analyze slices for alloca:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  A pointer to this alloca escaped by:
    call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
EarlyCSE CVP: Add conditional value for '' as i1 true in 
EarlyCSE CVP: Add conditional value for '' as i1 false in 
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function 'main'
LVI Getting block end value   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1 at ''
PUSH:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1 in 
POP   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2 at ''
PUSH:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2 in 
POP   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0 at ''
PUSH:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0 in 
POP   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0 at ''
PUSH:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0 in 
POP   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %1 = call dereferenceable_or_null(56) ptr @malloc(i64 56) at ''
PUSH:   %1 = call dereferenceable_or_null(56) ptr @malloc(i64 56) in 
 compute BB '' - unknown inst def found.
POP   %1 = call dereferenceable_or_null(56) ptr @malloc(i64 56) in  = overdefined
  Result = overdefined
LVI Getting block end value   %4 = getelementptr i64, ptr %1, i64 1 at ''
PUSH:   %4 = getelementptr i64, ptr %1, i64 1 in 
 compute BB '' - unknown inst def found.
POP   %4 = getelementptr i64, ptr %1, i64 1 in  = overdefined
  Result = overdefined
LVI Getting block end value   %6 = getelementptr i64, ptr %1, i64 2 at ''
PUSH:   %6 = getelementptr i64, ptr %1, i64 2 in 
 compute BB '' - unknown inst def found.
POP   %6 = getelementptr i64, ptr %1, i64 2 in  = overdefined
  Result = overdefined
LVI Getting block end value   %8 = getelementptr i64, ptr %1, i64 3 at ''
PUSH:   %8 = getelementptr i64, ptr %1, i64 3 in 
 compute BB '' - unknown inst def found.
POP   %8 = getelementptr i64, ptr %1, i64 3 in  = overdefined
  Result = overdefined
LVI Getting block end value   %10 = getelementptr i64, ptr %1, i64 4 at ''
PUSH:   %10 = getelementptr i64, ptr %1, i64 4 in 
 compute BB '' - unknown inst def found.
POP   %10 = getelementptr i64, ptr %1, i64 4 in  = overdefined
  Result = overdefined
LVI Getting block end value   %12 = getelementptr i64, ptr %1, i64 5 at ''
PUSH:   %12 = getelementptr i64, ptr %1, i64 5 in 
 compute BB '' - unknown inst def found.
POP   %12 = getelementptr i64, ptr %1, i64 5 in  = overdefined
  Result = overdefined
LVI Getting block end value   %14 = getelementptr i64, ptr %1, i64 6 at ''
PUSH:   %14 = getelementptr i64, ptr %1, i64 6 in 
 compute BB '' - unknown inst def found.
POP   %14 = getelementptr i64, ptr %1, i64 6 in  = overdefined
  Result = overdefined
LVI Getting block end value   %16 = getelementptr i64, ptr %1, i64 7 at ''
PUSH:   %16 = getelementptr i64, ptr %1, i64 7 in 
 compute BB '' - unknown inst def found.
POP   %16 = getelementptr i64, ptr %1, i64 7 in  = overdefined
  Result = overdefined
LVI Getting block end value   %18 = getelementptr i64, ptr %1, i64 8 at ''
PUSH:   %18 = getelementptr i64, ptr %1, i64 8 in 
 compute BB '' - unknown inst def found.
POP   %18 = getelementptr i64, ptr %1, i64 8 in  = overdefined
  Result = overdefined
LVI Getting block end value   %3 = load i64, ptr %1, align 4 at ''
PUSH:   %3 = load i64, ptr %1, align 4 in 
 compute BB '' - unknown inst def found.
POP   %3 = load i64, ptr %1, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at ''
  Result = constantrange<3, 4>
LVI Getting edge value   %26 = add i64 %22, 1 from '' to ''
PUSH:   %26 = add i64 %22, 1 in 
PUSH:   %22 = phi i64 [ %26, %24 ], [ 0, %0 ] in 
PUSH:   %22 = phi i64 [ %26, %24 ], [ 0, %0 ] in 
 compute BB '' - overdefined because of pred (local).
POP   %22 = phi i64 [ %26, %24 ], [ 0, %0 ] in  = overdefined
POP   %22 = phi i64 [ %26, %24 ], [ 0, %0 ] in  = constantrange<-9223372036854775808, 9223372036854775807>
POP   %26 = add i64 %22, 1 in  = constantrange<-9223372036854775807, -9223372036854775808>
  Result = constantrange<-9223372036854775807, -9223372036854775808>
LVI Getting block end value   %22 = phi i64 [ %26, %24 ], [ 0, %0 ] at ''
  Result = overdefined
LVI Getting block end value   %22 = phi i64 [ %26, %24 ], [ 0, %0 ] at ''
  Result = overdefined
LVI Getting block end value   %3 = load i64, ptr %1, align 4 at ''
PUSH:   %3 = load i64, ptr %1, align 4 in 
PUSH:   %3 = load i64, ptr %1, align 4 in 
POP   %3 = load i64, ptr %1, align 4 in  = constantrange<-9223372036854775807, -9223372036854775808>
 compute BB '' - overdefined because of pred '' (non local).
POP   %3 = load i64, ptr %1, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value   %25 = getelementptr i64, ptr %20, i64 %22 at ''
PUSH:   %25 = getelementptr i64, ptr %20, i64 %22 in 
 compute BB '' - unknown inst def found.
POP   %25 = getelementptr i64, ptr %20, i64 %22 in  = overdefined
  Result = overdefined
LVI Getting block end value   %22 = phi i64 [ %26, %24 ], [ 0, %0 ] at ''
  Result = constantrange<-9223372036854775808, 9223372036854775807>
LVI Getting block end value i64 1 at ''
  Result = constantrange<1, 2>
LVI Getting block end value   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1 at ''
PUSH:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1 in 
POP   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2 at ''
PUSH:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2 in 
POP   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3 at ''
PUSH:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3 in 
POP   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4 at ''
PUSH:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4 in 
POP   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %5 = load i64, ptr %4, align 4 at ''
PUSH:   %5 = load i64, ptr %4, align 4 in 
PUSH:   %5 = load i64, ptr %4, align 4 in 
PUSH:   %5 = load i64, ptr %4, align 4 in 
 compute BB '' - overdefined because of pred '' (non local).
POP   %5 = load i64, ptr %4, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %5 = load i64, ptr %4, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %5 = load i64, ptr %4, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at ''
  Result = constantrange<3, 4>
LVI Getting edge value   %35 = add i64 %31, 1 from '' to ''
PUSH:   %35 = add i64 %31, 1 in 
PUSH:   %31 = phi i64 [ %35, %33 ], [ 0, %27 ] in 
PUSH:   %31 = phi i64 [ %35, %33 ], [ 0, %27 ] in 
 compute BB '' - overdefined because of pred (local).
POP   %31 = phi i64 [ %35, %33 ], [ 0, %27 ] in  = overdefined
POP   %31 = phi i64 [ %35, %33 ], [ 0, %27 ] in  = constantrange<-9223372036854775808, 9223372036854775807>
POP   %35 = add i64 %31, 1 in  = constantrange<-9223372036854775807, -9223372036854775808>
  Result = constantrange<-9223372036854775807, -9223372036854775808>
LVI Getting block end value   %31 = phi i64 [ %35, %33 ], [ 0, %27 ] at ''
  Result = overdefined
LVI Getting block end value   %31 = phi i64 [ %35, %33 ], [ 0, %27 ] at ''
  Result = overdefined
LVI Getting block end value   %5 = load i64, ptr %4, align 4 at ''
PUSH:   %5 = load i64, ptr %4, align 4 in 
PUSH:   %5 = load i64, ptr %4, align 4 in 
POP   %5 = load i64, ptr %4, align 4 in  = constantrange<-9223372036854775807, -9223372036854775808>
 compute BB '' - overdefined because of pred '' (non local).
POP   %5 = load i64, ptr %4, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value   %34 = getelementptr i64, ptr %29, i64 %31 at ''
PUSH:   %34 = getelementptr i64, ptr %29, i64 %31 in 
 compute BB '' - unknown inst def found.
POP   %34 = getelementptr i64, ptr %29, i64 %31 in  = overdefined
  Result = overdefined
LVI Getting block end value   %31 = phi i64 [ %35, %33 ], [ 0, %27 ] at ''
  Result = constantrange<-9223372036854775808, 9223372036854775807>
LVI Getting block end value i64 1 at ''
  Result = constantrange<1, 2>
LVI Getting block end value   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1 at ''
PUSH:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1 in 
POP   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2 at ''
PUSH:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2 in 
POP   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3 at ''
PUSH:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3 in 
POP   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4 at ''
PUSH:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4 in 
POP   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %7 = load i64, ptr %6, align 4 at ''
PUSH:   %7 = load i64, ptr %6, align 4 in 
PUSH:   %7 = load i64, ptr %6, align 4 in 
PUSH:   %7 = load i64, ptr %6, align 4 in 
 compute BB '' - overdefined because of pred '' (non local).
POP   %7 = load i64, ptr %6, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %7 = load i64, ptr %6, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %7 = load i64, ptr %6, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at ''
  Result = constantrange<3, 4>
LVI Getting edge value   %44 = add i64 %40, 1 from '' to ''
PUSH:   %44 = add i64 %40, 1 in 
PUSH:   %40 = phi i64 [ %44, %42 ], [ 0, %36 ] in 
PUSH:   %40 = phi i64 [ %44, %42 ], [ 0, %36 ] in 
 compute BB '' - overdefined because of pred (local).
POP   %40 = phi i64 [ %44, %42 ], [ 0, %36 ] in  = overdefined
POP   %40 = phi i64 [ %44, %42 ], [ 0, %36 ] in  = constantrange<-9223372036854775808, 9223372036854775807>
POP   %44 = add i64 %40, 1 in  = constantrange<-9223372036854775807, -9223372036854775808>
  Result = constantrange<-9223372036854775807, -9223372036854775808>
LVI Getting block end value   %40 = phi i64 [ %44, %42 ], [ 0, %36 ] at ''
  Result = overdefined
LVI Getting block end value   %40 = phi i64 [ %44, %42 ], [ 0, %36 ] at ''
  Result = overdefined
LVI Getting block end value   %7 = load i64, ptr %6, align 4 at ''
PUSH:   %7 = load i64, ptr %6, align 4 in 
PUSH:   %7 = load i64, ptr %6, align 4 in 
POP   %7 = load i64, ptr %6, align 4 in  = constantrange<-9223372036854775807, -9223372036854775808>
 compute BB '' - overdefined because of pred '' (non local).
POP   %7 = load i64, ptr %6, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value   %43 = getelementptr i64, ptr %38, i64 %40 at ''
PUSH:   %43 = getelementptr i64, ptr %38, i64 %40 in 
 compute BB '' - unknown inst def found.
POP   %43 = getelementptr i64, ptr %38, i64 %40 in  = overdefined
  Result = overdefined
LVI Getting block end value   %40 = phi i64 [ %44, %42 ], [ 0, %36 ] at ''
  Result = constantrange<-9223372036854775808, 9223372036854775807>
LVI Getting block end value i64 1 at ''
  Result = constantrange<1, 2>
LVI Getting block end value   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1 at ''
PUSH:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1 in 
POP   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2 at ''
PUSH:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2 in 
POP   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3 at ''
PUSH:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3 in 
POP   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4 at ''
PUSH:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4 in 
POP   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %9 = load i64, ptr %8, align 4 at ''
PUSH:   %9 = load i64, ptr %8, align 4 in 
PUSH:   %9 = load i64, ptr %8, align 4 in 
PUSH:   %9 = load i64, ptr %8, align 4 in 
 compute BB '' - overdefined because of pred '' (non local).
POP   %9 = load i64, ptr %8, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %9 = load i64, ptr %8, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %9 = load i64, ptr %8, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at ''
  Result = constantrange<3, 4>
LVI Getting edge value   %53 = add i64 %49, 1 from '' to ''
PUSH:   %53 = add i64 %49, 1 in 
PUSH:   %49 = phi i64 [ %53, %51 ], [ 0, %45 ] in 
PUSH:   %49 = phi i64 [ %53, %51 ], [ 0, %45 ] in 
 compute BB '' - overdefined because of pred (local).
POP   %49 = phi i64 [ %53, %51 ], [ 0, %45 ] in  = overdefined
POP   %49 = phi i64 [ %53, %51 ], [ 0, %45 ] in  = constantrange<-9223372036854775808, 9223372036854775807>
POP   %53 = add i64 %49, 1 in  = constantrange<-9223372036854775807, -9223372036854775808>
  Result = constantrange<-9223372036854775807, -9223372036854775808>
LVI Getting block end value   %49 = phi i64 [ %53, %51 ], [ 0, %45 ] at ''
  Result = overdefined
LVI Getting block end value   %49 = phi i64 [ %53, %51 ], [ 0, %45 ] at ''
  Result = overdefined
LVI Getting block end value   %9 = load i64, ptr %8, align 4 at ''
PUSH:   %9 = load i64, ptr %8, align 4 in 
PUSH:   %9 = load i64, ptr %8, align 4 in 
POP   %9 = load i64, ptr %8, align 4 in  = constantrange<-9223372036854775807, -9223372036854775808>
 compute BB '' - overdefined because of pred '' (non local).
POP   %9 = load i64, ptr %8, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value   %52 = getelementptr i64, ptr %47, i64 %49 at ''
PUSH:   %52 = getelementptr i64, ptr %47, i64 %49 in 
 compute BB '' - unknown inst def found.
POP   %52 = getelementptr i64, ptr %47, i64 %49 in  = overdefined
  Result = overdefined
LVI Getting block end value   %49 = phi i64 [ %53, %51 ], [ 0, %45 ] at ''
  Result = constantrange<-9223372036854775808, 9223372036854775807>
LVI Getting block end value i64 1 at ''
  Result = constantrange<1, 2>
LVI Getting block end value   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 1 at ''
PUSH:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 1 in 
POP   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 1 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 2 at ''
PUSH:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 2 in 
POP   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 2 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 3 at ''
PUSH:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 3 in 
POP   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 3 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 4 at ''
PUSH:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 4 in 
POP   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 4 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %11 = load i64, ptr %10, align 4 at ''
PUSH:   %11 = load i64, ptr %10, align 4 in 
PUSH:   %11 = load i64, ptr %10, align 4 in 
PUSH:   %11 = load i64, ptr %10, align 4 in 
 compute BB '' - overdefined because of pred '' (non local).
POP   %11 = load i64, ptr %10, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %11 = load i64, ptr %10, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %11 = load i64, ptr %10, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at ''
  Result = constantrange<3, 4>
LVI Getting edge value   %62 = add i64 %58, 1 from '' to ''
PUSH:   %62 = add i64 %58, 1 in 
PUSH:   %58 = phi i64 [ %62, %60 ], [ 0, %54 ] in 
PUSH:   %58 = phi i64 [ %62, %60 ], [ 0, %54 ] in 
 compute BB '' - overdefined because of pred (local).
POP   %58 = phi i64 [ %62, %60 ], [ 0, %54 ] in  = overdefined
POP   %58 = phi i64 [ %62, %60 ], [ 0, %54 ] in  = constantrange<-9223372036854775808, 9223372036854775807>
POP   %62 = add i64 %58, 1 in  = constantrange<-9223372036854775807, -9223372036854775808>
  Result = constantrange<-9223372036854775807, -9223372036854775808>
LVI Getting block end value   %58 = phi i64 [ %62, %60 ], [ 0, %54 ] at ''
  Result = overdefined
LVI Getting block end value   %58 = phi i64 [ %62, %60 ], [ 0, %54 ] at ''
  Result = overdefined
LVI Getting block end value   %11 = load i64, ptr %10, align 4 at ''
PUSH:   %11 = load i64, ptr %10, align 4 in 
PUSH:   %11 = load i64, ptr %10, align 4 in 
POP   %11 = load i64, ptr %10, align 4 in  = constantrange<-9223372036854775807, -9223372036854775808>
 compute BB '' - overdefined because of pred '' (non local).
POP   %11 = load i64, ptr %10, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value   %61 = getelementptr i64, ptr %56, i64 %58 at ''
PUSH:   %61 = getelementptr i64, ptr %56, i64 %58 in 
 compute BB '' - unknown inst def found.
POP   %61 = getelementptr i64, ptr %56, i64 %58 in  = overdefined
  Result = overdefined
LVI Getting block end value   %58 = phi i64 [ %62, %60 ], [ 0, %54 ] at ''
  Result = constantrange<-9223372036854775808, 9223372036854775807>
LVI Getting block end value i64 1 at ''
  Result = constantrange<1, 2>
LVI Getting block end value   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 1 at ''
PUSH:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 1 in 
POP   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 1 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 2 at ''
PUSH:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 2 in 
POP   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 2 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 3 at ''
PUSH:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 3 in 
POP   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 3 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 4 at ''
PUSH:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 4 in 
POP   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 4 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %13 = load i64, ptr %12, align 4 at ''
PUSH:   %13 = load i64, ptr %12, align 4 in 
PUSH:   %13 = load i64, ptr %12, align 4 in 
PUSH:   %13 = load i64, ptr %12, align 4 in 
 compute BB '' - overdefined because of pred '' (non local).
POP   %13 = load i64, ptr %12, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %13 = load i64, ptr %12, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %13 = load i64, ptr %12, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at ''
  Result = constantrange<3, 4>
LVI Getting edge value   %71 = add i64 %67, 1 from '' to ''
PUSH:   %71 = add i64 %67, 1 in 
PUSH:   %67 = phi i64 [ %71, %69 ], [ 0, %63 ] in 
PUSH:   %67 = phi i64 [ %71, %69 ], [ 0, %63 ] in 
 compute BB '' - overdefined because of pred (local).
POP   %67 = phi i64 [ %71, %69 ], [ 0, %63 ] in  = overdefined
POP   %67 = phi i64 [ %71, %69 ], [ 0, %63 ] in  = constantrange<-9223372036854775808, 9223372036854775807>
POP   %71 = add i64 %67, 1 in  = constantrange<-9223372036854775807, -9223372036854775808>
  Result = constantrange<-9223372036854775807, -9223372036854775808>
LVI Getting block end value   %67 = phi i64 [ %71, %69 ], [ 0, %63 ] at ''
  Result = overdefined
LVI Getting block end value   %67 = phi i64 [ %71, %69 ], [ 0, %63 ] at ''
  Result = overdefined
LVI Getting block end value   %13 = load i64, ptr %12, align 4 at ''
PUSH:   %13 = load i64, ptr %12, align 4 in 
PUSH:   %13 = load i64, ptr %12, align 4 in 
POP   %13 = load i64, ptr %12, align 4 in  = constantrange<-9223372036854775807, -9223372036854775808>
 compute BB '' - overdefined because of pred '' (non local).
POP   %13 = load i64, ptr %12, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value   %70 = getelementptr i64, ptr %65, i64 %67 at ''
PUSH:   %70 = getelementptr i64, ptr %65, i64 %67 in 
 compute BB '' - unknown inst def found.
POP   %70 = getelementptr i64, ptr %65, i64 %67 in  = overdefined
  Result = overdefined
LVI Getting block end value   %67 = phi i64 [ %71, %69 ], [ 0, %63 ] at ''
  Result = constantrange<-9223372036854775808, 9223372036854775807>
LVI Getting block end value i64 1 at ''
  Result = constantrange<1, 2>
LVI Getting block end value   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 1 at ''
PUSH:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 1 in 
POP   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 1 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 2 at ''
PUSH:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 2 in 
POP   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 2 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 3 at ''
PUSH:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 3 in 
POP   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 3 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 4 at ''
PUSH:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 4 in 
POP   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 4 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %15 = load i64, ptr %14, align 4 at ''
PUSH:   %15 = load i64, ptr %14, align 4 in 
PUSH:   %15 = load i64, ptr %14, align 4 in 
PUSH:   %15 = load i64, ptr %14, align 4 in 
 compute BB '' - overdefined because of pred '' (non local).
POP   %15 = load i64, ptr %14, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %15 = load i64, ptr %14, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %15 = load i64, ptr %14, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at ''
  Result = constantrange<3, 4>
LVI Getting edge value   %80 = add i64 %76, 1 from '' to ''
PUSH:   %80 = add i64 %76, 1 in 
PUSH:   %76 = phi i64 [ %80, %78 ], [ 0, %72 ] in 
PUSH:   %76 = phi i64 [ %80, %78 ], [ 0, %72 ] in 
 compute BB '' - overdefined because of pred (local).
POP   %76 = phi i64 [ %80, %78 ], [ 0, %72 ] in  = overdefined
POP   %76 = phi i64 [ %80, %78 ], [ 0, %72 ] in  = constantrange<-9223372036854775808, 9223372036854775807>
POP   %80 = add i64 %76, 1 in  = constantrange<-9223372036854775807, -9223372036854775808>
  Result = constantrange<-9223372036854775807, -9223372036854775808>
LVI Getting block end value   %76 = phi i64 [ %80, %78 ], [ 0, %72 ] at ''
  Result = overdefined
LVI Getting block end value   %76 = phi i64 [ %80, %78 ], [ 0, %72 ] at ''
  Result = overdefined
LVI Getting block end value   %15 = load i64, ptr %14, align 4 at ''
PUSH:   %15 = load i64, ptr %14, align 4 in 
PUSH:   %15 = load i64, ptr %14, align 4 in 
POP   %15 = load i64, ptr %14, align 4 in  = constantrange<-9223372036854775807, -9223372036854775808>
 compute BB '' - overdefined because of pred '' (non local).
POP   %15 = load i64, ptr %14, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value   %79 = getelementptr i64, ptr %74, i64 %76 at ''
PUSH:   %79 = getelementptr i64, ptr %74, i64 %76 in 
 compute BB '' - unknown inst def found.
POP   %79 = getelementptr i64, ptr %74, i64 %76 in  = overdefined
  Result = overdefined
LVI Getting block end value   %76 = phi i64 [ %80, %78 ], [ 0, %72 ] at ''
  Result = constantrange<-9223372036854775808, 9223372036854775807>
LVI Getting block end value i64 1 at ''
  Result = constantrange<1, 2>
LVI Getting block end value   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 1 at ''
PUSH:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 1 in 
POP   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 1 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 2 at ''
PUSH:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 2 in 
POP   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 2 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 3 at ''
PUSH:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 3 in 
POP   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 3 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4 at ''
PUSH:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4 in 
POP   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %17 = load i64, ptr %16, align 4 at ''
PUSH:   %17 = load i64, ptr %16, align 4 in 
PUSH:   %17 = load i64, ptr %16, align 4 in 
PUSH:   %17 = load i64, ptr %16, align 4 in 
 compute BB '' - overdefined because of pred '' (non local).
POP   %17 = load i64, ptr %16, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %17 = load i64, ptr %16, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %17 = load i64, ptr %16, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at ''
  Result = constantrange<3, 4>
LVI Getting edge value   %89 = add i64 %85, 1 from '' to ''
PUSH:   %89 = add i64 %85, 1 in 
PUSH:   %85 = phi i64 [ %89, %87 ], [ 0, %81 ] in 
PUSH:   %85 = phi i64 [ %89, %87 ], [ 0, %81 ] in 
 compute BB '' - overdefined because of pred (local).
POP   %85 = phi i64 [ %89, %87 ], [ 0, %81 ] in  = overdefined
POP   %85 = phi i64 [ %89, %87 ], [ 0, %81 ] in  = constantrange<-9223372036854775808, 9223372036854775807>
POP   %89 = add i64 %85, 1 in  = constantrange<-9223372036854775807, -9223372036854775808>
  Result = constantrange<-9223372036854775807, -9223372036854775808>
LVI Getting block end value   %85 = phi i64 [ %89, %87 ], [ 0, %81 ] at ''
  Result = overdefined
LVI Getting block end value   %85 = phi i64 [ %89, %87 ], [ 0, %81 ] at ''
  Result = overdefined
LVI Getting block end value   %17 = load i64, ptr %16, align 4 at ''
PUSH:   %17 = load i64, ptr %16, align 4 in 
PUSH:   %17 = load i64, ptr %16, align 4 in 
POP   %17 = load i64, ptr %16, align 4 in  = constantrange<-9223372036854775807, -9223372036854775808>
 compute BB '' - overdefined because of pred '' (non local).
POP   %17 = load i64, ptr %16, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value   %88 = getelementptr i64, ptr %83, i64 %85 at ''
PUSH:   %88 = getelementptr i64, ptr %83, i64 %85 in 
 compute BB '' - unknown inst def found.
POP   %88 = getelementptr i64, ptr %83, i64 %85 in  = overdefined
  Result = overdefined
LVI Getting block end value   %85 = phi i64 [ %89, %87 ], [ 0, %81 ] at ''
  Result = constantrange<-9223372036854775808, 9223372036854775807>
LVI Getting block end value i64 1 at ''
  Result = constantrange<1, 2>
LVI Getting block end value   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 1 at ''
PUSH:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 1 in 
POP   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 1 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 2 at ''
PUSH:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 2 in 
POP   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 2 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 3 at ''
PUSH:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 3 in 
POP   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 3 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 4 at ''
PUSH:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 4 in 
POP   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 4 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %19 = load i64, ptr %18, align 4 at ''
PUSH:   %19 = load i64, ptr %18, align 4 in 
PUSH:   %19 = load i64, ptr %18, align 4 in 
PUSH:   %19 = load i64, ptr %18, align 4 in 
 compute BB '' - overdefined because of pred '' (non local).
POP   %19 = load i64, ptr %18, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %19 = load i64, ptr %18, align 4 in  = overdefined
 compute BB '' - overdefined because of pred '' (non local).
POP   %19 = load i64, ptr %18, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at ''
  Result = constantrange<3, 4>
LVI Getting edge value   %98 = add i64 %94, 1 from '' to ''
PUSH:   %98 = add i64 %94, 1 in 
PUSH:   %94 = phi i64 [ %98, %96 ], [ 0, %90 ] in 
PUSH:   %94 = phi i64 [ %98, %96 ], [ 0, %90 ] in 
 compute BB '' - overdefined because of pred (local).
POP   %94 = phi i64 [ %98, %96 ], [ 0, %90 ] in  = overdefined
POP   %94 = phi i64 [ %98, %96 ], [ 0, %90 ] in  = constantrange<-9223372036854775808, 9223372036854775807>
POP   %98 = add i64 %94, 1 in  = constantrange<-9223372036854775807, -9223372036854775808>
  Result = constantrange<-9223372036854775807, -9223372036854775808>
LVI Getting block end value   %94 = phi i64 [ %98, %96 ], [ 0, %90 ] at ''
  Result = overdefined
LVI Getting block end value   %94 = phi i64 [ %98, %96 ], [ 0, %90 ] at ''
  Result = overdefined
LVI Getting block end value   %19 = load i64, ptr %18, align 4 at ''
PUSH:   %19 = load i64, ptr %18, align 4 in 
PUSH:   %19 = load i64, ptr %18, align 4 in 
POP   %19 = load i64, ptr %18, align 4 in  = constantrange<-9223372036854775807, -9223372036854775808>
 compute BB '' - overdefined because of pred '' (non local).
POP   %19 = load i64, ptr %18, align 4 in  = overdefined
  Result = overdefined
LVI Getting block end value   %97 = getelementptr double, ptr %92, i64 %94 at ''
PUSH:   %97 = getelementptr double, ptr %92, i64 %94 in 
 compute BB '' - unknown inst def found.
POP   %97 = getelementptr double, ptr %92, i64 %94 in  = overdefined
  Result = overdefined
LVI Getting block end value   %94 = phi i64 [ %98, %96 ], [ 0, %90 ] at ''
  Result = constantrange<-9223372036854775808, 9223372036854775807>
LVI Getting block end value i64 1 at ''
  Result = constantrange<1, 2>
LVI Getting block end value   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 1 at ''
PUSH:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 1 in 
POP   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 1 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 2 at ''
PUSH:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 2 in 
POP   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 2 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 3 at ''
PUSH:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 3 in 
POP   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 3 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 4 at ''
PUSH:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 4 in 
POP   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 4 in  = notconstant<ptr null>
  Result = notconstant<ptr null>


INSTCOMBINE ITERATION #1 on main
ADD:   br label %21
ADD:   %26 = add nsw i64 %22, 1
ADD:   store i64 0, ptr %25, align 4
ADD:   %25 = getelementptr i64, ptr %20, i64 %22
ADD:   br label %30
ADD:   %35 = add nsw i64 %31, 1
ADD:   store i64 0, ptr %34, align 4
ADD:   %34 = getelementptr i64, ptr %29, i64 %31
ADD:   br label %39
ADD:   %44 = add nsw i64 %40, 1
ADD:   store i64 0, ptr %43, align 4
ADD:   %43 = getelementptr i64, ptr %38, i64 %40
ADD:   br label %48
ADD:   %53 = add nsw i64 %49, 1
ADD:   store i64 0, ptr %52, align 4
ADD:   %52 = getelementptr i64, ptr %47, i64 %49
ADD:   br label %57
ADD:   %62 = add nsw i64 %58, 1
ADD:   store i64 0, ptr %61, align 4
ADD:   %61 = getelementptr i64, ptr %56, i64 %58
ADD:   br label %66
ADD:   %71 = add nsw i64 %67, 1
ADD:   store i64 0, ptr %70, align 4
ADD:   %70 = getelementptr i64, ptr %65, i64 %67
ADD:   br label %75
ADD:   %80 = add nsw i64 %76, 1
ADD:   store i64 0, ptr %79, align 4
ADD:   %79 = getelementptr i64, ptr %74, i64 %76
ADD:   br label %84
ADD:   %89 = add nsw i64 %85, 1
ADD:   store i64 0, ptr %88, align 4
ADD:   %88 = getelementptr i64, ptr %83, i64 %85
ADD:   br label %93
ADD:   %98 = add nsw i64 %94, 1
ADD:   store double 0.000000e+00, ptr %97, align 8
ADD:   %97 = getelementptr double, ptr %92, i64 %94
ADD:   ret void
ADD:   call void @comet_print_memref_f64(i64 1, ptr nonnull %100)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %91)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %82)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %73)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %64)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %55)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %46)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
ADD:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %28, i64 1, ptr nonnull %37, i64 1, ptr nonnull %46, i64 1, ptr nonnull %55, i64 1, ptr nonnull %64, i64 1, ptr nonnull %73, i64 1, ptr nonnull %82, i64 1, ptr nonnull %91, i64 1, ptr nonnull %100, i32 1)
ADD:   store i64 1, ptr %.repack87, align 8
ADD:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 4
ADD:   store i64 %19, ptr %.repack85, align 8
ADD:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 3
ADD:   store i64 0, ptr %.repack83, align 8
ADD:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 2
ADD:   store ptr %92, ptr %.repack81, align 8
ADD:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 1
ADD:   store ptr %92, ptr %100, align 8
ADD:   %100 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %95, label %96, label %99
ADD:   %95 = icmp slt i64 %94, %19
ADD:   %94 = phi i64 [ %98, %96 ], [ 0, %90 ]
ADD:   br label %93
ADD:   %92 = call ptr @malloc(i64 %.idx80)
ADD:   %.idx80 = shl i64 %19, 3
ADD:   store i64 1, ptr %.repack78, align 8
ADD:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 4
ADD:   store i64 %17, ptr %.repack76, align 8
ADD:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 3
ADD:   store i64 0, ptr %.repack74, align 8
ADD:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 2
ADD:   store ptr %83, ptr %.repack72, align 8
ADD:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 1
ADD:   store ptr %83, ptr %91, align 8
ADD:   %91 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %86, label %87, label %90
ADD:   %86 = icmp slt i64 %85, %17
ADD:   %85 = phi i64 [ %89, %87 ], [ 0, %81 ]
ADD:   br label %84
ADD:   %83 = call ptr @malloc(i64 %.idx71)
ADD:   %.idx71 = shl i64 %17, 3
ADD:   store i64 1, ptr %.repack69, align 8
ADD:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4
ADD:   store i64 %15, ptr %.repack67, align 8
ADD:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 3
ADD:   store i64 0, ptr %.repack65, align 8
ADD:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 2
ADD:   store ptr %74, ptr %.repack63, align 8
ADD:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 1
ADD:   store ptr %74, ptr %82, align 8
ADD:   %82 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %77, label %78, label %81
ADD:   %77 = icmp slt i64 %76, %15
ADD:   %76 = phi i64 [ %80, %78 ], [ 0, %72 ]
ADD:   br label %75
ADD:   %74 = call ptr @malloc(i64 %.idx62)
ADD:   %.idx62 = shl i64 %15, 3
ADD:   store i64 1, ptr %.repack60, align 8
ADD:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 4
ADD:   store i64 %13, ptr %.repack58, align 8
ADD:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 3
ADD:   store i64 0, ptr %.repack56, align 8
ADD:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 2
ADD:   store ptr %65, ptr %.repack54, align 8
ADD:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 1
ADD:   store ptr %65, ptr %73, align 8
ADD:   %73 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %68, label %69, label %72
ADD:   %68 = icmp slt i64 %67, %13
ADD:   %67 = phi i64 [ %71, %69 ], [ 0, %63 ]
ADD:   br label %66
ADD:   %65 = call ptr @malloc(i64 %.idx53)
ADD:   %.idx53 = shl i64 %13, 3
ADD:   store i64 1, ptr %.repack51, align 8
ADD:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 4
ADD:   store i64 %11, ptr %.repack49, align 8
ADD:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 3
ADD:   store i64 0, ptr %.repack47, align 8
ADD:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 2
ADD:   store ptr %56, ptr %.repack45, align 8
ADD:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 1
ADD:   store ptr %56, ptr %64, align 8
ADD:   %64 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %59, label %60, label %63
ADD:   %59 = icmp slt i64 %58, %11
ADD:   %58 = phi i64 [ %62, %60 ], [ 0, %54 ]
ADD:   br label %57
ADD:   %56 = call ptr @malloc(i64 %.idx44)
ADD:   %.idx44 = shl i64 %11, 3
ADD:   store i64 1, ptr %.repack42, align 8
ADD:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 4
ADD:   store i64 %9, ptr %.repack40, align 8
ADD:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 3
ADD:   store i64 0, ptr %.repack38, align 8
ADD:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 2
ADD:   store ptr %47, ptr %.repack36, align 8
ADD:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 1
ADD:   store ptr %47, ptr %55, align 8
ADD:   %55 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %50, label %51, label %54
ADD:   %50 = icmp slt i64 %49, %9
ADD:   %49 = phi i64 [ %53, %51 ], [ 0, %45 ]
ADD:   br label %48
ADD:   %47 = call ptr @malloc(i64 %.idx35)
ADD:   %.idx35 = shl i64 %9, 3
ADD:   store i64 1, ptr %.repack33, align 8
ADD:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
ADD:   store i64 %7, ptr %.repack31, align 8
ADD:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
ADD:   store i64 0, ptr %.repack29, align 8
ADD:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
ADD:   store ptr %38, ptr %.repack27, align 8
ADD:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
ADD:   store ptr %38, ptr %46, align 8
ADD:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %41, label %42, label %45
ADD:   %41 = icmp slt i64 %40, %7
ADD:   %40 = phi i64 [ %44, %42 ], [ 0, %36 ]
ADD:   br label %39
ADD:   %38 = call ptr @malloc(i64 %.idx26)
ADD:   %.idx26 = shl i64 %7, 3
ADD:   store i64 1, ptr %.repack24, align 8
ADD:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
ADD:   store i64 %5, ptr %.repack22, align 8
ADD:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
ADD:   store i64 0, ptr %.repack20, align 8
ADD:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
ADD:   store ptr %29, ptr %.repack18, align 8
ADD:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
ADD:   store ptr %29, ptr %37, align 8
ADD:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %32, label %33, label %36
ADD:   %32 = icmp slt i64 %31, %5
ADD:   %31 = phi i64 [ %35, %33 ], [ 0, %27 ]
ADD:   br label %30
ADD:   %29 = call ptr @malloc(i64 %.idx17)
ADD:   %.idx17 = shl i64 %5, 3
ADD:   store i64 1, ptr %.repack15, align 8
ADD:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
ADD:   store i64 %3, ptr %.repack13, align 8
ADD:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
ADD:   store i64 0, ptr %.repack11, align 8
ADD:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
ADD:   store ptr %20, ptr %.repack9, align 8
ADD:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
ADD:   store ptr %20, ptr %28, align 8
ADD:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %23, label %24, label %27
ADD:   %23 = icmp slt i64 %22, %3
ADD:   %22 = phi i64 [ %26, %24 ], [ 0, %0 ]
ADD:   br label %21
ADD:   %20 = call ptr @malloc(i64 %.idx)
ADD:   %.idx = shl i64 %3, 3
ADD:   %19 = load i64, ptr %18, align 4
ADD:   %18 = getelementptr i64, ptr %1, i64 8
ADD:   %17 = load i64, ptr %16, align 4
ADD:   %16 = getelementptr i64, ptr %1, i64 7
ADD:   %15 = load i64, ptr %14, align 4
ADD:   %14 = getelementptr i64, ptr %1, i64 6
ADD:   %13 = load i64, ptr %12, align 4
ADD:   %12 = getelementptr i64, ptr %1, i64 5
ADD:   %11 = load i64, ptr %10, align 4
ADD:   %10 = getelementptr i64, ptr %1, i64 4
ADD:   %9 = load i64, ptr %8, align 4
ADD:   %8 = getelementptr i64, ptr %1, i64 3
ADD:   %7 = load i64, ptr %6, align 4
ADD:   %6 = getelementptr i64, ptr %1, i64 2
ADD:   %5 = load i64, ptr %4, align 4
ADD:   %4 = getelementptr i64, ptr %1, i64 1
ADD:   %3 = load i64, ptr %1, align 4
ADD:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
ADD:   store i64 1, ptr %.fca.4.0.gep, align 8
ADD:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
ADD:   store i64 7, ptr %.fca.3.0.gep, align 8
ADD:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
ADD:   store i64 0, ptr %.fca.2.gep, align 8
ADD:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
ADD:   store ptr %1, ptr %.fca.1.gep, align 8
ADD:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
ADD:   store ptr %1, ptr %2, align 8
ADD:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %1 = call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %1 = call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %1, ptr %2, align 8
IC: Visiting:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
IC: Visiting:   store ptr %1, ptr %.fca.1.gep, align 8
IC: Visiting:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.fca.2.gep, align 8
IC: Visiting:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
IC: Visiting:   store i64 7, ptr %.fca.3.0.gep, align 8
IC: Visiting:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
IC: Visiting:   store i64 1, ptr %.fca.4.0.gep, align 8
IC: Visiting:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
IC: Visiting:   %3 = load i64, ptr %1, align 4
IC: Visiting:   %4 = getelementptr i64, ptr %1, i64 1
IC: Visiting:   %5 = load i64, ptr %4, align 4
IC: Visiting:   %6 = getelementptr i64, ptr %1, i64 2
IC: Visiting:   %7 = load i64, ptr %6, align 4
IC: Visiting:   %8 = getelementptr i64, ptr %1, i64 3
IC: Visiting:   %9 = load i64, ptr %8, align 4
IC: Visiting:   %10 = getelementptr i64, ptr %1, i64 4
IC: Visiting:   %11 = load i64, ptr %10, align 4
IC: Visiting:   %12 = getelementptr i64, ptr %1, i64 5
IC: Visiting:   %13 = load i64, ptr %12, align 4
IC: Visiting:   %14 = getelementptr i64, ptr %1, i64 6
IC: Visiting:   %15 = load i64, ptr %14, align 4
IC: Visiting:   %16 = getelementptr i64, ptr %1, i64 7
IC: Visiting:   %17 = load i64, ptr %16, align 4
IC: Visiting:   %18 = getelementptr i64, ptr %1, i64 8
IC: Visiting:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %.idx = shl i64 %3, 3
IC: Visiting:   %20 = call ptr @malloc(i64 %.idx)
IC: Visiting:   br label %21
IC: Visiting:   %22 = phi i64 [ %26, %24 ], [ 0, %0 ]
IC: Visiting:   %23 = icmp slt i64 %22, %3
IC: Visiting:   br i1 %23, label %24, label %27
IC: Visiting:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %20, ptr %28, align 8
IC: Visiting:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
IC: Visiting:   store ptr %20, ptr %.repack9, align 8
IC: Visiting:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack11, align 8
IC: Visiting:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
IC: Visiting:   store i64 %3, ptr %.repack13, align 8
IC: Visiting:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack15, align 8
IC: Visiting:   %.idx17 = shl i64 %5, 3
IC: Visiting:   %29 = call ptr @malloc(i64 %.idx17)
IC: Visiting:   br label %30
IC: Visiting:   %31 = phi i64 [ %35, %33 ], [ 0, %27 ]
IC: Visiting:   %32 = icmp slt i64 %31, %5
IC: Visiting:   br i1 %32, label %33, label %36
IC: Visiting:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %29, ptr %37, align 8
IC: Visiting:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
IC: Visiting:   store ptr %29, ptr %.repack18, align 8
IC: Visiting:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack20, align 8
IC: Visiting:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
IC: Visiting:   store i64 %5, ptr %.repack22, align 8
IC: Visiting:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack24, align 8
IC: Visiting:   %.idx26 = shl i64 %7, 3
IC: Visiting:   %38 = call ptr @malloc(i64 %.idx26)
IC: Visiting:   br label %39
IC: Visiting:   %40 = phi i64 [ %44, %42 ], [ 0, %36 ]
IC: Visiting:   %41 = icmp slt i64 %40, %7
IC: Visiting:   br i1 %41, label %42, label %45
IC: Visiting:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %38, ptr %46, align 8
IC: Visiting:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
IC: Visiting:   store ptr %38, ptr %.repack27, align 8
IC: Visiting:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack29, align 8
IC: Visiting:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
IC: Visiting:   store i64 %7, ptr %.repack31, align 8
IC: Visiting:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack33, align 8
IC: Visiting:   %.idx35 = shl i64 %9, 3
IC: Visiting:   %47 = call ptr @malloc(i64 %.idx35)
IC: Visiting:   br label %48
IC: Visiting:   %49 = phi i64 [ %53, %51 ], [ 0, %45 ]
IC: Visiting:   %50 = icmp slt i64 %49, %9
IC: Visiting:   br i1 %50, label %51, label %54
IC: Visiting:   %55 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %47, ptr %55, align 8
IC: Visiting:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 1
IC: Visiting:   store ptr %47, ptr %.repack36, align 8
IC: Visiting:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack38, align 8
IC: Visiting:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 3
IC: Visiting:   store i64 %9, ptr %.repack40, align 8
IC: Visiting:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack42, align 8
IC: Visiting:   %.idx44 = shl i64 %11, 3
IC: Visiting:   %56 = call ptr @malloc(i64 %.idx44)
IC: Visiting:   br label %57
IC: Visiting:   %58 = phi i64 [ %62, %60 ], [ 0, %54 ]
IC: Visiting:   %59 = icmp slt i64 %58, %11
IC: Visiting:   br i1 %59, label %60, label %63
IC: Visiting:   %64 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %56, ptr %64, align 8
IC: Visiting:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 1
IC: Visiting:   store ptr %56, ptr %.repack45, align 8
IC: Visiting:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack47, align 8
IC: Visiting:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 3
IC: Visiting:   store i64 %11, ptr %.repack49, align 8
IC: Visiting:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack51, align 8
IC: Visiting:   %.idx53 = shl i64 %13, 3
IC: Visiting:   %65 = call ptr @malloc(i64 %.idx53)
IC: Visiting:   br label %66
IC: Visiting:   %67 = phi i64 [ %71, %69 ], [ 0, %63 ]
IC: Visiting:   %68 = icmp slt i64 %67, %13
IC: Visiting:   br i1 %68, label %69, label %72
IC: Visiting:   %73 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %65, ptr %73, align 8
IC: Visiting:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 1
IC: Visiting:   store ptr %65, ptr %.repack54, align 8
IC: Visiting:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack56, align 8
IC: Visiting:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 3
IC: Visiting:   store i64 %13, ptr %.repack58, align 8
IC: Visiting:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack60, align 8
IC: Visiting:   %.idx62 = shl i64 %15, 3
IC: Visiting:   %74 = call ptr @malloc(i64 %.idx62)
IC: Visiting:   br label %75
IC: Visiting:   %76 = phi i64 [ %80, %78 ], [ 0, %72 ]
IC: Visiting:   %77 = icmp slt i64 %76, %15
IC: Visiting:   br i1 %77, label %78, label %81
IC: Visiting:   %82 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %74, ptr %82, align 8
IC: Visiting:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 1
IC: Visiting:   store ptr %74, ptr %.repack63, align 8
IC: Visiting:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack65, align 8
IC: Visiting:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 3
IC: Visiting:   store i64 %15, ptr %.repack67, align 8
IC: Visiting:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack69, align 8
IC: Visiting:   %.idx71 = shl i64 %17, 3
IC: Visiting:   %83 = call ptr @malloc(i64 %.idx71)
IC: Visiting:   br label %84
IC: Visiting:   %85 = phi i64 [ %89, %87 ], [ 0, %81 ]
IC: Visiting:   %86 = icmp slt i64 %85, %17
IC: Visiting:   br i1 %86, label %87, label %90
IC: Visiting:   %91 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %83, ptr %91, align 8
IC: Visiting:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 1
IC: Visiting:   store ptr %83, ptr %.repack72, align 8
IC: Visiting:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack74, align 8
IC: Visiting:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 3
IC: Visiting:   store i64 %17, ptr %.repack76, align 8
IC: Visiting:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack78, align 8
IC: Visiting:   %.idx80 = shl i64 %19, 3
IC: Visiting:   %92 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   br label %93
IC: Visiting:   %94 = phi i64 [ %98, %96 ], [ 0, %90 ]
IC: Visiting:   %95 = icmp slt i64 %94, %19
IC: Visiting:   br i1 %95, label %96, label %99
IC: Visiting:   %100 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %92, ptr %100, align 8
IC: Visiting:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 1
IC: Visiting:   store ptr %92, ptr %.repack81, align 8
IC: Visiting:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack83, align 8
IC: Visiting:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 3
IC: Visiting:   store i64 %19, ptr %.repack85, align 8
IC: Visiting:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack87, align 8
IC: Visiting:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %28, i64 1, ptr nonnull %37, i64 1, ptr nonnull %46, i64 1, ptr nonnull %55, i64 1, ptr nonnull %64, i64 1, ptr nonnull %73, i64 1, ptr nonnull %82, i64 1, ptr nonnull %91, i64 1, ptr nonnull %100, i32 1)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %46)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %55)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %64)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %73)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %82)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %91)
IC: Visiting:   call void @comet_print_memref_f64(i64 1, ptr nonnull %100)
IC: Visiting:   ret void
IC: Visiting:   %97 = getelementptr double, ptr %92, i64 %94
IC: Visiting:   store double 0.000000e+00, ptr %97, align 8
IC: Visiting:   %98 = add nsw i64 %94, 1
IC: Mod =   %98 = add nsw i64 %94, 1
    New =   %98 = add nuw nsw i64 %94, 1
ADD:   %94 = phi i64 [ %98, %96 ], [ 0, %90 ]
ADD:   %98 = add nuw nsw i64 %94, 1
IC: Visiting:   %98 = add nuw nsw i64 %94, 1
IC: Visiting:   %94 = phi i64 [ %98, %96 ], [ 0, %90 ]
IC: Visiting:   br label %93
IC: Visiting:   %88 = getelementptr i64, ptr %83, i64 %85
IC: Visiting:   store i64 0, ptr %88, align 4
IC: Visiting:   %89 = add nsw i64 %85, 1
IC: Mod =   %89 = add nsw i64 %85, 1
    New =   %89 = add nuw nsw i64 %85, 1
ADD:   %85 = phi i64 [ %89, %87 ], [ 0, %81 ]
ADD:   %89 = add nuw nsw i64 %85, 1
IC: Visiting:   %89 = add nuw nsw i64 %85, 1
IC: Visiting:   %85 = phi i64 [ %89, %87 ], [ 0, %81 ]
IC: Visiting:   br label %84
IC: Visiting:   %79 = getelementptr i64, ptr %74, i64 %76
IC: Visiting:   store i64 0, ptr %79, align 4
IC: Visiting:   %80 = add nsw i64 %76, 1
IC: Mod =   %80 = add nsw i64 %76, 1
    New =   %80 = add nuw nsw i64 %76, 1
ADD:   %76 = phi i64 [ %80, %78 ], [ 0, %72 ]
ADD:   %80 = add nuw nsw i64 %76, 1
IC: Visiting:   %80 = add nuw nsw i64 %76, 1
IC: Visiting:   %76 = phi i64 [ %80, %78 ], [ 0, %72 ]
IC: Visiting:   br label %75
IC: Visiting:   %70 = getelementptr i64, ptr %65, i64 %67
IC: Visiting:   store i64 0, ptr %70, align 4
IC: Visiting:   %71 = add nsw i64 %67, 1
IC: Mod =   %71 = add nsw i64 %67, 1
    New =   %71 = add nuw nsw i64 %67, 1
ADD:   %67 = phi i64 [ %71, %69 ], [ 0, %63 ]
ADD:   %71 = add nuw nsw i64 %67, 1
IC: Visiting:   %71 = add nuw nsw i64 %67, 1
IC: Visiting:   %67 = phi i64 [ %71, %69 ], [ 0, %63 ]
IC: Visiting:   br label %66
IC: Visiting:   %61 = getelementptr i64, ptr %56, i64 %58
IC: Visiting:   store i64 0, ptr %61, align 4
IC: Visiting:   %62 = add nsw i64 %58, 1
IC: Mod =   %62 = add nsw i64 %58, 1
    New =   %62 = add nuw nsw i64 %58, 1
ADD:   %58 = phi i64 [ %62, %60 ], [ 0, %54 ]
ADD:   %62 = add nuw nsw i64 %58, 1
IC: Visiting:   %62 = add nuw nsw i64 %58, 1
IC: Visiting:   %58 = phi i64 [ %62, %60 ], [ 0, %54 ]
IC: Visiting:   br label %57
IC: Visiting:   %52 = getelementptr i64, ptr %47, i64 %49
IC: Visiting:   store i64 0, ptr %52, align 4
IC: Visiting:   %53 = add nsw i64 %49, 1
IC: Mod =   %53 = add nsw i64 %49, 1
    New =   %53 = add nuw nsw i64 %49, 1
ADD:   %49 = phi i64 [ %53, %51 ], [ 0, %45 ]
ADD:   %53 = add nuw nsw i64 %49, 1
IC: Visiting:   %53 = add nuw nsw i64 %49, 1
IC: Visiting:   %49 = phi i64 [ %53, %51 ], [ 0, %45 ]
IC: Visiting:   br label %48
IC: Visiting:   %43 = getelementptr i64, ptr %38, i64 %40
IC: Visiting:   store i64 0, ptr %43, align 4
IC: Visiting:   %44 = add nsw i64 %40, 1
IC: Mod =   %44 = add nsw i64 %40, 1
    New =   %44 = add nuw nsw i64 %40, 1
ADD:   %40 = phi i64 [ %44, %42 ], [ 0, %36 ]
ADD:   %44 = add nuw nsw i64 %40, 1
IC: Visiting:   %44 = add nuw nsw i64 %40, 1
IC: Visiting:   %40 = phi i64 [ %44, %42 ], [ 0, %36 ]
IC: Visiting:   br label %39
IC: Visiting:   %34 = getelementptr i64, ptr %29, i64 %31
IC: Visiting:   store i64 0, ptr %34, align 4
IC: Visiting:   %35 = add nsw i64 %31, 1
IC: Mod =   %35 = add nsw i64 %31, 1
    New =   %35 = add nuw nsw i64 %31, 1
ADD:   %31 = phi i64 [ %35, %33 ], [ 0, %27 ]
ADD:   %35 = add nuw nsw i64 %31, 1
IC: Visiting:   %35 = add nuw nsw i64 %31, 1
IC: Visiting:   %31 = phi i64 [ %35, %33 ], [ 0, %27 ]
IC: Visiting:   br label %30
IC: Visiting:   %25 = getelementptr i64, ptr %20, i64 %22
IC: Visiting:   store i64 0, ptr %25, align 4
IC: Visiting:   %26 = add nsw i64 %22, 1
IC: Mod =   %26 = add nsw i64 %22, 1
    New =   %26 = add nuw nsw i64 %22, 1
ADD:   %22 = phi i64 [ %26, %24 ], [ 0, %0 ]
ADD:   %26 = add nuw nsw i64 %22, 1
IC: Visiting:   %26 = add nuw nsw i64 %22, 1
IC: Visiting:   %22 = phi i64 [ %26, %24 ], [ 0, %0 ]
IC: Visiting:   br label %21


INSTCOMBINE ITERATION #2 on main
ADD:   br label %21
ADD:   %26 = add nuw nsw i64 %22, 1
ADD:   store i64 0, ptr %25, align 4
ADD:   %25 = getelementptr i64, ptr %20, i64 %22
ADD:   br label %30
ADD:   %35 = add nuw nsw i64 %31, 1
ADD:   store i64 0, ptr %34, align 4
ADD:   %34 = getelementptr i64, ptr %29, i64 %31
ADD:   br label %39
ADD:   %44 = add nuw nsw i64 %40, 1
ADD:   store i64 0, ptr %43, align 4
ADD:   %43 = getelementptr i64, ptr %38, i64 %40
ADD:   br label %48
ADD:   %53 = add nuw nsw i64 %49, 1
ADD:   store i64 0, ptr %52, align 4
ADD:   %52 = getelementptr i64, ptr %47, i64 %49
ADD:   br label %57
ADD:   %62 = add nuw nsw i64 %58, 1
ADD:   store i64 0, ptr %61, align 4
ADD:   %61 = getelementptr i64, ptr %56, i64 %58
ADD:   br label %66
ADD:   %71 = add nuw nsw i64 %67, 1
ADD:   store i64 0, ptr %70, align 4
ADD:   %70 = getelementptr i64, ptr %65, i64 %67
ADD:   br label %75
ADD:   %80 = add nuw nsw i64 %76, 1
ADD:   store i64 0, ptr %79, align 4
ADD:   %79 = getelementptr i64, ptr %74, i64 %76
ADD:   br label %84
ADD:   %89 = add nuw nsw i64 %85, 1
ADD:   store i64 0, ptr %88, align 4
ADD:   %88 = getelementptr i64, ptr %83, i64 %85
ADD:   br label %93
ADD:   %98 = add nuw nsw i64 %94, 1
ADD:   store double 0.000000e+00, ptr %97, align 8
ADD:   %97 = getelementptr double, ptr %92, i64 %94
ADD:   ret void
ADD:   call void @comet_print_memref_f64(i64 1, ptr nonnull %100)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %91)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %82)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %73)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %64)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %55)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %46)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
ADD:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %28, i64 1, ptr nonnull %37, i64 1, ptr nonnull %46, i64 1, ptr nonnull %55, i64 1, ptr nonnull %64, i64 1, ptr nonnull %73, i64 1, ptr nonnull %82, i64 1, ptr nonnull %91, i64 1, ptr nonnull %100, i32 1)
ADD:   store i64 1, ptr %.repack87, align 8
ADD:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 4
ADD:   store i64 %19, ptr %.repack85, align 8
ADD:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 3
ADD:   store i64 0, ptr %.repack83, align 8
ADD:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 2
ADD:   store ptr %92, ptr %.repack81, align 8
ADD:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 1
ADD:   store ptr %92, ptr %100, align 8
ADD:   %100 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %95, label %96, label %99
ADD:   %95 = icmp slt i64 %94, %19
ADD:   %94 = phi i64 [ %98, %96 ], [ 0, %90 ]
ADD:   br label %93
ADD:   %92 = call ptr @malloc(i64 %.idx80)
ADD:   %.idx80 = shl i64 %19, 3
ADD:   store i64 1, ptr %.repack78, align 8
ADD:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 4
ADD:   store i64 %17, ptr %.repack76, align 8
ADD:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 3
ADD:   store i64 0, ptr %.repack74, align 8
ADD:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 2
ADD:   store ptr %83, ptr %.repack72, align 8
ADD:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 1
ADD:   store ptr %83, ptr %91, align 8
ADD:   %91 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %86, label %87, label %90
ADD:   %86 = icmp slt i64 %85, %17
ADD:   %85 = phi i64 [ %89, %87 ], [ 0, %81 ]
ADD:   br label %84
ADD:   %83 = call ptr @malloc(i64 %.idx71)
ADD:   %.idx71 = shl i64 %17, 3
ADD:   store i64 1, ptr %.repack69, align 8
ADD:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4
ADD:   store i64 %15, ptr %.repack67, align 8
ADD:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 3
ADD:   store i64 0, ptr %.repack65, align 8
ADD:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 2
ADD:   store ptr %74, ptr %.repack63, align 8
ADD:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 1
ADD:   store ptr %74, ptr %82, align 8
ADD:   %82 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %77, label %78, label %81
ADD:   %77 = icmp slt i64 %76, %15
ADD:   %76 = phi i64 [ %80, %78 ], [ 0, %72 ]
ADD:   br label %75
ADD:   %74 = call ptr @malloc(i64 %.idx62)
ADD:   %.idx62 = shl i64 %15, 3
ADD:   store i64 1, ptr %.repack60, align 8
ADD:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 4
ADD:   store i64 %13, ptr %.repack58, align 8
ADD:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 3
ADD:   store i64 0, ptr %.repack56, align 8
ADD:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 2
ADD:   store ptr %65, ptr %.repack54, align 8
ADD:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 1
ADD:   store ptr %65, ptr %73, align 8
ADD:   %73 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %68, label %69, label %72
ADD:   %68 = icmp slt i64 %67, %13
ADD:   %67 = phi i64 [ %71, %69 ], [ 0, %63 ]
ADD:   br label %66
ADD:   %65 = call ptr @malloc(i64 %.idx53)
ADD:   %.idx53 = shl i64 %13, 3
ADD:   store i64 1, ptr %.repack51, align 8
ADD:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 4
ADD:   store i64 %11, ptr %.repack49, align 8
ADD:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 3
ADD:   store i64 0, ptr %.repack47, align 8
ADD:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 2
ADD:   store ptr %56, ptr %.repack45, align 8
ADD:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 1
ADD:   store ptr %56, ptr %64, align 8
ADD:   %64 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %59, label %60, label %63
ADD:   %59 = icmp slt i64 %58, %11
ADD:   %58 = phi i64 [ %62, %60 ], [ 0, %54 ]
ADD:   br label %57
ADD:   %56 = call ptr @malloc(i64 %.idx44)
ADD:   %.idx44 = shl i64 %11, 3
ADD:   store i64 1, ptr %.repack42, align 8
ADD:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 4
ADD:   store i64 %9, ptr %.repack40, align 8
ADD:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 3
ADD:   store i64 0, ptr %.repack38, align 8
ADD:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 2
ADD:   store ptr %47, ptr %.repack36, align 8
ADD:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 1
ADD:   store ptr %47, ptr %55, align 8
ADD:   %55 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %50, label %51, label %54
ADD:   %50 = icmp slt i64 %49, %9
ADD:   %49 = phi i64 [ %53, %51 ], [ 0, %45 ]
ADD:   br label %48
ADD:   %47 = call ptr @malloc(i64 %.idx35)
ADD:   %.idx35 = shl i64 %9, 3
ADD:   store i64 1, ptr %.repack33, align 8
ADD:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
ADD:   store i64 %7, ptr %.repack31, align 8
ADD:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
ADD:   store i64 0, ptr %.repack29, align 8
ADD:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
ADD:   store ptr %38, ptr %.repack27, align 8
ADD:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
ADD:   store ptr %38, ptr %46, align 8
ADD:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %41, label %42, label %45
ADD:   %41 = icmp slt i64 %40, %7
ADD:   %40 = phi i64 [ %44, %42 ], [ 0, %36 ]
ADD:   br label %39
ADD:   %38 = call ptr @malloc(i64 %.idx26)
ADD:   %.idx26 = shl i64 %7, 3
ADD:   store i64 1, ptr %.repack24, align 8
ADD:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
ADD:   store i64 %5, ptr %.repack22, align 8
ADD:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
ADD:   store i64 0, ptr %.repack20, align 8
ADD:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
ADD:   store ptr %29, ptr %.repack18, align 8
ADD:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
ADD:   store ptr %29, ptr %37, align 8
ADD:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %32, label %33, label %36
ADD:   %32 = icmp slt i64 %31, %5
ADD:   %31 = phi i64 [ %35, %33 ], [ 0, %27 ]
ADD:   br label %30
ADD:   %29 = call ptr @malloc(i64 %.idx17)
ADD:   %.idx17 = shl i64 %5, 3
ADD:   store i64 1, ptr %.repack15, align 8
ADD:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
ADD:   store i64 %3, ptr %.repack13, align 8
ADD:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
ADD:   store i64 0, ptr %.repack11, align 8
ADD:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
ADD:   store ptr %20, ptr %.repack9, align 8
ADD:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
ADD:   store ptr %20, ptr %28, align 8
ADD:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %23, label %24, label %27
ADD:   %23 = icmp slt i64 %22, %3
ADD:   %22 = phi i64 [ %26, %24 ], [ 0, %0 ]
ADD:   br label %21
ADD:   %20 = call ptr @malloc(i64 %.idx)
ADD:   %.idx = shl i64 %3, 3
ADD:   %19 = load i64, ptr %18, align 4
ADD:   %18 = getelementptr i64, ptr %1, i64 8
ADD:   %17 = load i64, ptr %16, align 4
ADD:   %16 = getelementptr i64, ptr %1, i64 7
ADD:   %15 = load i64, ptr %14, align 4
ADD:   %14 = getelementptr i64, ptr %1, i64 6
ADD:   %13 = load i64, ptr %12, align 4
ADD:   %12 = getelementptr i64, ptr %1, i64 5
ADD:   %11 = load i64, ptr %10, align 4
ADD:   %10 = getelementptr i64, ptr %1, i64 4
ADD:   %9 = load i64, ptr %8, align 4
ADD:   %8 = getelementptr i64, ptr %1, i64 3
ADD:   %7 = load i64, ptr %6, align 4
ADD:   %6 = getelementptr i64, ptr %1, i64 2
ADD:   %5 = load i64, ptr %4, align 4
ADD:   %4 = getelementptr i64, ptr %1, i64 1
ADD:   %3 = load i64, ptr %1, align 4
ADD:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
ADD:   store i64 1, ptr %.fca.4.0.gep, align 8
ADD:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
ADD:   store i64 7, ptr %.fca.3.0.gep, align 8
ADD:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
ADD:   store i64 0, ptr %.fca.2.gep, align 8
ADD:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
ADD:   store ptr %1, ptr %.fca.1.gep, align 8
ADD:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
ADD:   store ptr %1, ptr %2, align 8
ADD:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %1 = call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %1 = call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %1, ptr %2, align 8
IC: Visiting:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
IC: Visiting:   store ptr %1, ptr %.fca.1.gep, align 8
IC: Visiting:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.fca.2.gep, align 8
IC: Visiting:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
IC: Visiting:   store i64 7, ptr %.fca.3.0.gep, align 8
IC: Visiting:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
IC: Visiting:   store i64 1, ptr %.fca.4.0.gep, align 8
IC: Visiting:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
IC: Visiting:   %3 = load i64, ptr %1, align 4
IC: Visiting:   %4 = getelementptr i64, ptr %1, i64 1
IC: Visiting:   %5 = load i64, ptr %4, align 4
IC: Visiting:   %6 = getelementptr i64, ptr %1, i64 2
IC: Visiting:   %7 = load i64, ptr %6, align 4
IC: Visiting:   %8 = getelementptr i64, ptr %1, i64 3
IC: Visiting:   %9 = load i64, ptr %8, align 4
IC: Visiting:   %10 = getelementptr i64, ptr %1, i64 4
IC: Visiting:   %11 = load i64, ptr %10, align 4
IC: Visiting:   %12 = getelementptr i64, ptr %1, i64 5
IC: Visiting:   %13 = load i64, ptr %12, align 4
IC: Visiting:   %14 = getelementptr i64, ptr %1, i64 6
IC: Visiting:   %15 = load i64, ptr %14, align 4
IC: Visiting:   %16 = getelementptr i64, ptr %1, i64 7
IC: Visiting:   %17 = load i64, ptr %16, align 4
IC: Visiting:   %18 = getelementptr i64, ptr %1, i64 8
IC: Visiting:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %.idx = shl i64 %3, 3
IC: Visiting:   %20 = call ptr @malloc(i64 %.idx)
IC: Visiting:   br label %21
IC: Visiting:   %22 = phi i64 [ %26, %24 ], [ 0, %0 ]
IC: Visiting:   %23 = icmp slt i64 %22, %3
IC: Visiting:   br i1 %23, label %24, label %27
IC: Visiting:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %20, ptr %28, align 8
IC: Visiting:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
IC: Visiting:   store ptr %20, ptr %.repack9, align 8
IC: Visiting:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack11, align 8
IC: Visiting:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
IC: Visiting:   store i64 %3, ptr %.repack13, align 8
IC: Visiting:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack15, align 8
IC: Visiting:   %.idx17 = shl i64 %5, 3
IC: Visiting:   %29 = call ptr @malloc(i64 %.idx17)
IC: Visiting:   br label %30
IC: Visiting:   %31 = phi i64 [ %35, %33 ], [ 0, %27 ]
IC: Visiting:   %32 = icmp slt i64 %31, %5
IC: Visiting:   br i1 %32, label %33, label %36
IC: Visiting:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %29, ptr %37, align 8
IC: Visiting:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
IC: Visiting:   store ptr %29, ptr %.repack18, align 8
IC: Visiting:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack20, align 8
IC: Visiting:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
IC: Visiting:   store i64 %5, ptr %.repack22, align 8
IC: Visiting:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack24, align 8
IC: Visiting:   %.idx26 = shl i64 %7, 3
IC: Visiting:   %38 = call ptr @malloc(i64 %.idx26)
IC: Visiting:   br label %39
IC: Visiting:   %40 = phi i64 [ %44, %42 ], [ 0, %36 ]
IC: Visiting:   %41 = icmp slt i64 %40, %7
IC: Visiting:   br i1 %41, label %42, label %45
IC: Visiting:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %38, ptr %46, align 8
IC: Visiting:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
IC: Visiting:   store ptr %38, ptr %.repack27, align 8
IC: Visiting:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack29, align 8
IC: Visiting:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
IC: Visiting:   store i64 %7, ptr %.repack31, align 8
IC: Visiting:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack33, align 8
IC: Visiting:   %.idx35 = shl i64 %9, 3
IC: Visiting:   %47 = call ptr @malloc(i64 %.idx35)
IC: Visiting:   br label %48
IC: Visiting:   %49 = phi i64 [ %53, %51 ], [ 0, %45 ]
IC: Visiting:   %50 = icmp slt i64 %49, %9
IC: Visiting:   br i1 %50, label %51, label %54
IC: Visiting:   %55 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %47, ptr %55, align 8
IC: Visiting:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 1
IC: Visiting:   store ptr %47, ptr %.repack36, align 8
IC: Visiting:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack38, align 8
IC: Visiting:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 3
IC: Visiting:   store i64 %9, ptr %.repack40, align 8
IC: Visiting:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %55, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack42, align 8
IC: Visiting:   %.idx44 = shl i64 %11, 3
IC: Visiting:   %56 = call ptr @malloc(i64 %.idx44)
IC: Visiting:   br label %57
IC: Visiting:   %58 = phi i64 [ %62, %60 ], [ 0, %54 ]
IC: Visiting:   %59 = icmp slt i64 %58, %11
IC: Visiting:   br i1 %59, label %60, label %63
IC: Visiting:   %64 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %56, ptr %64, align 8
IC: Visiting:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 1
IC: Visiting:   store ptr %56, ptr %.repack45, align 8
IC: Visiting:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack47, align 8
IC: Visiting:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 3
IC: Visiting:   store i64 %11, ptr %.repack49, align 8
IC: Visiting:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %64, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack51, align 8
IC: Visiting:   %.idx53 = shl i64 %13, 3
IC: Visiting:   %65 = call ptr @malloc(i64 %.idx53)
IC: Visiting:   br label %66
IC: Visiting:   %67 = phi i64 [ %71, %69 ], [ 0, %63 ]
IC: Visiting:   %68 = icmp slt i64 %67, %13
IC: Visiting:   br i1 %68, label %69, label %72
IC: Visiting:   %73 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %65, ptr %73, align 8
IC: Visiting:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 1
IC: Visiting:   store ptr %65, ptr %.repack54, align 8
IC: Visiting:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack56, align 8
IC: Visiting:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 3
IC: Visiting:   store i64 %13, ptr %.repack58, align 8
IC: Visiting:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %73, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack60, align 8
IC: Visiting:   %.idx62 = shl i64 %15, 3
IC: Visiting:   %74 = call ptr @malloc(i64 %.idx62)
IC: Visiting:   br label %75
IC: Visiting:   %76 = phi i64 [ %80, %78 ], [ 0, %72 ]
IC: Visiting:   %77 = icmp slt i64 %76, %15
IC: Visiting:   br i1 %77, label %78, label %81
IC: Visiting:   %82 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %74, ptr %82, align 8
IC: Visiting:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 1
IC: Visiting:   store ptr %74, ptr %.repack63, align 8
IC: Visiting:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack65, align 8
IC: Visiting:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 3
IC: Visiting:   store i64 %15, ptr %.repack67, align 8
IC: Visiting:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack69, align 8
IC: Visiting:   %.idx71 = shl i64 %17, 3
IC: Visiting:   %83 = call ptr @malloc(i64 %.idx71)
IC: Visiting:   br label %84
IC: Visiting:   %85 = phi i64 [ %89, %87 ], [ 0, %81 ]
IC: Visiting:   %86 = icmp slt i64 %85, %17
IC: Visiting:   br i1 %86, label %87, label %90
IC: Visiting:   %91 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %83, ptr %91, align 8
IC: Visiting:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 1
IC: Visiting:   store ptr %83, ptr %.repack72, align 8
IC: Visiting:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack74, align 8
IC: Visiting:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 3
IC: Visiting:   store i64 %17, ptr %.repack76, align 8
IC: Visiting:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %91, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack78, align 8
IC: Visiting:   %.idx80 = shl i64 %19, 3
IC: Visiting:   %92 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   br label %93
IC: Visiting:   %94 = phi i64 [ %98, %96 ], [ 0, %90 ]
IC: Visiting:   %95 = icmp slt i64 %94, %19
IC: Visiting:   br i1 %95, label %96, label %99
IC: Visiting:   %100 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %92, ptr %100, align 8
IC: Visiting:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 1
IC: Visiting:   store ptr %92, ptr %.repack81, align 8
IC: Visiting:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack83, align 8
IC: Visiting:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 3
IC: Visiting:   store i64 %19, ptr %.repack85, align 8
IC: Visiting:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %100, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack87, align 8
IC: Visiting:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %28, i64 1, ptr nonnull %37, i64 1, ptr nonnull %46, i64 1, ptr nonnull %55, i64 1, ptr nonnull %64, i64 1, ptr nonnull %73, i64 1, ptr nonnull %82, i64 1, ptr nonnull %91, i64 1, ptr nonnull %100, i32 1)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %46)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %55)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %64)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %73)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %82)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %91)
IC: Visiting:   call void @comet_print_memref_f64(i64 1, ptr nonnull %100)
IC: Visiting:   ret void
IC: Visiting:   %97 = getelementptr double, ptr %92, i64 %94
IC: Visiting:   store double 0.000000e+00, ptr %97, align 8
IC: Visiting:   %98 = add nuw nsw i64 %94, 1
IC: Visiting:   br label %93
IC: Visiting:   %88 = getelementptr i64, ptr %83, i64 %85
IC: Visiting:   store i64 0, ptr %88, align 4
IC: Visiting:   %89 = add nuw nsw i64 %85, 1
IC: Visiting:   br label %84
IC: Visiting:   %79 = getelementptr i64, ptr %74, i64 %76
IC: Visiting:   store i64 0, ptr %79, align 4
IC: Visiting:   %80 = add nuw nsw i64 %76, 1
IC: Visiting:   br label %75
IC: Visiting:   %70 = getelementptr i64, ptr %65, i64 %67
IC: Visiting:   store i64 0, ptr %70, align 4
IC: Visiting:   %71 = add nuw nsw i64 %67, 1
IC: Visiting:   br label %66
IC: Visiting:   %61 = getelementptr i64, ptr %56, i64 %58
IC: Visiting:   store i64 0, ptr %61, align 4
IC: Visiting:   %62 = add nuw nsw i64 %58, 1
IC: Visiting:   br label %57
IC: Visiting:   %52 = getelementptr i64, ptr %47, i64 %49
IC: Visiting:   store i64 0, ptr %52, align 4
IC: Visiting:   %53 = add nuw nsw i64 %49, 1
IC: Visiting:   br label %48
IC: Visiting:   %43 = getelementptr i64, ptr %38, i64 %40
IC: Visiting:   store i64 0, ptr %43, align 4
IC: Visiting:   %44 = add nuw nsw i64 %40, 1
IC: Visiting:   br label %39
IC: Visiting:   %34 = getelementptr i64, ptr %29, i64 %31
IC: Visiting:   store i64 0, ptr %34, align 4
IC: Visiting:   %35 = add nuw nsw i64 %31, 1
IC: Visiting:   br label %30
IC: Visiting:   %25 = getelementptr i64, ptr %20, i64 %22
IC: Visiting:   store i64 0, ptr %25, align 4
IC: Visiting:   %26 = add nuw nsw i64 %22, 1
IC: Visiting:   br label %21
Processing condition to simplify:   %23 = icmp slt i64 %22, %3
Checking   %23 = icmp slt i64 %22, %3
   failed to decompose condition
Processing fact to add to the system:   %23 = icmp slt i64 %22, %3
Adding 'slt %22, %3'
  constraint: %22 + -1 * %3 <= -1

Top of stack : 2 3
CB: 4 53
Removing %22 + -1 * %3 <= -1

Processing fact to add to the system:   %23 = icmp slt i64 %22, %3
Adding 'sge %22, %3'
  constraint: %3 + -1 * %22 <= 0

---
%3 + -1 * %22 <= 0
%3 <= -1
sat
Top of stack : 4 53
CB: 5 52
Processing condition to simplify:   %32 = icmp slt i64 %31, %5
Checking   %32 = icmp slt i64 %31, %5
   failed to decompose condition
Top of stack : 4 53
CB: 6 7
Processing fact to add to the system:   %32 = icmp slt i64 %31, %5
Adding 'slt %31, %5'
  constraint: %31 + -1 * %5 <= -1

Top of stack : 6 7
CB: 8 51
Removing %31 + -1 * %5 <= -1

Top of stack : 4 53
CB: 8 51
Processing fact to add to the system:   %32 = icmp slt i64 %31, %5
Adding 'sge %31, %5'
  constraint: %5 + -1 * %31 <= 0

---
%3 + -1 * %22 <= 0
%5 + -1 * %31 <= 0
%5 <= -1
sat
Top of stack : 8 51
CB: 9 50
Processing condition to simplify:   %41 = icmp slt i64 %40, %7
Checking   %41 = icmp slt i64 %40, %7
   failed to decompose condition
Top of stack : 8 51
CB: 10 11
Processing fact to add to the system:   %41 = icmp slt i64 %40, %7
Adding 'slt %40, %7'
  constraint: %40 + -1 * %7 <= -1

Top of stack : 10 11
CB: 12 49
Removing %40 + -1 * %7 <= -1

Top of stack : 8 51
CB: 12 49
Processing fact to add to the system:   %41 = icmp slt i64 %40, %7
Adding 'sge %40, %7'
  constraint: %7 + -1 * %40 <= 0

---
%3 + -1 * %22 <= 0
%5 + -1 * %31 <= 0
%7 + -1 * %40 <= 0
%7 <= -1
sat
Top of stack : 12 49
CB: 13 48
Processing condition to simplify:   %50 = icmp slt i64 %49, %9
Checking   %50 = icmp slt i64 %49, %9
   failed to decompose condition
Top of stack : 12 49
CB: 14 15
Processing fact to add to the system:   %50 = icmp slt i64 %49, %9
Adding 'slt %49, %9'
  constraint: %49 + -1 * %9 <= -1

Top of stack : 14 15
CB: 16 47
Removing %49 + -1 * %9 <= -1

Top of stack : 12 49
CB: 16 47
Processing fact to add to the system:   %50 = icmp slt i64 %49, %9
Adding 'sge %49, %9'
  constraint: %9 + -1 * %49 <= 0

---
%3 + -1 * %22 <= 0
%5 + -1 * %31 <= 0
%7 + -1 * %40 <= 0
%9 + -1 * %49 <= 0
%9 <= -1
sat
Top of stack : 16 47
CB: 17 46
Processing condition to simplify:   %59 = icmp slt i64 %58, %11
Checking   %59 = icmp slt i64 %58, %11
   failed to decompose condition
Top of stack : 16 47
CB: 18 19
Processing fact to add to the system:   %59 = icmp slt i64 %58, %11
Adding 'slt %58, %11'
  constraint: %58 + -1 * %11 <= -1

Top of stack : 18 19
CB: 20 45
Removing %58 + -1 * %11 <= -1

Top of stack : 16 47
CB: 20 45
Processing fact to add to the system:   %59 = icmp slt i64 %58, %11
Adding 'sge %58, %11'
  constraint: %11 + -1 * %58 <= 0

---
%3 + -1 * %22 <= 0
%5 + -1 * %31 <= 0
%7 + -1 * %40 <= 0
%9 + -1 * %49 <= 0
%11 + -1 * %58 <= 0
%11 <= -1
sat
Top of stack : 20 45
CB: 21 44
Processing condition to simplify:   %68 = icmp slt i64 %67, %13
Checking   %68 = icmp slt i64 %67, %13
   failed to decompose condition
Top of stack : 20 45
CB: 22 23
Processing fact to add to the system:   %68 = icmp slt i64 %67, %13
Adding 'slt %67, %13'
  constraint: %67 + -1 * %13 <= -1

Top of stack : 22 23
CB: 24 43
Removing %67 + -1 * %13 <= -1

Top of stack : 20 45
CB: 24 43
Processing fact to add to the system:   %68 = icmp slt i64 %67, %13
Adding 'sge %67, %13'
  constraint: %13 + -1 * %67 <= 0

---
%3 + -1 * %22 <= 0
%5 + -1 * %31 <= 0
%7 + -1 * %40 <= 0
%9 + -1 * %49 <= 0
%11 + -1 * %58 <= 0
%13 + -1 * %67 <= 0
%13 <= -1
sat
Top of stack : 24 43
CB: 25 42
Processing condition to simplify:   %77 = icmp slt i64 %76, %15
Checking   %77 = icmp slt i64 %76, %15
   failed to decompose condition
Top of stack : 24 43
CB: 26 27
Processing fact to add to the system:   %77 = icmp slt i64 %76, %15
Adding 'slt %76, %15'
  constraint: %76 + -1 * %15 <= -1

Top of stack : 26 27
CB: 28 41
Removing %76 + -1 * %15 <= -1

Top of stack : 24 43
CB: 28 41
Processing fact to add to the system:   %77 = icmp slt i64 %76, %15
Adding 'sge %76, %15'
  constraint: %15 + -1 * %76 <= 0

---
%3 + -1 * %22 <= 0
%5 + -1 * %31 <= 0
%7 + -1 * %40 <= 0
%9 + -1 * %49 <= 0
%11 + -1 * %58 <= 0
%13 + -1 * %67 <= 0
%15 + -1 * %76 <= 0
%15 <= -1
sat
Top of stack : 28 41
CB: 29 40
Processing condition to simplify:   %86 = icmp slt i64 %85, %17
Checking   %86 = icmp slt i64 %85, %17
   failed to decompose condition
Top of stack : 28 41
CB: 30 31
Processing fact to add to the system:   %86 = icmp slt i64 %85, %17
Adding 'slt %85, %17'
  constraint: %85 + -1 * %17 <= -1

Top of stack : 30 31
CB: 32 39
Removing %85 + -1 * %17 <= -1

Top of stack : 28 41
CB: 32 39
Processing fact to add to the system:   %86 = icmp slt i64 %85, %17
Adding 'sge %85, %17'
  constraint: %17 + -1 * %85 <= 0

---
%3 + -1 * %22 <= 0
%5 + -1 * %31 <= 0
%7 + -1 * %40 <= 0
%9 + -1 * %49 <= 0
%11 + -1 * %58 <= 0
%13 + -1 * %67 <= 0
%15 + -1 * %76 <= 0
%17 + -1 * %85 <= 0
%17 <= -1
sat
Top of stack : 32 39
CB: 33 38
Processing condition to simplify:   %95 = icmp slt i64 %94, %19
Checking   %95 = icmp slt i64 %94, %19
   failed to decompose condition
Top of stack : 32 39
CB: 34 35
Processing fact to add to the system:   %95 = icmp slt i64 %94, %19
Adding 'slt %94, %19'
  constraint: %94 + -1 * %19 <= -1

Top of stack : 34 35
CB: 36 37
Removing %94 + -1 * %19 <= -1

Top of stack : 32 39
CB: 36 37
Processing fact to add to the system:   %95 = icmp slt i64 %94, %19
Adding 'sge %94, %19'
  constraint: %19 + -1 * %94 <= 0

---
%3 + -1 * %22 <= 0
%5 + -1 * %31 <= 0
%7 + -1 * %40 <= 0
%9 + -1 * %49 <= 0
%11 + -1 * %58 <= 0
%13 + -1 * %67 <= 0
%15 + -1 * %76 <= 0
%17 + -1 * %85 <= 0
%19 + -1 * %94 <= 0
%19 <= -1
sat
Marked as tail call candidate:   %1 = call dereferenceable_or_null(56) ptr @malloc(i64 56)
Combine negations for:   %.idx = shl i64 %3, 3
Combine negations for:   %.idx17 = shl i64 %5, 3
Combine negations for:   %.idx26 = shl i64 %7, 3
Combine negations for:   %.idx35 = shl i64 %9, 3
Combine negations for:   %.idx44 = shl i64 %11, 3
Combine negations for:   %.idx53 = shl i64 %13, 3
Combine negations for:   %.idx62 = shl i64 %15, 3
Combine negations for:   %.idx71 = shl i64 %17, 3
Combine negations for:   %.idx80 = shl i64 %19, 3
Combine negations for:   %98 = add nuw nsw i64 %94, 1
LINEARIZE:   %98 = add nuw nsw i64 %94, 1
OPERAND:   %94 = phi i64 [ %98, %96 ], [ 0, %90 ] (1)
ADD USES LEAF:   %94 = phi i64 [ %98, %96 ], [ 0, %90 ] (1)
OPERAND: i64 1 (1)
ADD USES LEAF: i64 1 (1)
RAIn:	add i64	[ %94, #1310721] [ 1, #0] 
RAOut:	add i64	[ %94, #1310721] [ 1, #0] 
Combine negations for:   %89 = add nuw nsw i64 %85, 1
LINEARIZE:   %89 = add nuw nsw i64 %85, 1
OPERAND:   %85 = phi i64 [ %89, %87 ], [ 0, %81 ] (1)
ADD USES LEAF:   %85 = phi i64 [ %89, %87 ], [ 0, %81 ] (1)
OPERAND: i64 1 (1)
ADD USES LEAF: i64 1 (1)
RAIn:	add i64	[ %85, #1179649] [ 1, #0] 
RAOut:	add i64	[ %85, #1179649] [ 1, #0] 
Combine negations for:   %80 = add nuw nsw i64 %76, 1
LINEARIZE:   %80 = add nuw nsw i64 %76, 1
OPERAND:   %76 = phi i64 [ %80, %78 ], [ 0, %72 ] (1)
ADD USES LEAF:   %76 = phi i64 [ %80, %78 ], [ 0, %72 ] (1)
OPERAND: i64 1 (1)
ADD USES LEAF: i64 1 (1)
RAIn:	add i64	[ %76, #1048577] [ 1, #0] 
RAOut:	add i64	[ %76, #1048577] [ 1, #0] 
Combine negations for:   %71 = add nuw nsw i64 %67, 1
LINEARIZE:   %71 = add nuw nsw i64 %67, 1
OPERAND:   %67 = phi i64 [ %71, %69 ], [ 0, %63 ] (1)
ADD USES LEAF:   %67 = phi i64 [ %71, %69 ], [ 0, %63 ] (1)
OPERAND: i64 1 (1)
ADD USES LEAF: i64 1 (1)
RAIn:	add i64	[ %67, #917505] [ 1, #0] 
RAOut:	add i64	[ %67, #917505] [ 1, #0] 
Combine negations for:   %62 = add nuw nsw i64 %58, 1
LINEARIZE:   %62 = add nuw nsw i64 %58, 1
OPERAND:   %58 = phi i64 [ %62, %60 ], [ 0, %54 ] (1)
ADD USES LEAF:   %58 = phi i64 [ %62, %60 ], [ 0, %54 ] (1)
OPERAND: i64 1 (1)
ADD USES LEAF: i64 1 (1)
RAIn:	add i64	[ %58, #786433] [ 1, #0] 
RAOut:	add i64	[ %58, #786433] [ 1, #0] 
Combine negations for:   %53 = add nuw nsw i64 %49, 1
LINEARIZE:   %53 = add nuw nsw i64 %49, 1
OPERAND:   %49 = phi i64 [ %53, %51 ], [ 0, %45 ] (1)
ADD USES LEAF:   %49 = phi i64 [ %53, %51 ], [ 0, %45 ] (1)
OPERAND: i64 1 (1)
ADD USES LEAF: i64 1 (1)
RAIn:	add i64	[ %49, #655361] [ 1, #0] 
RAOut:	add i64	[ %49, #655361] [ 1, #0] 
Combine negations for:   %44 = add nuw nsw i64 %40, 1
LINEARIZE:   %44 = add nuw nsw i64 %40, 1
OPERAND:   %40 = phi i64 [ %44, %42 ], [ 0, %36 ] (1)
ADD USES LEAF:   %40 = phi i64 [ %44, %42 ], [ 0, %36 ] (1)
OPERAND: i64 1 (1)
ADD USES LEAF: i64 1 (1)
RAIn:	add i64	[ %40, #524289] [ 1, #0] 
RAOut:	add i64	[ %40, #524289] [ 1, #0] 
Combine negations for:   %35 = add nuw nsw i64 %31, 1
LINEARIZE:   %35 = add nuw nsw i64 %31, 1
OPERAND:   %31 = phi i64 [ %35, %33 ], [ 0, %27 ] (1)
ADD USES LEAF:   %31 = phi i64 [ %35, %33 ], [ 0, %27 ] (1)
OPERAND: i64 1 (1)
ADD USES LEAF: i64 1 (1)
RAIn:	add i64	[ %31, #393217] [ 1, #0] 
RAOut:	add i64	[ %31, #393217] [ 1, #0] 
Combine negations for:   %26 = add nuw nsw i64 %22, 1
LINEARIZE:   %26 = add nuw nsw i64 %22, 1
OPERAND:   %22 = phi i64 [ %26, %24 ], [ 0, %0 ] (1)
ADD USES LEAF:   %22 = phi i64 [ %26, %24 ], [ 0, %0 ] (1)
OPERAND: i64 1 (1)
ADD USES LEAF: i64 1 (1)
RAIn:	add i64	[ %22, #262145] [ 1, #0] 
RAOut:	add i64	[ %22, #262145] [ 1, #0] 
In function main: No constant terminator folding candidates found in loop 
LICM sinking instruction:   %25 = getelementptr i64, ptr %20, i64 %22
LoopRotation: rotating Loop at depth 1 containing: %21<header><exiting>,%24<latch>
  Inserted PHI:   %26 = phi i64 [ 0, %0 ], [ %23, %22 ]
Inserting edge %0 -> %29
	Reachable %0 -> %29
		NCA == %0
Mark %29as affected, CurrentLevel 2
	Successor %32, level = 3
		Marking visited not affected %32
 Next: %32
	Successor %38, level = 4
		Marking visited not affected %38
	Successor %35, level = 4
		Marking visited not affected %35
 Next: %35
	Successor %32, level = 3
 Next: %38
	Successor %41, level = 5
		Marking visited not affected %41
 Next: %41
	Successor %47, level = 6
		Marking visited not affected %47
	Successor %44, level = 6
		Marking visited not affected %44
 Next: %44
	Successor %41, level = 5
 Next: %47
	Successor %50, level = 7
		Marking visited not affected %50
 Next: %50
	Successor %56, level = 8
		Marking visited not affected %56
	Successor %53, level = 8
		Marking visited not affected %53
 Next: %53
	Successor %50, level = 7
 Next: %56
	Successor %59, level = 9
		Marking visited not affected %59
 Next: %59
	Successor %65, level = 10
		Marking visited not affected %65
	Successor %62, level = 10
		Marking visited not affected %62
 Next: %62
	Successor %59, level = 9
 Next: %65
	Successor %68, level = 11
		Marking visited not affected %68
 Next: %68
	Successor %74, level = 12
		Marking visited not affected %74
	Successor %71, level = 12
		Marking visited not affected %71
 Next: %71
	Successor %68, level = 11
 Next: %74
	Successor %77, level = 13
		Marking visited not affected %77
 Next: %77
	Successor %83, level = 14
		Marking visited not affected %83
	Successor %80, level = 14
		Marking visited not affected %80
 Next: %80
	Successor %77, level = 13
 Next: %83
	Successor %86, level = 15
		Marking visited not affected %86
 Next: %86
	Successor %92, level = 16
		Marking visited not affected %92
	Successor %89, level = 16
		Marking visited not affected %89
 Next: %89
	Successor %86, level = 15
 Next: %92
	Successor %95, level = 17
		Marking visited not affected %95
 Next: %95
	Successor %101, level = 18
		Marking visited not affected %101
	Successor %98, level = 18
		Marking visited not affected %98
 Next: %98
	Successor %95, level = 17
 Next: %101
Updating NCD = %0
	IDom(%29) = %0
Inserting edge %0 -> %25
	Reachable %0 -> %25
		NCA == %0
Mark %25as affected, CurrentLevel 2
	Successor %22, level = 1
Updating NCD = %0
	IDom(%25) = %0
Deleting edge %0 -> %22
	NCD %0, ToIDom %0
IsReachableFromIDom %22
	Pred %25
	Support %0
	%22 is reachable from support %0
Deleting reachable %0 -> %22
	Rebuilding subtree
The entire tree needs to be rebuilt
Inserting edge %0 -> %._crit_edge
Inserting %0 -> (unreachable) %._crit_edge
After adding unreachable nodes
Inserted %0 -> (prev unreachable) %._crit_edge
Inserting edge %._crit_edge -> %25
	Reachable %._crit_edge -> %25
		NCA == %0
Deleting edge %0 -> %25
	NCD %0, ToIDom %0
IsReachableFromIDom %25
	Pred %._crit_edge
	Support %0
	%25 is reachable from support %0
Deleting reachable %0 -> %25
	Rebuilding subtree
The entire tree needs to be rebuilt
DomTree recalculated, skipping future batch updates
Inserting edge %22 -> %._crit_edge
Inserting %22 -> (unreachable) %._crit_edge
After adding unreachable nodes
Inserted %22 -> (prev unreachable) %._crit_edge
Inserting edge %._crit_edge -> %29
	Reachable %._crit_edge -> %29
		NCA == %0
Deleting edge %22 -> %29
	NCD %0, ToIDom %0
Deleting reachable %22 -> %29
	Rebuilding subtree
The entire tree needs to be rebuilt
DomTree recalculated, skipping future batch updates
Merging:  into 
Inserting edge %23 -> %23
	Reachable %23 -> %23
		NCA == %23
Inserting edge %23 -> %._crit_edge
	Reachable %23 -> %._crit_edge
		NCA == %23
Mark %._crit_edgeas affected, CurrentLevel 4
	Successor %28, level = 1
Updating NCD = %23
	IDom(%._crit_edge) = %23
Deleting edge %22 -> %23
Deleting edge %22 -> %._crit_edge
	NCD %23, ToIDom %23
Deleting reachable %22 -> %._crit_edge
	Rebuilding subtree
	Top of subtree: %23
	Running Semi-NCA
Deleting edge %23 -> %22
	NCD %23, ToIDom %23
IsReachableFromIDom %22
Deleting unreachable subtree %22
Erasing node %22
LoopRotation: into Loop at depth 1 containing: %22<header><latch><exiting>
LICM sinking instruction:   %24 = getelementptr i64, ptr %20, i64 %23
Unswitching loop in main: Loop at depth 1 containing: %22<header><latch><exiting>

In function main: No constant terminator folding candidates found in loop 
LICM sinking instruction:   %34 = getelementptr i64, ptr %29, i64 %31
LoopRotation: rotating Loop at depth 1 containing: %30<header><exiting>,%33<latch>
  Inserted PHI:   %35 = phi i64 [ 0, %27 ], [ %32, %31 ]
Inserting edge %27 -> %38
	Reachable %27 -> %38
		NCA == %27
Mark %38as affected, CurrentLevel 3
	Successor %41, level = 4
		Marking visited not affected %41
 Next: %41
	Successor %47, level = 5
		Marking visited not affected %47
	Successor %44, level = 5
		Marking visited not affected %44
 Next: %44
	Successor %41, level = 4
 Next: %47
	Successor %50, level = 6
		Marking visited not affected %50
 Next: %50
	Successor %56, level = 7
		Marking visited not affected %56
	Successor %53, level = 7
		Marking visited not affected %53
 Next: %53
	Successor %50, level = 6
 Next: %56
	Successor %59, level = 8
		Marking visited not affected %59
 Next: %59
	Successor %65, level = 9
		Marking visited not affected %65
	Successor %62, level = 9
		Marking visited not affected %62
 Next: %62
	Successor %59, level = 8
 Next: %65
	Successor %68, level = 10
		Marking visited not affected %68
 Next: %68
	Successor %74, level = 11
		Marking visited not affected %74
	Successor %71, level = 11
		Marking visited not affected %71
 Next: %71
	Successor %68, level = 10
 Next: %74
	Successor %77, level = 12
		Marking visited not affected %77
 Next: %77
	Successor %83, level = 13
		Marking visited not affected %83
	Successor %80, level = 13
		Marking visited not affected %80
 Next: %80
	Successor %77, level = 12
 Next: %83
	Successor %86, level = 14
		Marking visited not affected %86
 Next: %86
	Successor %92, level = 15
		Marking visited not affected %92
	Successor %89, level = 15
		Marking visited not affected %89
 Next: %89
	Successor %86, level = 14
 Next: %92
	Successor %95, level = 16
		Marking visited not affected %95
 Next: %95
	Successor %101, level = 17
		Marking visited not affected %101
	Successor %98, level = 17
		Marking visited not affected %98
 Next: %98
	Successor %95, level = 16
 Next: %101
Updating NCD = %27
	IDom(%38) = %27
Inserting edge %27 -> %34
	Reachable %27 -> %34
		NCA == %27
Mark %34as affected, CurrentLevel 3
	Successor %31, level = 2
Updating NCD = %27
	IDom(%34) = %27
Deleting edge %27 -> %31
	NCD %27, ToIDom %27
IsReachableFromIDom %31
	Pred %34
	Support %27
	%31 is reachable from support %27
Deleting reachable %27 -> %31
	Rebuilding subtree
	Top of subtree: %27
	Running Semi-NCA
Inserting edge %27 -> %._crit_edge89
Inserting %27 -> (unreachable) %._crit_edge89
After adding unreachable nodes
Inserted %27 -> (prev unreachable) %._crit_edge89
Inserting edge %._crit_edge89 -> %34
	Reachable %._crit_edge89 -> %34
		NCA == %27
Deleting edge %27 -> %34
	NCD %27, ToIDom %27
IsReachableFromIDom %34
	Pred %._crit_edge89
	Support %27
	%34 is reachable from support %27
Deleting reachable %27 -> %34
	Rebuilding subtree
	Top of subtree: %27
	Running Semi-NCA
Inserting edge %31 -> %._crit_edge91
Inserting %31 -> (unreachable) %._crit_edge91
After adding unreachable nodes
Inserted %31 -> (prev unreachable) %._crit_edge91
Inserting edge %._crit_edge91 -> %38
	Reachable %._crit_edge91 -> %38
		NCA == %27
Deleting edge %31 -> %38
	NCD %27, ToIDom %27
Deleting reachable %31 -> %38
	Rebuilding subtree
	Top of subtree: %27
	Running Semi-NCA
Merging:  into 
Inserting edge %32 -> %32
	Reachable %32 -> %32
		NCA == %32
Inserting edge %32 -> %._crit_edge91
	Reachable %32 -> %._crit_edge91
		NCA == %32
Mark %._crit_edge91as affected, CurrentLevel 5
	Successor %37, level = 2
Updating NCD = %32
	IDom(%._crit_edge91) = %32
Deleting edge %31 -> %32
Deleting edge %31 -> %._crit_edge91
	NCD %32, ToIDom %32
Deleting reachable %31 -> %._crit_edge91
	Rebuilding subtree
	Top of subtree: %32
	Running Semi-NCA
Deleting edge %32 -> %31
	NCD %32, ToIDom %32
IsReachableFromIDom %31
Deleting unreachable subtree %31
Erasing node %31
LoopRotation: into Loop at depth 1 containing: %31<header><latch><exiting>
LICM sinking instruction:   %33 = getelementptr i64, ptr %29, i64 %32
Unswitching loop in main: Loop at depth 1 containing: %31<header><latch><exiting>

In function main: No constant terminator folding candidates found in loop 
LICM sinking instruction:   %43 = getelementptr i64, ptr %38, i64 %40
LoopRotation: rotating Loop at depth 1 containing: %39<header><exiting>,%42<latch>
  Inserted PHI:   %44 = phi i64 [ 0, %36 ], [ %41, %40 ]
Inserting edge %36 -> %47
	Reachable %36 -> %47
		NCA == %36
Mark %47as affected, CurrentLevel 4
	Successor %50, level = 5
		Marking visited not affected %50
 Next: %50
	Successor %56, level = 6
		Marking visited not affected %56
	Successor %53, level = 6
		Marking visited not affected %53
 Next: %53
	Successor %50, level = 5
 Next: %56
	Successor %59, level = 7
		Marking visited not affected %59
 Next: %59
	Successor %65, level = 8
		Marking visited not affected %65
	Successor %62, level = 8
		Marking visited not affected %62
 Next: %62
	Successor %59, level = 7
 Next: %65
	Successor %68, level = 9
		Marking visited not affected %68
 Next: %68
	Successor %74, level = 10
		Marking visited not affected %74
	Successor %71, level = 10
		Marking visited not affected %71
 Next: %71
	Successor %68, level = 9
 Next: %74
	Successor %77, level = 11
		Marking visited not affected %77
 Next: %77
	Successor %83, level = 12
		Marking visited not affected %83
	Successor %80, level = 12
		Marking visited not affected %80
 Next: %80
	Successor %77, level = 11
 Next: %83
	Successor %86, level = 13
		Marking visited not affected %86
 Next: %86
	Successor %92, level = 14
		Marking visited not affected %92
	Successor %89, level = 14
		Marking visited not affected %89
 Next: %89
	Successor %86, level = 13
 Next: %92
	Successor %95, level = 15
		Marking visited not affected %95
 Next: %95
	Successor %101, level = 16
		Marking visited not affected %101
	Successor %98, level = 16
		Marking visited not affected %98
 Next: %98
	Successor %95, level = 15
 Next: %101
Updating NCD = %36
	IDom(%47) = %36
Inserting edge %36 -> %43
	Reachable %36 -> %43
		NCA == %36
Mark %43as affected, CurrentLevel 4
	Successor %40, level = 3
Updating NCD = %36
	IDom(%43) = %36
Deleting edge %36 -> %40
	NCD %36, ToIDom %36
IsReachableFromIDom %40
	Pred %43
	Support %36
	%40 is reachable from support %36
Deleting reachable %36 -> %40
	Rebuilding subtree
	Top of subtree: %36
	Running Semi-NCA
Inserting edge %36 -> %._crit_edge92
Inserting %36 -> (unreachable) %._crit_edge92
After adding unreachable nodes
Inserted %36 -> (prev unreachable) %._crit_edge92
Inserting edge %._crit_edge92 -> %43
	Reachable %._crit_edge92 -> %43
		NCA == %36
Deleting edge %36 -> %43
	NCD %36, ToIDom %36
IsReachableFromIDom %43
	Pred %._crit_edge92
	Support %36
	%43 is reachable from support %36
Deleting reachable %36 -> %43
	Rebuilding subtree
	Top of subtree: %36
	Running Semi-NCA
Inserting edge %40 -> %._crit_edge94
Inserting %40 -> (unreachable) %._crit_edge94
After adding unreachable nodes
Inserted %40 -> (prev unreachable) %._crit_edge94
Inserting edge %._crit_edge94 -> %47
	Reachable %._crit_edge94 -> %47
		NCA == %36
Deleting edge %40 -> %47
	NCD %36, ToIDom %36
Deleting reachable %40 -> %47
	Rebuilding subtree
	Top of subtree: %36
	Running Semi-NCA
Merging:  into 
Inserting edge %41 -> %41
	Reachable %41 -> %41
		NCA == %41
Inserting edge %41 -> %._crit_edge94
	Reachable %41 -> %._crit_edge94
		NCA == %41
Mark %._crit_edge94as affected, CurrentLevel 6
	Successor %46, level = 3
Updating NCD = %41
	IDom(%._crit_edge94) = %41
Deleting edge %40 -> %41
Deleting edge %40 -> %._crit_edge94
	NCD %41, ToIDom %41
Deleting reachable %40 -> %._crit_edge94
	Rebuilding subtree
	Top of subtree: %41
	Running Semi-NCA
Deleting edge %41 -> %40
	NCD %41, ToIDom %41
IsReachableFromIDom %40
Deleting unreachable subtree %40
Erasing node %40
LoopRotation: into Loop at depth 1 containing: %40<header><latch><exiting>
LICM sinking instruction:   %42 = getelementptr i64, ptr %38, i64 %41
Unswitching loop in main: Loop at depth 1 containing: %40<header><latch><exiting>

In function main: No constant terminator folding candidates found in loop 
LICM sinking instruction:   %52 = getelementptr i64, ptr %47, i64 %49
LoopRotation: rotating Loop at depth 1 containing: %48<header><exiting>,%51<latch>
  Inserted PHI:   %53 = phi i64 [ 0, %45 ], [ %50, %49 ]
Inserting edge %45 -> %56
	Reachable %45 -> %56
		NCA == %45
Mark %56as affected, CurrentLevel 5
	Successor %59, level = 6
		Marking visited not affected %59
 Next: %59
	Successor %65, level = 7
		Marking visited not affected %65
	Successor %62, level = 7
		Marking visited not affected %62
 Next: %62
	Successor %59, level = 6
 Next: %65
	Successor %68, level = 8
		Marking visited not affected %68
 Next: %68
	Successor %74, level = 9
		Marking visited not affected %74
	Successor %71, level = 9
		Marking visited not affected %71
 Next: %71
	Successor %68, level = 8
 Next: %74
	Successor %77, level = 10
		Marking visited not affected %77
 Next: %77
	Successor %83, level = 11
		Marking visited not affected %83
	Successor %80, level = 11
		Marking visited not affected %80
 Next: %80
	Successor %77, level = 10
 Next: %83
	Successor %86, level = 12
		Marking visited not affected %86
 Next: %86
	Successor %92, level = 13
		Marking visited not affected %92
	Successor %89, level = 13
		Marking visited not affected %89
 Next: %89
	Successor %86, level = 12
 Next: %92
	Successor %95, level = 14
		Marking visited not affected %95
 Next: %95
	Successor %101, level = 15
		Marking visited not affected %101
	Successor %98, level = 15
		Marking visited not affected %98
 Next: %98
	Successor %95, level = 14
 Next: %101
Updating NCD = %45
	IDom(%56) = %45
Inserting edge %45 -> %52
	Reachable %45 -> %52
		NCA == %45
Mark %52as affected, CurrentLevel 5
	Successor %49, level = 4
Updating NCD = %45
	IDom(%52) = %45
Deleting edge %45 -> %49
	NCD %45, ToIDom %45
IsReachableFromIDom %49
	Pred %52
	Support %45
	%49 is reachable from support %45
Deleting reachable %45 -> %49
	Rebuilding subtree
	Top of subtree: %45
	Running Semi-NCA
Inserting edge %45 -> %._crit_edge95
Inserting %45 -> (unreachable) %._crit_edge95
After adding unreachable nodes
Inserted %45 -> (prev unreachable) %._crit_edge95
Inserting edge %._crit_edge95 -> %52
	Reachable %._crit_edge95 -> %52
		NCA == %45
Deleting edge %45 -> %52
	NCD %45, ToIDom %45
IsReachableFromIDom %52
	Pred %._crit_edge95
	Support %45
	%52 is reachable from support %45
Deleting reachable %45 -> %52
	Rebuilding subtree
	Top of subtree: %45
	Running Semi-NCA
Inserting edge %49 -> %._crit_edge97
Inserting %49 -> (unreachable) %._crit_edge97
After adding unreachable nodes
Inserted %49 -> (prev unreachable) %._crit_edge97
Inserting edge %._crit_edge97 -> %56
	Reachable %._crit_edge97 -> %56
		NCA == %45
Deleting edge %49 -> %56
	NCD %45, ToIDom %45
Deleting reachable %49 -> %56
	Rebuilding subtree
	Top of subtree: %45
	Running Semi-NCA
Merging:  into 
Inserting edge %50 -> %50
	Reachable %50 -> %50
		NCA == %50
Inserting edge %50 -> %._crit_edge97
	Reachable %50 -> %._crit_edge97
		NCA == %50
Mark %._crit_edge97as affected, CurrentLevel 7
	Successor %55, level = 4
Updating NCD = %50
	IDom(%._crit_edge97) = %50
Deleting edge %49 -> %50
Deleting edge %49 -> %._crit_edge97
	NCD %50, ToIDom %50
Deleting reachable %49 -> %._crit_edge97
	Rebuilding subtree
	Top of subtree: %50
	Running Semi-NCA
Deleting edge %50 -> %49
	NCD %50, ToIDom %50
IsReachableFromIDom %49
Deleting unreachable subtree %49
Erasing node %49
LoopRotation: into Loop at depth 1 containing: %49<header><latch><exiting>
LICM sinking instruction:   %51 = getelementptr i64, ptr %47, i64 %50
Unswitching loop in main: Loop at depth 1 containing: %49<header><latch><exiting>

In function main: No constant terminator folding candidates found in loop 
LICM sinking instruction:   %61 = getelementptr i64, ptr %56, i64 %58
LoopRotation: rotating Loop at depth 1 containing: %57<header><exiting>,%60<latch>
  Inserted PHI:   %62 = phi i64 [ 0, %54 ], [ %59, %58 ]
Inserting edge %54 -> %65
	Reachable %54 -> %65
		NCA == %54
Mark %65as affected, CurrentLevel 6
	Successor %68, level = 7
		Marking visited not affected %68
 Next: %68
	Successor %74, level = 8
		Marking visited not affected %74
	Successor %71, level = 8
		Marking visited not affected %71
 Next: %71
	Successor %68, level = 7
 Next: %74
	Successor %77, level = 9
		Marking visited not affected %77
 Next: %77
	Successor %83, level = 10
		Marking visited not affected %83
	Successor %80, level = 10
		Marking visited not affected %80
 Next: %80
	Successor %77, level = 9
 Next: %83
	Successor %86, level = 11
		Marking visited not affected %86
 Next: %86
	Successor %92, level = 12
		Marking visited not affected %92
	Successor %89, level = 12
		Marking visited not affected %89
 Next: %89
	Successor %86, level = 11
 Next: %92
	Successor %95, level = 13
		Marking visited not affected %95
 Next: %95
	Successor %101, level = 14
		Marking visited not affected %101
	Successor %98, level = 14
		Marking visited not affected %98
 Next: %98
	Successor %95, level = 13
 Next: %101
Updating NCD = %54
	IDom(%65) = %54
Inserting edge %54 -> %61
	Reachable %54 -> %61
		NCA == %54
Mark %61as affected, CurrentLevel 6
	Successor %58, level = 5
Updating NCD = %54
	IDom(%61) = %54
Deleting edge %54 -> %58
	NCD %54, ToIDom %54
IsReachableFromIDom %58
	Pred %61
	Support %54
	%58 is reachable from support %54
Deleting reachable %54 -> %58
	Rebuilding subtree
	Top of subtree: %54
	Running Semi-NCA
Inserting edge %54 -> %._crit_edge98
Inserting %54 -> (unreachable) %._crit_edge98
After adding unreachable nodes
Inserted %54 -> (prev unreachable) %._crit_edge98
Inserting edge %._crit_edge98 -> %61
	Reachable %._crit_edge98 -> %61
		NCA == %54
Deleting edge %54 -> %61
	NCD %54, ToIDom %54
IsReachableFromIDom %61
	Pred %._crit_edge98
	Support %54
	%61 is reachable from support %54
Deleting reachable %54 -> %61
	Rebuilding subtree
	Top of subtree: %54
	Running Semi-NCA
Inserting edge %58 -> %._crit_edge100
Inserting %58 -> (unreachable) %._crit_edge100
After adding unreachable nodes
Inserted %58 -> (prev unreachable) %._crit_edge100
Inserting edge %._crit_edge100 -> %65
	Reachable %._crit_edge100 -> %65
		NCA == %54
Deleting edge %58 -> %65
	NCD %54, ToIDom %54
Deleting reachable %58 -> %65
	Rebuilding subtree
	Top of subtree: %54
	Running Semi-NCA
Merging:  into 
Inserting edge %59 -> %59
	Reachable %59 -> %59
		NCA == %59
Inserting edge %59 -> %._crit_edge100
	Reachable %59 -> %._crit_edge100
		NCA == %59
Mark %._crit_edge100as affected, CurrentLevel 8
	Successor %64, level = 5
Updating NCD = %59
	IDom(%._crit_edge100) = %59
Deleting edge %58 -> %59
Deleting edge %58 -> %._crit_edge100
	NCD %59, ToIDom %59
Deleting reachable %58 -> %._crit_edge100
	Rebuilding subtree
	Top of subtree: %59
	Running Semi-NCA
Deleting edge %59 -> %58
	NCD %59, ToIDom %59
IsReachableFromIDom %58
Deleting unreachable subtree %58
Erasing node %58
LoopRotation: into Loop at depth 1 containing: %58<header><latch><exiting>
LICM sinking instruction:   %60 = getelementptr i64, ptr %56, i64 %59
Unswitching loop in main: Loop at depth 1 containing: %58<header><latch><exiting>

In function main: No constant terminator folding candidates found in loop 
LICM sinking instruction:   %70 = getelementptr i64, ptr %65, i64 %67
LoopRotation: rotating Loop at depth 1 containing: %66<header><exiting>,%69<latch>
  Inserted PHI:   %71 = phi i64 [ 0, %63 ], [ %68, %67 ]
Inserting edge %63 -> %74
	Reachable %63 -> %74
		NCA == %63
Mark %74as affected, CurrentLevel 7
	Successor %77, level = 8
		Marking visited not affected %77
 Next: %77
	Successor %83, level = 9
		Marking visited not affected %83
	Successor %80, level = 9
		Marking visited not affected %80
 Next: %80
	Successor %77, level = 8
 Next: %83
	Successor %86, level = 10
		Marking visited not affected %86
 Next: %86
	Successor %92, level = 11
		Marking visited not affected %92
	Successor %89, level = 11
		Marking visited not affected %89
 Next: %89
	Successor %86, level = 10
 Next: %92
	Successor %95, level = 12
		Marking visited not affected %95
 Next: %95
	Successor %101, level = 13
		Marking visited not affected %101
	Successor %98, level = 13
		Marking visited not affected %98
 Next: %98
	Successor %95, level = 12
 Next: %101
Updating NCD = %63
	IDom(%74) = %63
Inserting edge %63 -> %70
	Reachable %63 -> %70
		NCA == %63
Mark %70as affected, CurrentLevel 7
	Successor %67, level = 6
Updating NCD = %63
	IDom(%70) = %63
Deleting edge %63 -> %67
	NCD %63, ToIDom %63
IsReachableFromIDom %67
	Pred %70
	Support %63
	%67 is reachable from support %63
Deleting reachable %63 -> %67
	Rebuilding subtree
	Top of subtree: %63
	Running Semi-NCA
Inserting edge %63 -> %._crit_edge101
Inserting %63 -> (unreachable) %._crit_edge101
After adding unreachable nodes
Inserted %63 -> (prev unreachable) %._crit_edge101
Inserting edge %._crit_edge101 -> %70
	Reachable %._crit_edge101 -> %70
		NCA == %63
Deleting edge %63 -> %70
	NCD %63, ToIDom %63
IsReachableFromIDom %70
	Pred %._crit_edge101
	Support %63
	%70 is reachable from support %63
Deleting reachable %63 -> %70
	Rebuilding subtree
	Top of subtree: %63
	Running Semi-NCA
Inserting edge %67 -> %._crit_edge103
Inserting %67 -> (unreachable) %._crit_edge103
After adding unreachable nodes
Inserted %67 -> (prev unreachable) %._crit_edge103
Inserting edge %._crit_edge103 -> %74
	Reachable %._crit_edge103 -> %74
		NCA == %63
Deleting edge %67 -> %74
	NCD %63, ToIDom %63
Deleting reachable %67 -> %74
	Rebuilding subtree
	Top of subtree: %63
	Running Semi-NCA
Merging:  into 
Inserting edge %68 -> %68
	Reachable %68 -> %68
		NCA == %68
Inserting edge %68 -> %._crit_edge103
	Reachable %68 -> %._crit_edge103
		NCA == %68
Mark %._crit_edge103as affected, CurrentLevel 9
	Successor %73, level = 6
Updating NCD = %68
	IDom(%._crit_edge103) = %68
Deleting edge %67 -> %68
Deleting edge %67 -> %._crit_edge103
	NCD %68, ToIDom %68
Deleting reachable %67 -> %._crit_edge103
	Rebuilding subtree
	Top of subtree: %68
	Running Semi-NCA
Deleting edge %68 -> %67
	NCD %68, ToIDom %68
IsReachableFromIDom %67
Deleting unreachable subtree %67
Erasing node %67
LoopRotation: into Loop at depth 1 containing: %67<header><latch><exiting>
LICM sinking instruction:   %69 = getelementptr i64, ptr %65, i64 %68
Unswitching loop in main: Loop at depth 1 containing: %67<header><latch><exiting>

In function main: No constant terminator folding candidates found in loop 
LICM sinking instruction:   %79 = getelementptr i64, ptr %74, i64 %76
LoopRotation: rotating Loop at depth 1 containing: %75<header><exiting>,%78<latch>
  Inserted PHI:   %80 = phi i64 [ 0, %72 ], [ %77, %76 ]
Inserting edge %72 -> %83
	Reachable %72 -> %83
		NCA == %72
Mark %83as affected, CurrentLevel 8
	Successor %86, level = 9
		Marking visited not affected %86
 Next: %86
	Successor %92, level = 10
		Marking visited not affected %92
	Successor %89, level = 10
		Marking visited not affected %89
 Next: %89
	Successor %86, level = 9
 Next: %92
	Successor %95, level = 11
		Marking visited not affected %95
 Next: %95
	Successor %101, level = 12
		Marking visited not affected %101
	Successor %98, level = 12
		Marking visited not affected %98
 Next: %98
	Successor %95, level = 11
 Next: %101
Updating NCD = %72
	IDom(%83) = %72
Inserting edge %72 -> %79
	Reachable %72 -> %79
		NCA == %72
Mark %79as affected, CurrentLevel 8
	Successor %76, level = 7
Updating NCD = %72
	IDom(%79) = %72
Deleting edge %72 -> %76
	NCD %72, ToIDom %72
IsReachableFromIDom %76
	Pred %79
	Support %72
	%76 is reachable from support %72
Deleting reachable %72 -> %76
	Rebuilding subtree
	Top of subtree: %72
	Running Semi-NCA
Inserting edge %72 -> %._crit_edge104
Inserting %72 -> (unreachable) %._crit_edge104
After adding unreachable nodes
Inserted %72 -> (prev unreachable) %._crit_edge104
Inserting edge %._crit_edge104 -> %79
	Reachable %._crit_edge104 -> %79
		NCA == %72
Deleting edge %72 -> %79
	NCD %72, ToIDom %72
IsReachableFromIDom %79
	Pred %._crit_edge104
	Support %72
	%79 is reachable from support %72
Deleting reachable %72 -> %79
	Rebuilding subtree
	Top of subtree: %72
	Running Semi-NCA
Inserting edge %76 -> %._crit_edge106
Inserting %76 -> (unreachable) %._crit_edge106
After adding unreachable nodes
Inserted %76 -> (prev unreachable) %._crit_edge106
Inserting edge %._crit_edge106 -> %83
	Reachable %._crit_edge106 -> %83
		NCA == %72
Deleting edge %76 -> %83
	NCD %72, ToIDom %72
Deleting reachable %76 -> %83
	Rebuilding subtree
	Top of subtree: %72
	Running Semi-NCA
Merging:  into 
Inserting edge %77 -> %77
	Reachable %77 -> %77
		NCA == %77
Inserting edge %77 -> %._crit_edge106
	Reachable %77 -> %._crit_edge106
		NCA == %77
Mark %._crit_edge106as affected, CurrentLevel 10
	Successor %82, level = 7
Updating NCD = %77
	IDom(%._crit_edge106) = %77
Deleting edge %76 -> %77
Deleting edge %76 -> %._crit_edge106
	NCD %77, ToIDom %77
Deleting reachable %76 -> %._crit_edge106
	Rebuilding subtree
	Top of subtree: %77
	Running Semi-NCA
Deleting edge %77 -> %76
	NCD %77, ToIDom %77
IsReachableFromIDom %76
Deleting unreachable subtree %76
Erasing node %76
LoopRotation: into Loop at depth 1 containing: %76<header><latch><exiting>
LICM sinking instruction:   %78 = getelementptr i64, ptr %74, i64 %77
Unswitching loop in main: Loop at depth 1 containing: %76<header><latch><exiting>

In function main: No constant terminator folding candidates found in loop 
LICM sinking instruction:   %88 = getelementptr i64, ptr %83, i64 %85
LoopRotation: rotating Loop at depth 1 containing: %84<header><exiting>,%87<latch>
  Inserted PHI:   %89 = phi i64 [ 0, %81 ], [ %86, %85 ]
Inserting edge %81 -> %92
	Reachable %81 -> %92
		NCA == %81
Mark %92as affected, CurrentLevel 9
	Successor %95, level = 10
		Marking visited not affected %95
 Next: %95
	Successor %101, level = 11
		Marking visited not affected %101
	Successor %98, level = 11
		Marking visited not affected %98
 Next: %98
	Successor %95, level = 10
 Next: %101
Updating NCD = %81
	IDom(%92) = %81
Inserting edge %81 -> %88
	Reachable %81 -> %88
		NCA == %81
Mark %88as affected, CurrentLevel 9
	Successor %85, level = 8
Updating NCD = %81
	IDom(%88) = %81
Deleting edge %81 -> %85
	NCD %81, ToIDom %81
IsReachableFromIDom %85
	Pred %88
	Support %81
	%85 is reachable from support %81
Deleting reachable %81 -> %85
	Rebuilding subtree
	Top of subtree: %81
	Running Semi-NCA
Inserting edge %81 -> %._crit_edge107
Inserting %81 -> (unreachable) %._crit_edge107
After adding unreachable nodes
Inserted %81 -> (prev unreachable) %._crit_edge107
Inserting edge %._crit_edge107 -> %88
	Reachable %._crit_edge107 -> %88
		NCA == %81
Deleting edge %81 -> %88
	NCD %81, ToIDom %81
IsReachableFromIDom %88
	Pred %._crit_edge107
	Support %81
	%88 is reachable from support %81
Deleting reachable %81 -> %88
	Rebuilding subtree
	Top of subtree: %81
	Running Semi-NCA
Inserting edge %85 -> %._crit_edge109
Inserting %85 -> (unreachable) %._crit_edge109
After adding unreachable nodes
Inserted %85 -> (prev unreachable) %._crit_edge109
Inserting edge %._crit_edge109 -> %92
	Reachable %._crit_edge109 -> %92
		NCA == %81
Deleting edge %85 -> %92
	NCD %81, ToIDom %81
Deleting reachable %85 -> %92
	Rebuilding subtree
	Top of subtree: %81
	Running Semi-NCA
Merging:  into 
Inserting edge %86 -> %86
	Reachable %86 -> %86
		NCA == %86
Inserting edge %86 -> %._crit_edge109
	Reachable %86 -> %._crit_edge109
		NCA == %86
Mark %._crit_edge109as affected, CurrentLevel 11
	Successor %91, level = 8
Updating NCD = %86
	IDom(%._crit_edge109) = %86
Deleting edge %85 -> %86
Deleting edge %85 -> %._crit_edge109
	NCD %86, ToIDom %86
Deleting reachable %85 -> %._crit_edge109
	Rebuilding subtree
	Top of subtree: %86
	Running Semi-NCA
Deleting edge %86 -> %85
	NCD %86, ToIDom %86
IsReachableFromIDom %85
Deleting unreachable subtree %85
Erasing node %85
LoopRotation: into Loop at depth 1 containing: %85<header><latch><exiting>
LICM sinking instruction:   %87 = getelementptr i64, ptr %83, i64 %86
Unswitching loop in main: Loop at depth 1 containing: %85<header><latch><exiting>

In function main: No constant terminator folding candidates found in loop 
LICM sinking instruction:   %97 = getelementptr double, ptr %92, i64 %94
LoopRotation: rotating Loop at depth 1 containing: %93<header><exiting>,%96<latch>
  Inserted PHI:   %98 = phi i64 [ 0, %90 ], [ %95, %94 ]
Inserting edge %90 -> %101
	Reachable %90 -> %101
		NCA == %90
Mark %101as affected, CurrentLevel 10
Updating NCD = %90
	IDom(%101) = %90
Inserting edge %90 -> %97
	Reachable %90 -> %97
		NCA == %90
Mark %97as affected, CurrentLevel 10
	Successor %94, level = 9
Updating NCD = %90
	IDom(%97) = %90
Deleting edge %90 -> %94
	NCD %90, ToIDom %90
IsReachableFromIDom %94
	Pred %97
	Support %90
	%94 is reachable from support %90
Deleting reachable %90 -> %94
	Rebuilding subtree
	Top of subtree: %90
	Running Semi-NCA
Inserting edge %90 -> %._crit_edge110
Inserting %90 -> (unreachable) %._crit_edge110
After adding unreachable nodes
Inserted %90 -> (prev unreachable) %._crit_edge110
Inserting edge %._crit_edge110 -> %97
	Reachable %._crit_edge110 -> %97
		NCA == %90
Deleting edge %90 -> %97
	NCD %90, ToIDom %90
IsReachableFromIDom %97
	Pred %._crit_edge110
	Support %90
	%97 is reachable from support %90
Deleting reachable %90 -> %97
	Rebuilding subtree
	Top of subtree: %90
	Running Semi-NCA
Inserting edge %94 -> %._crit_edge112
Inserting %94 -> (unreachable) %._crit_edge112
After adding unreachable nodes
Inserted %94 -> (prev unreachable) %._crit_edge112
Inserting edge %._crit_edge112 -> %101
	Reachable %._crit_edge112 -> %101
		NCA == %90
Deleting edge %94 -> %101
	NCD %90, ToIDom %90
Deleting reachable %94 -> %101
	Rebuilding subtree
	Top of subtree: %90
	Running Semi-NCA
Merging:  into 
Inserting edge %95 -> %95
	Reachable %95 -> %95
		NCA == %95
Inserting edge %95 -> %._crit_edge112
	Reachable %95 -> %._crit_edge112
		NCA == %95
Mark %._crit_edge112as affected, CurrentLevel 12
	Successor %100, level = 9
Updating NCD = %95
	IDom(%._crit_edge112) = %95
Deleting edge %94 -> %95
Deleting edge %94 -> %._crit_edge112
	NCD %95, ToIDom %95
Deleting reachable %94 -> %._crit_edge112
	Rebuilding subtree
	Top of subtree: %95
	Running Semi-NCA
Deleting edge %95 -> %94
	NCD %95, ToIDom %95
IsReachableFromIDom %94
Deleting unreachable subtree %94
Erasing node %94
LoopRotation: into Loop at depth 1 containing: %94<header><latch><exiting>
LICM sinking instruction:   %96 = getelementptr double, ptr %92, i64 %95
Unswitching loop in main: Loop at depth 1 containing: %94<header><latch><exiting>

Looking to fold .lr.ph into 
Killing Trivial BB: 

.lr.ph:                                           ; preds = %0
  br label %22
Looking to fold ._crit_edge into 
Killing Trivial BB: 

._crit_edge:                                      ; preds = %.lr.ph
  br label %26
Looking to fold .lr.ph90 into 
Killing Trivial BB: 

.lr.ph90:                                         ; preds = %._crit_edge
  br label %29
Looking to fold ._crit_edge91 into 
Killing Trivial BB: 

._crit_edge91:                                    ; preds = %.lr.ph90
  br label %33
Looking to fold .lr.ph93 into 
Killing Trivial BB: 

.lr.ph93:                                         ; preds = %._crit_edge91
  br label %36
Looking to fold ._crit_edge94 into 
Killing Trivial BB: 

._crit_edge94:                                    ; preds = %.lr.ph93
  br label %40
Looking to fold .lr.ph96 into 
Killing Trivial BB: 

.lr.ph96:                                         ; preds = %._crit_edge94
  br label %43
Looking to fold ._crit_edge97 into 
Killing Trivial BB: 

._crit_edge97:                                    ; preds = %.lr.ph96
  br label %47
Looking to fold .lr.ph99 into 
Killing Trivial BB: 

.lr.ph99:                                         ; preds = %._crit_edge97
  br label %50
Looking to fold ._crit_edge100 into 
Killing Trivial BB: 

._crit_edge100:                                   ; preds = %.lr.ph99
  br label %54
Looking to fold .lr.ph102 into 
Killing Trivial BB: 

.lr.ph102:                                        ; preds = %._crit_edge100
  br label %57
Looking to fold ._crit_edge103 into 
Killing Trivial BB: 

._crit_edge103:                                   ; preds = %.lr.ph102
  br label %61
Looking to fold .lr.ph105 into 
Killing Trivial BB: 

.lr.ph105:                                        ; preds = %._crit_edge103
  br label %64
Looking to fold ._crit_edge106 into 
Killing Trivial BB: 

._crit_edge106:                                   ; preds = %.lr.ph105
  br label %68
Looking to fold .lr.ph108 into 
Killing Trivial BB: 

.lr.ph108:                                        ; preds = %._crit_edge106
  br label %71
Looking to fold ._crit_edge109 into 
Killing Trivial BB: 

._crit_edge109:                                   ; preds = %.lr.ph108
  br label %75
Looking to fold .lr.ph111 into 
Killing Trivial BB: 

.lr.ph111:                                        ; preds = %._crit_edge109
  br label %78
Looking to fold ._crit_edge112 into 
Killing Trivial BB: 

._crit_edge112:                                   ; preds = %.lr.ph111
  br label %82


INSTCOMBINE ITERATION #1 on main
ADD:   br i1 %25, label %.lr.ph, label %._crit_edge
ADD:   %25 = icmp slt i64 %24, %3
ADD:   %24 = add nuw nsw i64 %22, 1
ADD:   store i64 0, ptr %23, align 4
ADD:   %23 = getelementptr i64, ptr %20, i64 %22
ADD:   %22 = phi i64 [ %24, %.lr.ph ], [ 0, %0 ]
ADD:   br i1 %32, label %.lr.ph90, label %._crit_edge91
ADD:   %32 = icmp slt i64 %31, %5
ADD:   %31 = add nuw nsw i64 %29, 1
ADD:   store i64 0, ptr %30, align 4
ADD:   %30 = getelementptr i64, ptr %27, i64 %29
ADD:   %29 = phi i64 [ %31, %.lr.ph90 ], [ 0, %._crit_edge ]
ADD:   br i1 %39, label %.lr.ph93, label %._crit_edge94
ADD:   %39 = icmp slt i64 %38, %7
ADD:   %38 = add nuw nsw i64 %36, 1
ADD:   store i64 0, ptr %37, align 4
ADD:   %37 = getelementptr i64, ptr %34, i64 %36
ADD:   %36 = phi i64 [ %38, %.lr.ph93 ], [ 0, %._crit_edge91 ]
ADD:   br i1 %46, label %.lr.ph96, label %._crit_edge97
ADD:   %46 = icmp slt i64 %45, %9
ADD:   %45 = add nuw nsw i64 %43, 1
ADD:   store i64 0, ptr %44, align 4
ADD:   %44 = getelementptr i64, ptr %41, i64 %43
ADD:   %43 = phi i64 [ %45, %.lr.ph96 ], [ 0, %._crit_edge94 ]
ADD:   br i1 %53, label %.lr.ph99, label %._crit_edge100
ADD:   %53 = icmp slt i64 %52, %11
ADD:   %52 = add nuw nsw i64 %50, 1
ADD:   store i64 0, ptr %51, align 4
ADD:   %51 = getelementptr i64, ptr %48, i64 %50
ADD:   %50 = phi i64 [ %52, %.lr.ph99 ], [ 0, %._crit_edge97 ]
ADD:   br i1 %60, label %.lr.ph102, label %._crit_edge103
ADD:   %60 = icmp slt i64 %59, %13
ADD:   %59 = add nuw nsw i64 %57, 1
ADD:   store i64 0, ptr %58, align 4
ADD:   %58 = getelementptr i64, ptr %55, i64 %57
ADD:   %57 = phi i64 [ %59, %.lr.ph102 ], [ 0, %._crit_edge100 ]
ADD:   br i1 %67, label %.lr.ph105, label %._crit_edge106
ADD:   %67 = icmp slt i64 %66, %15
ADD:   %66 = add nuw nsw i64 %64, 1
ADD:   store i64 0, ptr %65, align 4
ADD:   %65 = getelementptr i64, ptr %62, i64 %64
ADD:   %64 = phi i64 [ %66, %.lr.ph105 ], [ 0, %._crit_edge103 ]
ADD:   br i1 %74, label %.lr.ph108, label %._crit_edge109
ADD:   %74 = icmp slt i64 %73, %17
ADD:   %73 = add nuw nsw i64 %71, 1
ADD:   store i64 0, ptr %72, align 4
ADD:   %72 = getelementptr i64, ptr %69, i64 %71
ADD:   %71 = phi i64 [ %73, %.lr.ph108 ], [ 0, %._crit_edge106 ]
ADD:   br i1 %81, label %.lr.ph111, label %._crit_edge112
ADD:   %81 = icmp slt i64 %80, %19
ADD:   %80 = add nuw nsw i64 %78, 1
ADD:   store double 0.000000e+00, ptr %79, align 8
ADD:   %79 = getelementptr double, ptr %76, i64 %78
ADD:   %78 = phi i64 [ %80, %.lr.ph111 ], [ 0, %._crit_edge109 ]
ADD:   ret void
ADD:   call void @comet_print_memref_f64(i64 1, ptr nonnull %82)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %75)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %68)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %61)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %54)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %47)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %33)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %26)
ADD:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %26, i64 1, ptr nonnull %33, i64 1, ptr nonnull %40, i64 1, ptr nonnull %47, i64 1, ptr nonnull %54, i64 1, ptr nonnull %61, i64 1, ptr nonnull %68, i64 1, ptr nonnull %75, i64 1, ptr nonnull %82, i32 1)
ADD:   store i64 1, ptr %.repack87, align 8
ADD:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4
ADD:   store i64 %19, ptr %.repack85, align 8
ADD:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 3
ADD:   store i64 0, ptr %.repack83, align 8
ADD:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 2
ADD:   store ptr %76, ptr %.repack81, align 8
ADD:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 1
ADD:   store ptr %76, ptr %82, align 8
ADD:   %82 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %77, label %.lr.ph111, label %._crit_edge112
ADD:   %77 = icmp slt i64 0, %19
ADD:   %76 = call ptr @malloc(i64 %.idx80)
ADD:   %.idx80 = shl i64 %19, 3
ADD:   store i64 1, ptr %.repack78, align 8
ADD:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 4
ADD:   store i64 %17, ptr %.repack76, align 8
ADD:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 3
ADD:   store i64 0, ptr %.repack74, align 8
ADD:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 2
ADD:   store ptr %69, ptr %.repack72, align 8
ADD:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 1
ADD:   store ptr %69, ptr %75, align 8
ADD:   %75 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %70, label %.lr.ph108, label %._crit_edge109
ADD:   %70 = icmp slt i64 0, %17
ADD:   %69 = call ptr @malloc(i64 %.idx71)
ADD:   %.idx71 = shl i64 %17, 3
ADD:   store i64 1, ptr %.repack69, align 8
ADD:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 4
ADD:   store i64 %15, ptr %.repack67, align 8
ADD:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 3
ADD:   store i64 0, ptr %.repack65, align 8
ADD:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 2
ADD:   store ptr %62, ptr %.repack63, align 8
ADD:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 1
ADD:   store ptr %62, ptr %68, align 8
ADD:   %68 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %63, label %.lr.ph105, label %._crit_edge106
ADD:   %63 = icmp slt i64 0, %15
ADD:   %62 = call ptr @malloc(i64 %.idx62)
ADD:   %.idx62 = shl i64 %15, 3
ADD:   store i64 1, ptr %.repack60, align 8
ADD:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 4
ADD:   store i64 %13, ptr %.repack58, align 8
ADD:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 3
ADD:   store i64 0, ptr %.repack56, align 8
ADD:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 2
ADD:   store ptr %55, ptr %.repack54, align 8
ADD:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 1
ADD:   store ptr %55, ptr %61, align 8
ADD:   %61 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %56, label %.lr.ph102, label %._crit_edge103
ADD:   %56 = icmp slt i64 0, %13
ADD:   %55 = call ptr @malloc(i64 %.idx53)
ADD:   %.idx53 = shl i64 %13, 3
ADD:   store i64 1, ptr %.repack51, align 8
ADD:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 4
ADD:   store i64 %11, ptr %.repack49, align 8
ADD:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 3
ADD:   store i64 0, ptr %.repack47, align 8
ADD:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 2
ADD:   store ptr %48, ptr %.repack45, align 8
ADD:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 1
ADD:   store ptr %48, ptr %54, align 8
ADD:   %54 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %49, label %.lr.ph99, label %._crit_edge100
ADD:   %49 = icmp slt i64 0, %11
ADD:   %48 = call ptr @malloc(i64 %.idx44)
ADD:   %.idx44 = shl i64 %11, 3
ADD:   store i64 1, ptr %.repack42, align 8
ADD:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 4
ADD:   store i64 %9, ptr %.repack40, align 8
ADD:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 3
ADD:   store i64 0, ptr %.repack38, align 8
ADD:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 2
ADD:   store ptr %41, ptr %.repack36, align 8
ADD:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 1
ADD:   store ptr %41, ptr %47, align 8
ADD:   %47 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %42, label %.lr.ph96, label %._crit_edge97
ADD:   %42 = icmp slt i64 0, %9
ADD:   %41 = call ptr @malloc(i64 %.idx35)
ADD:   %.idx35 = shl i64 %9, 3
ADD:   store i64 1, ptr %.repack33, align 8
ADD:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
ADD:   store i64 %7, ptr %.repack31, align 8
ADD:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
ADD:   store i64 0, ptr %.repack29, align 8
ADD:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
ADD:   store ptr %34, ptr %.repack27, align 8
ADD:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
ADD:   store ptr %34, ptr %40, align 8
ADD:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %35, label %.lr.ph93, label %._crit_edge94
ADD:   %35 = icmp slt i64 0, %7
ADD:   %34 = call ptr @malloc(i64 %.idx26)
ADD:   %.idx26 = shl i64 %7, 3
ADD:   store i64 1, ptr %.repack24, align 8
ADD:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 4
ADD:   store i64 %5, ptr %.repack22, align 8
ADD:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 3
ADD:   store i64 0, ptr %.repack20, align 8
ADD:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 2
ADD:   store ptr %27, ptr %.repack18, align 8
ADD:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 1
ADD:   store ptr %27, ptr %33, align 8
ADD:   %33 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %28, label %.lr.ph90, label %._crit_edge91
ADD:   %28 = icmp slt i64 0, %5
ADD:   %27 = call ptr @malloc(i64 %.idx17)
ADD:   %.idx17 = shl i64 %5, 3
ADD:   store i64 1, ptr %.repack15, align 8
ADD:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 4
ADD:   store i64 %3, ptr %.repack13, align 8
ADD:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 3
ADD:   store i64 0, ptr %.repack11, align 8
ADD:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 2
ADD:   store ptr %20, ptr %.repack9, align 8
ADD:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 1
ADD:   store ptr %20, ptr %26, align 8
ADD:   %26 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %21, label %.lr.ph, label %._crit_edge
ADD:   %21 = icmp slt i64 0, %3
ADD:   %20 = call ptr @malloc(i64 %.idx)
ADD:   %.idx = shl i64 %3, 3
ADD:   %19 = load i64, ptr %18, align 4
ADD:   %18 = getelementptr i64, ptr %1, i64 8
ADD:   %17 = load i64, ptr %16, align 4
ADD:   %16 = getelementptr i64, ptr %1, i64 7
ADD:   %15 = load i64, ptr %14, align 4
ADD:   %14 = getelementptr i64, ptr %1, i64 6
ADD:   %13 = load i64, ptr %12, align 4
ADD:   %12 = getelementptr i64, ptr %1, i64 5
ADD:   %11 = load i64, ptr %10, align 4
ADD:   %10 = getelementptr i64, ptr %1, i64 4
ADD:   %9 = load i64, ptr %8, align 4
ADD:   %8 = getelementptr i64, ptr %1, i64 3
ADD:   %7 = load i64, ptr %6, align 4
ADD:   %6 = getelementptr i64, ptr %1, i64 2
ADD:   %5 = load i64, ptr %4, align 4
ADD:   %4 = getelementptr i64, ptr %1, i64 1
ADD:   %3 = load i64, ptr %1, align 4
ADD:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
ADD:   store i64 1, ptr %.fca.4.0.gep, align 8
ADD:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
ADD:   store i64 7, ptr %.fca.3.0.gep, align 8
ADD:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
ADD:   store i64 0, ptr %.fca.2.gep, align 8
ADD:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
ADD:   store ptr %1, ptr %.fca.1.gep, align 8
ADD:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
ADD:   store ptr %1, ptr %2, align 8
ADD:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %1, ptr %2, align 8
IC: Visiting:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
IC: Visiting:   store ptr %1, ptr %.fca.1.gep, align 8
IC: Visiting:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.fca.2.gep, align 8
IC: Visiting:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
IC: Visiting:   store i64 7, ptr %.fca.3.0.gep, align 8
IC: Visiting:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
IC: Visiting:   store i64 1, ptr %.fca.4.0.gep, align 8
IC: Visiting:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
IC: Visiting:   %3 = load i64, ptr %1, align 4
IC: Visiting:   %4 = getelementptr i64, ptr %1, i64 1
IC: Visiting:   %5 = load i64, ptr %4, align 4
IC: Visiting:   %6 = getelementptr i64, ptr %1, i64 2
IC: Visiting:   %7 = load i64, ptr %6, align 4
IC: Visiting:   %8 = getelementptr i64, ptr %1, i64 3
IC: Visiting:   %9 = load i64, ptr %8, align 4
IC: Visiting:   %10 = getelementptr i64, ptr %1, i64 4
IC: Visiting:   %11 = load i64, ptr %10, align 4
IC: Visiting:   %12 = getelementptr i64, ptr %1, i64 5
IC: Visiting:   %13 = load i64, ptr %12, align 4
IC: Visiting:   %14 = getelementptr i64, ptr %1, i64 6
IC: Visiting:   %15 = load i64, ptr %14, align 4
IC: Visiting:   %16 = getelementptr i64, ptr %1, i64 7
IC: Visiting:   %17 = load i64, ptr %16, align 4
IC: Visiting:   %18 = getelementptr i64, ptr %1, i64 8
IC: Visiting:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %.idx = shl i64 %3, 3
IC: Visiting:   %20 = call ptr @malloc(i64 %.idx)
IC: Visiting:   %21 = icmp slt i64 0, %3
IC: Mod =   %21 = icmp slt i64 0, %3
    New =   %21 = icmp sgt i64 %3, 0
ADD:   %21 = icmp sgt i64 %3, 0
IC: Visiting:   %21 = icmp sgt i64 %3, 0
IC: Visiting:   br i1 %21, label %.lr.ph, label %._crit_edge
IC: Visiting:   %26 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %20, ptr %26, align 8
IC: Visiting:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 1
IC: Visiting:   store ptr %20, ptr %.repack9, align 8
IC: Visiting:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack11, align 8
IC: Visiting:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 3
IC: Visiting:   store i64 %3, ptr %.repack13, align 8
IC: Visiting:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack15, align 8
IC: Visiting:   %.idx17 = shl i64 %5, 3
IC: Visiting:   %27 = call ptr @malloc(i64 %.idx17)
IC: Visiting:   %28 = icmp slt i64 0, %5
IC: Mod =   %28 = icmp slt i64 0, %5
    New =   %28 = icmp sgt i64 %5, 0
ADD:   %28 = icmp sgt i64 %5, 0
IC: Visiting:   %28 = icmp sgt i64 %5, 0
IC: Visiting:   br i1 %28, label %.lr.ph90, label %._crit_edge91
IC: Visiting:   %33 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %27, ptr %33, align 8
IC: Visiting:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 1
IC: Visiting:   store ptr %27, ptr %.repack18, align 8
IC: Visiting:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack20, align 8
IC: Visiting:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 3
IC: Visiting:   store i64 %5, ptr %.repack22, align 8
IC: Visiting:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack24, align 8
IC: Visiting:   %.idx26 = shl i64 %7, 3
IC: Visiting:   %34 = call ptr @malloc(i64 %.idx26)
IC: Visiting:   %35 = icmp slt i64 0, %7
IC: Mod =   %35 = icmp slt i64 0, %7
    New =   %35 = icmp sgt i64 %7, 0
ADD:   %35 = icmp sgt i64 %7, 0
IC: Visiting:   %35 = icmp sgt i64 %7, 0
IC: Visiting:   br i1 %35, label %.lr.ph93, label %._crit_edge94
IC: Visiting:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %34, ptr %40, align 8
IC: Visiting:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
IC: Visiting:   store ptr %34, ptr %.repack27, align 8
IC: Visiting:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack29, align 8
IC: Visiting:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
IC: Visiting:   store i64 %7, ptr %.repack31, align 8
IC: Visiting:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack33, align 8
IC: Visiting:   %.idx35 = shl i64 %9, 3
IC: Visiting:   %41 = call ptr @malloc(i64 %.idx35)
IC: Visiting:   %42 = icmp slt i64 0, %9
IC: Mod =   %42 = icmp slt i64 0, %9
    New =   %42 = icmp sgt i64 %9, 0
ADD:   %42 = icmp sgt i64 %9, 0
IC: Visiting:   %42 = icmp sgt i64 %9, 0
IC: Visiting:   br i1 %42, label %.lr.ph96, label %._crit_edge97
IC: Visiting:   %47 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %41, ptr %47, align 8
IC: Visiting:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 1
IC: Visiting:   store ptr %41, ptr %.repack36, align 8
IC: Visiting:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack38, align 8
IC: Visiting:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 3
IC: Visiting:   store i64 %9, ptr %.repack40, align 8
IC: Visiting:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack42, align 8
IC: Visiting:   %.idx44 = shl i64 %11, 3
IC: Visiting:   %48 = call ptr @malloc(i64 %.idx44)
IC: Visiting:   %49 = icmp slt i64 0, %11
IC: Mod =   %49 = icmp slt i64 0, %11
    New =   %49 = icmp sgt i64 %11, 0
ADD:   %49 = icmp sgt i64 %11, 0
IC: Visiting:   %49 = icmp sgt i64 %11, 0
IC: Visiting:   br i1 %49, label %.lr.ph99, label %._crit_edge100
IC: Visiting:   %54 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %48, ptr %54, align 8
IC: Visiting:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 1
IC: Visiting:   store ptr %48, ptr %.repack45, align 8
IC: Visiting:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack47, align 8
IC: Visiting:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 3
IC: Visiting:   store i64 %11, ptr %.repack49, align 8
IC: Visiting:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack51, align 8
IC: Visiting:   %.idx53 = shl i64 %13, 3
IC: Visiting:   %55 = call ptr @malloc(i64 %.idx53)
IC: Visiting:   %56 = icmp slt i64 0, %13
IC: Mod =   %56 = icmp slt i64 0, %13
    New =   %56 = icmp sgt i64 %13, 0
ADD:   %56 = icmp sgt i64 %13, 0
IC: Visiting:   %56 = icmp sgt i64 %13, 0
IC: Visiting:   br i1 %56, label %.lr.ph102, label %._crit_edge103
IC: Visiting:   %61 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %55, ptr %61, align 8
IC: Visiting:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 1
IC: Visiting:   store ptr %55, ptr %.repack54, align 8
IC: Visiting:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack56, align 8
IC: Visiting:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 3
IC: Visiting:   store i64 %13, ptr %.repack58, align 8
IC: Visiting:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack60, align 8
IC: Visiting:   %.idx62 = shl i64 %15, 3
IC: Visiting:   %62 = call ptr @malloc(i64 %.idx62)
IC: Visiting:   %63 = icmp slt i64 0, %15
IC: Mod =   %63 = icmp slt i64 0, %15
    New =   %63 = icmp sgt i64 %15, 0
ADD:   %63 = icmp sgt i64 %15, 0
IC: Visiting:   %63 = icmp sgt i64 %15, 0
IC: Visiting:   br i1 %63, label %.lr.ph105, label %._crit_edge106
IC: Visiting:   %68 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %62, ptr %68, align 8
IC: Visiting:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 1
IC: Visiting:   store ptr %62, ptr %.repack63, align 8
IC: Visiting:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack65, align 8
IC: Visiting:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 3
IC: Visiting:   store i64 %15, ptr %.repack67, align 8
IC: Visiting:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack69, align 8
IC: Visiting:   %.idx71 = shl i64 %17, 3
IC: Visiting:   %69 = call ptr @malloc(i64 %.idx71)
IC: Visiting:   %70 = icmp slt i64 0, %17
IC: Mod =   %70 = icmp slt i64 0, %17
    New =   %70 = icmp sgt i64 %17, 0
ADD:   %70 = icmp sgt i64 %17, 0
IC: Visiting:   %70 = icmp sgt i64 %17, 0
IC: Visiting:   br i1 %70, label %.lr.ph108, label %._crit_edge109
IC: Visiting:   %75 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %69, ptr %75, align 8
IC: Visiting:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 1
IC: Visiting:   store ptr %69, ptr %.repack72, align 8
IC: Visiting:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack74, align 8
IC: Visiting:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 3
IC: Visiting:   store i64 %17, ptr %.repack76, align 8
IC: Visiting:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack78, align 8
IC: Visiting:   %.idx80 = shl i64 %19, 3
IC: Visiting:   %76 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   %77 = icmp slt i64 0, %19
IC: Mod =   %77 = icmp slt i64 0, %19
    New =   %77 = icmp sgt i64 %19, 0
ADD:   %77 = icmp sgt i64 %19, 0
IC: Visiting:   %77 = icmp sgt i64 %19, 0
IC: Visiting:   br i1 %77, label %.lr.ph111, label %._crit_edge112
IC: Visiting:   %82 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %76, ptr %82, align 8
IC: Visiting:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 1
IC: Visiting:   store ptr %76, ptr %.repack81, align 8
IC: Visiting:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack83, align 8
IC: Visiting:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 3
IC: Visiting:   store i64 %19, ptr %.repack85, align 8
IC: Visiting:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack87, align 8
IC: Visiting:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %26, i64 1, ptr nonnull %33, i64 1, ptr nonnull %40, i64 1, ptr nonnull %47, i64 1, ptr nonnull %54, i64 1, ptr nonnull %61, i64 1, ptr nonnull %68, i64 1, ptr nonnull %75, i64 1, ptr nonnull %82, i32 1)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %26)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %33)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %47)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %54)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %61)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %68)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %75)
IC: Visiting:   call void @comet_print_memref_f64(i64 1, ptr nonnull %82)
IC: Visiting:   ret void
IC: Visiting:   %78 = phi i64 [ %80, %.lr.ph111 ], [ 0, %._crit_edge109 ]
IC: Visiting:   %79 = getelementptr double, ptr %76, i64 %78
IC: Visiting:   store double 0.000000e+00, ptr %79, align 8
IC: Visiting:   %80 = add nuw nsw i64 %78, 1
IC: Visiting:   %81 = icmp slt i64 %80, %19
IC: Visiting:   br i1 %81, label %.lr.ph111, label %._crit_edge112
IC: Visiting:   %71 = phi i64 [ %73, %.lr.ph108 ], [ 0, %._crit_edge106 ]
IC: Visiting:   %72 = getelementptr i64, ptr %69, i64 %71
IC: Visiting:   store i64 0, ptr %72, align 4
IC: Visiting:   %73 = add nuw nsw i64 %71, 1
IC: Visiting:   %74 = icmp slt i64 %73, %17
IC: Visiting:   br i1 %74, label %.lr.ph108, label %._crit_edge109
IC: Visiting:   %64 = phi i64 [ %66, %.lr.ph105 ], [ 0, %._crit_edge103 ]
IC: Visiting:   %65 = getelementptr i64, ptr %62, i64 %64
IC: Visiting:   store i64 0, ptr %65, align 4
IC: Visiting:   %66 = add nuw nsw i64 %64, 1
IC: Visiting:   %67 = icmp slt i64 %66, %15
IC: Visiting:   br i1 %67, label %.lr.ph105, label %._crit_edge106
IC: Visiting:   %57 = phi i64 [ %59, %.lr.ph102 ], [ 0, %._crit_edge100 ]
IC: Visiting:   %58 = getelementptr i64, ptr %55, i64 %57
IC: Visiting:   store i64 0, ptr %58, align 4
IC: Visiting:   %59 = add nuw nsw i64 %57, 1
IC: Visiting:   %60 = icmp slt i64 %59, %13
IC: Visiting:   br i1 %60, label %.lr.ph102, label %._crit_edge103
IC: Visiting:   %50 = phi i64 [ %52, %.lr.ph99 ], [ 0, %._crit_edge97 ]
IC: Visiting:   %51 = getelementptr i64, ptr %48, i64 %50
IC: Visiting:   store i64 0, ptr %51, align 4
IC: Visiting:   %52 = add nuw nsw i64 %50, 1
IC: Visiting:   %53 = icmp slt i64 %52, %11
IC: Visiting:   br i1 %53, label %.lr.ph99, label %._crit_edge100
IC: Visiting:   %43 = phi i64 [ %45, %.lr.ph96 ], [ 0, %._crit_edge94 ]
IC: Visiting:   %44 = getelementptr i64, ptr %41, i64 %43
IC: Visiting:   store i64 0, ptr %44, align 4
IC: Visiting:   %45 = add nuw nsw i64 %43, 1
IC: Visiting:   %46 = icmp slt i64 %45, %9
IC: Visiting:   br i1 %46, label %.lr.ph96, label %._crit_edge97
IC: Visiting:   %36 = phi i64 [ %38, %.lr.ph93 ], [ 0, %._crit_edge91 ]
IC: Visiting:   %37 = getelementptr i64, ptr %34, i64 %36
IC: Visiting:   store i64 0, ptr %37, align 4
IC: Visiting:   %38 = add nuw nsw i64 %36, 1
IC: Visiting:   %39 = icmp slt i64 %38, %7
IC: Visiting:   br i1 %39, label %.lr.ph93, label %._crit_edge94
IC: Visiting:   %29 = phi i64 [ %31, %.lr.ph90 ], [ 0, %._crit_edge ]
IC: Visiting:   %30 = getelementptr i64, ptr %27, i64 %29
IC: Visiting:   store i64 0, ptr %30, align 4
IC: Visiting:   %31 = add nuw nsw i64 %29, 1
IC: Visiting:   %32 = icmp slt i64 %31, %5
IC: Visiting:   br i1 %32, label %.lr.ph90, label %._crit_edge91
IC: Visiting:   %22 = phi i64 [ %24, %.lr.ph ], [ 0, %0 ]
IC: Visiting:   %23 = getelementptr i64, ptr %20, i64 %22
IC: Visiting:   store i64 0, ptr %23, align 4
IC: Visiting:   %24 = add nuw nsw i64 %22, 1
IC: Visiting:   %25 = icmp slt i64 %24, %3
IC: Visiting:   br i1 %25, label %.lr.ph, label %._crit_edge


INSTCOMBINE ITERATION #2 on main
ADD:   br i1 %25, label %.lr.ph, label %._crit_edge
ADD:   %25 = icmp slt i64 %24, %3
ADD:   %24 = add nuw nsw i64 %22, 1
ADD:   store i64 0, ptr %23, align 4
ADD:   %23 = getelementptr i64, ptr %20, i64 %22
ADD:   %22 = phi i64 [ %24, %.lr.ph ], [ 0, %0 ]
ADD:   br i1 %32, label %.lr.ph90, label %._crit_edge91
ADD:   %32 = icmp slt i64 %31, %5
ADD:   %31 = add nuw nsw i64 %29, 1
ADD:   store i64 0, ptr %30, align 4
ADD:   %30 = getelementptr i64, ptr %27, i64 %29
ADD:   %29 = phi i64 [ %31, %.lr.ph90 ], [ 0, %._crit_edge ]
ADD:   br i1 %39, label %.lr.ph93, label %._crit_edge94
ADD:   %39 = icmp slt i64 %38, %7
ADD:   %38 = add nuw nsw i64 %36, 1
ADD:   store i64 0, ptr %37, align 4
ADD:   %37 = getelementptr i64, ptr %34, i64 %36
ADD:   %36 = phi i64 [ %38, %.lr.ph93 ], [ 0, %._crit_edge91 ]
ADD:   br i1 %46, label %.lr.ph96, label %._crit_edge97
ADD:   %46 = icmp slt i64 %45, %9
ADD:   %45 = add nuw nsw i64 %43, 1
ADD:   store i64 0, ptr %44, align 4
ADD:   %44 = getelementptr i64, ptr %41, i64 %43
ADD:   %43 = phi i64 [ %45, %.lr.ph96 ], [ 0, %._crit_edge94 ]
ADD:   br i1 %53, label %.lr.ph99, label %._crit_edge100
ADD:   %53 = icmp slt i64 %52, %11
ADD:   %52 = add nuw nsw i64 %50, 1
ADD:   store i64 0, ptr %51, align 4
ADD:   %51 = getelementptr i64, ptr %48, i64 %50
ADD:   %50 = phi i64 [ %52, %.lr.ph99 ], [ 0, %._crit_edge97 ]
ADD:   br i1 %60, label %.lr.ph102, label %._crit_edge103
ADD:   %60 = icmp slt i64 %59, %13
ADD:   %59 = add nuw nsw i64 %57, 1
ADD:   store i64 0, ptr %58, align 4
ADD:   %58 = getelementptr i64, ptr %55, i64 %57
ADD:   %57 = phi i64 [ %59, %.lr.ph102 ], [ 0, %._crit_edge100 ]
ADD:   br i1 %67, label %.lr.ph105, label %._crit_edge106
ADD:   %67 = icmp slt i64 %66, %15
ADD:   %66 = add nuw nsw i64 %64, 1
ADD:   store i64 0, ptr %65, align 4
ADD:   %65 = getelementptr i64, ptr %62, i64 %64
ADD:   %64 = phi i64 [ %66, %.lr.ph105 ], [ 0, %._crit_edge103 ]
ADD:   br i1 %74, label %.lr.ph108, label %._crit_edge109
ADD:   %74 = icmp slt i64 %73, %17
ADD:   %73 = add nuw nsw i64 %71, 1
ADD:   store i64 0, ptr %72, align 4
ADD:   %72 = getelementptr i64, ptr %69, i64 %71
ADD:   %71 = phi i64 [ %73, %.lr.ph108 ], [ 0, %._crit_edge106 ]
ADD:   br i1 %81, label %.lr.ph111, label %._crit_edge112
ADD:   %81 = icmp slt i64 %80, %19
ADD:   %80 = add nuw nsw i64 %78, 1
ADD:   store double 0.000000e+00, ptr %79, align 8
ADD:   %79 = getelementptr double, ptr %76, i64 %78
ADD:   %78 = phi i64 [ %80, %.lr.ph111 ], [ 0, %._crit_edge109 ]
ADD:   ret void
ADD:   call void @comet_print_memref_f64(i64 1, ptr nonnull %82)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %75)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %68)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %61)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %54)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %47)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %33)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %26)
ADD:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %26, i64 1, ptr nonnull %33, i64 1, ptr nonnull %40, i64 1, ptr nonnull %47, i64 1, ptr nonnull %54, i64 1, ptr nonnull %61, i64 1, ptr nonnull %68, i64 1, ptr nonnull %75, i64 1, ptr nonnull %82, i32 1)
ADD:   store i64 1, ptr %.repack87, align 8
ADD:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4
ADD:   store i64 %19, ptr %.repack85, align 8
ADD:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 3
ADD:   store i64 0, ptr %.repack83, align 8
ADD:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 2
ADD:   store ptr %76, ptr %.repack81, align 8
ADD:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 1
ADD:   store ptr %76, ptr %82, align 8
ADD:   %82 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %77, label %.lr.ph111, label %._crit_edge112
ADD:   %77 = icmp sgt i64 %19, 0
ADD:   %76 = call ptr @malloc(i64 %.idx80)
ADD:   %.idx80 = shl i64 %19, 3
ADD:   store i64 1, ptr %.repack78, align 8
ADD:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 4
ADD:   store i64 %17, ptr %.repack76, align 8
ADD:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 3
ADD:   store i64 0, ptr %.repack74, align 8
ADD:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 2
ADD:   store ptr %69, ptr %.repack72, align 8
ADD:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 1
ADD:   store ptr %69, ptr %75, align 8
ADD:   %75 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %70, label %.lr.ph108, label %._crit_edge109
ADD:   %70 = icmp sgt i64 %17, 0
ADD:   %69 = call ptr @malloc(i64 %.idx71)
ADD:   %.idx71 = shl i64 %17, 3
ADD:   store i64 1, ptr %.repack69, align 8
ADD:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 4
ADD:   store i64 %15, ptr %.repack67, align 8
ADD:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 3
ADD:   store i64 0, ptr %.repack65, align 8
ADD:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 2
ADD:   store ptr %62, ptr %.repack63, align 8
ADD:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 1
ADD:   store ptr %62, ptr %68, align 8
ADD:   %68 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %63, label %.lr.ph105, label %._crit_edge106
ADD:   %63 = icmp sgt i64 %15, 0
ADD:   %62 = call ptr @malloc(i64 %.idx62)
ADD:   %.idx62 = shl i64 %15, 3
ADD:   store i64 1, ptr %.repack60, align 8
ADD:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 4
ADD:   store i64 %13, ptr %.repack58, align 8
ADD:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 3
ADD:   store i64 0, ptr %.repack56, align 8
ADD:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 2
ADD:   store ptr %55, ptr %.repack54, align 8
ADD:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 1
ADD:   store ptr %55, ptr %61, align 8
ADD:   %61 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %56, label %.lr.ph102, label %._crit_edge103
ADD:   %56 = icmp sgt i64 %13, 0
ADD:   %55 = call ptr @malloc(i64 %.idx53)
ADD:   %.idx53 = shl i64 %13, 3
ADD:   store i64 1, ptr %.repack51, align 8
ADD:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 4
ADD:   store i64 %11, ptr %.repack49, align 8
ADD:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 3
ADD:   store i64 0, ptr %.repack47, align 8
ADD:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 2
ADD:   store ptr %48, ptr %.repack45, align 8
ADD:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 1
ADD:   store ptr %48, ptr %54, align 8
ADD:   %54 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %49, label %.lr.ph99, label %._crit_edge100
ADD:   %49 = icmp sgt i64 %11, 0
ADD:   %48 = call ptr @malloc(i64 %.idx44)
ADD:   %.idx44 = shl i64 %11, 3
ADD:   store i64 1, ptr %.repack42, align 8
ADD:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 4
ADD:   store i64 %9, ptr %.repack40, align 8
ADD:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 3
ADD:   store i64 0, ptr %.repack38, align 8
ADD:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 2
ADD:   store ptr %41, ptr %.repack36, align 8
ADD:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 1
ADD:   store ptr %41, ptr %47, align 8
ADD:   %47 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %42, label %.lr.ph96, label %._crit_edge97
ADD:   %42 = icmp sgt i64 %9, 0
ADD:   %41 = call ptr @malloc(i64 %.idx35)
ADD:   %.idx35 = shl i64 %9, 3
ADD:   store i64 1, ptr %.repack33, align 8
ADD:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
ADD:   store i64 %7, ptr %.repack31, align 8
ADD:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
ADD:   store i64 0, ptr %.repack29, align 8
ADD:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
ADD:   store ptr %34, ptr %.repack27, align 8
ADD:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
ADD:   store ptr %34, ptr %40, align 8
ADD:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %35, label %.lr.ph93, label %._crit_edge94
ADD:   %35 = icmp sgt i64 %7, 0
ADD:   %34 = call ptr @malloc(i64 %.idx26)
ADD:   %.idx26 = shl i64 %7, 3
ADD:   store i64 1, ptr %.repack24, align 8
ADD:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 4
ADD:   store i64 %5, ptr %.repack22, align 8
ADD:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 3
ADD:   store i64 0, ptr %.repack20, align 8
ADD:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 2
ADD:   store ptr %27, ptr %.repack18, align 8
ADD:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 1
ADD:   store ptr %27, ptr %33, align 8
ADD:   %33 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %28, label %.lr.ph90, label %._crit_edge91
ADD:   %28 = icmp sgt i64 %5, 0
ADD:   %27 = call ptr @malloc(i64 %.idx17)
ADD:   %.idx17 = shl i64 %5, 3
ADD:   store i64 1, ptr %.repack15, align 8
ADD:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 4
ADD:   store i64 %3, ptr %.repack13, align 8
ADD:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 3
ADD:   store i64 0, ptr %.repack11, align 8
ADD:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 2
ADD:   store ptr %20, ptr %.repack9, align 8
ADD:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 1
ADD:   store ptr %20, ptr %26, align 8
ADD:   %26 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %21, label %.lr.ph, label %._crit_edge
ADD:   %21 = icmp sgt i64 %3, 0
ADD:   %20 = call ptr @malloc(i64 %.idx)
ADD:   %.idx = shl i64 %3, 3
ADD:   %19 = load i64, ptr %18, align 4
ADD:   %18 = getelementptr i64, ptr %1, i64 8
ADD:   %17 = load i64, ptr %16, align 4
ADD:   %16 = getelementptr i64, ptr %1, i64 7
ADD:   %15 = load i64, ptr %14, align 4
ADD:   %14 = getelementptr i64, ptr %1, i64 6
ADD:   %13 = load i64, ptr %12, align 4
ADD:   %12 = getelementptr i64, ptr %1, i64 5
ADD:   %11 = load i64, ptr %10, align 4
ADD:   %10 = getelementptr i64, ptr %1, i64 4
ADD:   %9 = load i64, ptr %8, align 4
ADD:   %8 = getelementptr i64, ptr %1, i64 3
ADD:   %7 = load i64, ptr %6, align 4
ADD:   %6 = getelementptr i64, ptr %1, i64 2
ADD:   %5 = load i64, ptr %4, align 4
ADD:   %4 = getelementptr i64, ptr %1, i64 1
ADD:   %3 = load i64, ptr %1, align 4
ADD:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
ADD:   store i64 1, ptr %.fca.4.0.gep, align 8
ADD:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
ADD:   store i64 7, ptr %.fca.3.0.gep, align 8
ADD:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
ADD:   store i64 0, ptr %.fca.2.gep, align 8
ADD:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
ADD:   store ptr %1, ptr %.fca.1.gep, align 8
ADD:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
ADD:   store ptr %1, ptr %2, align 8
ADD:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %1, ptr %2, align 8
IC: Visiting:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
IC: Visiting:   store ptr %1, ptr %.fca.1.gep, align 8
IC: Visiting:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.fca.2.gep, align 8
IC: Visiting:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
IC: Visiting:   store i64 7, ptr %.fca.3.0.gep, align 8
IC: Visiting:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
IC: Visiting:   store i64 1, ptr %.fca.4.0.gep, align 8
IC: Visiting:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
IC: Visiting:   %3 = load i64, ptr %1, align 4
IC: Visiting:   %4 = getelementptr i64, ptr %1, i64 1
IC: Visiting:   %5 = load i64, ptr %4, align 4
IC: Visiting:   %6 = getelementptr i64, ptr %1, i64 2
IC: Visiting:   %7 = load i64, ptr %6, align 4
IC: Visiting:   %8 = getelementptr i64, ptr %1, i64 3
IC: Visiting:   %9 = load i64, ptr %8, align 4
IC: Visiting:   %10 = getelementptr i64, ptr %1, i64 4
IC: Visiting:   %11 = load i64, ptr %10, align 4
IC: Visiting:   %12 = getelementptr i64, ptr %1, i64 5
IC: Visiting:   %13 = load i64, ptr %12, align 4
IC: Visiting:   %14 = getelementptr i64, ptr %1, i64 6
IC: Visiting:   %15 = load i64, ptr %14, align 4
IC: Visiting:   %16 = getelementptr i64, ptr %1, i64 7
IC: Visiting:   %17 = load i64, ptr %16, align 4
IC: Visiting:   %18 = getelementptr i64, ptr %1, i64 8
IC: Visiting:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %.idx = shl i64 %3, 3
IC: Visiting:   %20 = call ptr @malloc(i64 %.idx)
IC: Visiting:   %21 = icmp sgt i64 %3, 0
IC: Visiting:   br i1 %21, label %.lr.ph, label %._crit_edge
IC: Visiting:   %26 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %20, ptr %26, align 8
IC: Visiting:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 1
IC: Visiting:   store ptr %20, ptr %.repack9, align 8
IC: Visiting:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack11, align 8
IC: Visiting:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 3
IC: Visiting:   store i64 %3, ptr %.repack13, align 8
IC: Visiting:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %26, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack15, align 8
IC: Visiting:   %.idx17 = shl i64 %5, 3
IC: Visiting:   %27 = call ptr @malloc(i64 %.idx17)
IC: Visiting:   %28 = icmp sgt i64 %5, 0
IC: Visiting:   br i1 %28, label %.lr.ph90, label %._crit_edge91
IC: Visiting:   %33 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %27, ptr %33, align 8
IC: Visiting:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 1
IC: Visiting:   store ptr %27, ptr %.repack18, align 8
IC: Visiting:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack20, align 8
IC: Visiting:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 3
IC: Visiting:   store i64 %5, ptr %.repack22, align 8
IC: Visiting:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %33, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack24, align 8
IC: Visiting:   %.idx26 = shl i64 %7, 3
IC: Visiting:   %34 = call ptr @malloc(i64 %.idx26)
IC: Visiting:   %35 = icmp sgt i64 %7, 0
IC: Visiting:   br i1 %35, label %.lr.ph93, label %._crit_edge94
IC: Visiting:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %34, ptr %40, align 8
IC: Visiting:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
IC: Visiting:   store ptr %34, ptr %.repack27, align 8
IC: Visiting:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack29, align 8
IC: Visiting:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
IC: Visiting:   store i64 %7, ptr %.repack31, align 8
IC: Visiting:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack33, align 8
IC: Visiting:   %.idx35 = shl i64 %9, 3
IC: Visiting:   %41 = call ptr @malloc(i64 %.idx35)
IC: Visiting:   %42 = icmp sgt i64 %9, 0
IC: Visiting:   br i1 %42, label %.lr.ph96, label %._crit_edge97
IC: Visiting:   %47 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %41, ptr %47, align 8
IC: Visiting:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 1
IC: Visiting:   store ptr %41, ptr %.repack36, align 8
IC: Visiting:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack38, align 8
IC: Visiting:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 3
IC: Visiting:   store i64 %9, ptr %.repack40, align 8
IC: Visiting:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %47, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack42, align 8
IC: Visiting:   %.idx44 = shl i64 %11, 3
IC: Visiting:   %48 = call ptr @malloc(i64 %.idx44)
IC: Visiting:   %49 = icmp sgt i64 %11, 0
IC: Visiting:   br i1 %49, label %.lr.ph99, label %._crit_edge100
IC: Visiting:   %54 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %48, ptr %54, align 8
IC: Visiting:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 1
IC: Visiting:   store ptr %48, ptr %.repack45, align 8
IC: Visiting:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack47, align 8
IC: Visiting:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 3
IC: Visiting:   store i64 %11, ptr %.repack49, align 8
IC: Visiting:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %54, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack51, align 8
IC: Visiting:   %.idx53 = shl i64 %13, 3
IC: Visiting:   %55 = call ptr @malloc(i64 %.idx53)
IC: Visiting:   %56 = icmp sgt i64 %13, 0
IC: Visiting:   br i1 %56, label %.lr.ph102, label %._crit_edge103
IC: Visiting:   %61 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %55, ptr %61, align 8
IC: Visiting:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 1
IC: Visiting:   store ptr %55, ptr %.repack54, align 8
IC: Visiting:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack56, align 8
IC: Visiting:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 3
IC: Visiting:   store i64 %13, ptr %.repack58, align 8
IC: Visiting:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %61, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack60, align 8
IC: Visiting:   %.idx62 = shl i64 %15, 3
IC: Visiting:   %62 = call ptr @malloc(i64 %.idx62)
IC: Visiting:   %63 = icmp sgt i64 %15, 0
IC: Visiting:   br i1 %63, label %.lr.ph105, label %._crit_edge106
IC: Visiting:   %68 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %62, ptr %68, align 8
IC: Visiting:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 1
IC: Visiting:   store ptr %62, ptr %.repack63, align 8
IC: Visiting:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack65, align 8
IC: Visiting:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 3
IC: Visiting:   store i64 %15, ptr %.repack67, align 8
IC: Visiting:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %68, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack69, align 8
IC: Visiting:   %.idx71 = shl i64 %17, 3
IC: Visiting:   %69 = call ptr @malloc(i64 %.idx71)
IC: Visiting:   %70 = icmp sgt i64 %17, 0
IC: Visiting:   br i1 %70, label %.lr.ph108, label %._crit_edge109
IC: Visiting:   %75 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %69, ptr %75, align 8
IC: Visiting:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 1
IC: Visiting:   store ptr %69, ptr %.repack72, align 8
IC: Visiting:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack74, align 8
IC: Visiting:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 3
IC: Visiting:   store i64 %17, ptr %.repack76, align 8
IC: Visiting:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %75, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack78, align 8
IC: Visiting:   %.idx80 = shl i64 %19, 3
IC: Visiting:   %76 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   %77 = icmp sgt i64 %19, 0
IC: Visiting:   br i1 %77, label %.lr.ph111, label %._crit_edge112
IC: Visiting:   %82 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %76, ptr %82, align 8
IC: Visiting:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 1
IC: Visiting:   store ptr %76, ptr %.repack81, align 8
IC: Visiting:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack83, align 8
IC: Visiting:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 3
IC: Visiting:   store i64 %19, ptr %.repack85, align 8
IC: Visiting:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %82, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack87, align 8
IC: Visiting:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %26, i64 1, ptr nonnull %33, i64 1, ptr nonnull %40, i64 1, ptr nonnull %47, i64 1, ptr nonnull %54, i64 1, ptr nonnull %61, i64 1, ptr nonnull %68, i64 1, ptr nonnull %75, i64 1, ptr nonnull %82, i32 1)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %26)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %33)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %47)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %54)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %61)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %68)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %75)
IC: Visiting:   call void @comet_print_memref_f64(i64 1, ptr nonnull %82)
IC: Visiting:   ret void
IC: Visiting:   %78 = phi i64 [ %80, %.lr.ph111 ], [ 0, %._crit_edge109 ]
IC: Visiting:   %79 = getelementptr double, ptr %76, i64 %78
IC: Visiting:   store double 0.000000e+00, ptr %79, align 8
IC: Visiting:   %80 = add nuw nsw i64 %78, 1
IC: Visiting:   %81 = icmp slt i64 %80, %19
IC: Visiting:   br i1 %81, label %.lr.ph111, label %._crit_edge112
IC: Visiting:   %71 = phi i64 [ %73, %.lr.ph108 ], [ 0, %._crit_edge106 ]
IC: Visiting:   %72 = getelementptr i64, ptr %69, i64 %71
IC: Visiting:   store i64 0, ptr %72, align 4
IC: Visiting:   %73 = add nuw nsw i64 %71, 1
IC: Visiting:   %74 = icmp slt i64 %73, %17
IC: Visiting:   br i1 %74, label %.lr.ph108, label %._crit_edge109
IC: Visiting:   %64 = phi i64 [ %66, %.lr.ph105 ], [ 0, %._crit_edge103 ]
IC: Visiting:   %65 = getelementptr i64, ptr %62, i64 %64
IC: Visiting:   store i64 0, ptr %65, align 4
IC: Visiting:   %66 = add nuw nsw i64 %64, 1
IC: Visiting:   %67 = icmp slt i64 %66, %15
IC: Visiting:   br i1 %67, label %.lr.ph105, label %._crit_edge106
IC: Visiting:   %57 = phi i64 [ %59, %.lr.ph102 ], [ 0, %._crit_edge100 ]
IC: Visiting:   %58 = getelementptr i64, ptr %55, i64 %57
IC: Visiting:   store i64 0, ptr %58, align 4
IC: Visiting:   %59 = add nuw nsw i64 %57, 1
IC: Visiting:   %60 = icmp slt i64 %59, %13
IC: Visiting:   br i1 %60, label %.lr.ph102, label %._crit_edge103
IC: Visiting:   %50 = phi i64 [ %52, %.lr.ph99 ], [ 0, %._crit_edge97 ]
IC: Visiting:   %51 = getelementptr i64, ptr %48, i64 %50
IC: Visiting:   store i64 0, ptr %51, align 4
IC: Visiting:   %52 = add nuw nsw i64 %50, 1
IC: Visiting:   %53 = icmp slt i64 %52, %11
IC: Visiting:   br i1 %53, label %.lr.ph99, label %._crit_edge100
IC: Visiting:   %43 = phi i64 [ %45, %.lr.ph96 ], [ 0, %._crit_edge94 ]
IC: Visiting:   %44 = getelementptr i64, ptr %41, i64 %43
IC: Visiting:   store i64 0, ptr %44, align 4
IC: Visiting:   %45 = add nuw nsw i64 %43, 1
IC: Visiting:   %46 = icmp slt i64 %45, %9
IC: Visiting:   br i1 %46, label %.lr.ph96, label %._crit_edge97
IC: Visiting:   %36 = phi i64 [ %38, %.lr.ph93 ], [ 0, %._crit_edge91 ]
IC: Visiting:   %37 = getelementptr i64, ptr %34, i64 %36
IC: Visiting:   store i64 0, ptr %37, align 4
IC: Visiting:   %38 = add nuw nsw i64 %36, 1
IC: Visiting:   %39 = icmp slt i64 %38, %7
IC: Visiting:   br i1 %39, label %.lr.ph93, label %._crit_edge94
IC: Visiting:   %29 = phi i64 [ %31, %.lr.ph90 ], [ 0, %._crit_edge ]
IC: Visiting:   %30 = getelementptr i64, ptr %27, i64 %29
IC: Visiting:   store i64 0, ptr %30, align 4
IC: Visiting:   %31 = add nuw nsw i64 %29, 1
IC: Visiting:   %32 = icmp slt i64 %31, %5
IC: Visiting:   br i1 %32, label %.lr.ph90, label %._crit_edge91
IC: Visiting:   %22 = phi i64 [ %24, %.lr.ph ], [ 0, %0 ]
IC: Visiting:   %23 = getelementptr i64, ptr %20, i64 %22
IC: Visiting:   store i64 0, ptr %23, align 4
IC: Visiting:   %24 = add nuw nsw i64 %22, 1
IC: Visiting:   %25 = icmp slt i64 %24, %3
IC: Visiting:   br i1 %25, label %.lr.ph, label %._crit_edge
LoopSimplify: Creating pre-header .lr.ph111.preheader
LoopSimplify: Creating dedicated exit block ._crit_edge112.loopexit
LoopSimplify: Creating pre-header .lr.ph108.preheader
LoopSimplify: Creating dedicated exit block ._crit_edge109.loopexit
LoopSimplify: Creating pre-header .lr.ph105.preheader
LoopSimplify: Creating dedicated exit block ._crit_edge106.loopexit
LoopSimplify: Creating pre-header .lr.ph102.preheader
LoopSimplify: Creating dedicated exit block ._crit_edge103.loopexit
LoopSimplify: Creating pre-header .lr.ph99.preheader
LoopSimplify: Creating dedicated exit block ._crit_edge100.loopexit
LoopSimplify: Creating pre-header .lr.ph96.preheader
LoopSimplify: Creating dedicated exit block ._crit_edge97.loopexit
LoopSimplify: Creating pre-header .lr.ph93.preheader
LoopSimplify: Creating dedicated exit block ._crit_edge94.loopexit
LoopSimplify: Creating pre-header .lr.ph90.preheader
LoopSimplify: Creating dedicated exit block ._crit_edge91.loopexit
LoopSimplify: Creating pre-header .lr.ph.preheader
LoopSimplify: Creating dedicated exit block ._crit_edge.loopexit
loop-idiom Scanning: F[main] Countable Loop %.lr.ph
  Formed memset:   call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %22, i1 false)
    from store to: {%20,+,8}<%.lr.ph> at:   store i64 0, ptr %24, align 4
Analyzing Loop for deletion: Loop at depth 1 containing: %.lr.ph<header><latch><exiting>
Loop is invariant, delete it!
Inserting edge %.lr.ph.preheader -> %._crit_edge.loopexit
	Reachable %.lr.ph.preheader -> %._crit_edge.loopexit
		NCA == %.lr.ph.preheader
Mark %._crit_edge.loopexitas affected, CurrentLevel 3
	Successor %._crit_edge, level = 1
Updating NCD = %.lr.ph.preheader
	IDom(%._crit_edge.loopexit) = %.lr.ph.preheader
Deleting edge %.lr.ph.preheader -> %.lr.ph
	NCD %.lr.ph.preheader, ToIDom %.lr.ph.preheader
IsReachableFromIDom %.lr.ph
	Pred %.lr.ph
	Support %.lr.ph
Deleting unreachable subtree %.lr.ph
Processing affected node %._crit_edge.loopexit with NCD = %.lr.ph.preheader, MinNode =%.lr.ph
Erasing node %.lr.ph
DeleteUnreachable: running DFS with MinNode = %.lr.ph.preheader
Previous IDom(MinNode) = %0
Running Semi-NCA
loop-idiom Scanning: F[main] Countable Loop %.lr.ph90
  Formed memset:   call void @llvm.memset.p0.i64(ptr align 4 %24, i8 0, i64 %26, i1 false)
    from store to: {%24,+,8}<%.lr.ph90> at:   store i64 0, ptr %28, align 4
Analyzing Loop for deletion: Loop at depth 1 containing: %.lr.ph90<header><latch><exiting>
Loop is invariant, delete it!
Inserting edge %.lr.ph90.preheader -> %._crit_edge91.loopexit
	Reachable %.lr.ph90.preheader -> %._crit_edge91.loopexit
		NCA == %.lr.ph90.preheader
Mark %._crit_edge91.loopexitas affected, CurrentLevel 4
	Successor %._crit_edge91, level = 2
Updating NCD = %.lr.ph90.preheader
	IDom(%._crit_edge91.loopexit) = %.lr.ph90.preheader
Deleting edge %.lr.ph90.preheader -> %.lr.ph90
	NCD %.lr.ph90.preheader, ToIDom %.lr.ph90.preheader
IsReachableFromIDom %.lr.ph90
	Pred %.lr.ph90
	Support %.lr.ph90
Deleting unreachable subtree %.lr.ph90
Processing affected node %._crit_edge91.loopexit with NCD = %.lr.ph90.preheader, MinNode =%.lr.ph90
Erasing node %.lr.ph90
DeleteUnreachable: running DFS with MinNode = %.lr.ph90.preheader
Previous IDom(MinNode) = %._crit_edge
Running Semi-NCA
loop-idiom Scanning: F[main] Countable Loop %.lr.ph93
  Formed memset:   call void @llvm.memset.p0.i64(ptr align 4 %28, i8 0, i64 %30, i1 false)
    from store to: {%28,+,8}<%.lr.ph93> at:   store i64 0, ptr %32, align 4
Analyzing Loop for deletion: Loop at depth 1 containing: %.lr.ph93<header><latch><exiting>
Loop is invariant, delete it!
Inserting edge %.lr.ph93.preheader -> %._crit_edge94.loopexit
	Reachable %.lr.ph93.preheader -> %._crit_edge94.loopexit
		NCA == %.lr.ph93.preheader
Mark %._crit_edge94.loopexitas affected, CurrentLevel 5
	Successor %._crit_edge94, level = 3
Updating NCD = %.lr.ph93.preheader
	IDom(%._crit_edge94.loopexit) = %.lr.ph93.preheader
Deleting edge %.lr.ph93.preheader -> %.lr.ph93
	NCD %.lr.ph93.preheader, ToIDom %.lr.ph93.preheader
IsReachableFromIDom %.lr.ph93
	Pred %.lr.ph93
	Support %.lr.ph93
Deleting unreachable subtree %.lr.ph93
Processing affected node %._crit_edge94.loopexit with NCD = %.lr.ph93.preheader, MinNode =%.lr.ph93
Erasing node %.lr.ph93
DeleteUnreachable: running DFS with MinNode = %.lr.ph93.preheader
Previous IDom(MinNode) = %._crit_edge91
Running Semi-NCA
loop-idiom Scanning: F[main] Countable Loop %.lr.ph96
  Formed memset:   call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %34, i1 false)
    from store to: {%32,+,8}<%.lr.ph96> at:   store i64 0, ptr %36, align 4
Analyzing Loop for deletion: Loop at depth 1 containing: %.lr.ph96<header><latch><exiting>
Loop is invariant, delete it!
Inserting edge %.lr.ph96.preheader -> %._crit_edge97.loopexit
	Reachable %.lr.ph96.preheader -> %._crit_edge97.loopexit
		NCA == %.lr.ph96.preheader
Mark %._crit_edge97.loopexitas affected, CurrentLevel 6
	Successor %._crit_edge97, level = 4
Updating NCD = %.lr.ph96.preheader
	IDom(%._crit_edge97.loopexit) = %.lr.ph96.preheader
Deleting edge %.lr.ph96.preheader -> %.lr.ph96
	NCD %.lr.ph96.preheader, ToIDom %.lr.ph96.preheader
IsReachableFromIDom %.lr.ph96
	Pred %.lr.ph96
	Support %.lr.ph96
Deleting unreachable subtree %.lr.ph96
Processing affected node %._crit_edge97.loopexit with NCD = %.lr.ph96.preheader, MinNode =%.lr.ph96
Erasing node %.lr.ph96
DeleteUnreachable: running DFS with MinNode = %.lr.ph96.preheader
Previous IDom(MinNode) = %._crit_edge94
Running Semi-NCA
loop-idiom Scanning: F[main] Countable Loop %.lr.ph99
  Formed memset:   call void @llvm.memset.p0.i64(ptr align 4 %36, i8 0, i64 %38, i1 false)
    from store to: {%36,+,8}<%.lr.ph99> at:   store i64 0, ptr %40, align 4
Analyzing Loop for deletion: Loop at depth 1 containing: %.lr.ph99<header><latch><exiting>
Loop is invariant, delete it!
Inserting edge %.lr.ph99.preheader -> %._crit_edge100.loopexit
	Reachable %.lr.ph99.preheader -> %._crit_edge100.loopexit
		NCA == %.lr.ph99.preheader
Mark %._crit_edge100.loopexitas affected, CurrentLevel 7
	Successor %._crit_edge100, level = 5
Updating NCD = %.lr.ph99.preheader
	IDom(%._crit_edge100.loopexit) = %.lr.ph99.preheader
Deleting edge %.lr.ph99.preheader -> %.lr.ph99
	NCD %.lr.ph99.preheader, ToIDom %.lr.ph99.preheader
IsReachableFromIDom %.lr.ph99
	Pred %.lr.ph99
	Support %.lr.ph99
Deleting unreachable subtree %.lr.ph99
Processing affected node %._crit_edge100.loopexit with NCD = %.lr.ph99.preheader, MinNode =%.lr.ph99
Erasing node %.lr.ph99
DeleteUnreachable: running DFS with MinNode = %.lr.ph99.preheader
Previous IDom(MinNode) = %._crit_edge97
Running Semi-NCA
loop-idiom Scanning: F[main] Countable Loop %.lr.ph102
  Formed memset:   call void @llvm.memset.p0.i64(ptr align 4 %40, i8 0, i64 %42, i1 false)
    from store to: {%40,+,8}<%.lr.ph102> at:   store i64 0, ptr %44, align 4
Analyzing Loop for deletion: Loop at depth 1 containing: %.lr.ph102<header><latch><exiting>
Loop is invariant, delete it!
Inserting edge %.lr.ph102.preheader -> %._crit_edge103.loopexit
	Reachable %.lr.ph102.preheader -> %._crit_edge103.loopexit
		NCA == %.lr.ph102.preheader
Mark %._crit_edge103.loopexitas affected, CurrentLevel 8
	Successor %._crit_edge103, level = 6
Updating NCD = %.lr.ph102.preheader
	IDom(%._crit_edge103.loopexit) = %.lr.ph102.preheader
Deleting edge %.lr.ph102.preheader -> %.lr.ph102
	NCD %.lr.ph102.preheader, ToIDom %.lr.ph102.preheader
IsReachableFromIDom %.lr.ph102
	Pred %.lr.ph102
	Support %.lr.ph102
Deleting unreachable subtree %.lr.ph102
Processing affected node %._crit_edge103.loopexit with NCD = %.lr.ph102.preheader, MinNode =%.lr.ph102
Erasing node %.lr.ph102
DeleteUnreachable: running DFS with MinNode = %.lr.ph102.preheader
Previous IDom(MinNode) = %._crit_edge100
Running Semi-NCA
loop-idiom Scanning: F[main] Countable Loop %.lr.ph105
  Formed memset:   call void @llvm.memset.p0.i64(ptr align 4 %44, i8 0, i64 %46, i1 false)
    from store to: {%44,+,8}<%.lr.ph105> at:   store i64 0, ptr %48, align 4
Analyzing Loop for deletion: Loop at depth 1 containing: %.lr.ph105<header><latch><exiting>
Loop is invariant, delete it!
Inserting edge %.lr.ph105.preheader -> %._crit_edge106.loopexit
	Reachable %.lr.ph105.preheader -> %._crit_edge106.loopexit
		NCA == %.lr.ph105.preheader
Mark %._crit_edge106.loopexitas affected, CurrentLevel 9
	Successor %._crit_edge106, level = 7
Updating NCD = %.lr.ph105.preheader
	IDom(%._crit_edge106.loopexit) = %.lr.ph105.preheader
Deleting edge %.lr.ph105.preheader -> %.lr.ph105
	NCD %.lr.ph105.preheader, ToIDom %.lr.ph105.preheader
IsReachableFromIDom %.lr.ph105
	Pred %.lr.ph105
	Support %.lr.ph105
Deleting unreachable subtree %.lr.ph105
Processing affected node %._crit_edge106.loopexit with NCD = %.lr.ph105.preheader, MinNode =%.lr.ph105
Erasing node %.lr.ph105
DeleteUnreachable: running DFS with MinNode = %.lr.ph105.preheader
Previous IDom(MinNode) = %._crit_edge103
Running Semi-NCA
loop-idiom Scanning: F[main] Countable Loop %.lr.ph108
  Formed memset:   call void @llvm.memset.p0.i64(ptr align 4 %48, i8 0, i64 %50, i1 false)
    from store to: {%48,+,8}<%.lr.ph108> at:   store i64 0, ptr %52, align 4
Analyzing Loop for deletion: Loop at depth 1 containing: %.lr.ph108<header><latch><exiting>
Loop is invariant, delete it!
Inserting edge %.lr.ph108.preheader -> %._crit_edge109.loopexit
	Reachable %.lr.ph108.preheader -> %._crit_edge109.loopexit
		NCA == %.lr.ph108.preheader
Mark %._crit_edge109.loopexitas affected, CurrentLevel 10
	Successor %._crit_edge109, level = 8
Updating NCD = %.lr.ph108.preheader
	IDom(%._crit_edge109.loopexit) = %.lr.ph108.preheader
Deleting edge %.lr.ph108.preheader -> %.lr.ph108
	NCD %.lr.ph108.preheader, ToIDom %.lr.ph108.preheader
IsReachableFromIDom %.lr.ph108
	Pred %.lr.ph108
	Support %.lr.ph108
Deleting unreachable subtree %.lr.ph108
Processing affected node %._crit_edge109.loopexit with NCD = %.lr.ph108.preheader, MinNode =%.lr.ph108
Erasing node %.lr.ph108
DeleteUnreachable: running DFS with MinNode = %.lr.ph108.preheader
Previous IDom(MinNode) = %._crit_edge106
Running Semi-NCA
loop-idiom Scanning: F[main] Countable Loop %.lr.ph111
  Formed memset:   call void @llvm.memset.p0.i64(ptr align 8 %52, i8 0, i64 %54, i1 false)
    from store to: {%52,+,8}<%.lr.ph111> at:   store double 0.000000e+00, ptr %56, align 8
Analyzing Loop for deletion: Loop at depth 1 containing: %.lr.ph111<header><latch><exiting>
Loop is invariant, delete it!
Inserting edge %.lr.ph111.preheader -> %._crit_edge112.loopexit
	Reachable %.lr.ph111.preheader -> %._crit_edge112.loopexit
		NCA == %.lr.ph111.preheader
Mark %._crit_edge112.loopexitas affected, CurrentLevel 11
	Successor %._crit_edge112, level = 9
Updating NCD = %.lr.ph111.preheader
	IDom(%._crit_edge112.loopexit) = %.lr.ph111.preheader
Deleting edge %.lr.ph111.preheader -> %.lr.ph111
	NCD %.lr.ph111.preheader, ToIDom %.lr.ph111.preheader
IsReachableFromIDom %.lr.ph111
	Pred %.lr.ph111
	Support %.lr.ph111
Deleting unreachable subtree %.lr.ph111
Processing affected node %._crit_edge112.loopexit with NCD = %.lr.ph111.preheader, MinNode =%.lr.ph111
Erasing node %.lr.ph111
DeleteUnreachable: running DFS with MinNode = %.lr.ph111.preheader
Previous IDom(MinNode) = %._crit_edge109
Running Semi-NCA
SROA function: main
SROA alloca:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  Rewriting FCA loads and stores...
Can't analyze slices for alloca:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  A pointer to this alloca escaped by:
    call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
Instruction Merger
Merging: ._crit_edge.loopexit into .lr.ph.preheader
Inserting edge %.lr.ph.preheader -> %._crit_edge
	Reachable %.lr.ph.preheader -> %._crit_edge
		NCA == %0
Deleting edge %._crit_edge.loopexit -> %._crit_edge
	NCD %0, ToIDom %0
Deleting reachable %._crit_edge.loopexit -> %._crit_edge
	Rebuilding subtree
The entire tree needs to be rebuilt
DomTree recalculated, skipping future batch updates
Merging: ._crit_edge91.loopexit into .lr.ph90.preheader
Inserting edge %.lr.ph90.preheader -> %._crit_edge91
	Reachable %.lr.ph90.preheader -> %._crit_edge91
		NCA == %._crit_edge
Deleting edge %._crit_edge91.loopexit -> %._crit_edge91
	NCD %._crit_edge, ToIDom %._crit_edge
Deleting reachable %._crit_edge91.loopexit -> %._crit_edge91
	Rebuilding subtree
	Top of subtree: %._crit_edge
	Running Semi-NCA
Deleting edge %.lr.ph90.preheader -> %._crit_edge91.loopexit
	NCD %.lr.ph90.preheader, ToIDom %.lr.ph90.preheader
IsReachableFromIDom %._crit_edge91.loopexit
Deleting unreachable subtree %._crit_edge91.loopexit
Erasing node %._crit_edge91.loopexit
Merging: ._crit_edge94.loopexit into .lr.ph93.preheader
Inserting edge %.lr.ph93.preheader -> %._crit_edge94
	Reachable %.lr.ph93.preheader -> %._crit_edge94
		NCA == %._crit_edge91
Deleting edge %._crit_edge94.loopexit -> %._crit_edge94
	NCD %._crit_edge91, ToIDom %._crit_edge91
Deleting reachable %._crit_edge94.loopexit -> %._crit_edge94
	Rebuilding subtree
	Top of subtree: %._crit_edge91
	Running Semi-NCA
Deleting edge %.lr.ph93.preheader -> %._crit_edge94.loopexit
	NCD %.lr.ph93.preheader, ToIDom %.lr.ph93.preheader
IsReachableFromIDom %._crit_edge94.loopexit
Deleting unreachable subtree %._crit_edge94.loopexit
Erasing node %._crit_edge94.loopexit
Merging: ._crit_edge97.loopexit into .lr.ph96.preheader
Inserting edge %.lr.ph96.preheader -> %._crit_edge97
	Reachable %.lr.ph96.preheader -> %._crit_edge97
		NCA == %._crit_edge94
Deleting edge %._crit_edge97.loopexit -> %._crit_edge97
	NCD %._crit_edge94, ToIDom %._crit_edge94
Deleting reachable %._crit_edge97.loopexit -> %._crit_edge97
	Rebuilding subtree
	Top of subtree: %._crit_edge94
	Running Semi-NCA
Deleting edge %.lr.ph96.preheader -> %._crit_edge97.loopexit
	NCD %.lr.ph96.preheader, ToIDom %.lr.ph96.preheader
IsReachableFromIDom %._crit_edge97.loopexit
Deleting unreachable subtree %._crit_edge97.loopexit
Erasing node %._crit_edge97.loopexit
Merging: ._crit_edge100.loopexit into .lr.ph99.preheader
Inserting edge %.lr.ph99.preheader -> %._crit_edge100
	Reachable %.lr.ph99.preheader -> %._crit_edge100
		NCA == %._crit_edge97
Deleting edge %._crit_edge100.loopexit -> %._crit_edge100
	NCD %._crit_edge97, ToIDom %._crit_edge97
Deleting reachable %._crit_edge100.loopexit -> %._crit_edge100
	Rebuilding subtree
	Top of subtree: %._crit_edge97
	Running Semi-NCA
Deleting edge %.lr.ph99.preheader -> %._crit_edge100.loopexit
	NCD %.lr.ph99.preheader, ToIDom %.lr.ph99.preheader
IsReachableFromIDom %._crit_edge100.loopexit
Deleting unreachable subtree %._crit_edge100.loopexit
Erasing node %._crit_edge100.loopexit
Merging: ._crit_edge103.loopexit into .lr.ph102.preheader
Inserting edge %.lr.ph102.preheader -> %._crit_edge103
	Reachable %.lr.ph102.preheader -> %._crit_edge103
		NCA == %._crit_edge100
Deleting edge %._crit_edge103.loopexit -> %._crit_edge103
	NCD %._crit_edge100, ToIDom %._crit_edge100
Deleting reachable %._crit_edge103.loopexit -> %._crit_edge103
	Rebuilding subtree
	Top of subtree: %._crit_edge100
	Running Semi-NCA
Deleting edge %.lr.ph102.preheader -> %._crit_edge103.loopexit
	NCD %.lr.ph102.preheader, ToIDom %.lr.ph102.preheader
IsReachableFromIDom %._crit_edge103.loopexit
Deleting unreachable subtree %._crit_edge103.loopexit
Erasing node %._crit_edge103.loopexit
Merging: ._crit_edge106.loopexit into .lr.ph105.preheader
Inserting edge %.lr.ph105.preheader -> %._crit_edge106
	Reachable %.lr.ph105.preheader -> %._crit_edge106
		NCA == %._crit_edge103
Deleting edge %._crit_edge106.loopexit -> %._crit_edge106
	NCD %._crit_edge103, ToIDom %._crit_edge103
Deleting reachable %._crit_edge106.loopexit -> %._crit_edge106
	Rebuilding subtree
	Top of subtree: %._crit_edge103
	Running Semi-NCA
Deleting edge %.lr.ph105.preheader -> %._crit_edge106.loopexit
	NCD %.lr.ph105.preheader, ToIDom %.lr.ph105.preheader
IsReachableFromIDom %._crit_edge106.loopexit
Deleting unreachable subtree %._crit_edge106.loopexit
Erasing node %._crit_edge106.loopexit
Merging: ._crit_edge109.loopexit into .lr.ph108.preheader
Inserting edge %.lr.ph108.preheader -> %._crit_edge109
	Reachable %.lr.ph108.preheader -> %._crit_edge109
		NCA == %._crit_edge106
Deleting edge %._crit_edge109.loopexit -> %._crit_edge109
	NCD %._crit_edge106, ToIDom %._crit_edge106
Deleting reachable %._crit_edge109.loopexit -> %._crit_edge109
	Rebuilding subtree
	Top of subtree: %._crit_edge106
	Running Semi-NCA
Deleting edge %.lr.ph108.preheader -> %._crit_edge109.loopexit
	NCD %.lr.ph108.preheader, ToIDom %.lr.ph108.preheader
IsReachableFromIDom %._crit_edge109.loopexit
Deleting unreachable subtree %._crit_edge109.loopexit
Erasing node %._crit_edge109.loopexit
Merging: ._crit_edge112.loopexit into .lr.ph111.preheader
Inserting edge %.lr.ph111.preheader -> %._crit_edge112
	Reachable %.lr.ph111.preheader -> %._crit_edge112
		NCA == %._crit_edge109
Deleting edge %._crit_edge112.loopexit -> %._crit_edge112
	NCD %._crit_edge109, ToIDom %._crit_edge109
Deleting reachable %._crit_edge112.loopexit -> %._crit_edge112
	Rebuilding subtree
	Top of subtree: %._crit_edge109
	Running Semi-NCA
Deleting edge %.lr.ph111.preheader -> %._crit_edge112.loopexit
	NCD %.lr.ph111.preheader, ToIDom %.lr.ph111.preheader
IsReachableFromIDom %._crit_edge112.loopexit
Deleting unreachable subtree %._crit_edge112.loopexit
Erasing node %._crit_edge112.loopexit
GVN iteration: 0
GVN: load i64 %3 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %5 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %7 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %9 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %11 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %13 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %15 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %17 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %19 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN removed:   %22 = shl nuw i64 %3, 3
GVN removed:   %25 = shl nuw i64 %5, 3
GVN removed:   %28 = shl nuw i64 %7, 3
GVN removed:   %31 = shl nuw i64 %9, 3
GVN removed:   %34 = shl nuw i64 %11, 3
GVN removed:   %37 = shl nuw i64 %13, 3
GVN removed:   %40 = shl nuw i64 %15, 3
GVN removed:   %43 = shl nuw i64 %17, 3
GVN removed:   %46 = shl nuw i64 %19, 3
GVN iteration: 1
GVN: load i64 %3 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %5 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %7 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %9 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %11 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %13 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %15 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %17 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
GVN: load i64 %19 is clobbered by   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
SCCP on function 'main'
Marking Block Executable: 

Popped off BBWL: 
  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
  %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  store ptr %1, ptr %2, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
  store ptr %1, ptr %.fca.1.gep, align 8
  %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
  store i64 0, ptr %.fca.2.gep, align 8
  %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
  store i64 7, ptr %.fca.3.0.gep, align 8
  %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
  store i64 1, ptr %.fca.4.0.gep, align 8
  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
  %3 = load i64, ptr %1, align 4
  %4 = getelementptr i64, ptr %1, i64 1
  %5 = load i64, ptr %4, align 4
  %6 = getelementptr i64, ptr %1, i64 2
  %7 = load i64, ptr %6, align 4
  %8 = getelementptr i64, ptr %1, i64 3
  %9 = load i64, ptr %8, align 4
  %10 = getelementptr i64, ptr %1, i64 4
  %11 = load i64, ptr %10, align 4
  %12 = getelementptr i64, ptr %1, i64 5
  %13 = load i64, ptr %12, align 4
  %14 = getelementptr i64, ptr %1, i64 6
  %15 = load i64, ptr %14, align 4
  %16 = getelementptr i64, ptr %1, i64 7
  %17 = load i64, ptr %16, align 4
  %18 = getelementptr i64, ptr %1, i64 8
  %19 = load i64, ptr %18, align 4
  %.idx = shl i64 %3, 3
  %20 = call ptr @malloc(i64 %.idx)
  %21 = icmp sgt i64 %3, 0
  br i1 %21, label %.lr.ph.preheader, label %._crit_edge

Merged overdefined into   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56) : overdefined
SCCP: Don't know how to handle:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
markOverdefined:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
markOverdefined:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
markOverdefined:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
Merged overdefined into   %3 = load i64, ptr %1, align 4 : overdefined
markOverdefined:   %4 = getelementptr i64, ptr %1, i64 1
Merged overdefined into   %5 = load i64, ptr %4, align 4 : overdefined
markOverdefined:   %6 = getelementptr i64, ptr %1, i64 2
Merged overdefined into   %7 = load i64, ptr %6, align 4 : overdefined
markOverdefined:   %8 = getelementptr i64, ptr %1, i64 3
Merged overdefined into   %9 = load i64, ptr %8, align 4 : overdefined
markOverdefined:   %10 = getelementptr i64, ptr %1, i64 4
Merged overdefined into   %11 = load i64, ptr %10, align 4 : overdefined
markOverdefined:   %12 = getelementptr i64, ptr %1, i64 5
Merged overdefined into   %13 = load i64, ptr %12, align 4 : overdefined
markOverdefined:   %14 = getelementptr i64, ptr %1, i64 6
Merged overdefined into   %15 = load i64, ptr %14, align 4 : overdefined
markOverdefined:   %16 = getelementptr i64, ptr %1, i64 7
Merged overdefined into   %17 = load i64, ptr %16, align 4 : overdefined
markOverdefined:   %18 = getelementptr i64, ptr %1, i64 8
Merged overdefined into   %19 = load i64, ptr %18, align 4 : overdefined
Merged constantrange<0, -7> into   %.idx = shl i64 %3, 3 : constantrange<0, -7>
Merged overdefined into   %20 = call ptr @malloc(i64 %.idx) : overdefined
markOverdefined:   %21 = icmp sgt i64 %3, 0
Marking Block Executable: .lr.ph.preheader
Marking Block Executable: ._crit_edge

Popped off BBWL: 
._crit_edge:                                      ; preds = %.lr.ph.preheader, %0
  %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  store ptr %20, ptr %22, align 8
  %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
  store ptr %20, ptr %.repack9, align 8
  %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2
  store i64 0, ptr %.repack11, align 8
  %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3
  store i64 %3, ptr %.repack13, align 8
  %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4
  store i64 1, ptr %.repack15, align 8
  %.idx17 = shl i64 %5, 3
  %23 = call ptr @malloc(i64 %.idx17)
  %24 = icmp sgt i64 %5, 0
  br i1 %24, label %.lr.ph90.preheader, label %._crit_edge91

SCCP: Don't know how to handle:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
markOverdefined:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2
markOverdefined:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3
markOverdefined:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4
Merged constantrange<0, -7> into   %.idx17 = shl i64 %5, 3 : constantrange<0, -7>
Merged overdefined into   %23 = call ptr @malloc(i64 %.idx17) : overdefined
markOverdefined:   %24 = icmp sgt i64 %5, 0
Marking Block Executable: .lr.ph90.preheader
Marking Block Executable: ._crit_edge91

Popped off BBWL: 
._crit_edge91:                                    ; preds = %.lr.ph90.preheader, %._crit_edge
  %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  store ptr %23, ptr %25, align 8
  %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
  store ptr %23, ptr %.repack18, align 8
  %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2
  store i64 0, ptr %.repack20, align 8
  %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3
  store i64 %5, ptr %.repack22, align 8
  %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4
  store i64 1, ptr %.repack24, align 8
  %.idx26 = shl i64 %7, 3
  %26 = call ptr @malloc(i64 %.idx26)
  %27 = icmp sgt i64 %7, 0
  br i1 %27, label %.lr.ph93.preheader, label %._crit_edge94

SCCP: Don't know how to handle:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
markOverdefined:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2
markOverdefined:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3
markOverdefined:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4
Merged constantrange<0, -7> into   %.idx26 = shl i64 %7, 3 : constantrange<0, -7>
Merged overdefined into   %26 = call ptr @malloc(i64 %.idx26) : overdefined
markOverdefined:   %27 = icmp sgt i64 %7, 0
Marking Block Executable: .lr.ph93.preheader
Marking Block Executable: ._crit_edge94

Popped off BBWL: 
._crit_edge94:                                    ; preds = %.lr.ph93.preheader, %._crit_edge91
  %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  store ptr %26, ptr %28, align 8
  %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
  store ptr %26, ptr %.repack27, align 8
  %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
  store i64 0, ptr %.repack29, align 8
  %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
  store i64 %7, ptr %.repack31, align 8
  %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
  store i64 1, ptr %.repack33, align 8
  %.idx35 = shl i64 %9, 3
  %29 = call ptr @malloc(i64 %.idx35)
  %30 = icmp sgt i64 %9, 0
  br i1 %30, label %.lr.ph96.preheader, label %._crit_edge97

SCCP: Don't know how to handle:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
markOverdefined:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
markOverdefined:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
markOverdefined:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
Merged constantrange<0, -7> into   %.idx35 = shl i64 %9, 3 : constantrange<0, -7>
Merged overdefined into   %29 = call ptr @malloc(i64 %.idx35) : overdefined
markOverdefined:   %30 = icmp sgt i64 %9, 0
Marking Block Executable: .lr.ph96.preheader
Marking Block Executable: ._crit_edge97

Popped off BBWL: 
._crit_edge97:                                    ; preds = %.lr.ph96.preheader, %._crit_edge94
  %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  store ptr %29, ptr %31, align 8
  %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
  store ptr %29, ptr %.repack36, align 8
  %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2
  store i64 0, ptr %.repack38, align 8
  %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3
  store i64 %9, ptr %.repack40, align 8
  %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4
  store i64 1, ptr %.repack42, align 8
  %.idx44 = shl i64 %11, 3
  %32 = call ptr @malloc(i64 %.idx44)
  %33 = icmp sgt i64 %11, 0
  br i1 %33, label %.lr.ph99.preheader, label %._crit_edge100

SCCP: Don't know how to handle:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
markOverdefined:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2
markOverdefined:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3
markOverdefined:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4
Merged constantrange<0, -7> into   %.idx44 = shl i64 %11, 3 : constantrange<0, -7>
Merged overdefined into   %32 = call ptr @malloc(i64 %.idx44) : overdefined
markOverdefined:   %33 = icmp sgt i64 %11, 0
Marking Block Executable: .lr.ph99.preheader
Marking Block Executable: ._crit_edge100

Popped off BBWL: 
._crit_edge100:                                   ; preds = %.lr.ph99.preheader, %._crit_edge97
  %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  store ptr %32, ptr %34, align 8
  %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
  store ptr %32, ptr %.repack45, align 8
  %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2
  store i64 0, ptr %.repack47, align 8
  %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3
  store i64 %11, ptr %.repack49, align 8
  %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4
  store i64 1, ptr %.repack51, align 8
  %.idx53 = shl i64 %13, 3
  %35 = call ptr @malloc(i64 %.idx53)
  %36 = icmp sgt i64 %13, 0
  br i1 %36, label %.lr.ph102.preheader, label %._crit_edge103

SCCP: Don't know how to handle:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
markOverdefined:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2
markOverdefined:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3
markOverdefined:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4
Merged constantrange<0, -7> into   %.idx53 = shl i64 %13, 3 : constantrange<0, -7>
Merged overdefined into   %35 = call ptr @malloc(i64 %.idx53) : overdefined
markOverdefined:   %36 = icmp sgt i64 %13, 0
Marking Block Executable: .lr.ph102.preheader
Marking Block Executable: ._crit_edge103

Popped off BBWL: 
._crit_edge103:                                   ; preds = %.lr.ph102.preheader, %._crit_edge100
  %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  store ptr %35, ptr %37, align 8
  %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
  store ptr %35, ptr %.repack54, align 8
  %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
  store i64 0, ptr %.repack56, align 8
  %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
  store i64 %13, ptr %.repack58, align 8
  %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
  store i64 1, ptr %.repack60, align 8
  %.idx62 = shl i64 %15, 3
  %38 = call ptr @malloc(i64 %.idx62)
  %39 = icmp sgt i64 %15, 0
  br i1 %39, label %.lr.ph105.preheader, label %._crit_edge106

SCCP: Don't know how to handle:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
markOverdefined:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
markOverdefined:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
markOverdefined:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
Merged constantrange<0, -7> into   %.idx62 = shl i64 %15, 3 : constantrange<0, -7>
Merged overdefined into   %38 = call ptr @malloc(i64 %.idx62) : overdefined
markOverdefined:   %39 = icmp sgt i64 %15, 0
Marking Block Executable: .lr.ph105.preheader
Marking Block Executable: ._crit_edge106

Popped off BBWL: 
._crit_edge106:                                   ; preds = %.lr.ph105.preheader, %._crit_edge103
  %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  store ptr %38, ptr %40, align 8
  %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
  store ptr %38, ptr %.repack63, align 8
  %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
  store i64 0, ptr %.repack65, align 8
  %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
  store i64 %15, ptr %.repack67, align 8
  %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
  store i64 1, ptr %.repack69, align 8
  %.idx71 = shl i64 %17, 3
  %41 = call ptr @malloc(i64 %.idx71)
  %42 = icmp sgt i64 %17, 0
  br i1 %42, label %.lr.ph108.preheader, label %._crit_edge109

SCCP: Don't know how to handle:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
markOverdefined:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
markOverdefined:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
markOverdefined:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
Merged constantrange<0, -7> into   %.idx71 = shl i64 %17, 3 : constantrange<0, -7>
Merged overdefined into   %41 = call ptr @malloc(i64 %.idx71) : overdefined
markOverdefined:   %42 = icmp sgt i64 %17, 0
Marking Block Executable: .lr.ph108.preheader
Marking Block Executable: ._crit_edge109

Popped off BBWL: 
._crit_edge109:                                   ; preds = %.lr.ph108.preheader, %._crit_edge106
  %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  store ptr %41, ptr %43, align 8
  %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
  store ptr %41, ptr %.repack72, align 8
  %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2
  store i64 0, ptr %.repack74, align 8
  %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3
  store i64 %17, ptr %.repack76, align 8
  %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4
  store i64 1, ptr %.repack78, align 8
  %.idx80 = shl i64 %19, 3
  %44 = call ptr @malloc(i64 %.idx80)
  %45 = icmp sgt i64 %19, 0
  br i1 %45, label %.lr.ph111.preheader, label %._crit_edge112

SCCP: Don't know how to handle:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
markOverdefined:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2
markOverdefined:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3
markOverdefined:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4
Merged constantrange<0, -7> into   %.idx80 = shl i64 %19, 3 : constantrange<0, -7>
Merged overdefined into   %44 = call ptr @malloc(i64 %.idx80) : overdefined
markOverdefined:   %45 = icmp sgt i64 %19, 0
Marking Block Executable: .lr.ph111.preheader
Marking Block Executable: ._crit_edge112

Popped off BBWL: 
._crit_edge112:                                   ; preds = %.lr.ph111.preheader, %._crit_edge109
  %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  store ptr %44, ptr %46, align 8
  %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
  store ptr %44, ptr %.repack81, align 8
  %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
  store i64 0, ptr %.repack83, align 8
  %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
  store i64 %19, ptr %.repack85, align 8
  %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
  store i64 1, ptr %.repack87, align 8
  call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1)
  call void @comet_print_memref_i64(i64 1, ptr nonnull %22)
  call void @comet_print_memref_i64(i64 1, ptr nonnull %25)
  call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
  call void @comet_print_memref_i64(i64 1, ptr nonnull %31)
  call void @comet_print_memref_i64(i64 1, ptr nonnull %34)
  call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
  call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
  call void @comet_print_memref_i64(i64 1, ptr nonnull %43)
  call void @comet_print_memref_f64(i64 1, ptr nonnull %46)
  ret void

SCCP: Don't know how to handle:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
markOverdefined:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
markOverdefined:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
markOverdefined:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
markOverdefined:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4

Popped off BBWL: 
.lr.ph111.preheader:                              ; preds = %._crit_edge109
  call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false)
  br label %._crit_edge112

Marking Edge Executable: .lr.ph111.preheader -> ._crit_edge112

Popped off BBWL: 
.lr.ph108.preheader:                              ; preds = %._crit_edge106
  call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false)
  br label %._crit_edge109

Marking Edge Executable: .lr.ph108.preheader -> ._crit_edge109

Popped off BBWL: 
.lr.ph105.preheader:                              ; preds = %._crit_edge103
  call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false)
  br label %._crit_edge106

Marking Edge Executable: .lr.ph105.preheader -> ._crit_edge106

Popped off BBWL: 
.lr.ph102.preheader:                              ; preds = %._crit_edge100
  call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false)
  br label %._crit_edge103

Marking Edge Executable: .lr.ph102.preheader -> ._crit_edge103

Popped off BBWL: 
.lr.ph99.preheader:                               ; preds = %._crit_edge97
  call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false)
  br label %._crit_edge100

Marking Edge Executable: .lr.ph99.preheader -> ._crit_edge100

Popped off BBWL: 
.lr.ph96.preheader:                               ; preds = %._crit_edge94
  call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false)
  br label %._crit_edge97

Marking Edge Executable: .lr.ph96.preheader -> ._crit_edge97

Popped off BBWL: 
.lr.ph93.preheader:                               ; preds = %._crit_edge91
  call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false)
  br label %._crit_edge94

Marking Edge Executable: .lr.ph93.preheader -> ._crit_edge94

Popped off BBWL: 
.lr.ph90.preheader:                               ; preds = %._crit_edge
  call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false)
  br label %._crit_edge91

Marking Edge Executable: .lr.ph90.preheader -> ._crit_edge91

Popped off BBWL: 
.lr.ph.preheader:                                 ; preds = %0
  call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false)
  br label %._crit_edge

Marking Edge Executable: .lr.ph.preheader -> ._crit_edge

Popped off OI-WL:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4

Popped off OI-WL:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3

Popped off OI-WL:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2

Popped off OI-WL:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1

Popped off OI-WL:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8

Popped off OI-WL:   %45 = icmp sgt i64 %19, 0

Popped off OI-WL:   %44 = call ptr @malloc(i64 %.idx80)

Popped off OI-WL:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4

Popped off OI-WL:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3

Popped off OI-WL:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2

Popped off OI-WL:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1

Popped off OI-WL:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8

Popped off OI-WL:   %42 = icmp sgt i64 %17, 0

Popped off OI-WL:   %41 = call ptr @malloc(i64 %.idx71)

Popped off OI-WL:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4

Popped off OI-WL:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3

Popped off OI-WL:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2

Popped off OI-WL:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1

Popped off OI-WL:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8

Popped off OI-WL:   %39 = icmp sgt i64 %15, 0

Popped off OI-WL:   %38 = call ptr @malloc(i64 %.idx62)

Popped off OI-WL:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4

Popped off OI-WL:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3

Popped off OI-WL:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2

Popped off OI-WL:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1

Popped off OI-WL:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8

Popped off OI-WL:   %36 = icmp sgt i64 %13, 0

Popped off OI-WL:   %35 = call ptr @malloc(i64 %.idx53)

Popped off OI-WL:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4

Popped off OI-WL:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3

Popped off OI-WL:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2

Popped off OI-WL:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1

Popped off OI-WL:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8

Popped off OI-WL:   %33 = icmp sgt i64 %11, 0

Popped off OI-WL:   %32 = call ptr @malloc(i64 %.idx44)

Popped off OI-WL:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4

Popped off OI-WL:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3

Popped off OI-WL:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2

Popped off OI-WL:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1

Popped off OI-WL:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8

Popped off OI-WL:   %30 = icmp sgt i64 %9, 0

Popped off OI-WL:   %29 = call ptr @malloc(i64 %.idx35)

Popped off OI-WL:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4

Popped off OI-WL:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3

Popped off OI-WL:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2

Popped off OI-WL:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1

Popped off OI-WL:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8

Popped off OI-WL:   %27 = icmp sgt i64 %7, 0

Popped off OI-WL:   %26 = call ptr @malloc(i64 %.idx26)

Popped off OI-WL:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4

Popped off OI-WL:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3

Popped off OI-WL:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2

Popped off OI-WL:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1

Popped off OI-WL:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8

Popped off OI-WL:   %24 = icmp sgt i64 %5, 0

Popped off OI-WL:   %23 = call ptr @malloc(i64 %.idx17)

Popped off OI-WL:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4

Popped off OI-WL:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3

Popped off OI-WL:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2

Popped off OI-WL:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1

Popped off OI-WL:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8

Popped off OI-WL:   %21 = icmp sgt i64 %3, 0

Popped off OI-WL:   %20 = call ptr @malloc(i64 %.idx)

Popped off OI-WL:   %19 = load i64, ptr %18, align 4

Popped off OI-WL:   %18 = getelementptr i64, ptr %1, i64 8

Popped off OI-WL:   %17 = load i64, ptr %16, align 4

Popped off OI-WL:   %16 = getelementptr i64, ptr %1, i64 7

Popped off OI-WL:   %15 = load i64, ptr %14, align 4

Popped off OI-WL:   %14 = getelementptr i64, ptr %1, i64 6

Popped off OI-WL:   %13 = load i64, ptr %12, align 4

Popped off OI-WL:   %12 = getelementptr i64, ptr %1, i64 5

Popped off OI-WL:   %11 = load i64, ptr %10, align 4

Popped off OI-WL:   %10 = getelementptr i64, ptr %1, i64 4

Popped off OI-WL:   %9 = load i64, ptr %8, align 4

Popped off OI-WL:   %8 = getelementptr i64, ptr %1, i64 3

Popped off OI-WL:   %7 = load i64, ptr %6, align 4

Popped off OI-WL:   %6 = getelementptr i64, ptr %1, i64 2

Popped off OI-WL:   %5 = load i64, ptr %4, align 4

Popped off OI-WL:   %4 = getelementptr i64, ptr %1, i64 1

Popped off OI-WL:   %3 = load i64, ptr %1, align 4

Popped off OI-WL:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0

Popped off OI-WL:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0

Popped off OI-WL:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2

Popped off OI-WL:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1

Popped off OI-WL:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8

Popped off OI-WL:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)

Popped off I-WL:   %.idx80 = shl i64 %19, 3

Popped off I-WL:   %.idx71 = shl i64 %17, 3

Popped off I-WL:   %.idx62 = shl i64 %15, 3

Popped off I-WL:   %.idx53 = shl i64 %13, 3

Popped off I-WL:   %.idx44 = shl i64 %11, 3

Popped off I-WL:   %.idx35 = shl i64 %9, 3

Popped off I-WL:   %.idx26 = shl i64 %7, 3

Popped off I-WL:   %.idx17 = shl i64 %5, 3

Popped off I-WL:   %.idx = shl i64 %3, 3
RESOLVING UNDEFs
DemandedBits: Root:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
DemandedBits: Root:   store ptr %1, ptr %2, align 8
DemandedBits: Root:   store ptr %1, ptr %.fca.1.gep, align 8
DemandedBits: Root:   store i64 0, ptr %.fca.2.gep, align 8
DemandedBits: Root:   store i64 7, ptr %.fca.3.0.gep, align 8
DemandedBits: Root:   store i64 1, ptr %.fca.4.0.gep, align 8
DemandedBits: Root:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
DemandedBits: Root:   %20 = call ptr @malloc(i64 %.idx)
DemandedBits: Root:   br i1 %21, label %.lr.ph.preheader, label %._crit_edge
DemandedBits: Root:   call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false)
DemandedBits: Root:   br label %._crit_edge
DemandedBits: Root:   store ptr %20, ptr %22, align 8
DemandedBits: Root:   store ptr %20, ptr %.repack9, align 8
DemandedBits: Root:   store i64 0, ptr %.repack11, align 8
DemandedBits: Root:   store i64 %3, ptr %.repack13, align 8
DemandedBits: Root:   store i64 1, ptr %.repack15, align 8
DemandedBits: Root:   %23 = call ptr @malloc(i64 %.idx17)
DemandedBits: Root:   br i1 %24, label %.lr.ph90.preheader, label %._crit_edge91
DemandedBits: Root:   call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false)
DemandedBits: Root:   br label %._crit_edge91
DemandedBits: Root:   store ptr %23, ptr %25, align 8
DemandedBits: Root:   store ptr %23, ptr %.repack18, align 8
DemandedBits: Root:   store i64 0, ptr %.repack20, align 8
DemandedBits: Root:   store i64 %5, ptr %.repack22, align 8
DemandedBits: Root:   store i64 1, ptr %.repack24, align 8
DemandedBits: Root:   %26 = call ptr @malloc(i64 %.idx26)
DemandedBits: Root:   br i1 %27, label %.lr.ph93.preheader, label %._crit_edge94
DemandedBits: Root:   call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false)
DemandedBits: Root:   br label %._crit_edge94
DemandedBits: Root:   store ptr %26, ptr %28, align 8
DemandedBits: Root:   store ptr %26, ptr %.repack27, align 8
DemandedBits: Root:   store i64 0, ptr %.repack29, align 8
DemandedBits: Root:   store i64 %7, ptr %.repack31, align 8
DemandedBits: Root:   store i64 1, ptr %.repack33, align 8
DemandedBits: Root:   %29 = call ptr @malloc(i64 %.idx35)
DemandedBits: Root:   br i1 %30, label %.lr.ph96.preheader, label %._crit_edge97
DemandedBits: Root:   call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false)
DemandedBits: Root:   br label %._crit_edge97
DemandedBits: Root:   store ptr %29, ptr %31, align 8
DemandedBits: Root:   store ptr %29, ptr %.repack36, align 8
DemandedBits: Root:   store i64 0, ptr %.repack38, align 8
DemandedBits: Root:   store i64 %9, ptr %.repack40, align 8
DemandedBits: Root:   store i64 1, ptr %.repack42, align 8
DemandedBits: Root:   %32 = call ptr @malloc(i64 %.idx44)
DemandedBits: Root:   br i1 %33, label %.lr.ph99.preheader, label %._crit_edge100
DemandedBits: Root:   call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false)
DemandedBits: Root:   br label %._crit_edge100
DemandedBits: Root:   store ptr %32, ptr %34, align 8
DemandedBits: Root:   store ptr %32, ptr %.repack45, align 8
DemandedBits: Root:   store i64 0, ptr %.repack47, align 8
DemandedBits: Root:   store i64 %11, ptr %.repack49, align 8
DemandedBits: Root:   store i64 1, ptr %.repack51, align 8
DemandedBits: Root:   %35 = call ptr @malloc(i64 %.idx53)
DemandedBits: Root:   br i1 %36, label %.lr.ph102.preheader, label %._crit_edge103
DemandedBits: Root:   call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false)
DemandedBits: Root:   br label %._crit_edge103
DemandedBits: Root:   store ptr %35, ptr %37, align 8
DemandedBits: Root:   store ptr %35, ptr %.repack54, align 8
DemandedBits: Root:   store i64 0, ptr %.repack56, align 8
DemandedBits: Root:   store i64 %13, ptr %.repack58, align 8
DemandedBits: Root:   store i64 1, ptr %.repack60, align 8
DemandedBits: Root:   %38 = call ptr @malloc(i64 %.idx62)
DemandedBits: Root:   br i1 %39, label %.lr.ph105.preheader, label %._crit_edge106
DemandedBits: Root:   call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false)
DemandedBits: Root:   br label %._crit_edge106
DemandedBits: Root:   store ptr %38, ptr %40, align 8
DemandedBits: Root:   store ptr %38, ptr %.repack63, align 8
DemandedBits: Root:   store i64 0, ptr %.repack65, align 8
DemandedBits: Root:   store i64 %15, ptr %.repack67, align 8
DemandedBits: Root:   store i64 1, ptr %.repack69, align 8
DemandedBits: Root:   %41 = call ptr @malloc(i64 %.idx71)
DemandedBits: Root:   br i1 %42, label %.lr.ph108.preheader, label %._crit_edge109
DemandedBits: Root:   call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false)
DemandedBits: Root:   br label %._crit_edge109
DemandedBits: Root:   store ptr %41, ptr %43, align 8
DemandedBits: Root:   store ptr %41, ptr %.repack72, align 8
DemandedBits: Root:   store i64 0, ptr %.repack74, align 8
DemandedBits: Root:   store i64 %17, ptr %.repack76, align 8
DemandedBits: Root:   store i64 1, ptr %.repack78, align 8
DemandedBits: Root:   %44 = call ptr @malloc(i64 %.idx80)
DemandedBits: Root:   br i1 %45, label %.lr.ph111.preheader, label %._crit_edge112
DemandedBits: Root:   call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false)
DemandedBits: Root:   br label %._crit_edge112
DemandedBits: Root:   store ptr %44, ptr %46, align 8
DemandedBits: Root:   store ptr %44, ptr %.repack81, align 8
DemandedBits: Root:   store i64 0, ptr %.repack83, align 8
DemandedBits: Root:   store i64 %19, ptr %.repack85, align 8
DemandedBits: Root:   store i64 1, ptr %.repack87, align 8
DemandedBits: Root:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1)
DemandedBits: Root:   call void @comet_print_memref_i64(i64 1, ptr nonnull %22)
DemandedBits: Root:   call void @comet_print_memref_i64(i64 1, ptr nonnull %25)
DemandedBits: Root:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
DemandedBits: Root:   call void @comet_print_memref_i64(i64 1, ptr nonnull %31)
DemandedBits: Root:   call void @comet_print_memref_i64(i64 1, ptr nonnull %34)
DemandedBits: Root:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
DemandedBits: Root:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
DemandedBits: Root:   call void @comet_print_memref_i64(i64 1, ptr nonnull %43)
DemandedBits: Root:   call void @comet_print_memref_f64(i64 1, ptr nonnull %46)
DemandedBits: Root:   ret void
DemandedBits: Visiting:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
DemandedBits: Visiting:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
DemandedBits: Visiting:   %19 = load i64, ptr %18, align 4 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %18 = getelementptr i64, ptr %1, i64 8
DemandedBits: Visiting:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
DemandedBits: Visiting:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
DemandedBits: Visiting:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
DemandedBits: Visiting:   %44 = call ptr @malloc(i64 %.idx80)
DemandedBits: Visiting:   %45 = icmp sgt i64 %19, 0 Alive Out: 0x1
DemandedBits: Visiting:   %.idx80 = shl i64 %19, 3 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4
DemandedBits: Visiting:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3
DemandedBits: Visiting:   %17 = load i64, ptr %16, align 4 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %16 = getelementptr i64, ptr %1, i64 7
DemandedBits: Visiting:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2
DemandedBits: Visiting:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
DemandedBits: Visiting:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
DemandedBits: Visiting:   %41 = call ptr @malloc(i64 %.idx71)
DemandedBits: Visiting:   %42 = icmp sgt i64 %17, 0 Alive Out: 0x1
DemandedBits: Visiting:   %.idx71 = shl i64 %17, 3 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
DemandedBits: Visiting:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
DemandedBits: Visiting:   %15 = load i64, ptr %14, align 4 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %14 = getelementptr i64, ptr %1, i64 6
DemandedBits: Visiting:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
DemandedBits: Visiting:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
DemandedBits: Visiting:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
DemandedBits: Visiting:   %38 = call ptr @malloc(i64 %.idx62)
DemandedBits: Visiting:   %39 = icmp sgt i64 %15, 0 Alive Out: 0x1
DemandedBits: Visiting:   %.idx62 = shl i64 %15, 3 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
DemandedBits: Visiting:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
DemandedBits: Visiting:   %13 = load i64, ptr %12, align 4 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %12 = getelementptr i64, ptr %1, i64 5
DemandedBits: Visiting:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
DemandedBits: Visiting:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
DemandedBits: Visiting:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
DemandedBits: Visiting:   %35 = call ptr @malloc(i64 %.idx53)
DemandedBits: Visiting:   %36 = icmp sgt i64 %13, 0 Alive Out: 0x1
DemandedBits: Visiting:   %.idx53 = shl i64 %13, 3 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4
DemandedBits: Visiting:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3
DemandedBits: Visiting:   %11 = load i64, ptr %10, align 4 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %10 = getelementptr i64, ptr %1, i64 4
DemandedBits: Visiting:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2
DemandedBits: Visiting:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
DemandedBits: Visiting:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
DemandedBits: Visiting:   %32 = call ptr @malloc(i64 %.idx44)
DemandedBits: Visiting:   %33 = icmp sgt i64 %11, 0 Alive Out: 0x1
DemandedBits: Visiting:   %.idx44 = shl i64 %11, 3 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4
DemandedBits: Visiting:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3
DemandedBits: Visiting:   %9 = load i64, ptr %8, align 4 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %8 = getelementptr i64, ptr %1, i64 3
DemandedBits: Visiting:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2
DemandedBits: Visiting:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
DemandedBits: Visiting:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
DemandedBits: Visiting:   %29 = call ptr @malloc(i64 %.idx35)
DemandedBits: Visiting:   %30 = icmp sgt i64 %9, 0 Alive Out: 0x1
DemandedBits: Visiting:   %.idx35 = shl i64 %9, 3 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
DemandedBits: Visiting:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
DemandedBits: Visiting:   %7 = load i64, ptr %6, align 4 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %6 = getelementptr i64, ptr %1, i64 2
DemandedBits: Visiting:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
DemandedBits: Visiting:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
DemandedBits: Visiting:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
DemandedBits: Visiting:   %26 = call ptr @malloc(i64 %.idx26)
DemandedBits: Visiting:   %27 = icmp sgt i64 %7, 0 Alive Out: 0x1
DemandedBits: Visiting:   %.idx26 = shl i64 %7, 3 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4
DemandedBits: Visiting:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3
DemandedBits: Visiting:   %5 = load i64, ptr %4, align 4 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %4 = getelementptr i64, ptr %1, i64 1
DemandedBits: Visiting:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2
DemandedBits: Visiting:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
DemandedBits: Visiting:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
DemandedBits: Visiting:   %23 = call ptr @malloc(i64 %.idx17)
DemandedBits: Visiting:   %24 = icmp sgt i64 %5, 0 Alive Out: 0x1
DemandedBits: Visiting:   %.idx17 = shl i64 %5, 3 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4
DemandedBits: Visiting:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3
DemandedBits: Visiting:   %3 = load i64, ptr %1, align 4 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2
DemandedBits: Visiting:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
DemandedBits: Visiting:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
DemandedBits: Visiting:   %20 = call ptr @malloc(i64 %.idx)
DemandedBits: Visiting:   %21 = icmp sgt i64 %3, 0 Alive Out: 0x1
DemandedBits: Visiting:   %.idx = shl i64 %3, 3 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
DemandedBits: Visiting:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
DemandedBits: Visiting:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
DemandedBits: Visiting:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
DemandedBits: Visiting:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
DemandedBits: Visiting:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)


INSTCOMBINE ITERATION #1 on main
ADD:   br label %._crit_edge
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false)
ADD:   br label %._crit_edge91
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false)
ADD:   br label %._crit_edge94
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false)
ADD:   br label %._crit_edge97
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false)
ADD:   br label %._crit_edge100
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false)
ADD:   br label %._crit_edge103
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false)
ADD:   br label %._crit_edge106
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false)
ADD:   br label %._crit_edge109
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false)
ADD:   br label %._crit_edge112
ADD:   call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false)
ADD:   ret void
ADD:   call void @comet_print_memref_f64(i64 1, ptr nonnull %46)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %43)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %34)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %31)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %25)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %22)
ADD:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1)
ADD:   store i64 1, ptr %.repack87, align 8
ADD:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
ADD:   store i64 %19, ptr %.repack85, align 8
ADD:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
ADD:   store i64 0, ptr %.repack83, align 8
ADD:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
ADD:   store ptr %44, ptr %.repack81, align 8
ADD:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
ADD:   store ptr %44, ptr %46, align 8
ADD:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %45, label %.lr.ph111.preheader, label %._crit_edge112
ADD:   %45 = icmp sgt i64 %19, 0
ADD:   %44 = call ptr @malloc(i64 %.idx80)
ADD:   %.idx80 = shl i64 %19, 3
ADD:   store i64 1, ptr %.repack78, align 8
ADD:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4
ADD:   store i64 %17, ptr %.repack76, align 8
ADD:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3
ADD:   store i64 0, ptr %.repack74, align 8
ADD:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2
ADD:   store ptr %41, ptr %.repack72, align 8
ADD:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
ADD:   store ptr %41, ptr %43, align 8
ADD:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %42, label %.lr.ph108.preheader, label %._crit_edge109
ADD:   %42 = icmp sgt i64 %17, 0
ADD:   %41 = call ptr @malloc(i64 %.idx71)
ADD:   %.idx71 = shl i64 %17, 3
ADD:   store i64 1, ptr %.repack69, align 8
ADD:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
ADD:   store i64 %15, ptr %.repack67, align 8
ADD:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
ADD:   store i64 0, ptr %.repack65, align 8
ADD:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
ADD:   store ptr %38, ptr %.repack63, align 8
ADD:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
ADD:   store ptr %38, ptr %40, align 8
ADD:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %39, label %.lr.ph105.preheader, label %._crit_edge106
ADD:   %39 = icmp sgt i64 %15, 0
ADD:   %38 = call ptr @malloc(i64 %.idx62)
ADD:   %.idx62 = shl i64 %15, 3
ADD:   store i64 1, ptr %.repack60, align 8
ADD:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
ADD:   store i64 %13, ptr %.repack58, align 8
ADD:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
ADD:   store i64 0, ptr %.repack56, align 8
ADD:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
ADD:   store ptr %35, ptr %.repack54, align 8
ADD:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
ADD:   store ptr %35, ptr %37, align 8
ADD:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %36, label %.lr.ph102.preheader, label %._crit_edge103
ADD:   %36 = icmp sgt i64 %13, 0
ADD:   %35 = call ptr @malloc(i64 %.idx53)
ADD:   %.idx53 = shl i64 %13, 3
ADD:   store i64 1, ptr %.repack51, align 8
ADD:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4
ADD:   store i64 %11, ptr %.repack49, align 8
ADD:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3
ADD:   store i64 0, ptr %.repack47, align 8
ADD:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2
ADD:   store ptr %32, ptr %.repack45, align 8
ADD:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
ADD:   store ptr %32, ptr %34, align 8
ADD:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %33, label %.lr.ph99.preheader, label %._crit_edge100
ADD:   %33 = icmp sgt i64 %11, 0
ADD:   %32 = call ptr @malloc(i64 %.idx44)
ADD:   %.idx44 = shl i64 %11, 3
ADD:   store i64 1, ptr %.repack42, align 8
ADD:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4
ADD:   store i64 %9, ptr %.repack40, align 8
ADD:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3
ADD:   store i64 0, ptr %.repack38, align 8
ADD:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2
ADD:   store ptr %29, ptr %.repack36, align 8
ADD:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
ADD:   store ptr %29, ptr %31, align 8
ADD:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %30, label %.lr.ph96.preheader, label %._crit_edge97
ADD:   %30 = icmp sgt i64 %9, 0
ADD:   %29 = call ptr @malloc(i64 %.idx35)
ADD:   %.idx35 = shl i64 %9, 3
ADD:   store i64 1, ptr %.repack33, align 8
ADD:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
ADD:   store i64 %7, ptr %.repack31, align 8
ADD:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
ADD:   store i64 0, ptr %.repack29, align 8
ADD:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
ADD:   store ptr %26, ptr %.repack27, align 8
ADD:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
ADD:   store ptr %26, ptr %28, align 8
ADD:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %27, label %.lr.ph93.preheader, label %._crit_edge94
ADD:   %27 = icmp sgt i64 %7, 0
ADD:   %26 = call ptr @malloc(i64 %.idx26)
ADD:   %.idx26 = shl i64 %7, 3
ADD:   store i64 1, ptr %.repack24, align 8
ADD:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4
ADD:   store i64 %5, ptr %.repack22, align 8
ADD:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3
ADD:   store i64 0, ptr %.repack20, align 8
ADD:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2
ADD:   store ptr %23, ptr %.repack18, align 8
ADD:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
ADD:   store ptr %23, ptr %25, align 8
ADD:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %24, label %.lr.ph90.preheader, label %._crit_edge91
ADD:   %24 = icmp sgt i64 %5, 0
ADD:   %23 = call ptr @malloc(i64 %.idx17)
ADD:   %.idx17 = shl i64 %5, 3
ADD:   store i64 1, ptr %.repack15, align 8
ADD:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4
ADD:   store i64 %3, ptr %.repack13, align 8
ADD:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3
ADD:   store i64 0, ptr %.repack11, align 8
ADD:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2
ADD:   store ptr %20, ptr %.repack9, align 8
ADD:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
ADD:   store ptr %20, ptr %22, align 8
ADD:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %21, label %.lr.ph.preheader, label %._crit_edge
ADD:   %21 = icmp sgt i64 %3, 0
ADD:   %20 = call ptr @malloc(i64 %.idx)
ADD:   %.idx = shl i64 %3, 3
ADD:   %19 = load i64, ptr %18, align 4
ADD:   %18 = getelementptr i64, ptr %1, i64 8
ADD:   %17 = load i64, ptr %16, align 4
ADD:   %16 = getelementptr i64, ptr %1, i64 7
ADD:   %15 = load i64, ptr %14, align 4
ADD:   %14 = getelementptr i64, ptr %1, i64 6
ADD:   %13 = load i64, ptr %12, align 4
ADD:   %12 = getelementptr i64, ptr %1, i64 5
ADD:   %11 = load i64, ptr %10, align 4
ADD:   %10 = getelementptr i64, ptr %1, i64 4
ADD:   %9 = load i64, ptr %8, align 4
ADD:   %8 = getelementptr i64, ptr %1, i64 3
ADD:   %7 = load i64, ptr %6, align 4
ADD:   %6 = getelementptr i64, ptr %1, i64 2
ADD:   %5 = load i64, ptr %4, align 4
ADD:   %4 = getelementptr i64, ptr %1, i64 1
ADD:   %3 = load i64, ptr %1, align 4
ADD:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
ADD:   store i64 1, ptr %.fca.4.0.gep, align 8
ADD:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
ADD:   store i64 7, ptr %.fca.3.0.gep, align 8
ADD:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
ADD:   store i64 0, ptr %.fca.2.gep, align 8
ADD:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
ADD:   store ptr %1, ptr %.fca.1.gep, align 8
ADD:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
ADD:   store ptr %1, ptr %2, align 8
ADD:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %1, ptr %2, align 8
IC: Visiting:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
IC: Visiting:   store ptr %1, ptr %.fca.1.gep, align 8
IC: Visiting:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.fca.2.gep, align 8
IC: Visiting:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
IC: Visiting:   store i64 7, ptr %.fca.3.0.gep, align 8
IC: Visiting:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
IC: Visiting:   store i64 1, ptr %.fca.4.0.gep, align 8
IC: Visiting:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
IC: Visiting:   %3 = load i64, ptr %1, align 4
IC: Visiting:   %4 = getelementptr i64, ptr %1, i64 1
IC: Visiting:   %5 = load i64, ptr %4, align 4
IC: Visiting:   %6 = getelementptr i64, ptr %1, i64 2
IC: Visiting:   %7 = load i64, ptr %6, align 4
IC: Visiting:   %8 = getelementptr i64, ptr %1, i64 3
IC: Visiting:   %9 = load i64, ptr %8, align 4
IC: Visiting:   %10 = getelementptr i64, ptr %1, i64 4
IC: Visiting:   %11 = load i64, ptr %10, align 4
IC: Visiting:   %12 = getelementptr i64, ptr %1, i64 5
IC: Visiting:   %13 = load i64, ptr %12, align 4
IC: Visiting:   %14 = getelementptr i64, ptr %1, i64 6
IC: Visiting:   %15 = load i64, ptr %14, align 4
IC: Visiting:   %16 = getelementptr i64, ptr %1, i64 7
IC: Visiting:   %17 = load i64, ptr %16, align 4
IC: Visiting:   %18 = getelementptr i64, ptr %1, i64 8
IC: Visiting:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %.idx = shl i64 %3, 3
IC: Visiting:   %20 = call ptr @malloc(i64 %.idx)
IC: Visiting:   %21 = icmp sgt i64 %3, 0
IC: Visiting:   br i1 %21, label %.lr.ph.preheader, label %._crit_edge
IC: Visiting:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %20, ptr %22, align 8
IC: Visiting:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
IC: Visiting:   store ptr %20, ptr %.repack9, align 8
IC: Visiting:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack11, align 8
IC: Visiting:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3
IC: Visiting:   store i64 %3, ptr %.repack13, align 8
IC: Visiting:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack15, align 8
IC: Visiting:   %.idx17 = shl i64 %5, 3
IC: Visiting:   %23 = call ptr @malloc(i64 %.idx17)
IC: Visiting:   %24 = icmp sgt i64 %5, 0
IC: Visiting:   br i1 %24, label %.lr.ph90.preheader, label %._crit_edge91
IC: Visiting:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %23, ptr %25, align 8
IC: Visiting:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
IC: Visiting:   store ptr %23, ptr %.repack18, align 8
IC: Visiting:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack20, align 8
IC: Visiting:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3
IC: Visiting:   store i64 %5, ptr %.repack22, align 8
IC: Visiting:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack24, align 8
IC: Visiting:   %.idx26 = shl i64 %7, 3
IC: Visiting:   %26 = call ptr @malloc(i64 %.idx26)
IC: Visiting:   %27 = icmp sgt i64 %7, 0
IC: Visiting:   br i1 %27, label %.lr.ph93.preheader, label %._crit_edge94
IC: Visiting:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %26, ptr %28, align 8
IC: Visiting:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
IC: Visiting:   store ptr %26, ptr %.repack27, align 8
IC: Visiting:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack29, align 8
IC: Visiting:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
IC: Visiting:   store i64 %7, ptr %.repack31, align 8
IC: Visiting:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack33, align 8
IC: Visiting:   %.idx35 = shl i64 %9, 3
IC: Visiting:   %29 = call ptr @malloc(i64 %.idx35)
IC: Visiting:   %30 = icmp sgt i64 %9, 0
IC: Visiting:   br i1 %30, label %.lr.ph96.preheader, label %._crit_edge97
IC: Visiting:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %29, ptr %31, align 8
IC: Visiting:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
IC: Visiting:   store ptr %29, ptr %.repack36, align 8
IC: Visiting:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack38, align 8
IC: Visiting:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3
IC: Visiting:   store i64 %9, ptr %.repack40, align 8
IC: Visiting:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack42, align 8
IC: Visiting:   %.idx44 = shl i64 %11, 3
IC: Visiting:   %32 = call ptr @malloc(i64 %.idx44)
IC: Visiting:   %33 = icmp sgt i64 %11, 0
IC: Visiting:   br i1 %33, label %.lr.ph99.preheader, label %._crit_edge100
IC: Visiting:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %32, ptr %34, align 8
IC: Visiting:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
IC: Visiting:   store ptr %32, ptr %.repack45, align 8
IC: Visiting:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack47, align 8
IC: Visiting:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3
IC: Visiting:   store i64 %11, ptr %.repack49, align 8
IC: Visiting:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack51, align 8
IC: Visiting:   %.idx53 = shl i64 %13, 3
IC: Visiting:   %35 = call ptr @malloc(i64 %.idx53)
IC: Visiting:   %36 = icmp sgt i64 %13, 0
IC: Visiting:   br i1 %36, label %.lr.ph102.preheader, label %._crit_edge103
IC: Visiting:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %35, ptr %37, align 8
IC: Visiting:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
IC: Visiting:   store ptr %35, ptr %.repack54, align 8
IC: Visiting:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack56, align 8
IC: Visiting:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
IC: Visiting:   store i64 %13, ptr %.repack58, align 8
IC: Visiting:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack60, align 8
IC: Visiting:   %.idx62 = shl i64 %15, 3
IC: Visiting:   %38 = call ptr @malloc(i64 %.idx62)
IC: Visiting:   %39 = icmp sgt i64 %15, 0
IC: Visiting:   br i1 %39, label %.lr.ph105.preheader, label %._crit_edge106
IC: Visiting:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %38, ptr %40, align 8
IC: Visiting:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
IC: Visiting:   store ptr %38, ptr %.repack63, align 8
IC: Visiting:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack65, align 8
IC: Visiting:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
IC: Visiting:   store i64 %15, ptr %.repack67, align 8
IC: Visiting:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack69, align 8
IC: Visiting:   %.idx71 = shl i64 %17, 3
IC: Visiting:   %41 = call ptr @malloc(i64 %.idx71)
IC: Visiting:   %42 = icmp sgt i64 %17, 0
IC: Visiting:   br i1 %42, label %.lr.ph108.preheader, label %._crit_edge109
IC: Visiting:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %41, ptr %43, align 8
IC: Visiting:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
IC: Visiting:   store ptr %41, ptr %.repack72, align 8
IC: Visiting:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack74, align 8
IC: Visiting:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3
IC: Visiting:   store i64 %17, ptr %.repack76, align 8
IC: Visiting:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack78, align 8
IC: Visiting:   %.idx80 = shl i64 %19, 3
IC: Visiting:   %44 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   %45 = icmp sgt i64 %19, 0
IC: Visiting:   br i1 %45, label %.lr.ph111.preheader, label %._crit_edge112
IC: Visiting:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %44, ptr %46, align 8
IC: Visiting:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
IC: Visiting:   store ptr %44, ptr %.repack81, align 8
IC: Visiting:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack83, align 8
IC: Visiting:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
IC: Visiting:   store i64 %19, ptr %.repack85, align 8
IC: Visiting:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack87, align 8
IC: Visiting:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %22)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %25)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %31)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %34)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %43)
IC: Visiting:   call void @comet_print_memref_f64(i64 1, ptr nonnull %46)
IC: Visiting:   ret void
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false)
IC: Visiting:   br label %._crit_edge112
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false)
IC: Visiting:   br label %._crit_edge109
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false)
IC: Visiting:   br label %._crit_edge106
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false)
IC: Visiting:   br label %._crit_edge103
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false)
IC: Visiting:   br label %._crit_edge100
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false)
IC: Visiting:   br label %._crit_edge97
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false)
IC: Visiting:   br label %._crit_edge94
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false)
IC: Visiting:   br label %._crit_edge91
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false)
IC: Visiting:   br label %._crit_edge
Jump threading on function 'main'
LVI Getting value   %3 = load i64, ptr %1, align 4 at ''
  Result = overdefined
LVI Getting block end value   %3 = load i64, ptr %1, align 4 at ''
PUSH:   %3 = load i64, ptr %1, align 4 in 
 compute BB '' - unknown inst def found.
POP   %3 = load i64, ptr %1, align 4 in  = overdefined
  Result = overdefined
LVI Getting value   %5 = load i64, ptr %4, align 4 at ''
  Result = overdefined
LVI Getting edge value   %5 = load i64, ptr %4, align 4 from '.lr.ph.preheader' to '._crit_edge'
PUSH:   %5 = load i64, ptr %4, align 4 in .lr.ph.preheader
PUSH:   %5 = load i64, ptr %4, align 4 in 
 compute BB '' - unknown inst def found.
POP   %5 = load i64, ptr %4, align 4 in  = overdefined
 compute BB '.lr.ph.preheader' - overdefined because of pred '' (non local).
POP   %5 = load i64, ptr %4, align 4 in .lr.ph.preheader = overdefined
  Result = overdefined
LVI Getting edge value   %5 = load i64, ptr %4, align 4 from '.lr.ph.preheader' to '._crit_edge'
  Result = overdefined
LVI Getting edge value   %5 = load i64, ptr %4, align 4 from '' to '._crit_edge'
  Result = overdefined
LVI Getting value   %7 = load i64, ptr %6, align 4 at ''
  Result = overdefined
LVI Getting edge value   %7 = load i64, ptr %6, align 4 from '.lr.ph90.preheader' to '._crit_edge91'
PUSH:   %7 = load i64, ptr %6, align 4 in .lr.ph90.preheader
PUSH:   %7 = load i64, ptr %6, align 4 in ._crit_edge
PUSH:   %7 = load i64, ptr %6, align 4 in .lr.ph.preheader
PUSH:   %7 = load i64, ptr %6, align 4 in 
 compute BB '' - unknown inst def found.
POP   %7 = load i64, ptr %6, align 4 in  = overdefined
 compute BB '.lr.ph.preheader' - overdefined because of pred '' (non local).
POP   %7 = load i64, ptr %6, align 4 in .lr.ph.preheader = overdefined
 compute BB '._crit_edge' - overdefined because of pred '.lr.ph.preheader' (non local).
POP   %7 = load i64, ptr %6, align 4 in ._crit_edge = overdefined
 compute BB '.lr.ph90.preheader' - overdefined because of pred '._crit_edge' (non local).
POP   %7 = load i64, ptr %6, align 4 in .lr.ph90.preheader = overdefined
  Result = overdefined
LVI Getting edge value   %7 = load i64, ptr %6, align 4 from '.lr.ph90.preheader' to '._crit_edge91'
  Result = overdefined
LVI Getting edge value   %7 = load i64, ptr %6, align 4 from '._crit_edge' to '._crit_edge91'
  Result = overdefined
LVI Getting value   %9 = load i64, ptr %8, align 4 at ''
  Result = overdefined
LVI Getting edge value   %9 = load i64, ptr %8, align 4 from '.lr.ph93.preheader' to '._crit_edge94'
PUSH:   %9 = load i64, ptr %8, align 4 in .lr.ph93.preheader
PUSH:   %9 = load i64, ptr %8, align 4 in ._crit_edge91
PUSH:   %9 = load i64, ptr %8, align 4 in .lr.ph90.preheader
PUSH:   %9 = load i64, ptr %8, align 4 in ._crit_edge
PUSH:   %9 = load i64, ptr %8, align 4 in .lr.ph.preheader
PUSH:   %9 = load i64, ptr %8, align 4 in 
 compute BB '' - unknown inst def found.
POP   %9 = load i64, ptr %8, align 4 in  = overdefined
 compute BB '.lr.ph.preheader' - overdefined because of pred '' (non local).
POP   %9 = load i64, ptr %8, align 4 in .lr.ph.preheader = overdefined
 compute BB '._crit_edge' - overdefined because of pred '.lr.ph.preheader' (non local).
POP   %9 = load i64, ptr %8, align 4 in ._crit_edge = overdefined
 compute BB '.lr.ph90.preheader' - overdefined because of pred '._crit_edge' (non local).
POP   %9 = load i64, ptr %8, align 4 in .lr.ph90.preheader = overdefined
 compute BB '._crit_edge91' - overdefined because of pred '.lr.ph90.preheader' (non local).
POP   %9 = load i64, ptr %8, align 4 in ._crit_edge91 = overdefined
 compute BB '.lr.ph93.preheader' - overdefined because of pred '._crit_edge91' (non local).
POP   %9 = load i64, ptr %8, align 4 in .lr.ph93.preheader = overdefined
  Result = overdefined
LVI Getting edge value   %9 = load i64, ptr %8, align 4 from '.lr.ph93.preheader' to '._crit_edge94'
  Result = overdefined
LVI Getting edge value   %9 = load i64, ptr %8, align 4 from '._crit_edge91' to '._crit_edge94'
  Result = overdefined
LVI Getting value   %11 = load i64, ptr %10, align 4 at ''
  Result = overdefined
LVI Getting edge value   %11 = load i64, ptr %10, align 4 from '.lr.ph96.preheader' to '._crit_edge97'
PUSH:   %11 = load i64, ptr %10, align 4 in .lr.ph96.preheader
PUSH:   %11 = load i64, ptr %10, align 4 in ._crit_edge94
PUSH:   %11 = load i64, ptr %10, align 4 in .lr.ph93.preheader
PUSH:   %11 = load i64, ptr %10, align 4 in ._crit_edge91
PUSH:   %11 = load i64, ptr %10, align 4 in .lr.ph90.preheader
PUSH:   %11 = load i64, ptr %10, align 4 in ._crit_edge
PUSH:   %11 = load i64, ptr %10, align 4 in .lr.ph.preheader
PUSH:   %11 = load i64, ptr %10, align 4 in 
 compute BB '' - unknown inst def found.
POP   %11 = load i64, ptr %10, align 4 in  = overdefined
 compute BB '.lr.ph.preheader' - overdefined because of pred '' (non local).
POP   %11 = load i64, ptr %10, align 4 in .lr.ph.preheader = overdefined
 compute BB '._crit_edge' - overdefined because of pred '.lr.ph.preheader' (non local).
POP   %11 = load i64, ptr %10, align 4 in ._crit_edge = overdefined
 compute BB '.lr.ph90.preheader' - overdefined because of pred '._crit_edge' (non local).
POP   %11 = load i64, ptr %10, align 4 in .lr.ph90.preheader = overdefined
 compute BB '._crit_edge91' - overdefined because of pred '.lr.ph90.preheader' (non local).
POP   %11 = load i64, ptr %10, align 4 in ._crit_edge91 = overdefined
 compute BB '.lr.ph93.preheader' - overdefined because of pred '._crit_edge91' (non local).
POP   %11 = load i64, ptr %10, align 4 in .lr.ph93.preheader = overdefined
 compute BB '._crit_edge94' - overdefined because of pred '.lr.ph93.preheader' (non local).
POP   %11 = load i64, ptr %10, align 4 in ._crit_edge94 = overdefined
 compute BB '.lr.ph96.preheader' - overdefined because of pred '._crit_edge94' (non local).
POP   %11 = load i64, ptr %10, align 4 in .lr.ph96.preheader = overdefined
  Result = overdefined
LVI Getting edge value   %11 = load i64, ptr %10, align 4 from '.lr.ph96.preheader' to '._crit_edge97'
  Result = overdefined
LVI Getting edge value   %11 = load i64, ptr %10, align 4 from '._crit_edge94' to '._crit_edge97'
  Result = overdefined
LVI Getting value   %13 = load i64, ptr %12, align 4 at ''
  Result = overdefined
LVI Getting edge value   %13 = load i64, ptr %12, align 4 from '.lr.ph99.preheader' to '._crit_edge100'
PUSH:   %13 = load i64, ptr %12, align 4 in .lr.ph99.preheader
PUSH:   %13 = load i64, ptr %12, align 4 in ._crit_edge97
PUSH:   %13 = load i64, ptr %12, align 4 in .lr.ph96.preheader
PUSH:   %13 = load i64, ptr %12, align 4 in ._crit_edge94
PUSH:   %13 = load i64, ptr %12, align 4 in .lr.ph93.preheader
PUSH:   %13 = load i64, ptr %12, align 4 in ._crit_edge91
PUSH:   %13 = load i64, ptr %12, align 4 in .lr.ph90.preheader
PUSH:   %13 = load i64, ptr %12, align 4 in ._crit_edge
PUSH:   %13 = load i64, ptr %12, align 4 in .lr.ph.preheader
PUSH:   %13 = load i64, ptr %12, align 4 in 
 compute BB '' - unknown inst def found.
POP   %13 = load i64, ptr %12, align 4 in  = overdefined
 compute BB '.lr.ph.preheader' - overdefined because of pred '' (non local).
POP   %13 = load i64, ptr %12, align 4 in .lr.ph.preheader = overdefined
 compute BB '._crit_edge' - overdefined because of pred '.lr.ph.preheader' (non local).
POP   %13 = load i64, ptr %12, align 4 in ._crit_edge = overdefined
 compute BB '.lr.ph90.preheader' - overdefined because of pred '._crit_edge' (non local).
POP   %13 = load i64, ptr %12, align 4 in .lr.ph90.preheader = overdefined
 compute BB '._crit_edge91' - overdefined because of pred '.lr.ph90.preheader' (non local).
POP   %13 = load i64, ptr %12, align 4 in ._crit_edge91 = overdefined
 compute BB '.lr.ph93.preheader' - overdefined because of pred '._crit_edge91' (non local).
POP   %13 = load i64, ptr %12, align 4 in .lr.ph93.preheader = overdefined
 compute BB '._crit_edge94' - overdefined because of pred '.lr.ph93.preheader' (non local).
POP   %13 = load i64, ptr %12, align 4 in ._crit_edge94 = overdefined
 compute BB '.lr.ph96.preheader' - overdefined because of pred '._crit_edge94' (non local).
POP   %13 = load i64, ptr %12, align 4 in .lr.ph96.preheader = overdefined
 compute BB '._crit_edge97' - overdefined because of pred '.lr.ph96.preheader' (non local).
POP   %13 = load i64, ptr %12, align 4 in ._crit_edge97 = overdefined
 compute BB '.lr.ph99.preheader' - overdefined because of pred '._crit_edge97' (non local).
POP   %13 = load i64, ptr %12, align 4 in .lr.ph99.preheader = overdefined
  Result = overdefined
LVI Getting edge value   %13 = load i64, ptr %12, align 4 from '.lr.ph99.preheader' to '._crit_edge100'
  Result = overdefined
LVI Getting edge value   %13 = load i64, ptr %12, align 4 from '._crit_edge97' to '._crit_edge100'
  Result = overdefined
LVI Getting value   %15 = load i64, ptr %14, align 4 at ''
  Result = overdefined
LVI Getting edge value   %15 = load i64, ptr %14, align 4 from '.lr.ph102.preheader' to '._crit_edge103'
PUSH:   %15 = load i64, ptr %14, align 4 in .lr.ph102.preheader
PUSH:   %15 = load i64, ptr %14, align 4 in ._crit_edge100
PUSH:   %15 = load i64, ptr %14, align 4 in .lr.ph99.preheader
PUSH:   %15 = load i64, ptr %14, align 4 in ._crit_edge97
PUSH:   %15 = load i64, ptr %14, align 4 in .lr.ph96.preheader
PUSH:   %15 = load i64, ptr %14, align 4 in ._crit_edge94
PUSH:   %15 = load i64, ptr %14, align 4 in .lr.ph93.preheader
PUSH:   %15 = load i64, ptr %14, align 4 in ._crit_edge91
PUSH:   %15 = load i64, ptr %14, align 4 in .lr.ph90.preheader
PUSH:   %15 = load i64, ptr %14, align 4 in ._crit_edge
PUSH:   %15 = load i64, ptr %14, align 4 in .lr.ph.preheader
PUSH:   %15 = load i64, ptr %14, align 4 in 
 compute BB '' - unknown inst def found.
POP   %15 = load i64, ptr %14, align 4 in  = overdefined
 compute BB '.lr.ph.preheader' - overdefined because of pred '' (non local).
POP   %15 = load i64, ptr %14, align 4 in .lr.ph.preheader = overdefined
 compute BB '._crit_edge' - overdefined because of pred '.lr.ph.preheader' (non local).
POP   %15 = load i64, ptr %14, align 4 in ._crit_edge = overdefined
 compute BB '.lr.ph90.preheader' - overdefined because of pred '._crit_edge' (non local).
POP   %15 = load i64, ptr %14, align 4 in .lr.ph90.preheader = overdefined
 compute BB '._crit_edge91' - overdefined because of pred '.lr.ph90.preheader' (non local).
POP   %15 = load i64, ptr %14, align 4 in ._crit_edge91 = overdefined
 compute BB '.lr.ph93.preheader' - overdefined because of pred '._crit_edge91' (non local).
POP   %15 = load i64, ptr %14, align 4 in .lr.ph93.preheader = overdefined
 compute BB '._crit_edge94' - overdefined because of pred '.lr.ph93.preheader' (non local).
POP   %15 = load i64, ptr %14, align 4 in ._crit_edge94 = overdefined
 compute BB '.lr.ph96.preheader' - overdefined because of pred '._crit_edge94' (non local).
POP   %15 = load i64, ptr %14, align 4 in .lr.ph96.preheader = overdefined
 compute BB '._crit_edge97' - overdefined because of pred '.lr.ph96.preheader' (non local).
POP   %15 = load i64, ptr %14, align 4 in ._crit_edge97 = overdefined
 compute BB '.lr.ph99.preheader' - overdefined because of pred '._crit_edge97' (non local).
POP   %15 = load i64, ptr %14, align 4 in .lr.ph99.preheader = overdefined
 compute BB '._crit_edge100' - overdefined because of pred '.lr.ph99.preheader' (non local).
POP   %15 = load i64, ptr %14, align 4 in ._crit_edge100 = overdefined
 compute BB '.lr.ph102.preheader' - overdefined because of pred '._crit_edge100' (non local).
POP   %15 = load i64, ptr %14, align 4 in .lr.ph102.preheader = overdefined
  Result = overdefined
LVI Getting edge value   %15 = load i64, ptr %14, align 4 from '.lr.ph102.preheader' to '._crit_edge103'
  Result = overdefined
LVI Getting edge value   %15 = load i64, ptr %14, align 4 from '._crit_edge100' to '._crit_edge103'
  Result = overdefined
LVI Getting value   %17 = load i64, ptr %16, align 4 at ''
  Result = overdefined
LVI Getting edge value   %17 = load i64, ptr %16, align 4 from '.lr.ph105.preheader' to '._crit_edge106'
PUSH:   %17 = load i64, ptr %16, align 4 in .lr.ph105.preheader
PUSH:   %17 = load i64, ptr %16, align 4 in ._crit_edge103
PUSH:   %17 = load i64, ptr %16, align 4 in .lr.ph102.preheader
PUSH:   %17 = load i64, ptr %16, align 4 in ._crit_edge100
PUSH:   %17 = load i64, ptr %16, align 4 in .lr.ph99.preheader
PUSH:   %17 = load i64, ptr %16, align 4 in ._crit_edge97
PUSH:   %17 = load i64, ptr %16, align 4 in .lr.ph96.preheader
PUSH:   %17 = load i64, ptr %16, align 4 in ._crit_edge94
PUSH:   %17 = load i64, ptr %16, align 4 in .lr.ph93.preheader
PUSH:   %17 = load i64, ptr %16, align 4 in ._crit_edge91
PUSH:   %17 = load i64, ptr %16, align 4 in .lr.ph90.preheader
PUSH:   %17 = load i64, ptr %16, align 4 in ._crit_edge
PUSH:   %17 = load i64, ptr %16, align 4 in .lr.ph.preheader
PUSH:   %17 = load i64, ptr %16, align 4 in 
 compute BB '' - unknown inst def found.
POP   %17 = load i64, ptr %16, align 4 in  = overdefined
 compute BB '.lr.ph.preheader' - overdefined because of pred '' (non local).
POP   %17 = load i64, ptr %16, align 4 in .lr.ph.preheader = overdefined
 compute BB '._crit_edge' - overdefined because of pred '.lr.ph.preheader' (non local).
POP   %17 = load i64, ptr %16, align 4 in ._crit_edge = overdefined
 compute BB '.lr.ph90.preheader' - overdefined because of pred '._crit_edge' (non local).
POP   %17 = load i64, ptr %16, align 4 in .lr.ph90.preheader = overdefined
 compute BB '._crit_edge91' - overdefined because of pred '.lr.ph90.preheader' (non local).
POP   %17 = load i64, ptr %16, align 4 in ._crit_edge91 = overdefined
 compute BB '.lr.ph93.preheader' - overdefined because of pred '._crit_edge91' (non local).
POP   %17 = load i64, ptr %16, align 4 in .lr.ph93.preheader = overdefined
 compute BB '._crit_edge94' - overdefined because of pred '.lr.ph93.preheader' (non local).
POP   %17 = load i64, ptr %16, align 4 in ._crit_edge94 = overdefined
 compute BB '.lr.ph96.preheader' - overdefined because of pred '._crit_edge94' (non local).
POP   %17 = load i64, ptr %16, align 4 in .lr.ph96.preheader = overdefined
 compute BB '._crit_edge97' - overdefined because of pred '.lr.ph96.preheader' (non local).
POP   %17 = load i64, ptr %16, align 4 in ._crit_edge97 = overdefined
 compute BB '.lr.ph99.preheader' - overdefined because of pred '._crit_edge97' (non local).
POP   %17 = load i64, ptr %16, align 4 in .lr.ph99.preheader = overdefined
 compute BB '._crit_edge100' - overdefined because of pred '.lr.ph99.preheader' (non local).
POP   %17 = load i64, ptr %16, align 4 in ._crit_edge100 = overdefined
 compute BB '.lr.ph102.preheader' - overdefined because of pred '._crit_edge100' (non local).
POP   %17 = load i64, ptr %16, align 4 in .lr.ph102.preheader = overdefined
 compute BB '._crit_edge103' - overdefined because of pred '.lr.ph102.preheader' (non local).
POP   %17 = load i64, ptr %16, align 4 in ._crit_edge103 = overdefined
 compute BB '.lr.ph105.preheader' - overdefined because of pred '._crit_edge103' (non local).
POP   %17 = load i64, ptr %16, align 4 in .lr.ph105.preheader = overdefined
  Result = overdefined
LVI Getting edge value   %17 = load i64, ptr %16, align 4 from '.lr.ph105.preheader' to '._crit_edge106'
  Result = overdefined
LVI Getting edge value   %17 = load i64, ptr %16, align 4 from '._crit_edge103' to '._crit_edge106'
  Result = overdefined
LVI Getting value   %19 = load i64, ptr %18, align 4 at ''
  Result = overdefined
LVI Getting edge value   %19 = load i64, ptr %18, align 4 from '.lr.ph108.preheader' to '._crit_edge109'
PUSH:   %19 = load i64, ptr %18, align 4 in .lr.ph108.preheader
PUSH:   %19 = load i64, ptr %18, align 4 in ._crit_edge106
PUSH:   %19 = load i64, ptr %18, align 4 in .lr.ph105.preheader
PUSH:   %19 = load i64, ptr %18, align 4 in ._crit_edge103
PUSH:   %19 = load i64, ptr %18, align 4 in .lr.ph102.preheader
PUSH:   %19 = load i64, ptr %18, align 4 in ._crit_edge100
PUSH:   %19 = load i64, ptr %18, align 4 in .lr.ph99.preheader
PUSH:   %19 = load i64, ptr %18, align 4 in ._crit_edge97
PUSH:   %19 = load i64, ptr %18, align 4 in .lr.ph96.preheader
PUSH:   %19 = load i64, ptr %18, align 4 in ._crit_edge94
PUSH:   %19 = load i64, ptr %18, align 4 in .lr.ph93.preheader
PUSH:   %19 = load i64, ptr %18, align 4 in ._crit_edge91
PUSH:   %19 = load i64, ptr %18, align 4 in .lr.ph90.preheader
PUSH:   %19 = load i64, ptr %18, align 4 in ._crit_edge
PUSH:   %19 = load i64, ptr %18, align 4 in .lr.ph.preheader
PUSH:   %19 = load i64, ptr %18, align 4 in 
 compute BB '' - unknown inst def found.
POP   %19 = load i64, ptr %18, align 4 in  = overdefined
 compute BB '.lr.ph.preheader' - overdefined because of pred '' (non local).
POP   %19 = load i64, ptr %18, align 4 in .lr.ph.preheader = overdefined
 compute BB '._crit_edge' - overdefined because of pred '.lr.ph.preheader' (non local).
POP   %19 = load i64, ptr %18, align 4 in ._crit_edge = overdefined
 compute BB '.lr.ph90.preheader' - overdefined because of pred '._crit_edge' (non local).
POP   %19 = load i64, ptr %18, align 4 in .lr.ph90.preheader = overdefined
 compute BB '._crit_edge91' - overdefined because of pred '.lr.ph90.preheader' (non local).
POP   %19 = load i64, ptr %18, align 4 in ._crit_edge91 = overdefined
 compute BB '.lr.ph93.preheader' - overdefined because of pred '._crit_edge91' (non local).
POP   %19 = load i64, ptr %18, align 4 in .lr.ph93.preheader = overdefined
 compute BB '._crit_edge94' - overdefined because of pred '.lr.ph93.preheader' (non local).
POP   %19 = load i64, ptr %18, align 4 in ._crit_edge94 = overdefined
 compute BB '.lr.ph96.preheader' - overdefined because of pred '._crit_edge94' (non local).
POP   %19 = load i64, ptr %18, align 4 in .lr.ph96.preheader = overdefined
 compute BB '._crit_edge97' - overdefined because of pred '.lr.ph96.preheader' (non local).
POP   %19 = load i64, ptr %18, align 4 in ._crit_edge97 = overdefined
 compute BB '.lr.ph99.preheader' - overdefined because of pred '._crit_edge97' (non local).
POP   %19 = load i64, ptr %18, align 4 in .lr.ph99.preheader = overdefined
 compute BB '._crit_edge100' - overdefined because of pred '.lr.ph99.preheader' (non local).
POP   %19 = load i64, ptr %18, align 4 in ._crit_edge100 = overdefined
 compute BB '.lr.ph102.preheader' - overdefined because of pred '._crit_edge100' (non local).
POP   %19 = load i64, ptr %18, align 4 in .lr.ph102.preheader = overdefined
 compute BB '._crit_edge103' - overdefined because of pred '.lr.ph102.preheader' (non local).
POP   %19 = load i64, ptr %18, align 4 in ._crit_edge103 = overdefined
 compute BB '.lr.ph105.preheader' - overdefined because of pred '._crit_edge103' (non local).
POP   %19 = load i64, ptr %18, align 4 in .lr.ph105.preheader = overdefined
 compute BB '._crit_edge106' - overdefined because of pred '.lr.ph105.preheader' (non local).
POP   %19 = load i64, ptr %18, align 4 in ._crit_edge106 = overdefined
 compute BB '.lr.ph108.preheader' - overdefined because of pred '._crit_edge106' (non local).
POP   %19 = load i64, ptr %18, align 4 in .lr.ph108.preheader = overdefined
  Result = overdefined
LVI Getting edge value   %19 = load i64, ptr %18, align 4 from '.lr.ph108.preheader' to '._crit_edge109'
  Result = overdefined
LVI Getting edge value   %19 = load i64, ptr %18, align 4 from '._crit_edge106' to '._crit_edge109'
  Result = overdefined
LVI Getting block end value   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1 at ''
PUSH:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1 in 
POP   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2 at ''
PUSH:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2 in 
POP   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0 at ''
PUSH:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0 in 
POP   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0 at ''
PUSH:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0 in 
POP   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0 in  = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56) at ''
PUSH:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56) in 
 compute BB '' - unknown inst def found.
POP   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56) in  = overdefined
  Result = overdefined
LVI Getting block end value   %4 = getelementptr i64, ptr %1, i64 1 at ''
PUSH:   %4 = getelementptr i64, ptr %1, i64 1 in 
 compute BB '' - unknown inst def found.
POP   %4 = getelementptr i64, ptr %1, i64 1 in  = overdefined
  Result = overdefined
LVI Getting block end value   %6 = getelementptr i64, ptr %1, i64 2 at ''
PUSH:   %6 = getelementptr i64, ptr %1, i64 2 in 
 compute BB '' - unknown inst def found.
POP   %6 = getelementptr i64, ptr %1, i64 2 in  = overdefined
  Result = overdefined
LVI Getting block end value   %8 = getelementptr i64, ptr %1, i64 3 at ''
PUSH:   %8 = getelementptr i64, ptr %1, i64 3 in 
 compute BB '' - unknown inst def found.
POP   %8 = getelementptr i64, ptr %1, i64 3 in  = overdefined
  Result = overdefined
LVI Getting block end value   %10 = getelementptr i64, ptr %1, i64 4 at ''
PUSH:   %10 = getelementptr i64, ptr %1, i64 4 in 
 compute BB '' - unknown inst def found.
POP   %10 = getelementptr i64, ptr %1, i64 4 in  = overdefined
  Result = overdefined
LVI Getting block end value   %12 = getelementptr i64, ptr %1, i64 5 at ''
PUSH:   %12 = getelementptr i64, ptr %1, i64 5 in 
 compute BB '' - unknown inst def found.
POP   %12 = getelementptr i64, ptr %1, i64 5 in  = overdefined
  Result = overdefined
LVI Getting block end value   %14 = getelementptr i64, ptr %1, i64 6 at ''
PUSH:   %14 = getelementptr i64, ptr %1, i64 6 in 
 compute BB '' - unknown inst def found.
POP   %14 = getelementptr i64, ptr %1, i64 6 in  = overdefined
  Result = overdefined
LVI Getting block end value   %16 = getelementptr i64, ptr %1, i64 7 at ''
PUSH:   %16 = getelementptr i64, ptr %1, i64 7 in 
 compute BB '' - unknown inst def found.
POP   %16 = getelementptr i64, ptr %1, i64 7 in  = overdefined
  Result = overdefined
LVI Getting block end value   %18 = getelementptr i64, ptr %1, i64 8 at ''
PUSH:   %18 = getelementptr i64, ptr %1, i64 8 in 
 compute BB '' - unknown inst def found.
POP   %18 = getelementptr i64, ptr %1, i64 8 in  = overdefined
  Result = overdefined
LVI Getting block end value   %3 = load i64, ptr %1, align 4 at ''
  Result = overdefined
LVI Getting block end value i64 3 at ''
  Result = constantrange<3, 4>
LVI Getting block end value   %3 = load i64, ptr %1, align 4 at ''
  Result = overdefined
LVI Getting block end value   %3 = load i64, ptr %1, align 4 at ''
  Result = overdefined
LVI Getting block end value i64 0 at ''
  Result = constantrange<0, 1>
LVI Getting value   %20 = call ptr @malloc(i64 %.idx) at ''
  Result = overdefined
LVI Getting edge value   %20 = call ptr @malloc(i64 %.idx) from '' to '.lr.ph.preheader'
PUSH:   %20 = call ptr @malloc(i64 %.idx) in 
 compute BB '' - unknown inst def found.
POP   %20 = call ptr @malloc(i64 %.idx) in  = overdefined
  Result = overdefined
LVI Getting block end value   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1 at '._crit_edge'
PUSH:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1 in ._crit_edge
POP   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1 in ._crit_edge = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2 at '._crit_edge'
PUSH:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2 in ._crit_edge
POP   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2 in ._crit_edge = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3 at '._crit_edge'
PUSH:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3 in ._crit_edge
POP   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3 in ._crit_edge = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4 at '._crit_edge'
PUSH:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4 in ._crit_edge
POP   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4 in ._crit_edge = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %5 = load i64, ptr %4, align 4 at '._crit_edge'
PUSH:   %5 = load i64, ptr %4, align 4 in ._crit_edge
 compute BB '._crit_edge' - overdefined because of pred '.lr.ph.preheader' (non local).
POP   %5 = load i64, ptr %4, align 4 in ._crit_edge = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at '._crit_edge'
  Result = constantrange<3, 4>
LVI Getting block end value   %5 = load i64, ptr %4, align 4 at '._crit_edge'
  Result = overdefined
LVI Getting edge value   %5 = load i64, ptr %4, align 4 from '.lr.ph.preheader' to '._crit_edge'
  Result = overdefined
LVI Getting block end value   %5 = load i64, ptr %4, align 4 at '._crit_edge'
  Result = overdefined
LVI Getting block end value i64 0 at '._crit_edge'
  Result = constantrange<0, 1>
LVI Getting value   %23 = call ptr @malloc(i64 %.idx17) at ''
  Result = overdefined
LVI Getting edge value   %23 = call ptr @malloc(i64 %.idx17) from '._crit_edge' to '.lr.ph90.preheader'
PUSH:   %23 = call ptr @malloc(i64 %.idx17) in ._crit_edge
 compute BB '._crit_edge' - unknown inst def found.
POP   %23 = call ptr @malloc(i64 %.idx17) in ._crit_edge = overdefined
  Result = overdefined
LVI Getting block end value   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1 at '._crit_edge91'
PUSH:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1 in ._crit_edge91
POP   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1 in ._crit_edge91 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2 at '._crit_edge91'
PUSH:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2 in ._crit_edge91
POP   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2 in ._crit_edge91 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3 at '._crit_edge91'
PUSH:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3 in ._crit_edge91
POP   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3 in ._crit_edge91 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4 at '._crit_edge91'
PUSH:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4 in ._crit_edge91
POP   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4 in ._crit_edge91 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %7 = load i64, ptr %6, align 4 at '._crit_edge91'
PUSH:   %7 = load i64, ptr %6, align 4 in ._crit_edge91
 compute BB '._crit_edge91' - overdefined because of pred '.lr.ph90.preheader' (non local).
POP   %7 = load i64, ptr %6, align 4 in ._crit_edge91 = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at '._crit_edge91'
  Result = constantrange<3, 4>
LVI Getting block end value   %7 = load i64, ptr %6, align 4 at '._crit_edge91'
  Result = overdefined
LVI Getting edge value   %7 = load i64, ptr %6, align 4 from '.lr.ph90.preheader' to '._crit_edge91'
  Result = overdefined
LVI Getting block end value   %7 = load i64, ptr %6, align 4 at '._crit_edge91'
  Result = overdefined
LVI Getting block end value i64 0 at '._crit_edge91'
  Result = constantrange<0, 1>
LVI Getting value   %26 = call ptr @malloc(i64 %.idx26) at ''
  Result = overdefined
LVI Getting edge value   %26 = call ptr @malloc(i64 %.idx26) from '._crit_edge91' to '.lr.ph93.preheader'
PUSH:   %26 = call ptr @malloc(i64 %.idx26) in ._crit_edge91
 compute BB '._crit_edge91' - unknown inst def found.
POP   %26 = call ptr @malloc(i64 %.idx26) in ._crit_edge91 = overdefined
  Result = overdefined
LVI Getting block end value   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1 at '._crit_edge94'
PUSH:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1 in ._crit_edge94
POP   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1 in ._crit_edge94 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2 at '._crit_edge94'
PUSH:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2 in ._crit_edge94
POP   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2 in ._crit_edge94 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3 at '._crit_edge94'
PUSH:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3 in ._crit_edge94
POP   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3 in ._crit_edge94 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4 at '._crit_edge94'
PUSH:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4 in ._crit_edge94
POP   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4 in ._crit_edge94 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %9 = load i64, ptr %8, align 4 at '._crit_edge94'
PUSH:   %9 = load i64, ptr %8, align 4 in ._crit_edge94
 compute BB '._crit_edge94' - overdefined because of pred '.lr.ph93.preheader' (non local).
POP   %9 = load i64, ptr %8, align 4 in ._crit_edge94 = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at '._crit_edge94'
  Result = constantrange<3, 4>
LVI Getting block end value   %9 = load i64, ptr %8, align 4 at '._crit_edge94'
  Result = overdefined
LVI Getting edge value   %9 = load i64, ptr %8, align 4 from '.lr.ph93.preheader' to '._crit_edge94'
  Result = overdefined
LVI Getting block end value   %9 = load i64, ptr %8, align 4 at '._crit_edge94'
  Result = overdefined
LVI Getting block end value i64 0 at '._crit_edge94'
  Result = constantrange<0, 1>
LVI Getting value   %29 = call ptr @malloc(i64 %.idx35) at ''
  Result = overdefined
LVI Getting edge value   %29 = call ptr @malloc(i64 %.idx35) from '._crit_edge94' to '.lr.ph96.preheader'
PUSH:   %29 = call ptr @malloc(i64 %.idx35) in ._crit_edge94
 compute BB '._crit_edge94' - unknown inst def found.
POP   %29 = call ptr @malloc(i64 %.idx35) in ._crit_edge94 = overdefined
  Result = overdefined
LVI Getting block end value   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1 at '._crit_edge97'
PUSH:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1 in ._crit_edge97
POP   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1 in ._crit_edge97 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2 at '._crit_edge97'
PUSH:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2 in ._crit_edge97
POP   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2 in ._crit_edge97 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3 at '._crit_edge97'
PUSH:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3 in ._crit_edge97
POP   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3 in ._crit_edge97 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4 at '._crit_edge97'
PUSH:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4 in ._crit_edge97
POP   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4 in ._crit_edge97 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %11 = load i64, ptr %10, align 4 at '._crit_edge97'
PUSH:   %11 = load i64, ptr %10, align 4 in ._crit_edge97
 compute BB '._crit_edge97' - overdefined because of pred '.lr.ph96.preheader' (non local).
POP   %11 = load i64, ptr %10, align 4 in ._crit_edge97 = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at '._crit_edge97'
  Result = constantrange<3, 4>
LVI Getting block end value   %11 = load i64, ptr %10, align 4 at '._crit_edge97'
  Result = overdefined
LVI Getting edge value   %11 = load i64, ptr %10, align 4 from '.lr.ph96.preheader' to '._crit_edge97'
  Result = overdefined
LVI Getting block end value   %11 = load i64, ptr %10, align 4 at '._crit_edge97'
  Result = overdefined
LVI Getting block end value i64 0 at '._crit_edge97'
  Result = constantrange<0, 1>
LVI Getting value   %32 = call ptr @malloc(i64 %.idx44) at ''
  Result = overdefined
LVI Getting edge value   %32 = call ptr @malloc(i64 %.idx44) from '._crit_edge97' to '.lr.ph99.preheader'
PUSH:   %32 = call ptr @malloc(i64 %.idx44) in ._crit_edge97
 compute BB '._crit_edge97' - unknown inst def found.
POP   %32 = call ptr @malloc(i64 %.idx44) in ._crit_edge97 = overdefined
  Result = overdefined
LVI Getting block end value   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1 at '._crit_edge100'
PUSH:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1 in ._crit_edge100
POP   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1 in ._crit_edge100 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2 at '._crit_edge100'
PUSH:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2 in ._crit_edge100
POP   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2 in ._crit_edge100 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3 at '._crit_edge100'
PUSH:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3 in ._crit_edge100
POP   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3 in ._crit_edge100 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4 at '._crit_edge100'
PUSH:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4 in ._crit_edge100
POP   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4 in ._crit_edge100 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %13 = load i64, ptr %12, align 4 at '._crit_edge100'
PUSH:   %13 = load i64, ptr %12, align 4 in ._crit_edge100
 compute BB '._crit_edge100' - overdefined because of pred '.lr.ph99.preheader' (non local).
POP   %13 = load i64, ptr %12, align 4 in ._crit_edge100 = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at '._crit_edge100'
  Result = constantrange<3, 4>
LVI Getting block end value   %13 = load i64, ptr %12, align 4 at '._crit_edge100'
  Result = overdefined
LVI Getting edge value   %13 = load i64, ptr %12, align 4 from '.lr.ph99.preheader' to '._crit_edge100'
  Result = overdefined
LVI Getting block end value   %13 = load i64, ptr %12, align 4 at '._crit_edge100'
  Result = overdefined
LVI Getting block end value i64 0 at '._crit_edge100'
  Result = constantrange<0, 1>
LVI Getting value   %35 = call ptr @malloc(i64 %.idx53) at ''
  Result = overdefined
LVI Getting edge value   %35 = call ptr @malloc(i64 %.idx53) from '._crit_edge100' to '.lr.ph102.preheader'
PUSH:   %35 = call ptr @malloc(i64 %.idx53) in ._crit_edge100
 compute BB '._crit_edge100' - unknown inst def found.
POP   %35 = call ptr @malloc(i64 %.idx53) in ._crit_edge100 = overdefined
  Result = overdefined
LVI Getting block end value   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1 at '._crit_edge103'
PUSH:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1 in ._crit_edge103
POP   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1 in ._crit_edge103 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2 at '._crit_edge103'
PUSH:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2 in ._crit_edge103
POP   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2 in ._crit_edge103 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3 at '._crit_edge103'
PUSH:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3 in ._crit_edge103
POP   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3 in ._crit_edge103 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4 at '._crit_edge103'
PUSH:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4 in ._crit_edge103
POP   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4 in ._crit_edge103 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %15 = load i64, ptr %14, align 4 at '._crit_edge103'
PUSH:   %15 = load i64, ptr %14, align 4 in ._crit_edge103
 compute BB '._crit_edge103' - overdefined because of pred '.lr.ph102.preheader' (non local).
POP   %15 = load i64, ptr %14, align 4 in ._crit_edge103 = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at '._crit_edge103'
  Result = constantrange<3, 4>
LVI Getting block end value   %15 = load i64, ptr %14, align 4 at '._crit_edge103'
  Result = overdefined
LVI Getting edge value   %15 = load i64, ptr %14, align 4 from '.lr.ph102.preheader' to '._crit_edge103'
  Result = overdefined
LVI Getting block end value   %15 = load i64, ptr %14, align 4 at '._crit_edge103'
  Result = overdefined
LVI Getting block end value i64 0 at '._crit_edge103'
  Result = constantrange<0, 1>
LVI Getting value   %38 = call ptr @malloc(i64 %.idx62) at ''
  Result = overdefined
LVI Getting edge value   %38 = call ptr @malloc(i64 %.idx62) from '._crit_edge103' to '.lr.ph105.preheader'
PUSH:   %38 = call ptr @malloc(i64 %.idx62) in ._crit_edge103
 compute BB '._crit_edge103' - unknown inst def found.
POP   %38 = call ptr @malloc(i64 %.idx62) in ._crit_edge103 = overdefined
  Result = overdefined
LVI Getting block end value   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1 at '._crit_edge106'
PUSH:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1 in ._crit_edge106
POP   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1 in ._crit_edge106 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2 at '._crit_edge106'
PUSH:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2 in ._crit_edge106
POP   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2 in ._crit_edge106 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3 at '._crit_edge106'
PUSH:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3 in ._crit_edge106
POP   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3 in ._crit_edge106 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4 at '._crit_edge106'
PUSH:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4 in ._crit_edge106
POP   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4 in ._crit_edge106 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %17 = load i64, ptr %16, align 4 at '._crit_edge106'
PUSH:   %17 = load i64, ptr %16, align 4 in ._crit_edge106
 compute BB '._crit_edge106' - overdefined because of pred '.lr.ph105.preheader' (non local).
POP   %17 = load i64, ptr %16, align 4 in ._crit_edge106 = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at '._crit_edge106'
  Result = constantrange<3, 4>
LVI Getting block end value   %17 = load i64, ptr %16, align 4 at '._crit_edge106'
  Result = overdefined
LVI Getting edge value   %17 = load i64, ptr %16, align 4 from '.lr.ph105.preheader' to '._crit_edge106'
  Result = overdefined
LVI Getting block end value   %17 = load i64, ptr %16, align 4 at '._crit_edge106'
  Result = overdefined
LVI Getting block end value i64 0 at '._crit_edge106'
  Result = constantrange<0, 1>
LVI Getting value   %41 = call ptr @malloc(i64 %.idx71) at ''
  Result = overdefined
LVI Getting edge value   %41 = call ptr @malloc(i64 %.idx71) from '._crit_edge106' to '.lr.ph108.preheader'
PUSH:   %41 = call ptr @malloc(i64 %.idx71) in ._crit_edge106
 compute BB '._crit_edge106' - unknown inst def found.
POP   %41 = call ptr @malloc(i64 %.idx71) in ._crit_edge106 = overdefined
  Result = overdefined
LVI Getting block end value   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1 at '._crit_edge109'
PUSH:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1 in ._crit_edge109
POP   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1 in ._crit_edge109 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2 at '._crit_edge109'
PUSH:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2 in ._crit_edge109
POP   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2 in ._crit_edge109 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3 at '._crit_edge109'
PUSH:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3 in ._crit_edge109
POP   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3 in ._crit_edge109 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4 at '._crit_edge109'
PUSH:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4 in ._crit_edge109
POP   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4 in ._crit_edge109 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %19 = load i64, ptr %18, align 4 at '._crit_edge109'
PUSH:   %19 = load i64, ptr %18, align 4 in ._crit_edge109
 compute BB '._crit_edge109' - overdefined because of pred '.lr.ph108.preheader' (non local).
POP   %19 = load i64, ptr %18, align 4 in ._crit_edge109 = overdefined
  Result = overdefined
LVI Getting block end value i64 3 at '._crit_edge109'
  Result = constantrange<3, 4>
LVI Getting block end value   %19 = load i64, ptr %18, align 4 at '._crit_edge109'
  Result = overdefined
LVI Getting edge value   %19 = load i64, ptr %18, align 4 from '.lr.ph108.preheader' to '._crit_edge109'
  Result = overdefined
LVI Getting block end value   %19 = load i64, ptr %18, align 4 at '._crit_edge109'
  Result = overdefined
LVI Getting block end value i64 0 at '._crit_edge109'
  Result = constantrange<0, 1>
LVI Getting value   %44 = call ptr @malloc(i64 %.idx80) at ''
  Result = overdefined
LVI Getting edge value   %44 = call ptr @malloc(i64 %.idx80) from '._crit_edge109' to '.lr.ph111.preheader'
PUSH:   %44 = call ptr @malloc(i64 %.idx80) in ._crit_edge109
 compute BB '._crit_edge109' - unknown inst def found.
POP   %44 = call ptr @malloc(i64 %.idx80) in ._crit_edge109 = overdefined
  Result = overdefined
LVI Getting block end value   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1 at '._crit_edge112'
PUSH:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1 in ._crit_edge112
POP   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1 in ._crit_edge112 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2 at '._crit_edge112'
PUSH:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2 in ._crit_edge112
POP   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2 in ._crit_edge112 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3 at '._crit_edge112'
PUSH:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3 in ._crit_edge112
POP   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3 in ._crit_edge112 = notconstant<ptr null>
  Result = notconstant<ptr null>
LVI Getting block end value   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4 at '._crit_edge112'
PUSH:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4 in ._crit_edge112
POP   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4 in ._crit_edge112 = notconstant<ptr null>
  Result = notconstant<ptr null>
		Looking for trivial roots
Found a new trivial root: %._crit_edge112
Last visited node: %.lr.ph111.preheader
		Looking for non-trivial roots
Total: 19, Num: 20
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %._crit_edge112
3: %._crit_edge109
4: %._crit_edge106
5: %._crit_edge103
6: %._crit_edge100
7: %._crit_edge97
8: %._crit_edge94
9: %._crit_edge91
10: %._crit_edge
11: %0
12: %.lr.ph.preheader
13: %.lr.ph90.preheader
14: %.lr.ph93.preheader
15: %.lr.ph96.preheader
16: %.lr.ph99.preheader
17: %.lr.ph102.preheader
18: %.lr.ph105.preheader
19: %.lr.ph108.preheader
20: %.lr.ph111.preheader
Found roots: %._crit_edge112 
mark live:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
mark block live: 
mark live:   store ptr %1, ptr %2, align 8
mark live:   store ptr %1, ptr %.fca.1.gep, align 8
mark live:   store i64 0, ptr %.fca.2.gep, align 8
mark live:   store i64 7, ptr %.fca.3.0.gep, align 8
mark live:   store i64 1, ptr %.fca.4.0.gep, align 8
mark live:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
mark live:   %20 = call ptr @malloc(i64 %.idx)
mark live:   call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false)
mark block live: .lr.ph.preheader
mark live:   br label %._crit_edge
mark live:   store ptr %20, ptr %22, align 8
mark block live: ._crit_edge
mark live:   store ptr %20, ptr %.repack9, align 8
mark live:   store i64 0, ptr %.repack11, align 8
mark live:   store i64 %3, ptr %.repack13, align 8
mark live:   store i64 1, ptr %.repack15, align 8
mark live:   %23 = call ptr @malloc(i64 %.idx17)
mark live:   call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false)
mark block live: .lr.ph90.preheader
mark live:   br label %._crit_edge91
mark live:   store ptr %23, ptr %25, align 8
mark block live: ._crit_edge91
mark live:   store ptr %23, ptr %.repack18, align 8
mark live:   store i64 0, ptr %.repack20, align 8
mark live:   store i64 %5, ptr %.repack22, align 8
mark live:   store i64 1, ptr %.repack24, align 8
mark live:   %26 = call ptr @malloc(i64 %.idx26)
mark live:   call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false)
mark block live: .lr.ph93.preheader
mark live:   br label %._crit_edge94
mark live:   store ptr %26, ptr %28, align 8
mark block live: ._crit_edge94
mark live:   store ptr %26, ptr %.repack27, align 8
mark live:   store i64 0, ptr %.repack29, align 8
mark live:   store i64 %7, ptr %.repack31, align 8
mark live:   store i64 1, ptr %.repack33, align 8
mark live:   %29 = call ptr @malloc(i64 %.idx35)
mark live:   call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false)
mark block live: .lr.ph96.preheader
mark live:   br label %._crit_edge97
mark live:   store ptr %29, ptr %31, align 8
mark block live: ._crit_edge97
mark live:   store ptr %29, ptr %.repack36, align 8
mark live:   store i64 0, ptr %.repack38, align 8
mark live:   store i64 %9, ptr %.repack40, align 8
mark live:   store i64 1, ptr %.repack42, align 8
mark live:   %32 = call ptr @malloc(i64 %.idx44)
mark live:   call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false)
mark block live: .lr.ph99.preheader
mark live:   br label %._crit_edge100
mark live:   store ptr %32, ptr %34, align 8
mark block live: ._crit_edge100
mark live:   store ptr %32, ptr %.repack45, align 8
mark live:   store i64 0, ptr %.repack47, align 8
mark live:   store i64 %11, ptr %.repack49, align 8
mark live:   store i64 1, ptr %.repack51, align 8
mark live:   %35 = call ptr @malloc(i64 %.idx53)
mark live:   call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false)
mark block live: .lr.ph102.preheader
mark live:   br label %._crit_edge103
mark live:   store ptr %35, ptr %37, align 8
mark block live: ._crit_edge103
mark live:   store ptr %35, ptr %.repack54, align 8
mark live:   store i64 0, ptr %.repack56, align 8
mark live:   store i64 %13, ptr %.repack58, align 8
mark live:   store i64 1, ptr %.repack60, align 8
mark live:   %38 = call ptr @malloc(i64 %.idx62)
mark live:   call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false)
mark block live: .lr.ph105.preheader
mark live:   br label %._crit_edge106
mark live:   store ptr %38, ptr %40, align 8
mark block live: ._crit_edge106
mark live:   store ptr %38, ptr %.repack63, align 8
mark live:   store i64 0, ptr %.repack65, align 8
mark live:   store i64 %15, ptr %.repack67, align 8
mark live:   store i64 1, ptr %.repack69, align 8
mark live:   %41 = call ptr @malloc(i64 %.idx71)
mark live:   call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false)
mark block live: .lr.ph108.preheader
mark live:   br label %._crit_edge109
mark live:   store ptr %41, ptr %43, align 8
mark block live: ._crit_edge109
mark live:   store ptr %41, ptr %.repack72, align 8
mark live:   store i64 0, ptr %.repack74, align 8
mark live:   store i64 %17, ptr %.repack76, align 8
mark live:   store i64 1, ptr %.repack78, align 8
mark live:   %44 = call ptr @malloc(i64 %.idx80)
mark live:   call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false)
mark block live: .lr.ph111.preheader
mark live:   br label %._crit_edge112
mark live:   store ptr %44, ptr %46, align 8
mark block live: ._crit_edge112
mark live:   store ptr %44, ptr %.repack81, align 8
mark live:   store i64 0, ptr %.repack83, align 8
mark live:   store i64 %19, ptr %.repack85, align 8
mark live:   store i64 1, ptr %.repack87, align 8
mark live:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1)
mark live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %22)
mark live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %25)
mark live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
mark live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %31)
mark live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %34)
mark live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
mark live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
mark live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %43)
mark live:   call void @comet_print_memref_f64(i64 1, ptr nonnull %46)
mark live:   ret void
post-dom root child is a return: ._crit_edge112
work live:   ret void
work live:   call void @comet_print_memref_f64(i64 1, ptr nonnull %46)
mark live:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %43)
mark live:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
mark live:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
mark live:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %34)
mark live:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %31)
mark live:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
mark live:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %25)
mark live:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   call void @comet_print_memref_i64(i64 1, ptr nonnull %22)
mark live:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1)
work live:   store i64 1, ptr %.repack87, align 8
mark live:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
work live:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
work live:   store i64 %19, ptr %.repack85, align 8
mark live:   %19 = load i64, ptr %18, align 4
mark live:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
work live:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
work live:   %19 = load i64, ptr %18, align 4
mark live:   %18 = getelementptr i64, ptr %1, i64 8
work live:   %18 = getelementptr i64, ptr %1, i64 8
work live:   store i64 0, ptr %.repack83, align 8
mark live:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
work live:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
work live:   store ptr %44, ptr %.repack81, align 8
mark live:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
work live:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
work live:   store ptr %44, ptr %46, align 8
work live:   br label %._crit_edge112
work live:   call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false)
mark live:   %.idx80 = shl i64 %19, 3
work live:   %.idx80 = shl i64 %19, 3
work live:   %44 = call ptr @malloc(i64 %.idx80)
work live:   store i64 1, ptr %.repack78, align 8
mark live:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4
work live:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4
work live:   store i64 %17, ptr %.repack76, align 8
mark live:   %17 = load i64, ptr %16, align 4
mark live:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3
work live:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3
work live:   %17 = load i64, ptr %16, align 4
mark live:   %16 = getelementptr i64, ptr %1, i64 7
work live:   %16 = getelementptr i64, ptr %1, i64 7
work live:   store i64 0, ptr %.repack74, align 8
mark live:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2
work live:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2
work live:   store ptr %41, ptr %.repack72, align 8
mark live:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
work live:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
work live:   store ptr %41, ptr %43, align 8
work live:   br label %._crit_edge109
work live:   call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false)
mark live:   %.idx71 = shl i64 %17, 3
work live:   %.idx71 = shl i64 %17, 3
work live:   %41 = call ptr @malloc(i64 %.idx71)
work live:   store i64 1, ptr %.repack69, align 8
mark live:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
work live:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
work live:   store i64 %15, ptr %.repack67, align 8
mark live:   %15 = load i64, ptr %14, align 4
mark live:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
work live:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
work live:   %15 = load i64, ptr %14, align 4
mark live:   %14 = getelementptr i64, ptr %1, i64 6
work live:   %14 = getelementptr i64, ptr %1, i64 6
work live:   store i64 0, ptr %.repack65, align 8
mark live:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
work live:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
work live:   store ptr %38, ptr %.repack63, align 8
mark live:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
work live:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
work live:   store ptr %38, ptr %40, align 8
work live:   br label %._crit_edge106
work live:   call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false)
mark live:   %.idx62 = shl i64 %15, 3
work live:   %.idx62 = shl i64 %15, 3
work live:   %38 = call ptr @malloc(i64 %.idx62)
work live:   store i64 1, ptr %.repack60, align 8
mark live:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
work live:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
work live:   store i64 %13, ptr %.repack58, align 8
mark live:   %13 = load i64, ptr %12, align 4
mark live:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
work live:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
work live:   %13 = load i64, ptr %12, align 4
mark live:   %12 = getelementptr i64, ptr %1, i64 5
work live:   %12 = getelementptr i64, ptr %1, i64 5
work live:   store i64 0, ptr %.repack56, align 8
mark live:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
work live:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
work live:   store ptr %35, ptr %.repack54, align 8
mark live:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
work live:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
work live:   store ptr %35, ptr %37, align 8
work live:   br label %._crit_edge103
work live:   call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false)
mark live:   %.idx53 = shl i64 %13, 3
work live:   %.idx53 = shl i64 %13, 3
work live:   %35 = call ptr @malloc(i64 %.idx53)
work live:   store i64 1, ptr %.repack51, align 8
mark live:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4
work live:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4
work live:   store i64 %11, ptr %.repack49, align 8
mark live:   %11 = load i64, ptr %10, align 4
mark live:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3
work live:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3
work live:   %11 = load i64, ptr %10, align 4
mark live:   %10 = getelementptr i64, ptr %1, i64 4
work live:   %10 = getelementptr i64, ptr %1, i64 4
work live:   store i64 0, ptr %.repack47, align 8
mark live:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2
work live:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2
work live:   store ptr %32, ptr %.repack45, align 8
mark live:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
work live:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
work live:   store ptr %32, ptr %34, align 8
work live:   br label %._crit_edge100
work live:   call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false)
mark live:   %.idx44 = shl i64 %11, 3
work live:   %.idx44 = shl i64 %11, 3
work live:   %32 = call ptr @malloc(i64 %.idx44)
work live:   store i64 1, ptr %.repack42, align 8
mark live:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4
work live:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4
work live:   store i64 %9, ptr %.repack40, align 8
mark live:   %9 = load i64, ptr %8, align 4
mark live:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3
work live:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3
work live:   %9 = load i64, ptr %8, align 4
mark live:   %8 = getelementptr i64, ptr %1, i64 3
work live:   %8 = getelementptr i64, ptr %1, i64 3
work live:   store i64 0, ptr %.repack38, align 8
mark live:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2
work live:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2
work live:   store ptr %29, ptr %.repack36, align 8
mark live:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
work live:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
work live:   store ptr %29, ptr %31, align 8
work live:   br label %._crit_edge97
work live:   call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false)
mark live:   %.idx35 = shl i64 %9, 3
work live:   %.idx35 = shl i64 %9, 3
work live:   %29 = call ptr @malloc(i64 %.idx35)
work live:   store i64 1, ptr %.repack33, align 8
mark live:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
work live:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
work live:   store i64 %7, ptr %.repack31, align 8
mark live:   %7 = load i64, ptr %6, align 4
mark live:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
work live:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
work live:   %7 = load i64, ptr %6, align 4
mark live:   %6 = getelementptr i64, ptr %1, i64 2
work live:   %6 = getelementptr i64, ptr %1, i64 2
work live:   store i64 0, ptr %.repack29, align 8
mark live:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
work live:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
work live:   store ptr %26, ptr %.repack27, align 8
mark live:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
work live:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
work live:   store ptr %26, ptr %28, align 8
work live:   br label %._crit_edge94
work live:   call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false)
mark live:   %.idx26 = shl i64 %7, 3
work live:   %.idx26 = shl i64 %7, 3
work live:   %26 = call ptr @malloc(i64 %.idx26)
work live:   store i64 1, ptr %.repack24, align 8
mark live:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4
work live:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4
work live:   store i64 %5, ptr %.repack22, align 8
mark live:   %5 = load i64, ptr %4, align 4
mark live:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3
work live:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3
work live:   %5 = load i64, ptr %4, align 4
mark live:   %4 = getelementptr i64, ptr %1, i64 1
work live:   %4 = getelementptr i64, ptr %1, i64 1
work live:   store i64 0, ptr %.repack20, align 8
mark live:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2
work live:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2
work live:   store ptr %23, ptr %.repack18, align 8
mark live:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
work live:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
work live:   store ptr %23, ptr %25, align 8
work live:   br label %._crit_edge91
work live:   call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false)
mark live:   %.idx17 = shl i64 %5, 3
work live:   %.idx17 = shl i64 %5, 3
work live:   %23 = call ptr @malloc(i64 %.idx17)
work live:   store i64 1, ptr %.repack15, align 8
mark live:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4
work live:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4
work live:   store i64 %3, ptr %.repack13, align 8
mark live:   %3 = load i64, ptr %1, align 4
mark live:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3
work live:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3
work live:   %3 = load i64, ptr %1, align 4
work live:   store i64 0, ptr %.repack11, align 8
mark live:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2
work live:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2
work live:   store ptr %20, ptr %.repack9, align 8
mark live:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
work live:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
work live:   store ptr %20, ptr %22, align 8
work live:   br label %._crit_edge
work live:   call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false)
mark live:   %.idx = shl i64 %3, 3
work live:   %.idx = shl i64 %3, 3
work live:   %20 = call ptr @malloc(i64 %.idx)
work live:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
mark live:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
work live:   store i64 1, ptr %.fca.4.0.gep, align 8
mark live:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
work live:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
work live:   store i64 7, ptr %.fca.3.0.gep, align 8
mark live:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
work live:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
work live:   store i64 0, ptr %.fca.2.gep, align 8
mark live:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
work live:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
work live:   store ptr %1, ptr %.fca.1.gep, align 8
mark live:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
work live:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
work live:   store ptr %1, ptr %2, align 8
work live:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
new live blocks:
	.lr.ph108.preheader
	.lr.ph96.preheader
	
	.lr.ph93.preheader
	._crit_edge
	.lr.ph90.preheader
	.lr.ph105.preheader
	._crit_edge91
	.lr.ph111.preheader
	._crit_edge94
	.lr.ph102.preheader
	.lr.ph99.preheader
	._crit_edge97
	._crit_edge100
	._crit_edge103
	.lr.ph.preheader
	._crit_edge106
	._crit_edge109
	._crit_edge112
dead terminator blocks:
	
	._crit_edge
	._crit_edge91
	._crit_edge94
	._crit_edge97
	._crit_edge100
	._crit_edge103
	._crit_edge106
	._crit_edge109
live control in: 
mark live:   br i1 %21, label %.lr.ph.preheader, label %._crit_edge
live control in: ._crit_edge
mark live:   br i1 %24, label %.lr.ph90.preheader, label %._crit_edge91
live control in: ._crit_edge91
mark live:   br i1 %27, label %.lr.ph93.preheader, label %._crit_edge94
live control in: ._crit_edge94
mark live:   br i1 %30, label %.lr.ph96.preheader, label %._crit_edge97
live control in: ._crit_edge97
mark live:   br i1 %33, label %.lr.ph99.preheader, label %._crit_edge100
live control in: ._crit_edge100
mark live:   br i1 %36, label %.lr.ph102.preheader, label %._crit_edge103
live control in: ._crit_edge103
mark live:   br i1 %39, label %.lr.ph105.preheader, label %._crit_edge106
live control in: ._crit_edge106
mark live:   br i1 %42, label %.lr.ph108.preheader, label %._crit_edge109
live control in: ._crit_edge109
mark live:   br i1 %45, label %.lr.ph111.preheader, label %._crit_edge112
work live:   br i1 %45, label %.lr.ph111.preheader, label %._crit_edge112
mark live:   %45 = icmp sgt i64 %19, 0
work live:   %45 = icmp sgt i64 %19, 0
work live:   br i1 %42, label %.lr.ph108.preheader, label %._crit_edge109
mark live:   %42 = icmp sgt i64 %17, 0
work live:   %42 = icmp sgt i64 %17, 0
work live:   br i1 %39, label %.lr.ph105.preheader, label %._crit_edge106
mark live:   %39 = icmp sgt i64 %15, 0
work live:   %39 = icmp sgt i64 %15, 0
work live:   br i1 %36, label %.lr.ph102.preheader, label %._crit_edge103
mark live:   %36 = icmp sgt i64 %13, 0
work live:   %36 = icmp sgt i64 %13, 0
work live:   br i1 %33, label %.lr.ph99.preheader, label %._crit_edge100
mark live:   %33 = icmp sgt i64 %11, 0
work live:   %33 = icmp sgt i64 %11, 0
work live:   br i1 %30, label %.lr.ph96.preheader, label %._crit_edge97
mark live:   %30 = icmp sgt i64 %9, 0
work live:   %30 = icmp sgt i64 %9, 0
work live:   br i1 %27, label %.lr.ph93.preheader, label %._crit_edge94
mark live:   %27 = icmp sgt i64 %7, 0
work live:   %27 = icmp sgt i64 %7, 0
work live:   br i1 %24, label %.lr.ph90.preheader, label %._crit_edge91
mark live:   %24 = icmp sgt i64 %5, 0
work live:   %24 = icmp sgt i64 %5, 0
work live:   br i1 %21, label %.lr.ph.preheader, label %._crit_edge
mark live:   %21 = icmp sgt i64 %3, 0
work live:   %21 = icmp sgt i64 %3, 0
final dead terminator blocks: 
Trying to eliminate MemoryDefs killed by 66 = MemoryDef(81) (  store ptr %44, ptr %46, align 8)
  trying to get dominating access
   visiting 81 = MemoryPhi({._crit_edge109,64},{.lr.ph111.preheader,65})
   ...  found MemoryPhi
 Checking if we can kill 81 = MemoryPhi({._crit_edge109,64},{.lr.ph111.preheader,65})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 64 = MemoryDef(63) (  %44 = call ptr @malloc(i64 %.idx80))
   visiting 63 = MemoryDef(62) (  store i64 1, ptr %.repack78, align 8)
   visiting 62 = MemoryDef(61) (  store i64 %17, ptr %.repack76, align 8)
   visiting 61 = MemoryDef(60) (  store i64 0, ptr %.repack74, align 8)
   visiting 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8)
   visiting 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 65 = MemoryDef(64) (  call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false))
   visiting 64 = MemoryDef(63) (  %44 = call ptr @malloc(i64 %.idx80))
   visiting 63 = MemoryDef(62) (  store i64 1, ptr %.repack78, align 8)
   visiting 62 = MemoryDef(61) (  store i64 %17, ptr %.repack76, align 8)
   visiting 61 = MemoryDef(60) (  store i64 0, ptr %.repack74, align 8)
   visiting 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8)
   visiting 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 58 = MemoryDef(57) (  call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 67 = MemoryDef(66) (  store ptr %44, ptr %.repack81, align 8)
  trying to get dominating access
   visiting 66 = MemoryDef(81) (  store ptr %44, ptr %46, align 8)
   visiting 81 = MemoryPhi({._crit_edge109,64},{.lr.ph111.preheader,65})
   ...  found MemoryPhi
 Checking if we can kill 81 = MemoryPhi({._crit_edge109,64},{.lr.ph111.preheader,65})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 64 = MemoryDef(63) (  %44 = call ptr @malloc(i64 %.idx80))
   visiting 63 = MemoryDef(62) (  store i64 1, ptr %.repack78, align 8)
   visiting 62 = MemoryDef(61) (  store i64 %17, ptr %.repack76, align 8)
   visiting 61 = MemoryDef(60) (  store i64 0, ptr %.repack74, align 8)
   visiting 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8)
   visiting 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 65 = MemoryDef(64) (  call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false))
   visiting 64 = MemoryDef(63) (  %44 = call ptr @malloc(i64 %.idx80))
   visiting 63 = MemoryDef(62) (  store i64 1, ptr %.repack78, align 8)
   visiting 62 = MemoryDef(61) (  store i64 %17, ptr %.repack76, align 8)
   visiting 61 = MemoryDef(60) (  store i64 0, ptr %.repack74, align 8)
   visiting 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8)
   visiting 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 58 = MemoryDef(57) (  call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 68 = MemoryDef(67) (  store i64 0, ptr %.repack83, align 8)
  trying to get dominating access
   visiting 67 = MemoryDef(66) (  store ptr %44, ptr %.repack81, align 8)
   visiting 66 = MemoryDef(81) (  store ptr %44, ptr %46, align 8)
   visiting 81 = MemoryPhi({._crit_edge109,64},{.lr.ph111.preheader,65})
   ...  found MemoryPhi
 Checking if we can kill 81 = MemoryPhi({._crit_edge109,64},{.lr.ph111.preheader,65})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 64 = MemoryDef(63) (  %44 = call ptr @malloc(i64 %.idx80))
   visiting 63 = MemoryDef(62) (  store i64 1, ptr %.repack78, align 8)
   visiting 62 = MemoryDef(61) (  store i64 %17, ptr %.repack76, align 8)
   visiting 61 = MemoryDef(60) (  store i64 0, ptr %.repack74, align 8)
   visiting 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8)
   visiting 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 65 = MemoryDef(64) (  call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false))
   visiting 64 = MemoryDef(63) (  %44 = call ptr @malloc(i64 %.idx80))
   visiting 63 = MemoryDef(62) (  store i64 1, ptr %.repack78, align 8)
   visiting 62 = MemoryDef(61) (  store i64 %17, ptr %.repack76, align 8)
   visiting 61 = MemoryDef(60) (  store i64 0, ptr %.repack74, align 8)
   visiting 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8)
   visiting 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 58 = MemoryDef(57) (  call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 69 = MemoryDef(68) (  store i64 %19, ptr %.repack85, align 8)
  trying to get dominating access
   visiting 68 = MemoryDef(67) (  store i64 0, ptr %.repack83, align 8)
   visiting 67 = MemoryDef(66) (  store ptr %44, ptr %.repack81, align 8)
   visiting 66 = MemoryDef(81) (  store ptr %44, ptr %46, align 8)
   visiting 81 = MemoryPhi({._crit_edge109,64},{.lr.ph111.preheader,65})
   ...  found MemoryPhi
 Checking if we can kill 81 = MemoryPhi({._crit_edge109,64},{.lr.ph111.preheader,65})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 64 = MemoryDef(63) (  %44 = call ptr @malloc(i64 %.idx80))
   visiting 63 = MemoryDef(62) (  store i64 1, ptr %.repack78, align 8)
   visiting 62 = MemoryDef(61) (  store i64 %17, ptr %.repack76, align 8)
   visiting 61 = MemoryDef(60) (  store i64 0, ptr %.repack74, align 8)
   visiting 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8)
   visiting 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 65 = MemoryDef(64) (  call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false))
   visiting 64 = MemoryDef(63) (  %44 = call ptr @malloc(i64 %.idx80))
   visiting 63 = MemoryDef(62) (  store i64 1, ptr %.repack78, align 8)
   visiting 62 = MemoryDef(61) (  store i64 %17, ptr %.repack76, align 8)
   visiting 61 = MemoryDef(60) (  store i64 0, ptr %.repack74, align 8)
   visiting 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8)
   visiting 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 58 = MemoryDef(57) (  call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 70 = MemoryDef(69) (  store i64 1, ptr %.repack87, align 8)
  trying to get dominating access
   visiting 69 = MemoryDef(68) (  store i64 %19, ptr %.repack85, align 8)
   visiting 68 = MemoryDef(67) (  store i64 0, ptr %.repack83, align 8)
   visiting 67 = MemoryDef(66) (  store ptr %44, ptr %.repack81, align 8)
   visiting 66 = MemoryDef(81) (  store ptr %44, ptr %46, align 8)
   visiting 81 = MemoryPhi({._crit_edge109,64},{.lr.ph111.preheader,65})
   ...  found MemoryPhi
 Checking if we can kill 81 = MemoryPhi({._crit_edge109,64},{.lr.ph111.preheader,65})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 64 = MemoryDef(63) (  %44 = call ptr @malloc(i64 %.idx80))
   visiting 63 = MemoryDef(62) (  store i64 1, ptr %.repack78, align 8)
   visiting 62 = MemoryDef(61) (  store i64 %17, ptr %.repack76, align 8)
   visiting 61 = MemoryDef(60) (  store i64 0, ptr %.repack74, align 8)
   visiting 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8)
   visiting 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 65 = MemoryDef(64) (  call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false))
   visiting 64 = MemoryDef(63) (  %44 = call ptr @malloc(i64 %.idx80))
   visiting 63 = MemoryDef(62) (  store i64 1, ptr %.repack78, align 8)
   visiting 62 = MemoryDef(61) (  store i64 %17, ptr %.repack76, align 8)
   visiting 61 = MemoryDef(60) (  store i64 0, ptr %.repack74, align 8)
   visiting 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8)
   visiting 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 58 = MemoryDef(57) (  call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 65 = MemoryDef(64) (  call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false))
  trying to get dominating access
   visiting 64 = MemoryDef(63) (  %44 = call ptr @malloc(i64 %.idx80))
   visiting 63 = MemoryDef(62) (  store i64 1, ptr %.repack78, align 8)
   visiting 62 = MemoryDef(61) (  store i64 %17, ptr %.repack76, align 8)
   visiting 61 = MemoryDef(60) (  store i64 0, ptr %.repack74, align 8)
   visiting 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8)
   visiting 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   visiting 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8)
   visiting 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 58 = MemoryDef(57) (  call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false))
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 51 = MemoryDef(50) (  call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
  trying to get dominating access
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   visiting 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8)
   visiting 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 58 = MemoryDef(57) (  call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false))
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   visiting 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8)
   visiting 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 51 = MemoryDef(50) (  call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8)
  trying to get dominating access
   visiting 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   visiting 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8)
   visiting 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 58 = MemoryDef(57) (  call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false))
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   visiting 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8)
   visiting 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 51 = MemoryDef(50) (  call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 61 = MemoryDef(60) (  store i64 0, ptr %.repack74, align 8)
  trying to get dominating access
   visiting 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8)
   visiting 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   visiting 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8)
   visiting 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 58 = MemoryDef(57) (  call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false))
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   visiting 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8)
   visiting 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 51 = MemoryDef(50) (  call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 62 = MemoryDef(61) (  store i64 %17, ptr %.repack76, align 8)
  trying to get dominating access
   visiting 61 = MemoryDef(60) (  store i64 0, ptr %.repack74, align 8)
   visiting 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8)
   visiting 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   visiting 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8)
   visiting 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 58 = MemoryDef(57) (  call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false))
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   visiting 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8)
   visiting 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 51 = MemoryDef(50) (  call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 63 = MemoryDef(62) (  store i64 1, ptr %.repack78, align 8)
  trying to get dominating access
   visiting 62 = MemoryDef(61) (  store i64 %17, ptr %.repack76, align 8)
   visiting 61 = MemoryDef(60) (  store i64 0, ptr %.repack74, align 8)
   visiting 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8)
   visiting 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8)
   visiting 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
   ...  found MemoryPhi
 Checking if we can kill 82 = MemoryPhi({._crit_edge106,57},{.lr.ph108.preheader,58})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   visiting 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8)
   visiting 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 58 = MemoryDef(57) (  call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false))
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   visiting 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8)
   visiting 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 51 = MemoryDef(50) (  call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 58 = MemoryDef(57) (  call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false))
  trying to get dominating access
   visiting 57 = MemoryDef(56) (  %41 = call ptr @malloc(i64 %.idx71))
   visiting 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   visiting 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8)
   visiting 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   visiting 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8)
   visiting 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 51 = MemoryDef(50) (  call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false))
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 44 = MemoryDef(43) (  call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
  trying to get dominating access
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   visiting 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8)
   visiting 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 51 = MemoryDef(50) (  call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false))
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   visiting 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8)
   visiting 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 44 = MemoryDef(43) (  call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
  trying to get dominating access
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   visiting 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8)
   visiting 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 51 = MemoryDef(50) (  call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false))
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   visiting 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8)
   visiting 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 44 = MemoryDef(43) (  call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8)
  trying to get dominating access
   visiting 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   visiting 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8)
   visiting 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 51 = MemoryDef(50) (  call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false))
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   visiting 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8)
   visiting 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 44 = MemoryDef(43) (  call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
  trying to get dominating access
   visiting 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8)
   visiting 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   visiting 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8)
   visiting 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 51 = MemoryDef(50) (  call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false))
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   visiting 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8)
   visiting 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 44 = MemoryDef(43) (  call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8)
  trying to get dominating access
   visiting 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8)
   visiting 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8)
   visiting 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8)
   visiting 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8)
   visiting 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
   ...  found MemoryPhi
 Checking if we can kill 83 = MemoryPhi({._crit_edge103,50},{.lr.ph105.preheader,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   visiting 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8)
   visiting 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 51 = MemoryDef(50) (  call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false))
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   visiting 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8)
   visiting 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 44 = MemoryDef(43) (  call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 51 = MemoryDef(50) (  call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false))
  trying to get dominating access
   visiting 50 = MemoryDef(49) (  %38 = call ptr @malloc(i64 %.idx62))
   visiting 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   visiting 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8)
   visiting 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   visiting 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8)
   visiting 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 44 = MemoryDef(43) (  call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false))
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 37 = MemoryDef(36) (  call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
  trying to get dominating access
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   visiting 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8)
   visiting 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 44 = MemoryDef(43) (  call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false))
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   visiting 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8)
   visiting 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 37 = MemoryDef(36) (  call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
  trying to get dominating access
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   visiting 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8)
   visiting 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 44 = MemoryDef(43) (  call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false))
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   visiting 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8)
   visiting 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 37 = MemoryDef(36) (  call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8)
  trying to get dominating access
   visiting 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   visiting 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8)
   visiting 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 44 = MemoryDef(43) (  call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false))
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   visiting 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8)
   visiting 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 37 = MemoryDef(36) (  call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
  trying to get dominating access
   visiting 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8)
   visiting 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   visiting 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8)
   visiting 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 44 = MemoryDef(43) (  call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false))
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   visiting 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8)
   visiting 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 37 = MemoryDef(36) (  call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8)
  trying to get dominating access
   visiting 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8)
   visiting 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8)
   visiting 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8)
   visiting 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8)
   visiting 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
   ...  found MemoryPhi
 Checking if we can kill 84 = MemoryPhi({._crit_edge100,43},{.lr.ph102.preheader,44})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   visiting 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8)
   visiting 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 44 = MemoryDef(43) (  call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false))
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   visiting 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8)
   visiting 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 37 = MemoryDef(36) (  call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 44 = MemoryDef(43) (  call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false))
  trying to get dominating access
   visiting 43 = MemoryDef(42) (  %35 = call ptr @malloc(i64 %.idx53))
   visiting 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   visiting 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8)
   visiting 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   visiting 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8)
   visiting 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 37 = MemoryDef(36) (  call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false))
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 30 = MemoryDef(29) (  call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
  trying to get dominating access
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   visiting 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8)
   visiting 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 37 = MemoryDef(36) (  call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false))
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   visiting 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8)
   visiting 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 30 = MemoryDef(29) (  call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
  trying to get dominating access
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   visiting 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8)
   visiting 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 37 = MemoryDef(36) (  call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false))
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   visiting 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8)
   visiting 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 30 = MemoryDef(29) (  call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8)
  trying to get dominating access
   visiting 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   visiting 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8)
   visiting 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 37 = MemoryDef(36) (  call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false))
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   visiting 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8)
   visiting 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 30 = MemoryDef(29) (  call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
  trying to get dominating access
   visiting 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8)
   visiting 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   visiting 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8)
   visiting 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 37 = MemoryDef(36) (  call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false))
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   visiting 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8)
   visiting 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 30 = MemoryDef(29) (  call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8)
  trying to get dominating access
   visiting 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8)
   visiting 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8)
   visiting 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8)
   visiting 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8)
   visiting 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
   ...  found MemoryPhi
 Checking if we can kill 85 = MemoryPhi({._crit_edge97,36},{.lr.ph99.preheader,37})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   visiting 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8)
   visiting 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 37 = MemoryDef(36) (  call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false))
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   visiting 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8)
   visiting 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 30 = MemoryDef(29) (  call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 37 = MemoryDef(36) (  call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false))
  trying to get dominating access
   visiting 36 = MemoryDef(35) (  %32 = call ptr @malloc(i64 %.idx44))
   visiting 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   visiting 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8)
   visiting 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   visiting 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8)
   visiting 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 30 = MemoryDef(29) (  call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false))
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 23 = MemoryDef(22) (  call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
  trying to get dominating access
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   visiting 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8)
   visiting 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 30 = MemoryDef(29) (  call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false))
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   visiting 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8)
   visiting 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 23 = MemoryDef(22) (  call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
  trying to get dominating access
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   visiting 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8)
   visiting 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 30 = MemoryDef(29) (  call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false))
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   visiting 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8)
   visiting 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 23 = MemoryDef(22) (  call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8)
  trying to get dominating access
   visiting 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   visiting 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8)
   visiting 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 30 = MemoryDef(29) (  call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false))
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   visiting 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8)
   visiting 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 23 = MemoryDef(22) (  call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
  trying to get dominating access
   visiting 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8)
   visiting 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   visiting 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8)
   visiting 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 30 = MemoryDef(29) (  call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false))
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   visiting 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8)
   visiting 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 23 = MemoryDef(22) (  call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8)
  trying to get dominating access
   visiting 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8)
   visiting 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8)
   visiting 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8)
   visiting 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8)
   visiting 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
   ...  found MemoryPhi
 Checking if we can kill 86 = MemoryPhi({._crit_edge94,29},{.lr.ph96.preheader,30})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   visiting 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8)
   visiting 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 30 = MemoryDef(29) (  call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false))
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   visiting 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8)
   visiting 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 23 = MemoryDef(22) (  call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 30 = MemoryDef(29) (  call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false))
  trying to get dominating access
   visiting 29 = MemoryDef(28) (  %29 = call ptr @malloc(i64 %.idx35))
   visiting 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   visiting 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8)
   visiting 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   visiting 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8)
   visiting 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 23 = MemoryDef(22) (  call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false))
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 16 = MemoryDef(15) (  call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
  trying to get dominating access
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   visiting 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8)
   visiting 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 23 = MemoryDef(22) (  call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false))
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   visiting 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8)
   visiting 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 16 = MemoryDef(15) (  call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
  trying to get dominating access
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   visiting 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8)
   visiting 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 23 = MemoryDef(22) (  call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false))
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   visiting 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8)
   visiting 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 16 = MemoryDef(15) (  call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8)
  trying to get dominating access
   visiting 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   visiting 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8)
   visiting 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 23 = MemoryDef(22) (  call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false))
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   visiting 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8)
   visiting 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 16 = MemoryDef(15) (  call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
  trying to get dominating access
   visiting 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8)
   visiting 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   visiting 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8)
   visiting 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 23 = MemoryDef(22) (  call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false))
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   visiting 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8)
   visiting 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 16 = MemoryDef(15) (  call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8)
  trying to get dominating access
   visiting 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8)
   visiting 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8)
   visiting 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8)
   visiting 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8)
   visiting 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
   ...  found MemoryPhi
 Checking if we can kill 87 = MemoryPhi({._crit_edge91,22},{.lr.ph93.preheader,23})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   visiting 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8)
   visiting 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 23 = MemoryDef(22) (  call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false))
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   visiting 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8)
   visiting 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 16 = MemoryDef(15) (  call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 23 = MemoryDef(22) (  call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false))
  trying to get dominating access
   visiting 22 = MemoryDef(21) (  %26 = call ptr @malloc(i64 %.idx26))
   visiting 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   visiting 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8)
   visiting 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   visiting 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8)
   visiting 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 16 = MemoryDef(15) (  call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false))
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 9 = MemoryDef(8) (  call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
  trying to get dominating access
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   visiting 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8)
   visiting 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 16 = MemoryDef(15) (  call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false))
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   visiting 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8)
   visiting 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
   visiting 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 9 = MemoryDef(8) (  call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
  trying to get dominating access
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   visiting 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8)
   visiting 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 16 = MemoryDef(15) (  call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false))
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   visiting 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8)
   visiting 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
   visiting 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 9 = MemoryDef(8) (  call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8)
  trying to get dominating access
   visiting 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   visiting 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8)
   visiting 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 16 = MemoryDef(15) (  call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false))
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   visiting 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8)
   visiting 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
   visiting 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 9 = MemoryDef(8) (  call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
  trying to get dominating access
   visiting 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8)
   visiting 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   visiting 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8)
   visiting 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 16 = MemoryDef(15) (  call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false))
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   visiting 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8)
   visiting 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
   visiting 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8)
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 9 = MemoryDef(8) (  call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8)
  trying to get dominating access
   visiting 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8)
   visiting 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8)
   visiting 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8)
   visiting 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8)
   visiting 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
   ...  found MemoryPhi
 Checking if we can kill 88 = MemoryPhi({._crit_edge,15},{.lr.ph90.preheader,16})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   visiting 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8)
   visiting 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 16 = MemoryDef(15) (  call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false))
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   visiting 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8)
   visiting 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
   ...  hit walker step limit
  finished walk
  trying to get dominating access
   visiting 9 = MemoryDef(8) (  call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 16 = MemoryDef(15) (  call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false))
  trying to get dominating access
   visiting 15 = MemoryDef(14) (  %23 = call ptr @malloc(i64 %.idx17))
   visiting 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   visiting 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8)
   visiting 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
  ... skip, barrier
  finished walk
  trying to get dominating access
   visiting 9 = MemoryDef(8) (  call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false))
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
  ... skip, barrier
  finished walk
Trying to eliminate MemoryDefs killed by 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
  trying to get dominating access
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
   visiting 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8)
   visiting 5 = MemoryDef(4) (  store i64 7, ptr %.fca.3.0.gep, align 8)
   visiting 4 = MemoryDef(3) (  store i64 0, ptr %.fca.2.gep, align 8)
   visiting 3 = MemoryDef(2) (  store ptr %1, ptr %.fca.1.gep, align 8)
   visiting 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8)
   visiting 1 = MemoryDef(liveOnEntry) (  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
  trying to get dominating access
   visiting 9 = MemoryDef(8) (  call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false))
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
   visiting 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8)
   visiting 5 = MemoryDef(4) (  store i64 7, ptr %.fca.3.0.gep, align 8)
   visiting 4 = MemoryDef(3) (  store i64 0, ptr %.fca.2.gep, align 8)
   visiting 3 = MemoryDef(2) (  store ptr %1, ptr %.fca.1.gep, align 8)
   visiting 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8)
   visiting 1 = MemoryDef(liveOnEntry) (  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs killed by 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
  trying to get dominating access
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
   visiting 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8)
   visiting 5 = MemoryDef(4) (  store i64 7, ptr %.fca.3.0.gep, align 8)
   visiting 4 = MemoryDef(3) (  store i64 0, ptr %.fca.2.gep, align 8)
   visiting 3 = MemoryDef(2) (  store ptr %1, ptr %.fca.1.gep, align 8)
   visiting 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8)
   visiting 1 = MemoryDef(liveOnEntry) (  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
  trying to get dominating access
   visiting 9 = MemoryDef(8) (  call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false))
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
   visiting 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8)
   visiting 5 = MemoryDef(4) (  store i64 7, ptr %.fca.3.0.gep, align 8)
   visiting 4 = MemoryDef(3) (  store i64 0, ptr %.fca.2.gep, align 8)
   visiting 3 = MemoryDef(2) (  store ptr %1, ptr %.fca.1.gep, align 8)
   visiting 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8)
   visiting 1 = MemoryDef(liveOnEntry) (  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs killed by 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8)
  trying to get dominating access
   visiting 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
   visiting 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8)
   visiting 5 = MemoryDef(4) (  store i64 7, ptr %.fca.3.0.gep, align 8)
   visiting 4 = MemoryDef(3) (  store i64 0, ptr %.fca.2.gep, align 8)
   visiting 3 = MemoryDef(2) (  store ptr %1, ptr %.fca.1.gep, align 8)
   visiting 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8)
   visiting 1 = MemoryDef(liveOnEntry) (  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
  trying to get dominating access
   visiting 9 = MemoryDef(8) (  call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false))
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
   visiting 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8)
   visiting 5 = MemoryDef(4) (  store i64 7, ptr %.fca.3.0.gep, align 8)
   visiting 4 = MemoryDef(3) (  store i64 0, ptr %.fca.2.gep, align 8)
   visiting 3 = MemoryDef(2) (  store ptr %1, ptr %.fca.1.gep, align 8)
   visiting 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8)
   visiting 1 = MemoryDef(liveOnEntry) (  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs killed by 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
  trying to get dominating access
   visiting 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8)
   visiting 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
   visiting 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8)
   visiting 5 = MemoryDef(4) (  store i64 7, ptr %.fca.3.0.gep, align 8)
   visiting 4 = MemoryDef(3) (  store i64 0, ptr %.fca.2.gep, align 8)
   visiting 3 = MemoryDef(2) (  store ptr %1, ptr %.fca.1.gep, align 8)
   visiting 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8)
   visiting 1 = MemoryDef(liveOnEntry) (  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
  trying to get dominating access
   visiting 9 = MemoryDef(8) (  call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false))
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
   visiting 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8)
   visiting 5 = MemoryDef(4) (  store i64 7, ptr %.fca.3.0.gep, align 8)
   visiting 4 = MemoryDef(3) (  store i64 0, ptr %.fca.2.gep, align 8)
   visiting 3 = MemoryDef(2) (  store ptr %1, ptr %.fca.1.gep, align 8)
   visiting 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8)
   visiting 1 = MemoryDef(liveOnEntry) (  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs killed by 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8)
  trying to get dominating access
   visiting 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8)
   visiting 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8)
   visiting 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8)
   visiting 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8)
   visiting 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
   ...  found MemoryPhi
 Checking if we can kill 89 = MemoryPhi({%0,8},{.lr.ph.preheader,9})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
   visiting 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8)
   visiting 5 = MemoryDef(4) (  store i64 7, ptr %.fca.3.0.gep, align 8)
   visiting 4 = MemoryDef(3) (  store i64 0, ptr %.fca.2.gep, align 8)
   visiting 3 = MemoryDef(2) (  store ptr %1, ptr %.fca.1.gep, align 8)
   visiting 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8)
   visiting 1 = MemoryDef(liveOnEntry) (  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
  trying to get dominating access
   visiting 9 = MemoryDef(8) (  call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false))
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
   visiting 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8)
   visiting 5 = MemoryDef(4) (  store i64 7, ptr %.fca.3.0.gep, align 8)
   visiting 4 = MemoryDef(3) (  store i64 0, ptr %.fca.2.gep, align 8)
   visiting 3 = MemoryDef(2) (  store ptr %1, ptr %.fca.1.gep, align 8)
   visiting 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8)
   visiting 1 = MemoryDef(liveOnEntry) (  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56))
   ...  hit walker step limit
  finished walk
Trying to eliminate MemoryDefs killed by 9 = MemoryDef(8) (  call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false))
  trying to get dominating access
   visiting 8 = MemoryDef(7) (  %20 = call ptr @malloc(i64 %.idx))
   visiting 7 = MemoryDef(6) (  call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1))
  ... skip, barrier
  finished walk
Trying to eliminate MemoryDefs killed by 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8)
  trying to get dominating access
   visiting 1 = MemoryDef(liveOnEntry) (  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs killed by 3 = MemoryDef(2) (  store ptr %1, ptr %.fca.1.gep, align 8)
  trying to get dominating access
   visiting 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8)
   visiting 1 = MemoryDef(liveOnEntry) (  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs killed by 4 = MemoryDef(3) (  store i64 0, ptr %.fca.2.gep, align 8)
  trying to get dominating access
   visiting 3 = MemoryDef(2) (  store ptr %1, ptr %.fca.1.gep, align 8)
   visiting 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8)
   visiting 1 = MemoryDef(liveOnEntry) (  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs killed by 5 = MemoryDef(4) (  store i64 7, ptr %.fca.3.0.gep, align 8)
  trying to get dominating access
   visiting 4 = MemoryDef(3) (  store i64 0, ptr %.fca.2.gep, align 8)
   visiting 3 = MemoryDef(2) (  store ptr %1, ptr %.fca.1.gep, align 8)
   visiting 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8)
   visiting 1 = MemoryDef(liveOnEntry) (  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs killed by 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8)
  trying to get dominating access
   visiting 5 = MemoryDef(4) (  store i64 7, ptr %.fca.3.0.gep, align 8)
   visiting 4 = MemoryDef(3) (  store i64 0, ptr %.fca.2.gep, align 8)
   visiting 3 = MemoryDef(2) (  store ptr %1, ptr %.fca.1.gep, align 8)
   visiting 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8)
   visiting 1 = MemoryDef(liveOnEntry) (  %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs that write the already existing value
Trying to eliminate MemoryDefs at the end of the function
  Check if def 6 = MemoryDef(5) (  store i64 1, ptr %.fca.4.0.gep, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1).
  Check if def 5 = MemoryDef(4) (  store i64 7, ptr %.fca.3.0.gep, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1).
  Check if def 4 = MemoryDef(3) (  store i64 0, ptr %.fca.2.gep, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1).
  Check if def 3 = MemoryDef(2) (  store ptr %1, ptr %.fca.1.gep, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1).
  Check if def 2 = MemoryDef(1) (  store ptr %1, ptr %2, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1).
  Check if def 14 = MemoryDef(13) (  store i64 1, ptr %.repack15, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 13 = MemoryDef(12) (  store i64 %3, ptr %.repack13, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 12 = MemoryDef(11) (  store i64 0, ptr %.repack11, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 11 = MemoryDef(10) (  store ptr %20, ptr %.repack9, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 10 = MemoryDef(89) (  store ptr %20, ptr %22, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 21 = MemoryDef(20) (  store i64 1, ptr %.repack24, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 20 = MemoryDef(19) (  store i64 %5, ptr %.repack22, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 19 = MemoryDef(18) (  store i64 0, ptr %.repack20, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 18 = MemoryDef(17) (  store ptr %23, ptr %.repack18, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 17 = MemoryDef(88) (  store ptr %23, ptr %25, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 28 = MemoryDef(27) (  store i64 1, ptr %.repack33, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 27 = MemoryDef(26) (  store i64 %7, ptr %.repack31, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 26 = MemoryDef(25) (  store i64 0, ptr %.repack29, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 25 = MemoryDef(24) (  store ptr %26, ptr %.repack27, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 24 = MemoryDef(87) (  store ptr %26, ptr %28, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 35 = MemoryDef(34) (  store i64 1, ptr %.repack42, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 34 = MemoryDef(33) (  store i64 %9, ptr %.repack40, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 33 = MemoryDef(32) (  store i64 0, ptr %.repack38, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 32 = MemoryDef(31) (  store ptr %29, ptr %.repack36, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 31 = MemoryDef(86) (  store ptr %29, ptr %31, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 42 = MemoryDef(41) (  store i64 1, ptr %.repack51, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 41 = MemoryDef(40) (  store i64 %11, ptr %.repack49, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 40 = MemoryDef(39) (  store i64 0, ptr %.repack47, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 39 = MemoryDef(38) (  store ptr %32, ptr %.repack45, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 38 = MemoryDef(85) (  store ptr %32, ptr %34, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 49 = MemoryDef(48) (  store i64 1, ptr %.repack60, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 48 = MemoryDef(47) (  store i64 %13, ptr %.repack58, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 47 = MemoryDef(46) (  store i64 0, ptr %.repack56, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 46 = MemoryDef(45) (  store ptr %35, ptr %.repack54, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 45 = MemoryDef(84) (  store ptr %35, ptr %37, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 56 = MemoryDef(55) (  store i64 1, ptr %.repack69, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 55 = MemoryDef(54) (  store i64 %15, ptr %.repack67, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 54 = MemoryDef(53) (  store i64 0, ptr %.repack65, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 53 = MemoryDef(52) (  store ptr %38, ptr %.repack63, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 52 = MemoryDef(83) (  store ptr %38, ptr %40, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 63 = MemoryDef(62) (  store i64 1, ptr %.repack78, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 62 = MemoryDef(61) (  store i64 %17, ptr %.repack76, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 61 = MemoryDef(60) (  store i64 0, ptr %.repack74, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 60 = MemoryDef(59) (  store ptr %41, ptr %.repack72, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 59 = MemoryDef(82) (  store ptr %41, ptr %43, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 70 = MemoryDef(69) (  store i64 1, ptr %.repack87, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 69 = MemoryDef(68) (  store i64 %19, ptr %.repack85, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 68 = MemoryDef(67) (  store i64 0, ptr %.repack83, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 67 = MemoryDef(66) (  store ptr %44, ptr %.repack81, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).
  Check if def 66 = MemoryDef(81) (  store ptr %44, ptr %46, align 8) is at the end the function 
  ... hit read clobber   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1).


INSTCOMBINE ITERATION #1 on main
ADD:   br label %._crit_edge
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false)
ADD:   br label %._crit_edge91
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false)
ADD:   br label %._crit_edge94
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false)
ADD:   br label %._crit_edge97
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false)
ADD:   br label %._crit_edge100
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false)
ADD:   br label %._crit_edge103
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false)
ADD:   br label %._crit_edge106
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false)
ADD:   br label %._crit_edge109
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false)
ADD:   br label %._crit_edge112
ADD:   call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false)
ADD:   ret void
ADD:   call void @comet_print_memref_f64(i64 1, ptr nonnull %46)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %43)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %34)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %31)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %25)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %22)
ADD:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1)
ADD:   store i64 1, ptr %.repack87, align 8
ADD:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
ADD:   store i64 %19, ptr %.repack85, align 8
ADD:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
ADD:   store i64 0, ptr %.repack83, align 8
ADD:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
ADD:   store ptr %44, ptr %.repack81, align 8
ADD:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
ADD:   store ptr %44, ptr %46, align 8
ADD:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %45, label %.lr.ph111.preheader, label %._crit_edge112
ADD:   %45 = icmp sgt i64 %19, 0
ADD:   %44 = call ptr @malloc(i64 %.idx80)
ADD:   %.idx80 = shl i64 %19, 3
ADD:   store i64 1, ptr %.repack78, align 8
ADD:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4
ADD:   store i64 %17, ptr %.repack76, align 8
ADD:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3
ADD:   store i64 0, ptr %.repack74, align 8
ADD:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2
ADD:   store ptr %41, ptr %.repack72, align 8
ADD:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
ADD:   store ptr %41, ptr %43, align 8
ADD:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %42, label %.lr.ph108.preheader, label %._crit_edge109
ADD:   %42 = icmp sgt i64 %17, 0
ADD:   %41 = call ptr @malloc(i64 %.idx71)
ADD:   %.idx71 = shl i64 %17, 3
ADD:   store i64 1, ptr %.repack69, align 8
ADD:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
ADD:   store i64 %15, ptr %.repack67, align 8
ADD:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
ADD:   store i64 0, ptr %.repack65, align 8
ADD:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
ADD:   store ptr %38, ptr %.repack63, align 8
ADD:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
ADD:   store ptr %38, ptr %40, align 8
ADD:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %39, label %.lr.ph105.preheader, label %._crit_edge106
ADD:   %39 = icmp sgt i64 %15, 0
ADD:   %38 = call ptr @malloc(i64 %.idx62)
ADD:   %.idx62 = shl i64 %15, 3
ADD:   store i64 1, ptr %.repack60, align 8
ADD:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
ADD:   store i64 %13, ptr %.repack58, align 8
ADD:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
ADD:   store i64 0, ptr %.repack56, align 8
ADD:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
ADD:   store ptr %35, ptr %.repack54, align 8
ADD:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
ADD:   store ptr %35, ptr %37, align 8
ADD:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %36, label %.lr.ph102.preheader, label %._crit_edge103
ADD:   %36 = icmp sgt i64 %13, 0
ADD:   %35 = call ptr @malloc(i64 %.idx53)
ADD:   %.idx53 = shl i64 %13, 3
ADD:   store i64 1, ptr %.repack51, align 8
ADD:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4
ADD:   store i64 %11, ptr %.repack49, align 8
ADD:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3
ADD:   store i64 0, ptr %.repack47, align 8
ADD:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2
ADD:   store ptr %32, ptr %.repack45, align 8
ADD:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
ADD:   store ptr %32, ptr %34, align 8
ADD:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %33, label %.lr.ph99.preheader, label %._crit_edge100
ADD:   %33 = icmp sgt i64 %11, 0
ADD:   %32 = call ptr @malloc(i64 %.idx44)
ADD:   %.idx44 = shl i64 %11, 3
ADD:   store i64 1, ptr %.repack42, align 8
ADD:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4
ADD:   store i64 %9, ptr %.repack40, align 8
ADD:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3
ADD:   store i64 0, ptr %.repack38, align 8
ADD:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2
ADD:   store ptr %29, ptr %.repack36, align 8
ADD:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
ADD:   store ptr %29, ptr %31, align 8
ADD:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %30, label %.lr.ph96.preheader, label %._crit_edge97
ADD:   %30 = icmp sgt i64 %9, 0
ADD:   %29 = call ptr @malloc(i64 %.idx35)
ADD:   %.idx35 = shl i64 %9, 3
ADD:   store i64 1, ptr %.repack33, align 8
ADD:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
ADD:   store i64 %7, ptr %.repack31, align 8
ADD:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
ADD:   store i64 0, ptr %.repack29, align 8
ADD:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
ADD:   store ptr %26, ptr %.repack27, align 8
ADD:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
ADD:   store ptr %26, ptr %28, align 8
ADD:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %27, label %.lr.ph93.preheader, label %._crit_edge94
ADD:   %27 = icmp sgt i64 %7, 0
ADD:   %26 = call ptr @malloc(i64 %.idx26)
ADD:   %.idx26 = shl i64 %7, 3
ADD:   store i64 1, ptr %.repack24, align 8
ADD:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4
ADD:   store i64 %5, ptr %.repack22, align 8
ADD:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3
ADD:   store i64 0, ptr %.repack20, align 8
ADD:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2
ADD:   store ptr %23, ptr %.repack18, align 8
ADD:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
ADD:   store ptr %23, ptr %25, align 8
ADD:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %24, label %.lr.ph90.preheader, label %._crit_edge91
ADD:   %24 = icmp sgt i64 %5, 0
ADD:   %23 = call ptr @malloc(i64 %.idx17)
ADD:   %.idx17 = shl i64 %5, 3
ADD:   store i64 1, ptr %.repack15, align 8
ADD:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4
ADD:   store i64 %3, ptr %.repack13, align 8
ADD:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3
ADD:   store i64 0, ptr %.repack11, align 8
ADD:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2
ADD:   store ptr %20, ptr %.repack9, align 8
ADD:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
ADD:   store ptr %20, ptr %22, align 8
ADD:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %21, label %.lr.ph.preheader, label %._crit_edge
ADD:   %21 = icmp sgt i64 %3, 0
ADD:   %20 = call ptr @malloc(i64 %.idx)
ADD:   %.idx = shl i64 %3, 3
ADD:   %19 = load i64, ptr %18, align 4
ADD:   %18 = getelementptr i64, ptr %1, i64 8
ADD:   %17 = load i64, ptr %16, align 4
ADD:   %16 = getelementptr i64, ptr %1, i64 7
ADD:   %15 = load i64, ptr %14, align 4
ADD:   %14 = getelementptr i64, ptr %1, i64 6
ADD:   %13 = load i64, ptr %12, align 4
ADD:   %12 = getelementptr i64, ptr %1, i64 5
ADD:   %11 = load i64, ptr %10, align 4
ADD:   %10 = getelementptr i64, ptr %1, i64 4
ADD:   %9 = load i64, ptr %8, align 4
ADD:   %8 = getelementptr i64, ptr %1, i64 3
ADD:   %7 = load i64, ptr %6, align 4
ADD:   %6 = getelementptr i64, ptr %1, i64 2
ADD:   %5 = load i64, ptr %4, align 4
ADD:   %4 = getelementptr i64, ptr %1, i64 1
ADD:   %3 = load i64, ptr %1, align 4
ADD:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
ADD:   store i64 1, ptr %.fca.4.0.gep, align 8
ADD:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
ADD:   store i64 7, ptr %.fca.3.0.gep, align 8
ADD:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
ADD:   store i64 0, ptr %.fca.2.gep, align 8
ADD:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
ADD:   store ptr %1, ptr %.fca.1.gep, align 8
ADD:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
ADD:   store ptr %1, ptr %2, align 8
ADD:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %1, ptr %2, align 8
IC: Visiting:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
IC: Visiting:   store ptr %1, ptr %.fca.1.gep, align 8
IC: Visiting:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.fca.2.gep, align 8
IC: Visiting:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
IC: Visiting:   store i64 7, ptr %.fca.3.0.gep, align 8
IC: Visiting:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
IC: Visiting:   store i64 1, ptr %.fca.4.0.gep, align 8
IC: Visiting:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
IC: Visiting:   %3 = load i64, ptr %1, align 4
IC: Visiting:   %4 = getelementptr i64, ptr %1, i64 1
IC: Visiting:   %5 = load i64, ptr %4, align 4
IC: Visiting:   %6 = getelementptr i64, ptr %1, i64 2
IC: Visiting:   %7 = load i64, ptr %6, align 4
IC: Visiting:   %8 = getelementptr i64, ptr %1, i64 3
IC: Visiting:   %9 = load i64, ptr %8, align 4
IC: Visiting:   %10 = getelementptr i64, ptr %1, i64 4
IC: Visiting:   %11 = load i64, ptr %10, align 4
IC: Visiting:   %12 = getelementptr i64, ptr %1, i64 5
IC: Visiting:   %13 = load i64, ptr %12, align 4
IC: Visiting:   %14 = getelementptr i64, ptr %1, i64 6
IC: Visiting:   %15 = load i64, ptr %14, align 4
IC: Visiting:   %16 = getelementptr i64, ptr %1, i64 7
IC: Visiting:   %17 = load i64, ptr %16, align 4
IC: Visiting:   %18 = getelementptr i64, ptr %1, i64 8
IC: Visiting:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %.idx = shl i64 %3, 3
IC: Visiting:   %20 = call ptr @malloc(i64 %.idx)
IC: Visiting:   %21 = icmp sgt i64 %3, 0
IC: Visiting:   br i1 %21, label %.lr.ph.preheader, label %._crit_edge
IC: Visiting:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %20, ptr %22, align 8
IC: Visiting:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
IC: Visiting:   store ptr %20, ptr %.repack9, align 8
IC: Visiting:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack11, align 8
IC: Visiting:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3
IC: Visiting:   store i64 %3, ptr %.repack13, align 8
IC: Visiting:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack15, align 8
IC: Visiting:   %.idx17 = shl i64 %5, 3
IC: Visiting:   %23 = call ptr @malloc(i64 %.idx17)
IC: Visiting:   %24 = icmp sgt i64 %5, 0
IC: Visiting:   br i1 %24, label %.lr.ph90.preheader, label %._crit_edge91
IC: Visiting:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %23, ptr %25, align 8
IC: Visiting:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
IC: Visiting:   store ptr %23, ptr %.repack18, align 8
IC: Visiting:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack20, align 8
IC: Visiting:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3
IC: Visiting:   store i64 %5, ptr %.repack22, align 8
IC: Visiting:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack24, align 8
IC: Visiting:   %.idx26 = shl i64 %7, 3
IC: Visiting:   %26 = call ptr @malloc(i64 %.idx26)
IC: Visiting:   %27 = icmp sgt i64 %7, 0
IC: Visiting:   br i1 %27, label %.lr.ph93.preheader, label %._crit_edge94
IC: Visiting:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %26, ptr %28, align 8
IC: Visiting:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
IC: Visiting:   store ptr %26, ptr %.repack27, align 8
IC: Visiting:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack29, align 8
IC: Visiting:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
IC: Visiting:   store i64 %7, ptr %.repack31, align 8
IC: Visiting:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack33, align 8
IC: Visiting:   %.idx35 = shl i64 %9, 3
IC: Visiting:   %29 = call ptr @malloc(i64 %.idx35)
IC: Visiting:   %30 = icmp sgt i64 %9, 0
IC: Visiting:   br i1 %30, label %.lr.ph96.preheader, label %._crit_edge97
IC: Visiting:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %29, ptr %31, align 8
IC: Visiting:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
IC: Visiting:   store ptr %29, ptr %.repack36, align 8
IC: Visiting:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack38, align 8
IC: Visiting:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3
IC: Visiting:   store i64 %9, ptr %.repack40, align 8
IC: Visiting:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack42, align 8
IC: Visiting:   %.idx44 = shl i64 %11, 3
IC: Visiting:   %32 = call ptr @malloc(i64 %.idx44)
IC: Visiting:   %33 = icmp sgt i64 %11, 0
IC: Visiting:   br i1 %33, label %.lr.ph99.preheader, label %._crit_edge100
IC: Visiting:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %32, ptr %34, align 8
IC: Visiting:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
IC: Visiting:   store ptr %32, ptr %.repack45, align 8
IC: Visiting:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack47, align 8
IC: Visiting:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3
IC: Visiting:   store i64 %11, ptr %.repack49, align 8
IC: Visiting:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack51, align 8
IC: Visiting:   %.idx53 = shl i64 %13, 3
IC: Visiting:   %35 = call ptr @malloc(i64 %.idx53)
IC: Visiting:   %36 = icmp sgt i64 %13, 0
IC: Visiting:   br i1 %36, label %.lr.ph102.preheader, label %._crit_edge103
IC: Visiting:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %35, ptr %37, align 8
IC: Visiting:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
IC: Visiting:   store ptr %35, ptr %.repack54, align 8
IC: Visiting:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack56, align 8
IC: Visiting:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
IC: Visiting:   store i64 %13, ptr %.repack58, align 8
IC: Visiting:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack60, align 8
IC: Visiting:   %.idx62 = shl i64 %15, 3
IC: Visiting:   %38 = call ptr @malloc(i64 %.idx62)
IC: Visiting:   %39 = icmp sgt i64 %15, 0
IC: Visiting:   br i1 %39, label %.lr.ph105.preheader, label %._crit_edge106
IC: Visiting:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %38, ptr %40, align 8
IC: Visiting:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
IC: Visiting:   store ptr %38, ptr %.repack63, align 8
IC: Visiting:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack65, align 8
IC: Visiting:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
IC: Visiting:   store i64 %15, ptr %.repack67, align 8
IC: Visiting:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack69, align 8
IC: Visiting:   %.idx71 = shl i64 %17, 3
IC: Visiting:   %41 = call ptr @malloc(i64 %.idx71)
IC: Visiting:   %42 = icmp sgt i64 %17, 0
IC: Visiting:   br i1 %42, label %.lr.ph108.preheader, label %._crit_edge109
IC: Visiting:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %41, ptr %43, align 8
IC: Visiting:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
IC: Visiting:   store ptr %41, ptr %.repack72, align 8
IC: Visiting:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack74, align 8
IC: Visiting:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3
IC: Visiting:   store i64 %17, ptr %.repack76, align 8
IC: Visiting:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack78, align 8
IC: Visiting:   %.idx80 = shl i64 %19, 3
IC: Visiting:   %44 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   %45 = icmp sgt i64 %19, 0
IC: Visiting:   br i1 %45, label %.lr.ph111.preheader, label %._crit_edge112
IC: Visiting:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %44, ptr %46, align 8
IC: Visiting:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
IC: Visiting:   store ptr %44, ptr %.repack81, align 8
IC: Visiting:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack83, align 8
IC: Visiting:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
IC: Visiting:   store i64 %19, ptr %.repack85, align 8
IC: Visiting:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack87, align 8
IC: Visiting:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %22)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %25)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %31)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %34)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %43)
IC: Visiting:   call void @comet_print_memref_f64(i64 1, ptr nonnull %46)
IC: Visiting:   ret void
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false)
IC: Visiting:   br label %._crit_edge112
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false)
IC: Visiting:   br label %._crit_edge109
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false)
IC: Visiting:   br label %._crit_edge106
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false)
IC: Visiting:   br label %._crit_edge103
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false)
IC: Visiting:   br label %._crit_edge100
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false)
IC: Visiting:   br label %._crit_edge97
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false)
IC: Visiting:   br label %._crit_edge94
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false)
IC: Visiting:   br label %._crit_edge91
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false)
IC: Visiting:   br label %._crit_edge
Running an SCC pass across the RefSCC: [(_mlir_main)]
Inlining calls in: _mlir_main
    Function size: 2
Inlining calls in: _mlir_main
    Function size: 2
      Analyzing call of main... (caller:_mlir_main)
		Looking for trivial roots
Found a new trivial root: %1
Last visited node: %1
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %1
Found roots: %1 
---- Branch Probability Info : _mlir_main ----

Computing probabilities for 

block-frequency: _mlir_main
===========================
reverse-post-order-traversal
 - 0: 
loop-detection
compute-mass-in-function
 - node: 
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - : float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _mlir_main
 - : float = 1.0, int = 8

      Initial cost: -30
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 13
      NumInstructions: 36
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 210
      Threshold: 625
    NOT Inlining (cost=never): dynamic alloca, Call:   call void @main()
Running function passes across an SCC: (_mlir_main)
SROA function: _mlir_main
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_mlir_main'


INSTCOMBINE ITERATION #1 on _mlir_main
ADD:   ret void
ADD:   call void @main()
IC: Visiting:   call void @main()
IC: Visiting:   ret void
Marked as tail call candidate:   call void @main()
Calculated Rank[] = 3


INSTCOMBINE ITERATION #1 on _mlir_main
ADD:   ret void
ADD:   tail call void @main()
IC: Visiting:   tail call void @main()
IC: Visiting:   ret void
SROA function: _mlir_main
Instruction Merger
GVN iteration: 0
SCCP on function '_mlir_main'
Marking Block Executable: 
markOverdefined: ptr %0

Popped off OI-WL: ptr %0

Popped off BBWL: 
  tail call void @main()
  ret void

RESOLVING UNDEFs
DemandedBits: Root:   tail call void @main()
DemandedBits: Root:   ret void


INSTCOMBINE ITERATION #1 on _mlir_main
ADD:   ret void
ADD:   tail call void @main()
IC: Visiting:   tail call void @main()
IC: Visiting:   ret void
Jump threading on function '_mlir_main'
mark live:   tail call void @main()
mark block live: 
mark live:   ret void
post-dom root child is a return: 
work live:   ret void
work live:   tail call void @main()
final dead terminator blocks: 
Trying to eliminate MemoryDefs that write the already existing value
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _mlir_main
ADD:   ret void
ADD:   tail call void @main()
IC: Visiting:   tail call void @main()
IC: Visiting:   ret void
DeadArgumentEliminationPass - Deleting dead varargs
DeadArgumentEliminationPass - Determining liveness
DeadArgumentEliminationPass - Intrinsically live fn: malloc
DeadArgumentEliminationPass - Intrinsically live fn: main
DeadArgumentEliminationPass - Intrinsically live fn: read_input_2D_f64
DeadArgumentEliminationPass - Intrinsically live fn: read_input_sizes_2D_f64
DeadArgumentEliminationPass - Intrinsically live fn: comet_print_memref_f64
DeadArgumentEliminationPass - Intrinsically live fn: comet_print_memref_i64
DeadArgumentEliminationPass - Intrinsically live fn: _mlir_main
DeadArgumentEliminationPass - Intrinsically live fn: llvm.memset.p0.i64
F2I: Looking at function main


INSTCOMBINE ITERATION #1 on main
ADD:   br label %._crit_edge
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false)
ADD:   br label %._crit_edge91
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false)
ADD:   br label %._crit_edge94
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false)
ADD:   br label %._crit_edge97
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false)
ADD:   br label %._crit_edge100
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false)
ADD:   br label %._crit_edge103
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false)
ADD:   br label %._crit_edge106
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false)
ADD:   br label %._crit_edge109
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false)
ADD:   br label %._crit_edge112
ADD:   call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false)
ADD:   ret void
ADD:   call void @comet_print_memref_f64(i64 1, ptr nonnull %46)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %43)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %34)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %31)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %25)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %22)
ADD:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1)
ADD:   store i64 1, ptr %.repack87, align 8
ADD:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
ADD:   store i64 %19, ptr %.repack85, align 8
ADD:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
ADD:   store i64 0, ptr %.repack83, align 8
ADD:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
ADD:   store ptr %44, ptr %.repack81, align 8
ADD:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
ADD:   store ptr %44, ptr %46, align 8
ADD:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %45, label %.lr.ph111.preheader, label %._crit_edge112
ADD:   %45 = icmp sgt i64 %19, 0
ADD:   %44 = call ptr @malloc(i64 %.idx80)
ADD:   %.idx80 = shl i64 %19, 3
ADD:   store i64 1, ptr %.repack78, align 8
ADD:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4
ADD:   store i64 %17, ptr %.repack76, align 8
ADD:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3
ADD:   store i64 0, ptr %.repack74, align 8
ADD:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2
ADD:   store ptr %41, ptr %.repack72, align 8
ADD:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
ADD:   store ptr %41, ptr %43, align 8
ADD:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %42, label %.lr.ph108.preheader, label %._crit_edge109
ADD:   %42 = icmp sgt i64 %17, 0
ADD:   %41 = call ptr @malloc(i64 %.idx71)
ADD:   %.idx71 = shl i64 %17, 3
ADD:   store i64 1, ptr %.repack69, align 8
ADD:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
ADD:   store i64 %15, ptr %.repack67, align 8
ADD:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
ADD:   store i64 0, ptr %.repack65, align 8
ADD:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
ADD:   store ptr %38, ptr %.repack63, align 8
ADD:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
ADD:   store ptr %38, ptr %40, align 8
ADD:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %39, label %.lr.ph105.preheader, label %._crit_edge106
ADD:   %39 = icmp sgt i64 %15, 0
ADD:   %38 = call ptr @malloc(i64 %.idx62)
ADD:   %.idx62 = shl i64 %15, 3
ADD:   store i64 1, ptr %.repack60, align 8
ADD:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
ADD:   store i64 %13, ptr %.repack58, align 8
ADD:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
ADD:   store i64 0, ptr %.repack56, align 8
ADD:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
ADD:   store ptr %35, ptr %.repack54, align 8
ADD:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
ADD:   store ptr %35, ptr %37, align 8
ADD:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %36, label %.lr.ph102.preheader, label %._crit_edge103
ADD:   %36 = icmp sgt i64 %13, 0
ADD:   %35 = call ptr @malloc(i64 %.idx53)
ADD:   %.idx53 = shl i64 %13, 3
ADD:   store i64 1, ptr %.repack51, align 8
ADD:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4
ADD:   store i64 %11, ptr %.repack49, align 8
ADD:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3
ADD:   store i64 0, ptr %.repack47, align 8
ADD:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2
ADD:   store ptr %32, ptr %.repack45, align 8
ADD:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
ADD:   store ptr %32, ptr %34, align 8
ADD:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %33, label %.lr.ph99.preheader, label %._crit_edge100
ADD:   %33 = icmp sgt i64 %11, 0
ADD:   %32 = call ptr @malloc(i64 %.idx44)
ADD:   %.idx44 = shl i64 %11, 3
ADD:   store i64 1, ptr %.repack42, align 8
ADD:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4
ADD:   store i64 %9, ptr %.repack40, align 8
ADD:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3
ADD:   store i64 0, ptr %.repack38, align 8
ADD:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2
ADD:   store ptr %29, ptr %.repack36, align 8
ADD:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
ADD:   store ptr %29, ptr %31, align 8
ADD:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %30, label %.lr.ph96.preheader, label %._crit_edge97
ADD:   %30 = icmp sgt i64 %9, 0
ADD:   %29 = call ptr @malloc(i64 %.idx35)
ADD:   %.idx35 = shl i64 %9, 3
ADD:   store i64 1, ptr %.repack33, align 8
ADD:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
ADD:   store i64 %7, ptr %.repack31, align 8
ADD:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
ADD:   store i64 0, ptr %.repack29, align 8
ADD:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
ADD:   store ptr %26, ptr %.repack27, align 8
ADD:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
ADD:   store ptr %26, ptr %28, align 8
ADD:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %27, label %.lr.ph93.preheader, label %._crit_edge94
ADD:   %27 = icmp sgt i64 %7, 0
ADD:   %26 = call ptr @malloc(i64 %.idx26)
ADD:   %.idx26 = shl i64 %7, 3
ADD:   store i64 1, ptr %.repack24, align 8
ADD:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4
ADD:   store i64 %5, ptr %.repack22, align 8
ADD:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3
ADD:   store i64 0, ptr %.repack20, align 8
ADD:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2
ADD:   store ptr %23, ptr %.repack18, align 8
ADD:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
ADD:   store ptr %23, ptr %25, align 8
ADD:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %24, label %.lr.ph90.preheader, label %._crit_edge91
ADD:   %24 = icmp sgt i64 %5, 0
ADD:   %23 = call ptr @malloc(i64 %.idx17)
ADD:   %.idx17 = shl i64 %5, 3
ADD:   store i64 1, ptr %.repack15, align 8
ADD:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4
ADD:   store i64 %3, ptr %.repack13, align 8
ADD:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3
ADD:   store i64 0, ptr %.repack11, align 8
ADD:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2
ADD:   store ptr %20, ptr %.repack9, align 8
ADD:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
ADD:   store ptr %20, ptr %22, align 8
ADD:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %21, label %.lr.ph.preheader, label %._crit_edge
ADD:   %21 = icmp sgt i64 %3, 0
ADD:   %20 = call ptr @malloc(i64 %.idx)
ADD:   %.idx = shl i64 %3, 3
ADD:   %19 = load i64, ptr %18, align 4
ADD:   %18 = getelementptr i64, ptr %1, i64 8
ADD:   %17 = load i64, ptr %16, align 4
ADD:   %16 = getelementptr i64, ptr %1, i64 7
ADD:   %15 = load i64, ptr %14, align 4
ADD:   %14 = getelementptr i64, ptr %1, i64 6
ADD:   %13 = load i64, ptr %12, align 4
ADD:   %12 = getelementptr i64, ptr %1, i64 5
ADD:   %11 = load i64, ptr %10, align 4
ADD:   %10 = getelementptr i64, ptr %1, i64 4
ADD:   %9 = load i64, ptr %8, align 4
ADD:   %8 = getelementptr i64, ptr %1, i64 3
ADD:   %7 = load i64, ptr %6, align 4
ADD:   %6 = getelementptr i64, ptr %1, i64 2
ADD:   %5 = load i64, ptr %4, align 4
ADD:   %4 = getelementptr i64, ptr %1, i64 1
ADD:   %3 = load i64, ptr %1, align 4
ADD:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
ADD:   store i64 1, ptr %.fca.4.0.gep, align 8
ADD:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
ADD:   store i64 7, ptr %.fca.3.0.gep, align 8
ADD:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
ADD:   store i64 0, ptr %.fca.2.gep, align 8
ADD:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
ADD:   store ptr %1, ptr %.fca.1.gep, align 8
ADD:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
ADD:   store ptr %1, ptr %2, align 8
ADD:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %1, ptr %2, align 8
IC: Visiting:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
IC: Visiting:   store ptr %1, ptr %.fca.1.gep, align 8
IC: Visiting:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.fca.2.gep, align 8
IC: Visiting:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
IC: Visiting:   store i64 7, ptr %.fca.3.0.gep, align 8
IC: Visiting:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
IC: Visiting:   store i64 1, ptr %.fca.4.0.gep, align 8
IC: Visiting:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
IC: Visiting:   %3 = load i64, ptr %1, align 4
IC: Visiting:   %4 = getelementptr i64, ptr %1, i64 1
IC: Visiting:   %5 = load i64, ptr %4, align 4
IC: Visiting:   %6 = getelementptr i64, ptr %1, i64 2
IC: Visiting:   %7 = load i64, ptr %6, align 4
IC: Visiting:   %8 = getelementptr i64, ptr %1, i64 3
IC: Visiting:   %9 = load i64, ptr %8, align 4
IC: Visiting:   %10 = getelementptr i64, ptr %1, i64 4
IC: Visiting:   %11 = load i64, ptr %10, align 4
IC: Visiting:   %12 = getelementptr i64, ptr %1, i64 5
IC: Visiting:   %13 = load i64, ptr %12, align 4
IC: Visiting:   %14 = getelementptr i64, ptr %1, i64 6
IC: Visiting:   %15 = load i64, ptr %14, align 4
IC: Visiting:   %16 = getelementptr i64, ptr %1, i64 7
IC: Visiting:   %17 = load i64, ptr %16, align 4
IC: Visiting:   %18 = getelementptr i64, ptr %1, i64 8
IC: Visiting:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %.idx = shl i64 %3, 3
IC: Visiting:   %20 = call ptr @malloc(i64 %.idx)
IC: Visiting:   %21 = icmp sgt i64 %3, 0
IC: Visiting:   br i1 %21, label %.lr.ph.preheader, label %._crit_edge
IC: Visiting:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %20, ptr %22, align 8
IC: Visiting:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
IC: Visiting:   store ptr %20, ptr %.repack9, align 8
IC: Visiting:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack11, align 8
IC: Visiting:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3
IC: Visiting:   store i64 %3, ptr %.repack13, align 8
IC: Visiting:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack15, align 8
IC: Visiting:   %.idx17 = shl i64 %5, 3
IC: Visiting:   %23 = call ptr @malloc(i64 %.idx17)
IC: Visiting:   %24 = icmp sgt i64 %5, 0
IC: Visiting:   br i1 %24, label %.lr.ph90.preheader, label %._crit_edge91
IC: Visiting:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %23, ptr %25, align 8
IC: Visiting:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
IC: Visiting:   store ptr %23, ptr %.repack18, align 8
IC: Visiting:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack20, align 8
IC: Visiting:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3
IC: Visiting:   store i64 %5, ptr %.repack22, align 8
IC: Visiting:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack24, align 8
IC: Visiting:   %.idx26 = shl i64 %7, 3
IC: Visiting:   %26 = call ptr @malloc(i64 %.idx26)
IC: Visiting:   %27 = icmp sgt i64 %7, 0
IC: Visiting:   br i1 %27, label %.lr.ph93.preheader, label %._crit_edge94
IC: Visiting:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %26, ptr %28, align 8
IC: Visiting:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
IC: Visiting:   store ptr %26, ptr %.repack27, align 8
IC: Visiting:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack29, align 8
IC: Visiting:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
IC: Visiting:   store i64 %7, ptr %.repack31, align 8
IC: Visiting:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack33, align 8
IC: Visiting:   %.idx35 = shl i64 %9, 3
IC: Visiting:   %29 = call ptr @malloc(i64 %.idx35)
IC: Visiting:   %30 = icmp sgt i64 %9, 0
IC: Visiting:   br i1 %30, label %.lr.ph96.preheader, label %._crit_edge97
IC: Visiting:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %29, ptr %31, align 8
IC: Visiting:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
IC: Visiting:   store ptr %29, ptr %.repack36, align 8
IC: Visiting:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack38, align 8
IC: Visiting:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3
IC: Visiting:   store i64 %9, ptr %.repack40, align 8
IC: Visiting:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack42, align 8
IC: Visiting:   %.idx44 = shl i64 %11, 3
IC: Visiting:   %32 = call ptr @malloc(i64 %.idx44)
IC: Visiting:   %33 = icmp sgt i64 %11, 0
IC: Visiting:   br i1 %33, label %.lr.ph99.preheader, label %._crit_edge100
IC: Visiting:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %32, ptr %34, align 8
IC: Visiting:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
IC: Visiting:   store ptr %32, ptr %.repack45, align 8
IC: Visiting:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack47, align 8
IC: Visiting:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3
IC: Visiting:   store i64 %11, ptr %.repack49, align 8
IC: Visiting:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack51, align 8
IC: Visiting:   %.idx53 = shl i64 %13, 3
IC: Visiting:   %35 = call ptr @malloc(i64 %.idx53)
IC: Visiting:   %36 = icmp sgt i64 %13, 0
IC: Visiting:   br i1 %36, label %.lr.ph102.preheader, label %._crit_edge103
IC: Visiting:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %35, ptr %37, align 8
IC: Visiting:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
IC: Visiting:   store ptr %35, ptr %.repack54, align 8
IC: Visiting:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack56, align 8
IC: Visiting:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
IC: Visiting:   store i64 %13, ptr %.repack58, align 8
IC: Visiting:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack60, align 8
IC: Visiting:   %.idx62 = shl i64 %15, 3
IC: Visiting:   %38 = call ptr @malloc(i64 %.idx62)
IC: Visiting:   %39 = icmp sgt i64 %15, 0
IC: Visiting:   br i1 %39, label %.lr.ph105.preheader, label %._crit_edge106
IC: Visiting:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %38, ptr %40, align 8
IC: Visiting:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
IC: Visiting:   store ptr %38, ptr %.repack63, align 8
IC: Visiting:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack65, align 8
IC: Visiting:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
IC: Visiting:   store i64 %15, ptr %.repack67, align 8
IC: Visiting:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack69, align 8
IC: Visiting:   %.idx71 = shl i64 %17, 3
IC: Visiting:   %41 = call ptr @malloc(i64 %.idx71)
IC: Visiting:   %42 = icmp sgt i64 %17, 0
IC: Visiting:   br i1 %42, label %.lr.ph108.preheader, label %._crit_edge109
IC: Visiting:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %41, ptr %43, align 8
IC: Visiting:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
IC: Visiting:   store ptr %41, ptr %.repack72, align 8
IC: Visiting:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack74, align 8
IC: Visiting:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3
IC: Visiting:   store i64 %17, ptr %.repack76, align 8
IC: Visiting:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack78, align 8
IC: Visiting:   %.idx80 = shl i64 %19, 3
IC: Visiting:   %44 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   %45 = icmp sgt i64 %19, 0
IC: Visiting:   br i1 %45, label %.lr.ph111.preheader, label %._crit_edge112
IC: Visiting:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %44, ptr %46, align 8
IC: Visiting:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
IC: Visiting:   store ptr %44, ptr %.repack81, align 8
IC: Visiting:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack83, align 8
IC: Visiting:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
IC: Visiting:   store i64 %19, ptr %.repack85, align 8
IC: Visiting:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack87, align 8
IC: Visiting:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %22)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %25)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %31)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %34)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %43)
IC: Visiting:   call void @comet_print_memref_f64(i64 1, ptr nonnull %46)
IC: Visiting:   ret void
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false)
IC: Visiting:   br label %._crit_edge112
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false)
IC: Visiting:   br label %._crit_edge109
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false)
IC: Visiting:   br label %._crit_edge106
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false)
IC: Visiting:   br label %._crit_edge103
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false)
IC: Visiting:   br label %._crit_edge100
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false)
IC: Visiting:   br label %._crit_edge97
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false)
IC: Visiting:   br label %._crit_edge94
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false)
IC: Visiting:   br label %._crit_edge91
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false)
IC: Visiting:   br label %._crit_edge
SLP: Analyzing blocks in main.
SLP: Found stores for 1 underlying objects.
SLP: Analyzing a store chain of length 5.
SLP: Trying to vectorize starting at nodes (2)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Analyzing a store chain of length 2
SLP: Analyzing 2 stores at offset 0
SLP:  bundle:   store ptr %44, ptr %46, align 8
SLP:  initialize schedule region to   store ptr %44, ptr %46, align 8
SLP:  extend schedule region end to   store ptr %44, ptr %.repack81, align 8
SLP: try schedule bundle [  store ptr %44, ptr %46, align 8;  store ptr %44, ptr %.repack81, align 8] in block ._crit_edge112
SLP:       update deps of [  store ptr %44, ptr %46, align 8;  store ptr %44, ptr %.repack81, align 8]
SLP:       update deps of /   store ptr %44, ptr %.repack81, align 8
SLP:     gets ready on update:   store ptr %44, ptr %46, align 8
SLP:    initially in ready list: [  store ptr %44, ptr %46, align 8;  store ptr %44, ptr %.repack81, align 8]
SLP: We are able to schedule this bundle.
SLP: Gathering due to C,S,B,O, small shuffle. 
SLP: Shuffle for reused scalars.
SLP: Scalar used twice in bundle.
SLP: added a vector of stores.
SLP: Check whether the tree with height 2 is fully vectorizable .
SLP: Calculating cost for tree of size 2.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %44 = call ptr @malloc(i64 %.idx80)
    %44 = call ptr @malloc(i64 %.idx80)
Operand 1:
    %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
Scalars: 
    store ptr %44, ptr %46, align 8
    store ptr %44, ptr %.repack81, align 8
State: Vectorize
MainOp:   store ptr %44, ptr %46, align 8
AltOp:   store ptr %44, ptr %46, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 1
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -1
SLP: Calculated GEPs cost savings or Tree:
0.
Operand 0:
    %44 = call ptr @malloc(i64 %.idx80)
    %44 = call ptr @malloc(i64 %.idx80)
Operand 1:
    %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
Scalars: 
    store ptr %44, ptr %46, align 8
    store ptr %44, ptr %.repack81, align 8
State: Vectorize
MainOp:   store ptr %44, ptr %46, align 8
AltOp:   store ptr %44, ptr %46, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP:     GEP cost saving = 0
SLP: Adding cost -1 for bundle that starts with   store ptr %44, ptr %46, align 8.
SLP: Current total cost = -1
SLP: Adding cost 2 for bundle that starts with   %44 = call ptr @malloc(i64 %.idx80).
SLP: Current total cost = 1
SLP: #LV: 0, Looking at   store ptr %44, ptr %46, align 8
SLP: Spill Cost = 0.
SLP: Extract Cost = 0.
SLP: Total Cost = 1.
SLP: Found cost = 1 for VF=2
SLP: Found stores for 1 underlying objects.
SLP: Analyzing a store chain of length 5.
SLP: Trying to vectorize starting at nodes (2)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Analyzing a store chain of length 2
SLP: Analyzing 2 stores at offset 0
SLP:  bundle:   store ptr %41, ptr %43, align 8
SLP:  initialize schedule region to   store ptr %41, ptr %43, align 8
SLP:  extend schedule region end to   store ptr %41, ptr %.repack72, align 8
SLP: try schedule bundle [  store ptr %41, ptr %43, align 8;  store ptr %41, ptr %.repack72, align 8] in block ._crit_edge109
SLP:       update deps of [  store ptr %41, ptr %43, align 8;  store ptr %41, ptr %.repack72, align 8]
SLP:       update deps of /   store ptr %41, ptr %.repack72, align 8
SLP:     gets ready on update:   store ptr %41, ptr %43, align 8
SLP:    initially in ready list: [  store ptr %41, ptr %43, align 8;  store ptr %41, ptr %.repack72, align 8]
SLP: We are able to schedule this bundle.
SLP: Gathering due to C,S,B,O, small shuffle. 
SLP: Shuffle for reused scalars.
SLP: Scalar used twice in bundle.
SLP: added a vector of stores.
SLP: Check whether the tree with height 2 is fully vectorizable .
SLP: Calculating cost for tree of size 2.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %41 = call ptr @malloc(i64 %.idx71)
    %41 = call ptr @malloc(i64 %.idx71)
Operand 1:
    %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
Scalars: 
    store ptr %41, ptr %43, align 8
    store ptr %41, ptr %.repack72, align 8
State: Vectorize
MainOp:   store ptr %41, ptr %43, align 8
AltOp:   store ptr %41, ptr %43, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 1
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -1
SLP: Calculated GEPs cost savings or Tree:
0.
Operand 0:
    %41 = call ptr @malloc(i64 %.idx71)
    %41 = call ptr @malloc(i64 %.idx71)
Operand 1:
    %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
Scalars: 
    store ptr %41, ptr %43, align 8
    store ptr %41, ptr %.repack72, align 8
State: Vectorize
MainOp:   store ptr %41, ptr %43, align 8
AltOp:   store ptr %41, ptr %43, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP:     GEP cost saving = 0
SLP: Adding cost -1 for bundle that starts with   store ptr %41, ptr %43, align 8.
SLP: Current total cost = -1
SLP: Adding cost 2 for bundle that starts with   %41 = call ptr @malloc(i64 %.idx71).
SLP: Current total cost = 1
SLP: #LV: 0, Looking at   store ptr %41, ptr %43, align 8
SLP: Spill Cost = 0.
SLP: Extract Cost = 0.
SLP: Total Cost = 1.
SLP: Found cost = 1 for VF=2
SLP: Trying to vectorize starting at nodes (1)
SLP: Found stores for 1 underlying objects.
SLP: Analyzing a store chain of length 5.
SLP: Trying to vectorize starting at nodes (2)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Analyzing a store chain of length 2
SLP: Analyzing 2 stores at offset 0
SLP:  bundle:   store ptr %38, ptr %40, align 8
SLP:  initialize schedule region to   store ptr %38, ptr %40, align 8
SLP:  extend schedule region end to   store ptr %38, ptr %.repack63, align 8
SLP: try schedule bundle [  store ptr %38, ptr %40, align 8;  store ptr %38, ptr %.repack63, align 8] in block ._crit_edge106
SLP:       update deps of [  store ptr %38, ptr %40, align 8;  store ptr %38, ptr %.repack63, align 8]
SLP:       update deps of /   store ptr %38, ptr %.repack63, align 8
SLP:     gets ready on update:   store ptr %38, ptr %40, align 8
SLP:    initially in ready list: [  store ptr %38, ptr %40, align 8;  store ptr %38, ptr %.repack63, align 8]
SLP: We are able to schedule this bundle.
SLP: Gathering due to C,S,B,O, small shuffle. 
SLP: Shuffle for reused scalars.
SLP: Scalar used twice in bundle.
SLP: added a vector of stores.
SLP: Check whether the tree with height 2 is fully vectorizable .
SLP: Calculating cost for tree of size 2.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %38 = call ptr @malloc(i64 %.idx62)
    %38 = call ptr @malloc(i64 %.idx62)
Operand 1:
    %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
Scalars: 
    store ptr %38, ptr %40, align 8
    store ptr %38, ptr %.repack63, align 8
State: Vectorize
MainOp:   store ptr %38, ptr %40, align 8
AltOp:   store ptr %38, ptr %40, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 1
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -1
SLP: Calculated GEPs cost savings or Tree:
0.
Operand 0:
    %38 = call ptr @malloc(i64 %.idx62)
    %38 = call ptr @malloc(i64 %.idx62)
Operand 1:
    %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
Scalars: 
    store ptr %38, ptr %40, align 8
    store ptr %38, ptr %.repack63, align 8
State: Vectorize
MainOp:   store ptr %38, ptr %40, align 8
AltOp:   store ptr %38, ptr %40, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP:     GEP cost saving = 0
SLP: Adding cost -1 for bundle that starts with   store ptr %38, ptr %40, align 8.
SLP: Current total cost = -1
SLP: Adding cost 2 for bundle that starts with   %38 = call ptr @malloc(i64 %.idx62).
SLP: Current total cost = 1
SLP: #LV: 0, Looking at   store ptr %38, ptr %40, align 8
SLP: Spill Cost = 0.
SLP: Extract Cost = 0.
SLP: Total Cost = 1.
SLP: Found cost = 1 for VF=2
SLP: Trying to vectorize starting at nodes (1)
SLP: Found stores for 1 underlying objects.
SLP: Analyzing a store chain of length 5.
SLP: Trying to vectorize starting at nodes (2)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Analyzing a store chain of length 2
SLP: Analyzing 2 stores at offset 0
SLP:  bundle:   store ptr %35, ptr %37, align 8
SLP:  initialize schedule region to   store ptr %35, ptr %37, align 8
SLP:  extend schedule region end to   store ptr %35, ptr %.repack54, align 8
SLP: try schedule bundle [  store ptr %35, ptr %37, align 8;  store ptr %35, ptr %.repack54, align 8] in block ._crit_edge103
SLP:       update deps of [  store ptr %35, ptr %37, align 8;  store ptr %35, ptr %.repack54, align 8]
SLP:       update deps of /   store ptr %35, ptr %.repack54, align 8
SLP:     gets ready on update:   store ptr %35, ptr %37, align 8
SLP:    initially in ready list: [  store ptr %35, ptr %37, align 8;  store ptr %35, ptr %.repack54, align 8]
SLP: We are able to schedule this bundle.
SLP: Gathering due to C,S,B,O, small shuffle. 
SLP: Shuffle for reused scalars.
SLP: Scalar used twice in bundle.
SLP: added a vector of stores.
SLP: Check whether the tree with height 2 is fully vectorizable .
SLP: Calculating cost for tree of size 2.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %35 = call ptr @malloc(i64 %.idx53)
    %35 = call ptr @malloc(i64 %.idx53)
Operand 1:
    %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
Scalars: 
    store ptr %35, ptr %37, align 8
    store ptr %35, ptr %.repack54, align 8
State: Vectorize
MainOp:   store ptr %35, ptr %37, align 8
AltOp:   store ptr %35, ptr %37, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 1
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -1
SLP: Calculated GEPs cost savings or Tree:
0.
Operand 0:
    %35 = call ptr @malloc(i64 %.idx53)
    %35 = call ptr @malloc(i64 %.idx53)
Operand 1:
    %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
Scalars: 
    store ptr %35, ptr %37, align 8
    store ptr %35, ptr %.repack54, align 8
State: Vectorize
MainOp:   store ptr %35, ptr %37, align 8
AltOp:   store ptr %35, ptr %37, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP:     GEP cost saving = 0
SLP: Adding cost -1 for bundle that starts with   store ptr %35, ptr %37, align 8.
SLP: Current total cost = -1
SLP: Adding cost 2 for bundle that starts with   %35 = call ptr @malloc(i64 %.idx53).
SLP: Current total cost = 1
SLP: #LV: 0, Looking at   store ptr %35, ptr %37, align 8
SLP: Spill Cost = 0.
SLP: Extract Cost = 0.
SLP: Total Cost = 1.
SLP: Found cost = 1 for VF=2
SLP: Trying to vectorize starting at nodes (1)
SLP: Found stores for 1 underlying objects.
SLP: Analyzing a store chain of length 5.
SLP: Trying to vectorize starting at nodes (2)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Analyzing a store chain of length 2
SLP: Analyzing 2 stores at offset 0
SLP:  bundle:   store ptr %32, ptr %34, align 8
SLP:  initialize schedule region to   store ptr %32, ptr %34, align 8
SLP:  extend schedule region end to   store ptr %32, ptr %.repack45, align 8
SLP: try schedule bundle [  store ptr %32, ptr %34, align 8;  store ptr %32, ptr %.repack45, align 8] in block ._crit_edge100
SLP:       update deps of [  store ptr %32, ptr %34, align 8;  store ptr %32, ptr %.repack45, align 8]
SLP:       update deps of /   store ptr %32, ptr %.repack45, align 8
SLP:     gets ready on update:   store ptr %32, ptr %34, align 8
SLP:    initially in ready list: [  store ptr %32, ptr %34, align 8;  store ptr %32, ptr %.repack45, align 8]
SLP: We are able to schedule this bundle.
SLP: Gathering due to C,S,B,O, small shuffle. 
SLP: Shuffle for reused scalars.
SLP: Scalar used twice in bundle.
SLP: added a vector of stores.
SLP: Check whether the tree with height 2 is fully vectorizable .
SLP: Calculating cost for tree of size 2.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %32 = call ptr @malloc(i64 %.idx44)
    %32 = call ptr @malloc(i64 %.idx44)
Operand 1:
    %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
Scalars: 
    store ptr %32, ptr %34, align 8
    store ptr %32, ptr %.repack45, align 8
State: Vectorize
MainOp:   store ptr %32, ptr %34, align 8
AltOp:   store ptr %32, ptr %34, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 1
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -1
SLP: Calculated GEPs cost savings or Tree:
0.
Operand 0:
    %32 = call ptr @malloc(i64 %.idx44)
    %32 = call ptr @malloc(i64 %.idx44)
Operand 1:
    %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
Scalars: 
    store ptr %32, ptr %34, align 8
    store ptr %32, ptr %.repack45, align 8
State: Vectorize
MainOp:   store ptr %32, ptr %34, align 8
AltOp:   store ptr %32, ptr %34, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP:     GEP cost saving = 0
SLP: Adding cost -1 for bundle that starts with   store ptr %32, ptr %34, align 8.
SLP: Current total cost = -1
SLP: Adding cost 2 for bundle that starts with   %32 = call ptr @malloc(i64 %.idx44).
SLP: Current total cost = 1
SLP: #LV: 0, Looking at   store ptr %32, ptr %34, align 8
SLP: Spill Cost = 0.
SLP: Extract Cost = 0.
SLP: Total Cost = 1.
SLP: Found cost = 1 for VF=2
SLP: Trying to vectorize starting at nodes (1)
SLP: Found stores for 1 underlying objects.
SLP: Analyzing a store chain of length 5.
SLP: Trying to vectorize starting at nodes (2)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Analyzing a store chain of length 2
SLP: Analyzing 2 stores at offset 0
SLP:  bundle:   store ptr %29, ptr %31, align 8
SLP:  initialize schedule region to   store ptr %29, ptr %31, align 8
SLP:  extend schedule region end to   store ptr %29, ptr %.repack36, align 8
SLP: try schedule bundle [  store ptr %29, ptr %31, align 8;  store ptr %29, ptr %.repack36, align 8] in block ._crit_edge97
SLP:       update deps of [  store ptr %29, ptr %31, align 8;  store ptr %29, ptr %.repack36, align 8]
SLP:       update deps of /   store ptr %29, ptr %.repack36, align 8
SLP:     gets ready on update:   store ptr %29, ptr %31, align 8
SLP:    initially in ready list: [  store ptr %29, ptr %31, align 8;  store ptr %29, ptr %.repack36, align 8]
SLP: We are able to schedule this bundle.
SLP: Gathering due to C,S,B,O, small shuffle. 
SLP: Shuffle for reused scalars.
SLP: Scalar used twice in bundle.
SLP: added a vector of stores.
SLP: Check whether the tree with height 2 is fully vectorizable .
SLP: Calculating cost for tree of size 2.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %29 = call ptr @malloc(i64 %.idx35)
    %29 = call ptr @malloc(i64 %.idx35)
Operand 1:
    %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
Scalars: 
    store ptr %29, ptr %31, align 8
    store ptr %29, ptr %.repack36, align 8
State: Vectorize
MainOp:   store ptr %29, ptr %31, align 8
AltOp:   store ptr %29, ptr %31, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 1
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -1
SLP: Calculated GEPs cost savings or Tree:
0.
Operand 0:
    %29 = call ptr @malloc(i64 %.idx35)
    %29 = call ptr @malloc(i64 %.idx35)
Operand 1:
    %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
Scalars: 
    store ptr %29, ptr %31, align 8
    store ptr %29, ptr %.repack36, align 8
State: Vectorize
MainOp:   store ptr %29, ptr %31, align 8
AltOp:   store ptr %29, ptr %31, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP:     GEP cost saving = 0
SLP: Adding cost -1 for bundle that starts with   store ptr %29, ptr %31, align 8.
SLP: Current total cost = -1
SLP: Adding cost 2 for bundle that starts with   %29 = call ptr @malloc(i64 %.idx35).
SLP: Current total cost = 1
SLP: #LV: 0, Looking at   store ptr %29, ptr %31, align 8
SLP: Spill Cost = 0.
SLP: Extract Cost = 0.
SLP: Total Cost = 1.
SLP: Found cost = 1 for VF=2
SLP: Trying to vectorize starting at nodes (1)
SLP: Found stores for 1 underlying objects.
SLP: Analyzing a store chain of length 5.
SLP: Trying to vectorize starting at nodes (2)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Analyzing a store chain of length 2
SLP: Analyzing 2 stores at offset 0
SLP:  bundle:   store ptr %26, ptr %28, align 8
SLP:  initialize schedule region to   store ptr %26, ptr %28, align 8
SLP:  extend schedule region end to   store ptr %26, ptr %.repack27, align 8
SLP: try schedule bundle [  store ptr %26, ptr %28, align 8;  store ptr %26, ptr %.repack27, align 8] in block ._crit_edge94
SLP:       update deps of [  store ptr %26, ptr %28, align 8;  store ptr %26, ptr %.repack27, align 8]
SLP:       update deps of /   store ptr %26, ptr %.repack27, align 8
SLP:     gets ready on update:   store ptr %26, ptr %28, align 8
SLP:    initially in ready list: [  store ptr %26, ptr %28, align 8;  store ptr %26, ptr %.repack27, align 8]
SLP: We are able to schedule this bundle.
SLP: Gathering due to C,S,B,O, small shuffle. 
SLP: Shuffle for reused scalars.
SLP: Scalar used twice in bundle.
SLP: added a vector of stores.
SLP: Check whether the tree with height 2 is fully vectorizable .
SLP: Calculating cost for tree of size 2.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %26 = call ptr @malloc(i64 %.idx26)
    %26 = call ptr @malloc(i64 %.idx26)
Operand 1:
    %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
Scalars: 
    store ptr %26, ptr %28, align 8
    store ptr %26, ptr %.repack27, align 8
State: Vectorize
MainOp:   store ptr %26, ptr %28, align 8
AltOp:   store ptr %26, ptr %28, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 1
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -1
SLP: Calculated GEPs cost savings or Tree:
0.
Operand 0:
    %26 = call ptr @malloc(i64 %.idx26)
    %26 = call ptr @malloc(i64 %.idx26)
Operand 1:
    %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
Scalars: 
    store ptr %26, ptr %28, align 8
    store ptr %26, ptr %.repack27, align 8
State: Vectorize
MainOp:   store ptr %26, ptr %28, align 8
AltOp:   store ptr %26, ptr %28, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP:     GEP cost saving = 0
SLP: Adding cost -1 for bundle that starts with   store ptr %26, ptr %28, align 8.
SLP: Current total cost = -1
SLP: Adding cost 2 for bundle that starts with   %26 = call ptr @malloc(i64 %.idx26).
SLP: Current total cost = 1
SLP: #LV: 0, Looking at   store ptr %26, ptr %28, align 8
SLP: Spill Cost = 0.
SLP: Extract Cost = 0.
SLP: Total Cost = 1.
SLP: Found cost = 1 for VF=2
SLP: Trying to vectorize starting at nodes (1)
SLP: Found stores for 1 underlying objects.
SLP: Analyzing a store chain of length 5.
SLP: Trying to vectorize starting at nodes (2)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Analyzing a store chain of length 2
SLP: Analyzing 2 stores at offset 0
SLP:  bundle:   store ptr %23, ptr %25, align 8
SLP:  initialize schedule region to   store ptr %23, ptr %25, align 8
SLP:  extend schedule region end to   store ptr %23, ptr %.repack18, align 8
SLP: try schedule bundle [  store ptr %23, ptr %25, align 8;  store ptr %23, ptr %.repack18, align 8] in block ._crit_edge91
SLP:       update deps of [  store ptr %23, ptr %25, align 8;  store ptr %23, ptr %.repack18, align 8]
SLP:       update deps of /   store ptr %23, ptr %.repack18, align 8
SLP:     gets ready on update:   store ptr %23, ptr %25, align 8
SLP:    initially in ready list: [  store ptr %23, ptr %25, align 8;  store ptr %23, ptr %.repack18, align 8]
SLP: We are able to schedule this bundle.
SLP: Gathering due to C,S,B,O, small shuffle. 
SLP: Shuffle for reused scalars.
SLP: Scalar used twice in bundle.
SLP: added a vector of stores.
SLP: Check whether the tree with height 2 is fully vectorizable .
SLP: Calculating cost for tree of size 2.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %23 = call ptr @malloc(i64 %.idx17)
    %23 = call ptr @malloc(i64 %.idx17)
Operand 1:
    %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
Scalars: 
    store ptr %23, ptr %25, align 8
    store ptr %23, ptr %.repack18, align 8
State: Vectorize
MainOp:   store ptr %23, ptr %25, align 8
AltOp:   store ptr %23, ptr %25, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 1
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -1
SLP: Calculated GEPs cost savings or Tree:
0.
Operand 0:
    %23 = call ptr @malloc(i64 %.idx17)
    %23 = call ptr @malloc(i64 %.idx17)
Operand 1:
    %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
Scalars: 
    store ptr %23, ptr %25, align 8
    store ptr %23, ptr %.repack18, align 8
State: Vectorize
MainOp:   store ptr %23, ptr %25, align 8
AltOp:   store ptr %23, ptr %25, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP:     GEP cost saving = 0
SLP: Adding cost -1 for bundle that starts with   store ptr %23, ptr %25, align 8.
SLP: Current total cost = -1
SLP: Adding cost 2 for bundle that starts with   %23 = call ptr @malloc(i64 %.idx17).
SLP: Current total cost = 1
SLP: #LV: 0, Looking at   store ptr %23, ptr %25, align 8
SLP: Spill Cost = 0.
SLP: Extract Cost = 0.
SLP: Total Cost = 1.
SLP: Found cost = 1 for VF=2
SLP: Trying to vectorize starting at nodes (1)
SLP: Found stores for 1 underlying objects.
SLP: Analyzing a store chain of length 5.
SLP: Trying to vectorize starting at nodes (2)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Analyzing a store chain of length 2
SLP: Analyzing 2 stores at offset 0
SLP:  bundle:   store ptr %20, ptr %22, align 8
SLP:  initialize schedule region to   store ptr %20, ptr %22, align 8
SLP:  extend schedule region end to   store ptr %20, ptr %.repack9, align 8
SLP: try schedule bundle [  store ptr %20, ptr %22, align 8;  store ptr %20, ptr %.repack9, align 8] in block ._crit_edge
SLP:       update deps of [  store ptr %20, ptr %22, align 8;  store ptr %20, ptr %.repack9, align 8]
SLP:       update deps of /   store ptr %20, ptr %.repack9, align 8
SLP:     gets ready on update:   store ptr %20, ptr %22, align 8
SLP:    initially in ready list: [  store ptr %20, ptr %22, align 8;  store ptr %20, ptr %.repack9, align 8]
SLP: We are able to schedule this bundle.
SLP: Gathering due to C,S,B,O, small shuffle. 
SLP: Shuffle for reused scalars.
SLP: Scalar used twice in bundle.
SLP: added a vector of stores.
SLP: Check whether the tree with height 2 is fully vectorizable .
SLP: Calculating cost for tree of size 2.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %20 = call ptr @malloc(i64 %.idx)
    %20 = call ptr @malloc(i64 %.idx)
Operand 1:
    %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
Scalars: 
    store ptr %20, ptr %22, align 8
    store ptr %20, ptr %.repack9, align 8
State: Vectorize
MainOp:   store ptr %20, ptr %22, align 8
AltOp:   store ptr %20, ptr %22, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 1
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -1
SLP: Calculated GEPs cost savings or Tree:
0.
Operand 0:
    %20 = call ptr @malloc(i64 %.idx)
    %20 = call ptr @malloc(i64 %.idx)
Operand 1:
    %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
Scalars: 
    store ptr %20, ptr %22, align 8
    store ptr %20, ptr %.repack9, align 8
State: Vectorize
MainOp:   store ptr %20, ptr %22, align 8
AltOp:   store ptr %20, ptr %22, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP:     GEP cost saving = 0
SLP: Adding cost -1 for bundle that starts with   store ptr %20, ptr %22, align 8.
SLP: Current total cost = -1
SLP: Adding cost 2 for bundle that starts with   %20 = call ptr @malloc(i64 %.idx).
SLP: Current total cost = 1
SLP: #LV: 0, Looking at   store ptr %20, ptr %22, align 8
SLP: Spill Cost = 0.
SLP: Extract Cost = 0.
SLP: Total Cost = 1.
SLP: Found cost = 1 for VF=2
SLP: Trying to vectorize starting at nodes (1)
SLP: Found stores for 1 underlying objects.
SLP: Analyzing a store chain of length 5.
SLP: Trying to vectorize starting at nodes (3)
SLP: Analyzing a store chain of length 2
SLP: Analyzing 2 stores at offset 0
SLP:  bundle:   store i64 0, ptr %.fca.2.gep, align 8
SLP:  initialize schedule region to   store i64 0, ptr %.fca.2.gep, align 8
SLP:  extend schedule region end to   store i64 7, ptr %.fca.3.0.gep, align 8
SLP: try schedule bundle [  store i64 0, ptr %.fca.2.gep, align 8;  store i64 7, ptr %.fca.3.0.gep, align 8] in block 
SLP:       update deps of [  store i64 0, ptr %.fca.2.gep, align 8;  store i64 7, ptr %.fca.3.0.gep, align 8]
SLP:       update deps of /   store i64 7, ptr %.fca.3.0.gep, align 8
SLP:     gets ready on update:   store i64 0, ptr %.fca.2.gep, align 8
SLP:    initially in ready list: [  store i64 0, ptr %.fca.2.gep, align 8;  store i64 7, ptr %.fca.3.0.gep, align 8]
SLP: We are able to schedule this bundle.
SLP: Gathering due to C,S,B,O, small shuffle. 
SLP: added a vector of stores.
SLP: Check whether the tree with height 2 is fully vectorizable .
SLP: Calculating cost for tree of size 2.
SLP: Calculated costs for Tree:
0.
Operand 0:
  i64 0
  i64 7
Operand 1:
    %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
    %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
Scalars: 
    store i64 0, ptr %.fca.2.gep, align 8
    store i64 7, ptr %.fca.3.0.gep, align 8
State: Vectorize
MainOp:   store i64 0, ptr %.fca.2.gep, align 8
AltOp:   store i64 0, ptr %.fca.2.gep, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 2
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 0
SLP: Calculated GEPs cost savings or Tree:
0.
Operand 0:
  i64 0
  i64 7
Operand 1:
    %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
    %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
Scalars: 
    store i64 0, ptr %.fca.2.gep, align 8
    store i64 7, ptr %.fca.3.0.gep, align 8
State: Vectorize
MainOp:   store i64 0, ptr %.fca.2.gep, align 8
AltOp:   store i64 0, ptr %.fca.2.gep, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP:     GEP cost saving = 0
SLP: Adding cost 0 for bundle that starts with   store i64 0, ptr %.fca.2.gep, align 8.
SLP: Current total cost = 0
SLP: Adding cost 0 for bundle that starts with i64 0.
SLP: Current total cost = 0
SLP: Spill Cost = 0.
SLP: Extract Cost = 0.
SLP: Total Cost = 0.
SLP: Found cost = 0 for VF=2
SLP: Analyzing a store chain of length 2
SLP: Analyzing 2 stores at offset 1
SLP:  bundle:   store i64 7, ptr %.fca.3.0.gep, align 8
SLP:  initialize schedule region to   store i64 7, ptr %.fca.3.0.gep, align 8
SLP:  extend schedule region end to   store i64 1, ptr %.fca.4.0.gep, align 8
SLP: try schedule bundle [  store i64 7, ptr %.fca.3.0.gep, align 8;  store i64 1, ptr %.fca.4.0.gep, align 8] in block 
SLP:       update deps of [  store i64 7, ptr %.fca.3.0.gep, align 8;  store i64 1, ptr %.fca.4.0.gep, align 8]
SLP:       update deps of /   store i64 1, ptr %.fca.4.0.gep, align 8
SLP:     gets ready on update:   store i64 7, ptr %.fca.3.0.gep, align 8
SLP:    initially in ready list: [  store i64 7, ptr %.fca.3.0.gep, align 8;  store i64 1, ptr %.fca.4.0.gep, align 8]
SLP: We are able to schedule this bundle.
SLP: Gathering due to C,S,B,O, small shuffle. 
SLP: added a vector of stores.
SLP: Check whether the tree with height 2 is fully vectorizable .
SLP: Calculating cost for tree of size 2.
SLP: Calculated costs for Tree:
0.
Operand 0:
  i64 7
  i64 1
Operand 1:
    %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
    %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
Scalars: 
    store i64 7, ptr %.fca.3.0.gep, align 8
    store i64 1, ptr %.fca.4.0.gep, align 8
State: Vectorize
MainOp:   store i64 7, ptr %.fca.3.0.gep, align 8
AltOp:   store i64 7, ptr %.fca.3.0.gep, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 2
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 0
SLP: Calculated GEPs cost savings or Tree:
0.
Operand 0:
  i64 7
  i64 1
Operand 1:
    %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
    %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
Scalars: 
    store i64 7, ptr %.fca.3.0.gep, align 8
    store i64 1, ptr %.fca.4.0.gep, align 8
State: Vectorize
MainOp:   store i64 7, ptr %.fca.3.0.gep, align 8
AltOp:   store i64 7, ptr %.fca.3.0.gep, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP:     GEP cost saving = 0
SLP: Adding cost 0 for bundle that starts with   store i64 7, ptr %.fca.3.0.gep, align 8.
SLP: Current total cost = 0
SLP: Adding cost 0 for bundle that starts with i64 7.
SLP: Current total cost = 0
SLP: Spill Cost = 0.
SLP: Extract Cost = 0.
SLP: Total Cost = 0.
SLP: Found cost = 0 for VF=2
SLP: Trying to vectorize starting at nodes (1)
SLP: Trying to vectorize starting at nodes (1)
SLP: Analyzing a store chain of length 2
SLP: Analyzing 2 stores at offset 0
SLP:  bundle:   store ptr %1, ptr %2, align 8
SLP:  initialize schedule region to   store ptr %1, ptr %2, align 8
SLP:  extend schedule region end to   store ptr %1, ptr %.fca.1.gep, align 8
SLP: try schedule bundle [  store ptr %1, ptr %2, align 8;  store ptr %1, ptr %.fca.1.gep, align 8] in block 
SLP:       update deps of [  store ptr %1, ptr %2, align 8;  store ptr %1, ptr %.fca.1.gep, align 8]
SLP:       update deps of /   store ptr %1, ptr %.fca.1.gep, align 8
SLP:     gets ready on update:   store ptr %1, ptr %2, align 8
SLP:    initially in ready list: [  store ptr %1, ptr %2, align 8;  store ptr %1, ptr %.fca.1.gep, align 8]
SLP: We are able to schedule this bundle.
SLP: Gathering due to C,S,B,O, small shuffle. 
SLP: Shuffle for reused scalars.
SLP: Scalar used twice in bundle.
SLP: added a vector of stores.
SLP: Check whether the tree with height 2 is fully vectorizable .
SLP: Calculating cost for tree of size 2.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
    %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
Operand 1:
    %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
Scalars: 
    store ptr %1, ptr %2, align 8
    store ptr %1, ptr %.fca.1.gep, align 8
State: Vectorize
MainOp:   store ptr %1, ptr %2, align 8
AltOp:   store ptr %1, ptr %2, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 1
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -1
SLP: Calculated GEPs cost savings or Tree:
0.
Operand 0:
    %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
    %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
Operand 1:
    %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
    %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
Scalars: 
    store ptr %1, ptr %2, align 8
    store ptr %1, ptr %.fca.1.gep, align 8
State: Vectorize
MainOp:   store ptr %1, ptr %2, align 8
AltOp:   store ptr %1, ptr %2, align 8
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP:     GEP cost saving = 0
SLP: Adding cost -1 for bundle that starts with   store ptr %1, ptr %2, align 8.
SLP: Current total cost = -1
SLP: Adding cost 2 for bundle that starts with   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56).
SLP: Current total cost = 1
SLP: #LV: 0, Looking at   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
SLP: Spill Cost = 0.
SLP: Extract Cost = 0.
SLP: Total Cost = 1.
SLP: Found cost = 1 for VF=2
SLP: Trying to vectorize starting at nodes (1)


INSTCOMBINE ITERATION #1 on main
ADD:   br label %._crit_edge
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false)
ADD:   br label %._crit_edge91
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false)
ADD:   br label %._crit_edge94
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false)
ADD:   br label %._crit_edge97
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false)
ADD:   br label %._crit_edge100
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false)
ADD:   br label %._crit_edge103
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false)
ADD:   br label %._crit_edge106
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false)
ADD:   br label %._crit_edge109
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false)
ADD:   br label %._crit_edge112
ADD:   call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false)
ADD:   ret void
ADD:   call void @comet_print_memref_f64(i64 1, ptr nonnull %46)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %43)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %34)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %31)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %25)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %22)
ADD:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1)
ADD:   store i64 1, ptr %.repack87, align 8
ADD:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
ADD:   store i64 %19, ptr %.repack85, align 8
ADD:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
ADD:   store i64 0, ptr %.repack83, align 8
ADD:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
ADD:   store ptr %44, ptr %.repack81, align 8
ADD:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
ADD:   store ptr %44, ptr %46, align 8
ADD:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %45, label %.lr.ph111.preheader, label %._crit_edge112
ADD:   %45 = icmp sgt i64 %19, 0
ADD:   %44 = call ptr @malloc(i64 %.idx80)
ADD:   %.idx80 = shl i64 %19, 3
ADD:   store i64 1, ptr %.repack78, align 8
ADD:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4
ADD:   store i64 %17, ptr %.repack76, align 8
ADD:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3
ADD:   store i64 0, ptr %.repack74, align 8
ADD:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2
ADD:   store ptr %41, ptr %.repack72, align 8
ADD:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
ADD:   store ptr %41, ptr %43, align 8
ADD:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %42, label %.lr.ph108.preheader, label %._crit_edge109
ADD:   %42 = icmp sgt i64 %17, 0
ADD:   %41 = call ptr @malloc(i64 %.idx71)
ADD:   %.idx71 = shl i64 %17, 3
ADD:   store i64 1, ptr %.repack69, align 8
ADD:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
ADD:   store i64 %15, ptr %.repack67, align 8
ADD:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
ADD:   store i64 0, ptr %.repack65, align 8
ADD:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
ADD:   store ptr %38, ptr %.repack63, align 8
ADD:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
ADD:   store ptr %38, ptr %40, align 8
ADD:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %39, label %.lr.ph105.preheader, label %._crit_edge106
ADD:   %39 = icmp sgt i64 %15, 0
ADD:   %38 = call ptr @malloc(i64 %.idx62)
ADD:   %.idx62 = shl i64 %15, 3
ADD:   store i64 1, ptr %.repack60, align 8
ADD:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
ADD:   store i64 %13, ptr %.repack58, align 8
ADD:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
ADD:   store i64 0, ptr %.repack56, align 8
ADD:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
ADD:   store ptr %35, ptr %.repack54, align 8
ADD:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
ADD:   store ptr %35, ptr %37, align 8
ADD:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %36, label %.lr.ph102.preheader, label %._crit_edge103
ADD:   %36 = icmp sgt i64 %13, 0
ADD:   %35 = call ptr @malloc(i64 %.idx53)
ADD:   %.idx53 = shl i64 %13, 3
ADD:   store i64 1, ptr %.repack51, align 8
ADD:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4
ADD:   store i64 %11, ptr %.repack49, align 8
ADD:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3
ADD:   store i64 0, ptr %.repack47, align 8
ADD:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2
ADD:   store ptr %32, ptr %.repack45, align 8
ADD:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
ADD:   store ptr %32, ptr %34, align 8
ADD:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %33, label %.lr.ph99.preheader, label %._crit_edge100
ADD:   %33 = icmp sgt i64 %11, 0
ADD:   %32 = call ptr @malloc(i64 %.idx44)
ADD:   %.idx44 = shl i64 %11, 3
ADD:   store i64 1, ptr %.repack42, align 8
ADD:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4
ADD:   store i64 %9, ptr %.repack40, align 8
ADD:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3
ADD:   store i64 0, ptr %.repack38, align 8
ADD:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2
ADD:   store ptr %29, ptr %.repack36, align 8
ADD:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
ADD:   store ptr %29, ptr %31, align 8
ADD:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %30, label %.lr.ph96.preheader, label %._crit_edge97
ADD:   %30 = icmp sgt i64 %9, 0
ADD:   %29 = call ptr @malloc(i64 %.idx35)
ADD:   %.idx35 = shl i64 %9, 3
ADD:   store i64 1, ptr %.repack33, align 8
ADD:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
ADD:   store i64 %7, ptr %.repack31, align 8
ADD:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
ADD:   store i64 0, ptr %.repack29, align 8
ADD:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
ADD:   store ptr %26, ptr %.repack27, align 8
ADD:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
ADD:   store ptr %26, ptr %28, align 8
ADD:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %27, label %.lr.ph93.preheader, label %._crit_edge94
ADD:   %27 = icmp sgt i64 %7, 0
ADD:   %26 = call ptr @malloc(i64 %.idx26)
ADD:   %.idx26 = shl i64 %7, 3
ADD:   store i64 1, ptr %.repack24, align 8
ADD:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4
ADD:   store i64 %5, ptr %.repack22, align 8
ADD:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3
ADD:   store i64 0, ptr %.repack20, align 8
ADD:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2
ADD:   store ptr %23, ptr %.repack18, align 8
ADD:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
ADD:   store ptr %23, ptr %25, align 8
ADD:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %24, label %.lr.ph90.preheader, label %._crit_edge91
ADD:   %24 = icmp sgt i64 %5, 0
ADD:   %23 = call ptr @malloc(i64 %.idx17)
ADD:   %.idx17 = shl i64 %5, 3
ADD:   store i64 1, ptr %.repack15, align 8
ADD:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4
ADD:   store i64 %3, ptr %.repack13, align 8
ADD:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3
ADD:   store i64 0, ptr %.repack11, align 8
ADD:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2
ADD:   store ptr %20, ptr %.repack9, align 8
ADD:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
ADD:   store ptr %20, ptr %22, align 8
ADD:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %21, label %.lr.ph.preheader, label %._crit_edge
ADD:   %21 = icmp sgt i64 %3, 0
ADD:   %20 = call ptr @malloc(i64 %.idx)
ADD:   %.idx = shl i64 %3, 3
ADD:   %19 = load i64, ptr %18, align 4
ADD:   %18 = getelementptr i64, ptr %1, i64 8
ADD:   %17 = load i64, ptr %16, align 4
ADD:   %16 = getelementptr i64, ptr %1, i64 7
ADD:   %15 = load i64, ptr %14, align 4
ADD:   %14 = getelementptr i64, ptr %1, i64 6
ADD:   %13 = load i64, ptr %12, align 4
ADD:   %12 = getelementptr i64, ptr %1, i64 5
ADD:   %11 = load i64, ptr %10, align 4
ADD:   %10 = getelementptr i64, ptr %1, i64 4
ADD:   %9 = load i64, ptr %8, align 4
ADD:   %8 = getelementptr i64, ptr %1, i64 3
ADD:   %7 = load i64, ptr %6, align 4
ADD:   %6 = getelementptr i64, ptr %1, i64 2
ADD:   %5 = load i64, ptr %4, align 4
ADD:   %4 = getelementptr i64, ptr %1, i64 1
ADD:   %3 = load i64, ptr %1, align 4
ADD:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
ADD:   store i64 1, ptr %.fca.4.0.gep, align 8
ADD:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
ADD:   store i64 7, ptr %.fca.3.0.gep, align 8
ADD:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
ADD:   store i64 0, ptr %.fca.2.gep, align 8
ADD:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
ADD:   store ptr %1, ptr %.fca.1.gep, align 8
ADD:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
ADD:   store ptr %1, ptr %2, align 8
ADD:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %1, ptr %2, align 8
IC: Visiting:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
IC: Visiting:   store ptr %1, ptr %.fca.1.gep, align 8
IC: Visiting:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.fca.2.gep, align 8
IC: Visiting:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
IC: Visiting:   store i64 7, ptr %.fca.3.0.gep, align 8
IC: Visiting:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
IC: Visiting:   store i64 1, ptr %.fca.4.0.gep, align 8
IC: Visiting:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
IC: Visiting:   %3 = load i64, ptr %1, align 4
IC: Visiting:   %4 = getelementptr i64, ptr %1, i64 1
IC: Visiting:   %5 = load i64, ptr %4, align 4
IC: Visiting:   %6 = getelementptr i64, ptr %1, i64 2
IC: Visiting:   %7 = load i64, ptr %6, align 4
IC: Visiting:   %8 = getelementptr i64, ptr %1, i64 3
IC: Visiting:   %9 = load i64, ptr %8, align 4
IC: Visiting:   %10 = getelementptr i64, ptr %1, i64 4
IC: Visiting:   %11 = load i64, ptr %10, align 4
IC: Visiting:   %12 = getelementptr i64, ptr %1, i64 5
IC: Visiting:   %13 = load i64, ptr %12, align 4
IC: Visiting:   %14 = getelementptr i64, ptr %1, i64 6
IC: Visiting:   %15 = load i64, ptr %14, align 4
IC: Visiting:   %16 = getelementptr i64, ptr %1, i64 7
IC: Visiting:   %17 = load i64, ptr %16, align 4
IC: Visiting:   %18 = getelementptr i64, ptr %1, i64 8
IC: Visiting:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %.idx = shl i64 %3, 3
IC: Visiting:   %20 = call ptr @malloc(i64 %.idx)
IC: Visiting:   %21 = icmp sgt i64 %3, 0
IC: Visiting:   br i1 %21, label %.lr.ph.preheader, label %._crit_edge
IC: Visiting:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %20, ptr %22, align 8
IC: Visiting:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
IC: Visiting:   store ptr %20, ptr %.repack9, align 8
IC: Visiting:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack11, align 8
IC: Visiting:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3
IC: Visiting:   store i64 %3, ptr %.repack13, align 8
IC: Visiting:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack15, align 8
IC: Visiting:   %.idx17 = shl i64 %5, 3
IC: Visiting:   %23 = call ptr @malloc(i64 %.idx17)
IC: Visiting:   %24 = icmp sgt i64 %5, 0
IC: Visiting:   br i1 %24, label %.lr.ph90.preheader, label %._crit_edge91
IC: Visiting:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %23, ptr %25, align 8
IC: Visiting:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
IC: Visiting:   store ptr %23, ptr %.repack18, align 8
IC: Visiting:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack20, align 8
IC: Visiting:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3
IC: Visiting:   store i64 %5, ptr %.repack22, align 8
IC: Visiting:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack24, align 8
IC: Visiting:   %.idx26 = shl i64 %7, 3
IC: Visiting:   %26 = call ptr @malloc(i64 %.idx26)
IC: Visiting:   %27 = icmp sgt i64 %7, 0
IC: Visiting:   br i1 %27, label %.lr.ph93.preheader, label %._crit_edge94
IC: Visiting:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %26, ptr %28, align 8
IC: Visiting:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
IC: Visiting:   store ptr %26, ptr %.repack27, align 8
IC: Visiting:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack29, align 8
IC: Visiting:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
IC: Visiting:   store i64 %7, ptr %.repack31, align 8
IC: Visiting:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack33, align 8
IC: Visiting:   %.idx35 = shl i64 %9, 3
IC: Visiting:   %29 = call ptr @malloc(i64 %.idx35)
IC: Visiting:   %30 = icmp sgt i64 %9, 0
IC: Visiting:   br i1 %30, label %.lr.ph96.preheader, label %._crit_edge97
IC: Visiting:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %29, ptr %31, align 8
IC: Visiting:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
IC: Visiting:   store ptr %29, ptr %.repack36, align 8
IC: Visiting:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack38, align 8
IC: Visiting:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3
IC: Visiting:   store i64 %9, ptr %.repack40, align 8
IC: Visiting:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack42, align 8
IC: Visiting:   %.idx44 = shl i64 %11, 3
IC: Visiting:   %32 = call ptr @malloc(i64 %.idx44)
IC: Visiting:   %33 = icmp sgt i64 %11, 0
IC: Visiting:   br i1 %33, label %.lr.ph99.preheader, label %._crit_edge100
IC: Visiting:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %32, ptr %34, align 8
IC: Visiting:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
IC: Visiting:   store ptr %32, ptr %.repack45, align 8
IC: Visiting:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack47, align 8
IC: Visiting:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3
IC: Visiting:   store i64 %11, ptr %.repack49, align 8
IC: Visiting:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack51, align 8
IC: Visiting:   %.idx53 = shl i64 %13, 3
IC: Visiting:   %35 = call ptr @malloc(i64 %.idx53)
IC: Visiting:   %36 = icmp sgt i64 %13, 0
IC: Visiting:   br i1 %36, label %.lr.ph102.preheader, label %._crit_edge103
IC: Visiting:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %35, ptr %37, align 8
IC: Visiting:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
IC: Visiting:   store ptr %35, ptr %.repack54, align 8
IC: Visiting:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack56, align 8
IC: Visiting:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
IC: Visiting:   store i64 %13, ptr %.repack58, align 8
IC: Visiting:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack60, align 8
IC: Visiting:   %.idx62 = shl i64 %15, 3
IC: Visiting:   %38 = call ptr @malloc(i64 %.idx62)
IC: Visiting:   %39 = icmp sgt i64 %15, 0
IC: Visiting:   br i1 %39, label %.lr.ph105.preheader, label %._crit_edge106
IC: Visiting:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %38, ptr %40, align 8
IC: Visiting:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
IC: Visiting:   store ptr %38, ptr %.repack63, align 8
IC: Visiting:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack65, align 8
IC: Visiting:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
IC: Visiting:   store i64 %15, ptr %.repack67, align 8
IC: Visiting:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack69, align 8
IC: Visiting:   %.idx71 = shl i64 %17, 3
IC: Visiting:   %41 = call ptr @malloc(i64 %.idx71)
IC: Visiting:   %42 = icmp sgt i64 %17, 0
IC: Visiting:   br i1 %42, label %.lr.ph108.preheader, label %._crit_edge109
IC: Visiting:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %41, ptr %43, align 8
IC: Visiting:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
IC: Visiting:   store ptr %41, ptr %.repack72, align 8
IC: Visiting:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack74, align 8
IC: Visiting:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3
IC: Visiting:   store i64 %17, ptr %.repack76, align 8
IC: Visiting:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack78, align 8
IC: Visiting:   %.idx80 = shl i64 %19, 3
IC: Visiting:   %44 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   %45 = icmp sgt i64 %19, 0
IC: Visiting:   br i1 %45, label %.lr.ph111.preheader, label %._crit_edge112
IC: Visiting:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %44, ptr %46, align 8
IC: Visiting:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
IC: Visiting:   store ptr %44, ptr %.repack81, align 8
IC: Visiting:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack83, align 8
IC: Visiting:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
IC: Visiting:   store i64 %19, ptr %.repack85, align 8
IC: Visiting:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack87, align 8
IC: Visiting:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %22)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %25)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %31)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %34)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %43)
IC: Visiting:   call void @comet_print_memref_f64(i64 1, ptr nonnull %46)
IC: Visiting:   ret void
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false)
IC: Visiting:   br label %._crit_edge112
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false)
IC: Visiting:   br label %._crit_edge109
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false)
IC: Visiting:   br label %._crit_edge106
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false)
IC: Visiting:   br label %._crit_edge103
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false)
IC: Visiting:   br label %._crit_edge100
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false)
IC: Visiting:   br label %._crit_edge97
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false)
IC: Visiting:   br label %._crit_edge94
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false)
IC: Visiting:   br label %._crit_edge91
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false)
IC: Visiting:   br label %._crit_edge
SROA function: main
SROA alloca:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  Rewriting FCA loads and stores...
Can't analyze slices for alloca:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
  A pointer to this alloca escaped by:
    call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)


INSTCOMBINE ITERATION #1 on main
ADD:   br label %._crit_edge
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false)
ADD:   br label %._crit_edge91
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false)
ADD:   br label %._crit_edge94
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false)
ADD:   br label %._crit_edge97
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false)
ADD:   br label %._crit_edge100
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false)
ADD:   br label %._crit_edge103
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false)
ADD:   br label %._crit_edge106
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false)
ADD:   br label %._crit_edge109
ADD:   call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false)
ADD:   br label %._crit_edge112
ADD:   call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false)
ADD:   ret void
ADD:   call void @comet_print_memref_f64(i64 1, ptr nonnull %46)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %43)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %34)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %31)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %25)
ADD:   call void @comet_print_memref_i64(i64 1, ptr nonnull %22)
ADD:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1)
ADD:   store i64 1, ptr %.repack87, align 8
ADD:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
ADD:   store i64 %19, ptr %.repack85, align 8
ADD:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
ADD:   store i64 0, ptr %.repack83, align 8
ADD:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
ADD:   store ptr %44, ptr %.repack81, align 8
ADD:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
ADD:   store ptr %44, ptr %46, align 8
ADD:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %45, label %.lr.ph111.preheader, label %._crit_edge112
ADD:   %45 = icmp sgt i64 %19, 0
ADD:   %44 = call ptr @malloc(i64 %.idx80)
ADD:   %.idx80 = shl i64 %19, 3
ADD:   store i64 1, ptr %.repack78, align 8
ADD:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4
ADD:   store i64 %17, ptr %.repack76, align 8
ADD:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3
ADD:   store i64 0, ptr %.repack74, align 8
ADD:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2
ADD:   store ptr %41, ptr %.repack72, align 8
ADD:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
ADD:   store ptr %41, ptr %43, align 8
ADD:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %42, label %.lr.ph108.preheader, label %._crit_edge109
ADD:   %42 = icmp sgt i64 %17, 0
ADD:   %41 = call ptr @malloc(i64 %.idx71)
ADD:   %.idx71 = shl i64 %17, 3
ADD:   store i64 1, ptr %.repack69, align 8
ADD:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
ADD:   store i64 %15, ptr %.repack67, align 8
ADD:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
ADD:   store i64 0, ptr %.repack65, align 8
ADD:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
ADD:   store ptr %38, ptr %.repack63, align 8
ADD:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
ADD:   store ptr %38, ptr %40, align 8
ADD:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %39, label %.lr.ph105.preheader, label %._crit_edge106
ADD:   %39 = icmp sgt i64 %15, 0
ADD:   %38 = call ptr @malloc(i64 %.idx62)
ADD:   %.idx62 = shl i64 %15, 3
ADD:   store i64 1, ptr %.repack60, align 8
ADD:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
ADD:   store i64 %13, ptr %.repack58, align 8
ADD:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
ADD:   store i64 0, ptr %.repack56, align 8
ADD:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
ADD:   store ptr %35, ptr %.repack54, align 8
ADD:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
ADD:   store ptr %35, ptr %37, align 8
ADD:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %36, label %.lr.ph102.preheader, label %._crit_edge103
ADD:   %36 = icmp sgt i64 %13, 0
ADD:   %35 = call ptr @malloc(i64 %.idx53)
ADD:   %.idx53 = shl i64 %13, 3
ADD:   store i64 1, ptr %.repack51, align 8
ADD:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4
ADD:   store i64 %11, ptr %.repack49, align 8
ADD:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3
ADD:   store i64 0, ptr %.repack47, align 8
ADD:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2
ADD:   store ptr %32, ptr %.repack45, align 8
ADD:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
ADD:   store ptr %32, ptr %34, align 8
ADD:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %33, label %.lr.ph99.preheader, label %._crit_edge100
ADD:   %33 = icmp sgt i64 %11, 0
ADD:   %32 = call ptr @malloc(i64 %.idx44)
ADD:   %.idx44 = shl i64 %11, 3
ADD:   store i64 1, ptr %.repack42, align 8
ADD:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4
ADD:   store i64 %9, ptr %.repack40, align 8
ADD:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3
ADD:   store i64 0, ptr %.repack38, align 8
ADD:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2
ADD:   store ptr %29, ptr %.repack36, align 8
ADD:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
ADD:   store ptr %29, ptr %31, align 8
ADD:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %30, label %.lr.ph96.preheader, label %._crit_edge97
ADD:   %30 = icmp sgt i64 %9, 0
ADD:   %29 = call ptr @malloc(i64 %.idx35)
ADD:   %.idx35 = shl i64 %9, 3
ADD:   store i64 1, ptr %.repack33, align 8
ADD:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
ADD:   store i64 %7, ptr %.repack31, align 8
ADD:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
ADD:   store i64 0, ptr %.repack29, align 8
ADD:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
ADD:   store ptr %26, ptr %.repack27, align 8
ADD:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
ADD:   store ptr %26, ptr %28, align 8
ADD:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %27, label %.lr.ph93.preheader, label %._crit_edge94
ADD:   %27 = icmp sgt i64 %7, 0
ADD:   %26 = call ptr @malloc(i64 %.idx26)
ADD:   %.idx26 = shl i64 %7, 3
ADD:   store i64 1, ptr %.repack24, align 8
ADD:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4
ADD:   store i64 %5, ptr %.repack22, align 8
ADD:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3
ADD:   store i64 0, ptr %.repack20, align 8
ADD:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2
ADD:   store ptr %23, ptr %.repack18, align 8
ADD:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
ADD:   store ptr %23, ptr %25, align 8
ADD:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %24, label %.lr.ph90.preheader, label %._crit_edge91
ADD:   %24 = icmp sgt i64 %5, 0
ADD:   %23 = call ptr @malloc(i64 %.idx17)
ADD:   %.idx17 = shl i64 %5, 3
ADD:   store i64 1, ptr %.repack15, align 8
ADD:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4
ADD:   store i64 %3, ptr %.repack13, align 8
ADD:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3
ADD:   store i64 0, ptr %.repack11, align 8
ADD:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2
ADD:   store ptr %20, ptr %.repack9, align 8
ADD:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
ADD:   store ptr %20, ptr %22, align 8
ADD:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   br i1 %21, label %.lr.ph.preheader, label %._crit_edge
ADD:   %21 = icmp sgt i64 %3, 0
ADD:   %20 = call ptr @malloc(i64 %.idx)
ADD:   %.idx = shl i64 %3, 3
ADD:   %19 = load i64, ptr %18, align 4
ADD:   %18 = getelementptr i64, ptr %1, i64 8
ADD:   %17 = load i64, ptr %16, align 4
ADD:   %16 = getelementptr i64, ptr %1, i64 7
ADD:   %15 = load i64, ptr %14, align 4
ADD:   %14 = getelementptr i64, ptr %1, i64 6
ADD:   %13 = load i64, ptr %12, align 4
ADD:   %12 = getelementptr i64, ptr %1, i64 5
ADD:   %11 = load i64, ptr %10, align 4
ADD:   %10 = getelementptr i64, ptr %1, i64 4
ADD:   %9 = load i64, ptr %8, align 4
ADD:   %8 = getelementptr i64, ptr %1, i64 3
ADD:   %7 = load i64, ptr %6, align 4
ADD:   %6 = getelementptr i64, ptr %1, i64 2
ADD:   %5 = load i64, ptr %4, align 4
ADD:   %4 = getelementptr i64, ptr %1, i64 1
ADD:   %3 = load i64, ptr %1, align 4
ADD:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
ADD:   store i64 1, ptr %.fca.4.0.gep, align 8
ADD:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
ADD:   store i64 7, ptr %.fca.3.0.gep, align 8
ADD:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
ADD:   store i64 0, ptr %.fca.2.gep, align 8
ADD:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
ADD:   store ptr %1, ptr %.fca.1.gep, align 8
ADD:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
ADD:   store ptr %1, ptr %2, align 8
ADD:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
ADD:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %1 = tail call dereferenceable_or_null(56) ptr @malloc(i64 56)
IC: Visiting:   %2 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %1, ptr %2, align 8
IC: Visiting:   %.fca.1.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 1
IC: Visiting:   store ptr %1, ptr %.fca.1.gep, align 8
IC: Visiting:   %.fca.2.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.fca.2.gep, align 8
IC: Visiting:   %.fca.3.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 3, i64 0
IC: Visiting:   store i64 7, ptr %.fca.3.0.gep, align 8
IC: Visiting:   %.fca.4.0.gep = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %2, i64 0, i32 4, i64 0
IC: Visiting:   store i64 1, ptr %.fca.4.0.gep, align 8
IC: Visiting:   call void @read_input_sizes_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %2, i32 1)
IC: Visiting:   %3 = load i64, ptr %1, align 4
IC: Visiting:   %4 = getelementptr i64, ptr %1, i64 1
IC: Visiting:   %5 = load i64, ptr %4, align 4
IC: Visiting:   %6 = getelementptr i64, ptr %1, i64 2
IC: Visiting:   %7 = load i64, ptr %6, align 4
IC: Visiting:   %8 = getelementptr i64, ptr %1, i64 3
IC: Visiting:   %9 = load i64, ptr %8, align 4
IC: Visiting:   %10 = getelementptr i64, ptr %1, i64 4
IC: Visiting:   %11 = load i64, ptr %10, align 4
IC: Visiting:   %12 = getelementptr i64, ptr %1, i64 5
IC: Visiting:   %13 = load i64, ptr %12, align 4
IC: Visiting:   %14 = getelementptr i64, ptr %1, i64 6
IC: Visiting:   %15 = load i64, ptr %14, align 4
IC: Visiting:   %16 = getelementptr i64, ptr %1, i64 7
IC: Visiting:   %17 = load i64, ptr %16, align 4
IC: Visiting:   %18 = getelementptr i64, ptr %1, i64 8
IC: Visiting:   %19 = load i64, ptr %18, align 4
IC: Visiting:   %.idx = shl i64 %3, 3
IC: Visiting:   %20 = call ptr @malloc(i64 %.idx)
IC: Visiting:   %21 = icmp sgt i64 %3, 0
IC: Visiting:   br i1 %21, label %.lr.ph.preheader, label %._crit_edge
IC: Visiting:   %22 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %20, ptr %22, align 8
IC: Visiting:   %.repack9 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 1
IC: Visiting:   store ptr %20, ptr %.repack9, align 8
IC: Visiting:   %.repack11 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack11, align 8
IC: Visiting:   %.repack13 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 3
IC: Visiting:   store i64 %3, ptr %.repack13, align 8
IC: Visiting:   %.repack15 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %22, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack15, align 8
IC: Visiting:   %.idx17 = shl i64 %5, 3
IC: Visiting:   %23 = call ptr @malloc(i64 %.idx17)
IC: Visiting:   %24 = icmp sgt i64 %5, 0
IC: Visiting:   br i1 %24, label %.lr.ph90.preheader, label %._crit_edge91
IC: Visiting:   %25 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %23, ptr %25, align 8
IC: Visiting:   %.repack18 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 1
IC: Visiting:   store ptr %23, ptr %.repack18, align 8
IC: Visiting:   %.repack20 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack20, align 8
IC: Visiting:   %.repack22 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 3
IC: Visiting:   store i64 %5, ptr %.repack22, align 8
IC: Visiting:   %.repack24 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %25, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack24, align 8
IC: Visiting:   %.idx26 = shl i64 %7, 3
IC: Visiting:   %26 = call ptr @malloc(i64 %.idx26)
IC: Visiting:   %27 = icmp sgt i64 %7, 0
IC: Visiting:   br i1 %27, label %.lr.ph93.preheader, label %._crit_edge94
IC: Visiting:   %28 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %26, ptr %28, align 8
IC: Visiting:   %.repack27 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 1
IC: Visiting:   store ptr %26, ptr %.repack27, align 8
IC: Visiting:   %.repack29 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack29, align 8
IC: Visiting:   %.repack31 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 3
IC: Visiting:   store i64 %7, ptr %.repack31, align 8
IC: Visiting:   %.repack33 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %28, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack33, align 8
IC: Visiting:   %.idx35 = shl i64 %9, 3
IC: Visiting:   %29 = call ptr @malloc(i64 %.idx35)
IC: Visiting:   %30 = icmp sgt i64 %9, 0
IC: Visiting:   br i1 %30, label %.lr.ph96.preheader, label %._crit_edge97
IC: Visiting:   %31 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %29, ptr %31, align 8
IC: Visiting:   %.repack36 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 1
IC: Visiting:   store ptr %29, ptr %.repack36, align 8
IC: Visiting:   %.repack38 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack38, align 8
IC: Visiting:   %.repack40 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 3
IC: Visiting:   store i64 %9, ptr %.repack40, align 8
IC: Visiting:   %.repack42 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %31, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack42, align 8
IC: Visiting:   %.idx44 = shl i64 %11, 3
IC: Visiting:   %32 = call ptr @malloc(i64 %.idx44)
IC: Visiting:   %33 = icmp sgt i64 %11, 0
IC: Visiting:   br i1 %33, label %.lr.ph99.preheader, label %._crit_edge100
IC: Visiting:   %34 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %32, ptr %34, align 8
IC: Visiting:   %.repack45 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 1
IC: Visiting:   store ptr %32, ptr %.repack45, align 8
IC: Visiting:   %.repack47 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack47, align 8
IC: Visiting:   %.repack49 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 3
IC: Visiting:   store i64 %11, ptr %.repack49, align 8
IC: Visiting:   %.repack51 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %34, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack51, align 8
IC: Visiting:   %.idx53 = shl i64 %13, 3
IC: Visiting:   %35 = call ptr @malloc(i64 %.idx53)
IC: Visiting:   %36 = icmp sgt i64 %13, 0
IC: Visiting:   br i1 %36, label %.lr.ph102.preheader, label %._crit_edge103
IC: Visiting:   %37 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %35, ptr %37, align 8
IC: Visiting:   %.repack54 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 1
IC: Visiting:   store ptr %35, ptr %.repack54, align 8
IC: Visiting:   %.repack56 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack56, align 8
IC: Visiting:   %.repack58 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 3
IC: Visiting:   store i64 %13, ptr %.repack58, align 8
IC: Visiting:   %.repack60 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %37, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack60, align 8
IC: Visiting:   %.idx62 = shl i64 %15, 3
IC: Visiting:   %38 = call ptr @malloc(i64 %.idx62)
IC: Visiting:   %39 = icmp sgt i64 %15, 0
IC: Visiting:   br i1 %39, label %.lr.ph105.preheader, label %._crit_edge106
IC: Visiting:   %40 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %38, ptr %40, align 8
IC: Visiting:   %.repack63 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 1
IC: Visiting:   store ptr %38, ptr %.repack63, align 8
IC: Visiting:   %.repack65 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack65, align 8
IC: Visiting:   %.repack67 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 3
IC: Visiting:   store i64 %15, ptr %.repack67, align 8
IC: Visiting:   %.repack69 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %40, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack69, align 8
IC: Visiting:   %.idx71 = shl i64 %17, 3
IC: Visiting:   %41 = call ptr @malloc(i64 %.idx71)
IC: Visiting:   %42 = icmp sgt i64 %17, 0
IC: Visiting:   br i1 %42, label %.lr.ph108.preheader, label %._crit_edge109
IC: Visiting:   %43 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %41, ptr %43, align 8
IC: Visiting:   %.repack72 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 1
IC: Visiting:   store ptr %41, ptr %.repack72, align 8
IC: Visiting:   %.repack74 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack74, align 8
IC: Visiting:   %.repack76 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 3
IC: Visiting:   store i64 %17, ptr %.repack76, align 8
IC: Visiting:   %.repack78 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %43, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack78, align 8
IC: Visiting:   %.idx80 = shl i64 %19, 3
IC: Visiting:   %44 = call ptr @malloc(i64 %.idx80)
IC: Visiting:   %45 = icmp sgt i64 %19, 0
IC: Visiting:   br i1 %45, label %.lr.ph111.preheader, label %._crit_edge112
IC: Visiting:   %46 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, align 8
IC: Visiting:   store ptr %44, ptr %46, align 8
IC: Visiting:   %.repack81 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 1
IC: Visiting:   store ptr %44, ptr %.repack81, align 8
IC: Visiting:   %.repack83 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 2
IC: Visiting:   store i64 0, ptr %.repack83, align 8
IC: Visiting:   %.repack85 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 3
IC: Visiting:   store i64 %19, ptr %.repack85, align 8
IC: Visiting:   %.repack87 = getelementptr inbounds { ptr, ptr, i64, [1 x i64], [1 x i64] }, ptr %46, i64 0, i32 4
IC: Visiting:   store i64 1, ptr %.repack87, align 8
IC: Visiting:   call void @read_input_2D_f64(i32 1, i64 0, i64 3, i64 0, i64 -1, i64 1, ptr nonnull %22, i64 1, ptr nonnull %25, i64 1, ptr nonnull %28, i64 1, ptr nonnull %31, i64 1, ptr nonnull %34, i64 1, ptr nonnull %37, i64 1, ptr nonnull %40, i64 1, ptr nonnull %43, i64 1, ptr nonnull %46, i32 1)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %22)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %25)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %28)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %31)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %34)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %37)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %40)
IC: Visiting:   call void @comet_print_memref_i64(i64 1, ptr nonnull %43)
IC: Visiting:   call void @comet_print_memref_f64(i64 1, ptr nonnull %46)
IC: Visiting:   ret void
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 8 %44, i8 0, i64 %.idx80, i1 false)
IC: Visiting:   br label %._crit_edge112
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %41, i8 0, i64 %.idx71, i1 false)
IC: Visiting:   br label %._crit_edge109
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %38, i8 0, i64 %.idx62, i1 false)
IC: Visiting:   br label %._crit_edge106
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %35, i8 0, i64 %.idx53, i1 false)
IC: Visiting:   br label %._crit_edge103
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %32, i8 0, i64 %.idx44, i1 false)
IC: Visiting:   br label %._crit_edge100
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %29, i8 0, i64 %.idx35, i1 false)
IC: Visiting:   br label %._crit_edge97
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %26, i8 0, i64 %.idx26, i1 false)
IC: Visiting:   br label %._crit_edge94
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %23, i8 0, i64 %.idx17, i1 false)
IC: Visiting:   br label %._crit_edge91
IC: Visiting:   call void @llvm.memset.p0.i64(ptr align 4 %20, i8 0, i64 %.idx, i1 false)
IC: Visiting:   br label %._crit_edge
F2I: Looking at function _mlir_main


INSTCOMBINE ITERATION #1 on _mlir_main
ADD:   ret void
ADD:   tail call void @main()
IC: Visiting:   tail call void @main()
IC: Visiting:   ret void
SLP: Analyzing blocks in _mlir_main.


INSTCOMBINE ITERATION #1 on _mlir_main
ADD:   ret void
ADD:   tail call void @main()
IC: Visiting:   tail call void @main()
IC: Visiting:   ret void
SROA function: _mlir_main


INSTCOMBINE ITERATION #1 on _mlir_main
ADD:   ret void
ADD:   tail call void @main()
IC: Visiting:   tail call void @main()
IC: Visiting:   ret void
		Looking for trivial roots
Found a new trivial root: %._crit_edge112
Last visited node: %.lr.ph111.preheader
		Looking for non-trivial roots
Total: 19, Num: 20
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %._crit_edge112
3: %._crit_edge109
4: %._crit_edge106
5: %._crit_edge103
6: %._crit_edge100
7: %._crit_edge97
8: %._crit_edge94
9: %._crit_edge91
10: %._crit_edge
11: %0
12: %.lr.ph.preheader
13: %.lr.ph90.preheader
14: %.lr.ph93.preheader
15: %.lr.ph96.preheader
16: %.lr.ph99.preheader
17: %.lr.ph102.preheader
18: %.lr.ph105.preheader
19: %.lr.ph108.preheader
20: %.lr.ph111.preheader
Found roots: %._crit_edge112 
---- Branch Probability Info : main ----

Computing probabilities for ._crit_edge112
Computing probabilities for .lr.ph111.preheader
Computing probabilities for ._crit_edge109
eraseBlock ._crit_edge109
set edge ._crit_edge109 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge109 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph108.preheader
Computing probabilities for ._crit_edge106
eraseBlock ._crit_edge106
set edge ._crit_edge106 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge106 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph105.preheader
Computing probabilities for ._crit_edge103
eraseBlock ._crit_edge103
set edge ._crit_edge103 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge103 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph102.preheader
Computing probabilities for ._crit_edge100
eraseBlock ._crit_edge100
set edge ._crit_edge100 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge100 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph99.preheader
Computing probabilities for ._crit_edge97
eraseBlock ._crit_edge97
set edge ._crit_edge97 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge97 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph96.preheader
Computing probabilities for ._crit_edge94
eraseBlock ._crit_edge94
set edge ._crit_edge94 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge94 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph93.preheader
Computing probabilities for ._crit_edge91
eraseBlock ._crit_edge91
set edge ._crit_edge91 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge91 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph90.preheader
Computing probabilities for ._crit_edge
eraseBlock ._crit_edge
set edge ._crit_edge -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph.preheader
Computing probabilities for 
eraseBlock 
set edge  -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge  -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: 
 - 1: .lr.ph.preheader
 - 2: ._crit_edge
 - 3: .lr.ph90.preheader
 - 4: ._crit_edge91
 - 5: .lr.ph93.preheader
 - 6: ._crit_edge94
 - 7: .lr.ph96.preheader
 - 8: ._crit_edge97
 - 9: .lr.ph99.preheader
 - 10: ._crit_edge100
 - 11: .lr.ph102.preheader
 - 12: ._crit_edge103
 - 13: .lr.ph105.preheader
 - 14: ._crit_edge106
 - 15: .lr.ph108.preheader
 - 16: ._crit_edge109
 - 17: .lr.ph111.preheader
 - 18: ._crit_edge112
loop-detection
compute-mass-in-function
 - node: 
  => [ local  ] weight = 1342177280, succ = .lr.ph.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge
 - node: .lr.ph.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge
 - node: ._crit_edge
  => [ local  ] weight = 1342177280, succ = .lr.ph90.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge91
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph90.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge91
 - node: .lr.ph90.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge91
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge91
 - node: ._crit_edge91
  => [ local  ] weight = 1342177280, succ = .lr.ph93.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge94
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph93.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge94
 - node: .lr.ph93.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge94
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge94
 - node: ._crit_edge94
  => [ local  ] weight = 1342177280, succ = .lr.ph96.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge97
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph96.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge97
 - node: .lr.ph96.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge97
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge97
 - node: ._crit_edge97
  => [ local  ] weight = 1342177280, succ = .lr.ph99.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge100
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph99.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge100
 - node: .lr.ph99.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge100
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge100
 - node: ._crit_edge100
  => [ local  ] weight = 1342177280, succ = .lr.ph102.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge103
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph102.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge103
 - node: .lr.ph102.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge103
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge103
 - node: ._crit_edge103
  => [ local  ] weight = 1342177280, succ = .lr.ph105.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge106
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph105.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge106
 - node: .lr.ph105.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge106
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge106
 - node: ._crit_edge106
  => [ local  ] weight = 1342177280, succ = .lr.ph108.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge109
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph108.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge109
 - node: .lr.ph108.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge109
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge109
 - node: ._crit_edge109
  => [ local  ] weight = 1342177280, succ = .lr.ph111.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge112
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph111.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge112
 - node: .lr.ph111.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge112
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge112
 - node: ._crit_edge112
  => mass:  ffffffffffffffff
float-to-int: min = 0.625, max = 1.0, factor = 12.8
 - : float = 1.0, scaled = 12.8, int = 12
 - .lr.ph.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph90.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge91: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph93.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge94: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph96.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge97: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph99.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge100: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph102.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge103: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph105.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge106: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph108.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge109: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph111.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge112: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: main
 - : float = 1.0, int = 12
 - .lr.ph.preheader: float = 0.625, int = 8
 - ._crit_edge: float = 1.0, int = 12
 - .lr.ph90.preheader: float = 0.625, int = 8
 - ._crit_edge91: float = 1.0, int = 12
 - .lr.ph93.preheader: float = 0.625, int = 8
 - ._crit_edge94: float = 1.0, int = 12
 - .lr.ph96.preheader: float = 0.625, int = 8
 - ._crit_edge97: float = 1.0, int = 12
 - .lr.ph99.preheader: float = 0.625, int = 8
 - ._crit_edge100: float = 1.0, int = 12
 - .lr.ph102.preheader: float = 0.625, int = 8
 - ._crit_edge103: float = 1.0, int = 12
 - .lr.ph105.preheader: float = 0.625, int = 8
 - ._crit_edge106: float = 1.0, int = 12
 - .lr.ph108.preheader: float = 0.625, int = 8
 - ._crit_edge109: float = 1.0, int = 12
 - .lr.ph111.preheader: float = 0.625, int = 8
 - ._crit_edge112: float = 1.0, int = 12

		Looking for trivial roots
Found a new trivial root: %1
Last visited node: %1
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %1
Found roots: %1 
---- Branch Probability Info : _mlir_main ----

Computing probabilities for 

block-frequency: _mlir_main
===========================
reverse-post-order-traversal
 - 0: 
loop-detection
compute-mass-in-function
 - node: 
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - : float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _mlir_main
 - : float = 1.0, int = 8

Defining MU LLVMDialectModule for main (tracker: default)  { ("_main", [Callable]), ("__mlir_main", [Callable]) }
Warning: Discarding empty MU <Absolute Symbols> for main
Looking up { (__mlir_main, RequiredSymbol) } in [ ("main", MatchAllSymbols) ] (required state: Ready)
Dispatching MaterializationUnits...
Done dispatching MaterializationUnits.
Entering OL_applyQueryPhase1:
  Lookup kind: Static
  Search order: [ ("main", MatchAllSymbols) ], Current index = 0 (entering new JITDylib)
  Lookup set: { (__mlir_main, RequiredSymbol) }
  Definition generator candidates: { (__mlir_main, RequiredSymbol) }
  Definition generator non-candidates: { }
Visiting "main" (MatchAllSymbols) with lookup set { (__mlir_main, RequiredSymbol) }:
  First time visiting main, resetting candidate sets and building generator stack
  Updating candidate set...
    Remaining candidates = { }
  No candidates to generate.
All symbols matched.
Phase 1 succeeded.
Entering OL_completeLookup:
  Lookup kind: Static
  Search order: [ ("main", MatchAllSymbols) ], Current index = 1
  Lookup set: { (__mlir_main, RequiredSymbol) }
  Definition generator candidates: { }
  Definition generator non-candidates: { }
Visiting "main" (MatchAllSymbols) with lookup set { (__mlir_main, RequiredSymbol) }:
  Attempting to match "__mlir_main" (RequiredSymbol)... matched, preparing to dispatch MU@0x600001028070 (LLVMDialectModule)
Stripping unmatched weakly-referenced symbols
Query successfully lodged
Adding MUs to dispatch:
  For main: Adding 1 MUs.
No dependencies to register
Dispatching MaterializationUnits...
  Dispatching "LLVMDialectModule"
Dispatching: Materialization task: LLVMDialectModule in main
Emitting, for main, MU@0x600001028070 ("LLVMDialectModule", { })
No object for LLVMDialectModule in cache. Compiling.

Features:+64bit-mode,-32bit-mode,-16bit-mode,+sse2,+xsaves,+sse2,-hreset,-avx512cd,-sha,+xsaveopt,-kl,-avxvnni,-mwaitx,-clzero,+sse4.2,+bmi,-cldemote,-widekl,-avx512f,-raoint,+xsavec,+lzcnt,-serialize,-avxvnniint8,+fsgsbase,+aes,+sse,-sse4a,-rdpru,-tbm,-avx512bf16,-rtm,+fma,-waitpkg,-amx-fp16,-avx512ifma,-avx512vp2intersect,+popcnt,-vaes,-prefetchi,+f16c,+avx2,+sahf,+xsave,-uintr,+fxsr,+sgx,-pconfig,-avx512er,-avx512fp16,-gfni,+rdseed,+bmi2,-movdir64b,-avx512vl,-pku,-xop,-avx512bw,-avx512vbmi,+prfchw,-rdpid,+sse3,+cx16,-vpclmulqdq,-avx512vbmi2,-enqcmd,-amx-bf16,+64bit,-amx-int8,-avx512pf,-ptwrite,-amx-tile,-lwp,-avx512vpopcntdq,-avx512dq,-avxneconvert,+mmx,-fma4,-avx512vnni,-avxifma,+avx,+cmov,+sse4.1,+movbe,+invpcid,+adx,-clwb,-prefetchwt1,-cmpccxadd,+ssse3,+cx8,+clflushopt,-tsxldtrk,+pclmul,+crc32,+rdrnd,-avx512bitalg,-shstk,-movdiri,-wbnoinvd
CPU:skylake
TuneCPU:skylake

Subtarget features: SSELevel 8, 3DNowLevel 1, 64bit 1
G_ADD (opcode 46): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SUB (opcode 47): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MUL (opcode 48): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIV (opcode 49): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_UDIV (opcode 50): 1 type index, 0 imm indices
.. opcode 50 is aliased to 49
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_SREM (opcode 51): 1 type index, 0 imm indices
.. opcode 51 is aliased to 49
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_UREM (opcode 52): 1 type index, 0 imm indices
.. opcode 52 is aliased to 49
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_SDIVREM (opcode 53): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVREM (opcode 54): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_AND (opcode 55): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_OR (opcode 56): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_XOR (opcode 57): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_IMPLICIT_DEF (opcode 58): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PHI (opcode 59): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FRAME_INDEX (opcode 60): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_GLOBAL_VALUE (opcode 61): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CONSTANT_POOL (opcode 62): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_EXTRACT (opcode 63): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UNMERGE_VALUES (opcode 64): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INSERT (opcode 65): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MERGE_VALUES (opcode 66): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BUILD_VECTOR (opcode 67): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BUILD_VECTOR_TRUNC (opcode 68): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CONCAT_VECTORS (opcode 69): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTRTOINT (opcode 70): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_INTTOPTR (opcode 71): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_BITCAST (opcode 72): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FREEZE (opcode 73): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_FPTRUNC_ROUND (opcode 74): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_TRUNC (opcode 75): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_ROUND (opcode 76): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_LRINT (opcode 77): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_ROUNDEVEN (opcode 78): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_READCYCLECOUNTER (opcode 79): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_LOAD (opcode 80): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SEXTLOAD (opcode 81): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ZEXTLOAD (opcode 82): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_LOAD (opcode 83): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_SEXTLOAD (opcode 84): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_ZEXTLOAD (opcode 85): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STORE (opcode 86): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_STORE (opcode 87): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG_WITH_SUCCESS (opcode 88): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG (opcode 89): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XCHG (opcode 90): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_ADD (opcode 91): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_SUB (opcode 92): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_AND (opcode 93): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_NAND (opcode 94): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_OR (opcode 95): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XOR (opcode 96): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MAX (opcode 97): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MIN (opcode 98): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMAX (opcode 99): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMIN (opcode 100): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FADD (opcode 101): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FSUB (opcode 102): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FMAX (opcode 103): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FMIN (opcode 104): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UINC_WRAP (opcode 105): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UDEC_WRAP (opcode 106): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FENCE (opcode 107): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRCOND (opcode 108): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRINDIRECT (opcode 109): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INVOKE_REGION_START (opcode 110): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC (opcode 111): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_W_SIDE_EFFECTS (opcode 112): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ANYEXT (opcode 113): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_TRUNC (opcode 114): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CONSTANT (opcode 115): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCONSTANT (opcode 116): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VASTART (opcode 117): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VAARG (opcode 118): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SEXT (opcode 119): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SEXT_INREG (opcode 120): 1 type index, 1 imm index
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_ZEXT (opcode 121): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SHL (opcode 122): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_LSHR (opcode 123): 2 type indices, 0 imm indices
.. opcode 123 is aliased to 122
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_ASHR (opcode 124): 2 type indices, 0 imm indices
.. opcode 124 is aliased to 122
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FSHL (opcode 125): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSHR (opcode 126): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ROTR (opcode 127): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ROTL (opcode 128): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ICMP (opcode 129): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FCMP (opcode 130): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_SELECT (opcode 131): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDO (opcode 132): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDE (opcode 133): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBO (opcode 134): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBE (opcode 135): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDO (opcode 136): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDE (opcode 137): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBO (opcode 138): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBE (opcode 139): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULO (opcode 140): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULO (opcode 141): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULH (opcode 142): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULH (opcode 143): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDSAT (opcode 144): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDSAT (opcode 145): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBSAT (opcode 146): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBSAT (opcode 147): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USHLSAT (opcode 148): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSHLSAT (opcode 149): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULFIX (opcode 150): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULFIX (opcode 151): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULFIXSAT (opcode 152): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULFIXSAT (opcode 153): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIVFIX (opcode 154): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVFIX (opcode 155): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIVFIXSAT (opcode 156): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVFIXSAT (opcode 157): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FADD (opcode 158): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSUB (opcode 159): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMUL (opcode 160): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMA (opcode 161): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAD (opcode 162): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FDIV (opcode 163): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FREM (opcode 164): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPOW (opcode 165): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPOWI (opcode 166): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FEXP (opcode 167): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FEXP2 (opcode 168): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG (opcode 169): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG2 (opcode 170): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG10 (opcode 171): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FNEG (opcode 172): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPEXT (opcode 173): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPTRUNC (opcode 174): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPTOSI (opcode 175): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FPTOUI (opcode 176): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SITOFP (opcode 177): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_UITOFP (opcode 178): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FABS (opcode 179): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCOPYSIGN (opcode 180): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_IS_FPCLASS (opcode 181): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCANONICALIZE (opcode 182): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINNUM (opcode 183): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXNUM (opcode 184): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINNUM_IEEE (opcode 185): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXNUM_IEEE (opcode 186): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINIMUM (opcode 187): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXIMUM (opcode 188): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTR_ADD (opcode 189): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTRMASK (opcode 190): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMIN (opcode 191): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMAX (opcode 192): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMIN (opcode 193): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMAX (opcode 194): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ABS (opcode 195): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_LROUND (opcode 196): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_LLROUND (opcode 197): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BR (opcode 198): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRJT (opcode 199): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INSERT_VECTOR_ELT (opcode 200): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_EXTRACT_VECTOR_ELT (opcode 201): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SHUFFLE_VECTOR (opcode 202): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTTZ (opcode 203): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTTZ_ZERO_UNDEF (opcode 204): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTLZ (opcode 205): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTLZ_ZERO_UNDEF (opcode 206): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTPOP (opcode 207): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BSWAP (opcode 208): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BITREVERSE (opcode 209): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCEIL (opcode 210): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCOS (opcode 211): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSIN (opcode 212): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSQRT (opcode 213): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FFLOOR (opcode 214): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FRINT (opcode 215): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FNEARBYINT (opcode 216): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ADDRSPACE_CAST (opcode 217): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BLOCK_ADDR (opcode 218): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_JUMP_TABLE (opcode 219): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_DYN_STACKALLOC (opcode 220): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FADD (opcode 221): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FSUB (opcode 222): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FMUL (opcode 223): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FDIV (opcode 224): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FREM (opcode 225): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FMA (opcode 226): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FSQRT (opcode 227): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_READ_REGISTER (opcode 228): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_WRITE_REGISTER (opcode 229): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MEMCPY (opcode 230): 3 type indices, 1 imm index
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_MEMCPY_INLINE (opcode 231): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MEMMOVE (opcode 232): 3 type indices, 1 imm index
.. opcode 232 is aliased to 230
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_MEMSET (opcode 233): 3 type indices, 1 imm index
.. opcode 233 is aliased to 230
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_BZERO (opcode 234): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SEQ_FADD (opcode 235): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SEQ_FMUL (opcode 236): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FADD (opcode 237): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMUL (opcode 238): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMAX (opcode 239): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMIN (opcode 240): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_ADD (opcode 241): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_MUL (opcode 242): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_AND (opcode 243): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_OR (opcode 244): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_XOR (opcode 245): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SMAX (opcode 246): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SMIN (opcode 247): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_UMAX (opcode 248): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_UMIN (opcode 249): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SBFX (opcode 250): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UBFX (opcode 251): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
MergeICmpsLegacyPass: main
		Looking for trivial roots
Found a new trivial root: %._crit_edge112
Last visited node: %.lr.ph111.preheader
		Looking for non-trivial roots
Total: 19, Num: 20
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %._crit_edge112
3: %._crit_edge109
4: %._crit_edge106
5: %._crit_edge103
6: %._crit_edge100
7: %._crit_edge97
8: %._crit_edge94
9: %._crit_edge91
10: %._crit_edge
11: %0
12: %.lr.ph.preheader
13: %.lr.ph90.preheader
14: %.lr.ph93.preheader
15: %.lr.ph96.preheader
16: %.lr.ph99.preheader
17: %.lr.ph102.preheader
18: %.lr.ph105.preheader
19: %.lr.ph108.preheader
20: %.lr.ph111.preheader
Found roots: %._crit_edge112 
---- Branch Probability Info : main ----

Computing probabilities for ._crit_edge112
Computing probabilities for .lr.ph111.preheader
Computing probabilities for ._crit_edge109
eraseBlock ._crit_edge109
set edge ._crit_edge109 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge109 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph108.preheader
Computing probabilities for ._crit_edge106
eraseBlock ._crit_edge106
set edge ._crit_edge106 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge106 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph105.preheader
Computing probabilities for ._crit_edge103
eraseBlock ._crit_edge103
set edge ._crit_edge103 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge103 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph102.preheader
Computing probabilities for ._crit_edge100
eraseBlock ._crit_edge100
set edge ._crit_edge100 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge100 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph99.preheader
Computing probabilities for ._crit_edge97
eraseBlock ._crit_edge97
set edge ._crit_edge97 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge97 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph96.preheader
Computing probabilities for ._crit_edge94
eraseBlock ._crit_edge94
set edge ._crit_edge94 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge94 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph93.preheader
Computing probabilities for ._crit_edge91
eraseBlock ._crit_edge91
set edge ._crit_edge91 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge91 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph90.preheader
Computing probabilities for ._crit_edge
eraseBlock ._crit_edge
set edge ._crit_edge -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph.preheader
Computing probabilities for 
eraseBlock 
set edge  -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge  -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: 
 - 1: .lr.ph.preheader
 - 2: ._crit_edge
 - 3: .lr.ph90.preheader
 - 4: ._crit_edge91
 - 5: .lr.ph93.preheader
 - 6: ._crit_edge94
 - 7: .lr.ph96.preheader
 - 8: ._crit_edge97
 - 9: .lr.ph99.preheader
 - 10: ._crit_edge100
 - 11: .lr.ph102.preheader
 - 12: ._crit_edge103
 - 13: .lr.ph105.preheader
 - 14: ._crit_edge106
 - 15: .lr.ph108.preheader
 - 16: ._crit_edge109
 - 17: .lr.ph111.preheader
 - 18: ._crit_edge112
loop-detection
compute-mass-in-function
 - node: 
  => [ local  ] weight = 1342177280, succ = .lr.ph.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge
 - node: .lr.ph.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge
 - node: ._crit_edge
  => [ local  ] weight = 1342177280, succ = .lr.ph90.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge91
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph90.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge91
 - node: .lr.ph90.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge91
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge91
 - node: ._crit_edge91
  => [ local  ] weight = 1342177280, succ = .lr.ph93.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge94
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph93.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge94
 - node: .lr.ph93.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge94
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge94
 - node: ._crit_edge94
  => [ local  ] weight = 1342177280, succ = .lr.ph96.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge97
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph96.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge97
 - node: .lr.ph96.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge97
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge97
 - node: ._crit_edge97
  => [ local  ] weight = 1342177280, succ = .lr.ph99.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge100
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph99.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge100
 - node: .lr.ph99.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge100
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge100
 - node: ._crit_edge100
  => [ local  ] weight = 1342177280, succ = .lr.ph102.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge103
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph102.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge103
 - node: .lr.ph102.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge103
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge103
 - node: ._crit_edge103
  => [ local  ] weight = 1342177280, succ = .lr.ph105.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge106
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph105.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge106
 - node: .lr.ph105.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge106
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge106
 - node: ._crit_edge106
  => [ local  ] weight = 1342177280, succ = .lr.ph108.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge109
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph108.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge109
 - node: .lr.ph108.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge109
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge109
 - node: ._crit_edge109
  => [ local  ] weight = 1342177280, succ = .lr.ph111.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge112
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph111.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge112
 - node: .lr.ph111.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge112
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge112
 - node: ._crit_edge112
  => mass:  ffffffffffffffff
float-to-int: min = 0.625, max = 1.0, factor = 12.8
 - : float = 1.0, scaled = 12.8, int = 12
 - .lr.ph.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph90.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge91: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph93.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge94: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph96.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge97: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph99.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge100: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph102.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge103: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph105.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge106: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph108.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge109: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph111.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge112: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: main
 - : float = 1.0, int = 12
 - .lr.ph.preheader: float = 0.625, int = 8
 - ._crit_edge: float = 1.0, int = 12
 - .lr.ph90.preheader: float = 0.625, int = 8
 - ._crit_edge91: float = 1.0, int = 12
 - .lr.ph93.preheader: float = 0.625, int = 8
 - ._crit_edge94: float = 1.0, int = 12
 - .lr.ph96.preheader: float = 0.625, int = 8
 - ._crit_edge97: float = 1.0, int = 12
 - .lr.ph99.preheader: float = 0.625, int = 8
 - ._crit_edge100: float = 1.0, int = 12
 - .lr.ph102.preheader: float = 0.625, int = 8
 - ._crit_edge103: float = 1.0, int = 12
 - .lr.ph105.preheader: float = 0.625, int = 8
 - ._crit_edge106: float = 1.0, int = 12
 - .lr.ph108.preheader: float = 0.625, int = 8
 - ._crit_edge109: float = 1.0, int = 12
 - .lr.ph111.preheader: float = 0.625, int = 8
 - ._crit_edge112: float = 1.0, int = 12

********** Begin Constant Hoisting **********
********** Function: main
********** End Constant Hoisting **********
********** Begin TLS Variable Hoist **********
********** Function: main
********** End TLS Variable Hoist **********
*** Interleaved Access Pass: main
---- Branch Probability Info : main ----

		Looking for trivial roots
Found a new trivial root: %._crit_edge112
Last visited node: %.lr.ph111.preheader
		Looking for non-trivial roots
Total: 19, Num: 20
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %._crit_edge112
3: %._crit_edge109
4: %._crit_edge106
5: %._crit_edge103
6: %._crit_edge100
7: %._crit_edge97
8: %._crit_edge94
9: %._crit_edge91
10: %._crit_edge
11: %0
12: %.lr.ph.preheader
13: %.lr.ph90.preheader
14: %.lr.ph93.preheader
15: %.lr.ph96.preheader
16: %.lr.ph99.preheader
17: %.lr.ph102.preheader
18: %.lr.ph105.preheader
19: %.lr.ph108.preheader
20: %.lr.ph111.preheader
Found roots: %._crit_edge112 
Computing probabilities for ._crit_edge112
Computing probabilities for .lr.ph111.preheader
Computing probabilities for ._crit_edge109
eraseBlock ._crit_edge109
set edge ._crit_edge109 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge109 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph108.preheader
Computing probabilities for ._crit_edge106
eraseBlock ._crit_edge106
set edge ._crit_edge106 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge106 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph105.preheader
Computing probabilities for ._crit_edge103
eraseBlock ._crit_edge103
set edge ._crit_edge103 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge103 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph102.preheader
Computing probabilities for ._crit_edge100
eraseBlock ._crit_edge100
set edge ._crit_edge100 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge100 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph99.preheader
Computing probabilities for ._crit_edge97
eraseBlock ._crit_edge97
set edge ._crit_edge97 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge97 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph96.preheader
Computing probabilities for ._crit_edge94
eraseBlock ._crit_edge94
set edge ._crit_edge94 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge94 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph93.preheader
Computing probabilities for ._crit_edge91
eraseBlock ._crit_edge91
set edge ._crit_edge91 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge91 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph90.preheader
Computing probabilities for ._crit_edge
eraseBlock ._crit_edge
set edge ._crit_edge -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph.preheader
Computing probabilities for 
eraseBlock 
set edge  -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge  -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: 
 - 1: .lr.ph.preheader
 - 2: ._crit_edge
 - 3: .lr.ph90.preheader
 - 4: ._crit_edge91
 - 5: .lr.ph93.preheader
 - 6: ._crit_edge94
 - 7: .lr.ph96.preheader
 - 8: ._crit_edge97
 - 9: .lr.ph99.preheader
 - 10: ._crit_edge100
 - 11: .lr.ph102.preheader
 - 12: ._crit_edge103
 - 13: .lr.ph105.preheader
 - 14: ._crit_edge106
 - 15: .lr.ph108.preheader
 - 16: ._crit_edge109
 - 17: .lr.ph111.preheader
 - 18: ._crit_edge112
loop-detection
compute-mass-in-function
 - node: 
  => [ local  ] weight = 1342177280, succ = .lr.ph.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge
 - node: .lr.ph.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge
 - node: ._crit_edge
  => [ local  ] weight = 1342177280, succ = .lr.ph90.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge91
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph90.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge91
 - node: .lr.ph90.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge91
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge91
 - node: ._crit_edge91
  => [ local  ] weight = 1342177280, succ = .lr.ph93.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge94
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph93.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge94
 - node: .lr.ph93.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge94
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge94
 - node: ._crit_edge94
  => [ local  ] weight = 1342177280, succ = .lr.ph96.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge97
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph96.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge97
 - node: .lr.ph96.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge97
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge97
 - node: ._crit_edge97
  => [ local  ] weight = 1342177280, succ = .lr.ph99.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge100
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph99.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge100
 - node: .lr.ph99.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge100
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge100
 - node: ._crit_edge100
  => [ local  ] weight = 1342177280, succ = .lr.ph102.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge103
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph102.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge103
 - node: .lr.ph102.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge103
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge103
 - node: ._crit_edge103
  => [ local  ] weight = 1342177280, succ = .lr.ph105.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge106
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph105.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge106
 - node: .lr.ph105.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge106
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge106
 - node: ._crit_edge106
  => [ local  ] weight = 1342177280, succ = .lr.ph108.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge109
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph108.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge109
 - node: .lr.ph108.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge109
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge109
 - node: ._crit_edge109
  => [ local  ] weight = 1342177280, succ = .lr.ph111.preheader
  => [ local  ] weight = 805306368, succ = ._crit_edge112
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to .lr.ph111.preheader
  => assign 6000000000000000 (0000000000000000) to ._crit_edge112
 - node: .lr.ph111.preheader
  => [ local  ] weight = 2147483648, succ = ._crit_edge112
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to ._crit_edge112
 - node: ._crit_edge112
  => mass:  ffffffffffffffff
float-to-int: min = 0.625, max = 1.0, factor = 12.8
 - : float = 1.0, scaled = 12.8, int = 12
 - .lr.ph.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph90.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge91: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph93.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge94: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph96.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge97: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph99.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge100: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph102.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge103: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph105.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge106: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph108.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge109: float = 1.0, scaled = 12.8, int = 12
 - .lr.ph111.preheader: float = 0.625, scaled = 8.0, int = 8
 - ._crit_edge112: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: main
 - : float = 1.0, int = 12
 - .lr.ph.preheader: float = 0.625, int = 8
 - ._crit_edge: float = 1.0, int = 12
 - .lr.ph90.preheader: float = 0.625, int = 8
 - ._crit_edge91: float = 1.0, int = 12
 - .lr.ph93.preheader: float = 0.625, int = 8
 - ._crit_edge94: float = 1.0, int = 12
 - .lr.ph96.preheader: float = 0.625, int = 8
 - ._crit_edge97: float = 1.0, int = 12
 - .lr.ph99.preheader: float = 0.625, int = 8
 - ._crit_edge100: float = 1.0, int = 12
 - .lr.ph102.preheader: float = 0.625, int = 8
 - ._crit_edge103: float = 1.0, int = 12
 - .lr.ph105.preheader: float = 0.625, int = 8
 - ._crit_edge106: float = 1.0, int = 12
 - .lr.ph108.preheader: float = 0.625, int = 8
 - ._crit_edge109: float = 1.0, int = 12
 - .lr.ph111.preheader: float = 0.625, int = 8
 - ._crit_edge112: float = 1.0, int = 12

CGP: Found      local addrmode: [inbounds Base:%2]
CGP: Found      local addrmode: [inbounds 8 + Base:%2]
CGP: Found      local addrmode: [inbounds 16 + Base:%2]
CGP: Found      local addrmode: [inbounds 24 + Base:%2]
CGP: Found      local addrmode: [inbounds 32 + Base:%2]
CGP: Found      local addrmode: [inbounds Base:%1]
CGP: Found      local addrmode: [8 + Base:%1]
CGP: Found      local addrmode: [16 + Base:%1]
CGP: Found      local addrmode: [24 + Base:%1]
CGP: Found      local addrmode: [32 + Base:%1]
CGP: Found      local addrmode: [40 + Base:%1]
CGP: Found      local addrmode: [48 + Base:%1]
CGP: Found      local addrmode: [56 + Base:%1]
CGP: Found      local addrmode: [64 + Base:%1]
CGP: Found      local addrmode: [inbounds Base:%22]
CGP: Found      local addrmode: [inbounds 8 + Base:%22]
CGP: Found      local addrmode: [inbounds 16 + Base:%22]
CGP: Found      local addrmode: [inbounds 24 + Base:%22]
CGP: Found      local addrmode: [inbounds 32 + Base:%22]
CGP: Found      local addrmode: [inbounds Base:%25]
CGP: Found      local addrmode: [inbounds 8 + Base:%25]
CGP: Found      local addrmode: [inbounds 16 + Base:%25]
CGP: Found      local addrmode: [inbounds 24 + Base:%25]
CGP: Found      local addrmode: [inbounds 32 + Base:%25]
CGP: Found      local addrmode: [inbounds Base:%28]
CGP: Found      local addrmode: [inbounds 8 + Base:%28]
CGP: Found      local addrmode: [inbounds 16 + Base:%28]
CGP: Found      local addrmode: [inbounds 24 + Base:%28]
CGP: Found      local addrmode: [inbounds 32 + Base:%28]
CGP: Found      local addrmode: [inbounds Base:%31]
CGP: Found      local addrmode: [inbounds 8 + Base:%31]
CGP: Found      local addrmode: [inbounds 16 + Base:%31]
CGP: Found      local addrmode: [inbounds 24 + Base:%31]
CGP: Found      local addrmode: [inbounds 32 + Base:%31]
CGP: Found      local addrmode: [inbounds Base:%34]
CGP: Found      local addrmode: [inbounds 8 + Base:%34]
CGP: Found      local addrmode: [inbounds 16 + Base:%34]
CGP: Found      local addrmode: [inbounds 24 + Base:%34]
CGP: Found      local addrmode: [inbounds 32 + Base:%34]
CGP: Found      local addrmode: [inbounds Base:%37]
CGP: Found      local addrmode: [inbounds 8 + Base:%37]
CGP: Found      local addrmode: [inbounds 16 + Base:%37]
CGP: Found      local addrmode: [inbounds 24 + Base:%37]
CGP: Found      local addrmode: [inbounds 32 + Base:%37]
CGP: Found      local addrmode: [inbounds Base:%40]
CGP: Found      local addrmode: [inbounds 8 + Base:%40]
CGP: Found      local addrmode: [inbounds 16 + Base:%40]
CGP: Found      local addrmode: [inbounds 24 + Base:%40]
CGP: Found      local addrmode: [inbounds 32 + Base:%40]
CGP: Found      local addrmode: [inbounds Base:%43]
CGP: Found      local addrmode: [inbounds 8 + Base:%43]
CGP: Found      local addrmode: [inbounds 16 + Base:%43]
CGP: Found      local addrmode: [inbounds 24 + Base:%43]
CGP: Found      local addrmode: [inbounds 32 + Base:%43]
CGP: Found      local addrmode: [inbounds Base:%46]
CGP: Found      local addrmode: [inbounds 8 + Base:%46]
CGP: Found      local addrmode: [inbounds 16 + Base:%46]
CGP: Found      local addrmode: [inbounds 24 + Base:%46]
CGP: Found      local addrmode: [inbounds 32 + Base:%46]
[SafeStack] Function: main
[SafeStack]     safestack is not requested for this function
		Looking for trivial roots
Found a new trivial root: %._crit_edge112
Last visited node: %.lr.ph111.preheader
		Looking for non-trivial roots
Total: 19, Num: 20
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %._crit_edge112
3: %._crit_edge109
4: %._crit_edge106
5: %._crit_edge103
6: %._crit_edge100
7: %._crit_edge97
8: %._crit_edge94
9: %._crit_edge91
10: %._crit_edge
11: %0
12: %.lr.ph.preheader
13: %.lr.ph90.preheader
14: %.lr.ph93.preheader
15: %.lr.ph96.preheader
16: %.lr.ph99.preheader
17: %.lr.ph102.preheader
18: %.lr.ph105.preheader
19: %.lr.ph108.preheader
20: %.lr.ph111.preheader
Found roots: %._crit_edge112 
---- Branch Probability Info : main ----

Computing probabilities for ._crit_edge112
Computing probabilities for .lr.ph111.preheader
Computing probabilities for ._crit_edge109
eraseBlock ._crit_edge109
set edge ._crit_edge109 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge109 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph108.preheader
Computing probabilities for ._crit_edge106
eraseBlock ._crit_edge106
set edge ._crit_edge106 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge106 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph105.preheader
Computing probabilities for ._crit_edge103
eraseBlock ._crit_edge103
set edge ._crit_edge103 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge103 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph102.preheader
Computing probabilities for ._crit_edge100
eraseBlock ._crit_edge100
set edge ._crit_edge100 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge100 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph99.preheader
Computing probabilities for ._crit_edge97
eraseBlock ._crit_edge97
set edge ._crit_edge97 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge97 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph96.preheader
Computing probabilities for ._crit_edge94
eraseBlock ._crit_edge94
set edge ._crit_edge94 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge94 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph93.preheader
Computing probabilities for ._crit_edge91
eraseBlock ._crit_edge91
set edge ._crit_edge91 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge91 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph90.preheader
Computing probabilities for ._crit_edge
eraseBlock ._crit_edge
set edge ._crit_edge -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge ._crit_edge -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for .lr.ph.preheader
Computing probabilities for 
eraseBlock 
set edge  -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge  -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%



=== main
Creating constant: t2: i64 = Constant<56>
Creating constant: t3: i64 = TargetConstant<0>
Creating new node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>
Creating new node: t8: ch,glue = X86ISD::CALL t6, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Creating new node: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
Creating new node: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Creating constant: t13: i64 = Constant<0>
Creating new node: t14: i64 = undef
Creating new node: t15: ch = store<(store (s64) into %ir.2)> t11:1, t11, FrameIndex:i64<0>, undef:i64
Creating constant: t16: i64 = Constant<8>
Creating new node: t17: i64 = add nuw FrameIndex:i64<0>, Constant:i64<8>
Creating new node: t18: ch = store<(store (s64) into %ir..fca.1.gep)> t15, t11, t17, undef:i64
Creating constant: t19: i64 = Constant<16>
Creating new node: t20: i64 = add nuw FrameIndex:i64<0>, Constant:i64<16>
Creating new node: t21: ch = store<(store (s64) into %ir..fca.2.gep)> t18, Constant:i64<0>, t20, undef:i64
Creating constant: t22: i64 = Constant<24>
Creating new node: t23: i64 = add nuw FrameIndex:i64<0>, Constant:i64<24>
Creating constant: t24: i64 = Constant<7>
Creating new node: t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t21, Constant:i64<7>, t23, undef:i64
Creating constant: t26: i64 = Constant<32>
Creating new node: t27: i64 = add nuw FrameIndex:i64<0>, Constant:i64<32>
Creating constant: t28: i64 = Constant<1>
Creating new node: t29: ch = store<(store (s64) into %ir..fca.4.0.gep)> t25, Constant:i64<1>, t27, undef:i64
Creating constant: t31: i32 = Constant<1>
Creating constant: t32: i64 = Constant<3>
Creating constant: t33: i64 = Constant<-1>
Creating constant: t34: i64 = TargetConstant<16>
Creating new node: t35: ch,glue = callseq_start t29, TargetConstant:i64<16>, TargetConstant:i64<0>
Creating new node: t37: i64,ch = CopyFromReg t35, Register:i64 $rsp
Creating new node: t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64
Creating new node: t39: i64 = add t37, Constant:i64<8>
Creating new node: t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64
Creating new node: t41: ch = TokenFactor t38, t40
Creating new node: t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>
Creating new node: t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1
Creating new node: t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1
Creating new node: t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1
Creating new node: t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1
Creating new node: t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1
Creating new node: t54: ch,glue = X86ISD::CALL t53, GlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1
Creating new node: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
Creating new node: t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64
Creating new node: t58: ch = CopyToReg t0, Register:i64 %0, t56
Creating new node: t59: i64 = add t11, Constant:i64<8>
Creating new node: t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64
Creating new node: t62: ch = CopyToReg t0, Register:i64 %1, t60
Creating new node: t63: i64 = add t11, Constant:i64<16>
Creating new node: t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64
Creating new node: t66: ch = CopyToReg t0, Register:i64 %2, t64
Creating new node: t67: i64 = add t11, Constant:i64<24>
Creating new node: t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64
Creating new node: t70: ch = CopyToReg t0, Register:i64 %3, t68
Creating new node: t71: i64 = add t11, Constant:i64<32>
Creating new node: t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64
Creating new node: t74: ch = CopyToReg t0, Register:i64 %4, t72
Creating constant: t75: i64 = Constant<40>
Creating new node: t76: i64 = add t11, Constant:i64<40>
Creating new node: t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64
Creating new node: t79: ch = CopyToReg t0, Register:i64 %5, t77
Creating constant: t80: i64 = Constant<48>
Creating new node: t81: i64 = add t11, Constant:i64<48>
Creating new node: t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64
Creating new node: t84: ch = CopyToReg t0, Register:i64 %6, t82
Creating new node: t85: i64 = add t11, Constant:i64<56>
Creating new node: t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64
Creating new node: t88: ch = CopyToReg t0, Register:i64 %7, t86
Creating constant: t89: i64 = Constant<64>
Creating new node: t90: i64 = add t11, Constant:i64<64>
Creating new node: t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64
Creating new node: t93: ch = CopyToReg t0, Register:i64 %8, t91
Creating constant: t94: i8 = Constant<3>
Creating new node: t95: i64 = shl t56, Constant:i8<3>
Creating new node: t97: ch = CopyToReg t0, Register:i64 %9, t95
Creating new node: t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1
Creating new node: t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95
Creating new node: t101: ch,glue = X86ISD::CALL t100, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t100:1
Creating new node: t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1
Creating new node: t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1
Creating new node: t105: ch = CopyToReg t0, Register:i64 %10, t103
Creating new node: t107: i1 = setcc t56, Constant:i64<0>, setgt:ch
Creating constant: t108: i1 = Constant<-1>
Creating new node: t109: i1 = xor t107, Constant:i1<-1>
Creating new node: t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1
Creating new node: t112: ch = brcond t110, t109, BasicBlock:ch<._crit_edge 0x7fee590537d0>
Creating new node: t114: ch = br t112, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>
Initial selection DAG: %bb.0 'main:'
SelectionDAG has 115 nodes:
  t0: ch,glue = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>
  t8: ch,glue = X86ISD::CALL t6, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
  t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
            t15: ch = store<(store (s64) into %ir.2)> t11:1, t11, FrameIndex:i64<0>, undef:i64
            t17: i64 = add nuw FrameIndex:i64<0>, Constant:i64<8>
          t18: ch = store<(store (s64) into %ir..fca.1.gep)> t15, t11, t17, undef:i64
          t20: i64 = add nuw FrameIndex:i64<0>, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..fca.2.gep)> t18, Constant:i64<0>, t20, undef:i64
        t23: i64 = add nuw FrameIndex:i64<0>, Constant:i64<24>
      t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t21, Constant:i64<7>, t23, undef:i64
      t27: i64 = add nuw FrameIndex:i64<0>, Constant:i64<32>
    t29: ch = store<(store (s64) into %ir..fca.4.0.gep)> t25, Constant:i64<1>, t27, undef:i64
  t35: ch,glue = callseq_start t29, TargetConstant:i64<16>, TargetConstant:i64<0>
  t37: i64,ch = CopyFromReg t35, Register:i64 $rsp
      t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64
        t39: i64 = add t37, Constant:i64<8>
      t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64
    t41: ch = TokenFactor t38, t40
  t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>
  t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1
  t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1
  t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1
  t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1
  t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1
  t54: ch,glue = X86ISD::CALL t53, GlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1
  t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
  t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64
    t59: i64 = add t11, Constant:i64<8>
  t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64
    t63: i64 = add t11, Constant:i64<16>
  t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64
    t67: i64 = add t11, Constant:i64<24>
  t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64
    t71: i64 = add t11, Constant:i64<32>
  t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64
    t76: i64 = add t11, Constant:i64<40>
  t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64
    t81: i64 = add t11, Constant:i64<48>
  t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64
    t85: i64 = add t11, Constant:i64<56>
  t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64
    t90: i64 = add t11, Constant:i64<64>
  t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64
  t95: i64 = shl t56, Constant:i8<3>
      t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1
    t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>
  t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95
  t101: ch,glue = X86ISD::CALL t100, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t100:1
  t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1
  t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1
        t58: ch = CopyToReg t0, Register:i64 %0, t56
        t62: ch = CopyToReg t0, Register:i64 %1, t60
        t66: ch = CopyToReg t0, Register:i64 %2, t64
        t70: ch = CopyToReg t0, Register:i64 %3, t68
        t74: ch = CopyToReg t0, Register:i64 %4, t72
        t79: ch = CopyToReg t0, Register:i64 %5, t77
        t84: ch = CopyToReg t0, Register:i64 %6, t82
        t88: ch = CopyToReg t0, Register:i64 %7, t86
        t93: ch = CopyToReg t0, Register:i64 %8, t91
        t97: ch = CopyToReg t0, Register:i64 %9, t95
        t105: ch = CopyToReg t0, Register:i64 %10, t103
      t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1
        t107: i1 = setcc t56, Constant:i64<0>, setgt:ch
      t109: i1 = xor t107, Constant:i1<-1>
    t112: ch = brcond t110, t109, BasicBlock:ch<._crit_edge 0x7fee590537d0>
  t114: ch = br t112, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>



Combining: t114: ch = br t112, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>

Combining: t113: ch = BasicBlock<.lr.ph.preheader 0x7fee590536d0>

Combining: t112: ch = brcond t110, t109, BasicBlock:ch<._crit_edge 0x7fee590537d0>
Creating new node: t116: i1 = setcc t56, Constant:i64<0>, setle:ch
Creating new node: t117: ch = brcond t110, t116, BasicBlock:ch<._crit_edge 0x7fee590537d0>
 ... into: t117: ch = brcond t110, t116, BasicBlock:ch<._crit_edge 0x7fee590537d0>

Combining: t114: ch = br t117, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>

Combining: t117: ch = brcond t110, t116, BasicBlock:ch<._crit_edge 0x7fee590537d0>

Combining: t116: i1 = setcc t56, Constant:i64<0>, setle:ch
Creating new node: t119: i1 = setcc t56, Constant:i64<1>, setlt:ch
 ... into: t119: i1 = setcc t56, Constant:i64<1>, setlt:ch

Combining: t117: ch = brcond t110, t119, BasicBlock:ch<._crit_edge 0x7fee590537d0>

Combining: t119: i1 = setcc t56, Constant:i64<1>, setlt:ch

Combining: t118: ch = setlt

Combining: t111: ch = BasicBlock<._crit_edge 0x7fee590537d0>

Combining: t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1

Combining: t105: ch = CopyToReg t0, Register:i64 %10, t103

Combining: t104: i64 = Register %10

Combining: t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1

Combining: t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1

Combining: t101: ch,glue = X86ISD::CALL t100, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t100:1

Combining: t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95

Combining: t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1

Combining: t97: ch = CopyToReg t0, Register:i64 %9, t95

Combining: t96: i64 = Register %9

Combining: t95: i64 = shl t56, Constant:i8<3>

Combining: t94: i8 = Constant<3>

Combining: t93: ch = CopyToReg t0, Register:i64 %8, t91

Combining: t92: i64 = Register %8

Combining: t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64

Combining: t90: i64 = add t11, Constant:i64<64>

Combining: t89: i64 = Constant<64>

Combining: t88: ch = CopyToReg t0, Register:i64 %7, t86

Combining: t87: i64 = Register %7

Combining: t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64

Combining: t85: i64 = add t11, Constant:i64<56>

Combining: t84: ch = CopyToReg t0, Register:i64 %6, t82

Combining: t83: i64 = Register %6

Combining: t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64

Combining: t81: i64 = add t11, Constant:i64<48>

Combining: t80: i64 = Constant<48>

Combining: t79: ch = CopyToReg t0, Register:i64 %5, t77

Combining: t78: i64 = Register %5

Combining: t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64

Combining: t76: i64 = add t11, Constant:i64<40>

Combining: t75: i64 = Constant<40>

Combining: t74: ch = CopyToReg t0, Register:i64 %4, t72

Combining: t73: i64 = Register %4

Combining: t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64

Combining: t71: i64 = add t11, Constant:i64<32>

Combining: t70: ch = CopyToReg t0, Register:i64 %3, t68

Combining: t69: i64 = Register %3

Combining: t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64

Combining: t67: i64 = add t11, Constant:i64<24>

Combining: t66: ch = CopyToReg t0, Register:i64 %2, t64

Combining: t65: i64 = Register %2

Combining: t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64

Combining: t63: i64 = add t11, Constant:i64<16>

Combining: t62: ch = CopyToReg t0, Register:i64 %1, t60

Combining: t61: i64 = Register %1

Combining: t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64

Combining: t59: i64 = add t11, Constant:i64<8>

Combining: t58: ch = CopyToReg t0, Register:i64 %0, t56

Combining: t57: i64 = Register %0

Combining: t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64

Combining: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1

Combining: t54: ch,glue = X86ISD::CALL t53, GlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1

Combining: t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1

Combining: t52: i64 = Register $r9

Combining: t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1

Combining: t50: i64 = Register $r8

Combining: t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1

Combining: t48: i64 = Register $rcx

Combining: t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1

Combining: t46: i64 = Register $rdx

Combining: t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1

Combining: t44: i64 = Register $rsi

Combining: t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>

Combining: t42: i32 = Register $edi

Combining: t41: ch = TokenFactor t38, t40

Combining: t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64

Combining: t39: i64 = add t37, Constant:i64<8>

Combining: t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64

Combining: t37: i64,ch = CopyFromReg t35, Register:i64 $rsp

Combining: t36: i64 = Register $rsp

Combining: t35: ch,glue = callseq_start t29, TargetConstant:i64<16>, TargetConstant:i64<0>

Combining: t34: i64 = TargetConstant<16>

Combining: t33: i64 = Constant<-1>

Combining: t32: i64 = Constant<3>

Combining: t31: i32 = Constant<1>

Combining: t30: i64 = GlobalAddress<ptr @read_input_sizes_2D_f64> 0

Combining: t29: ch = store<(store (s64) into %ir..fca.4.0.gep)> t25, Constant:i64<1>, t27, undef:i64
Creating new node: t120: ch = store<(store (s64) into %ir..fca.4.0.gep)> t9, Constant:i64<1>, t27, undef:i64
Creating new node: t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120

Replacing.1 t29: ch = store<(store (s64) into %ir..fca.4.0.gep)> t25, Constant:i64<1>, t27, undef:i64

With: t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120
 and 0 other values

Combining: t120: ch = store<(store (s64) into %ir..fca.4.0.gep)> t9, Constant:i64<1>, t27, undef:i64

Combining: t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120

Combining: t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>

Combining: t28: i64 = Constant<1>

Combining: t27: i64 = add nuw FrameIndex:i64<0>, Constant:i64<32>

Combining: t26: i64 = Constant<32>

Combining: t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t9, Constant:i64<7>, t23, undef:i64

Combining: t24: i64 = Constant<7>

Combining: t23: i64 = add nuw FrameIndex:i64<0>, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..fca.2.gep)> t9, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw FrameIndex:i64<0>, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..fca.1.gep)> t9, t11, t17, undef:i64

Combining: t17: i64 = add nuw FrameIndex:i64<0>, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.2)> t9, t11, FrameIndex:i64<0>, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64 = Constant<0>

Combining: t12: i64 = FrameIndex<0>

Combining: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1

Combining: t10: i64 = Register $rax

Combining: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1

Combining: t8: ch,glue = X86ISD::CALL t6, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1

Combining: t7: Untyped = RegisterMask

Combining: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>

Combining: t5: i64 = Register $rdi

Combining: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t3: i64 = TargetConstant<0>

Combining: t2: i64 = Constant<56>

Combining: t1: i64 = GlobalAddress<ptr @malloc> 0

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.0 'main:'
SelectionDAG has 114 nodes:
  t0: ch,glue = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>
  t8: ch,glue = X86ISD::CALL t6, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
  t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
      t15: ch = store<(store (s64) into %ir.2)> t9, t11, FrameIndex:i64<0>, undef:i64
        t17: i64 = add nuw FrameIndex:i64<0>, Constant:i64<8>
      t18: ch = store<(store (s64) into %ir..fca.1.gep)> t9, t11, t17, undef:i64
        t20: i64 = add nuw FrameIndex:i64<0>, Constant:i64<16>
      t21: ch = store<(store (s64) into %ir..fca.2.gep)> t9, Constant:i64<0>, t20, undef:i64
        t23: i64 = add nuw FrameIndex:i64<0>, Constant:i64<24>
      t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t9, Constant:i64<7>, t23, undef:i64
        t27: i64 = add nuw FrameIndex:i64<0>, Constant:i64<32>
      t120: ch = store<(store (s64) into %ir..fca.4.0.gep)> t9, Constant:i64<1>, t27, undef:i64
    t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120
  t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>
  t37: i64,ch = CopyFromReg t35, Register:i64 $rsp
      t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64
        t39: i64 = add t37, Constant:i64<8>
      t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64
    t41: ch = TokenFactor t38, t40
  t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>
  t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1
  t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1
  t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1
  t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1
  t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1
  t54: ch,glue = X86ISD::CALL t53, GlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1
  t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
  t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64
    t59: i64 = add t11, Constant:i64<8>
  t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64
    t63: i64 = add t11, Constant:i64<16>
  t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64
    t67: i64 = add t11, Constant:i64<24>
  t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64
    t71: i64 = add t11, Constant:i64<32>
  t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64
    t76: i64 = add t11, Constant:i64<40>
  t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64
    t81: i64 = add t11, Constant:i64<48>
  t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64
    t85: i64 = add t11, Constant:i64<56>
  t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64
    t90: i64 = add t11, Constant:i64<64>
  t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64
  t95: i64 = shl t56, Constant:i8<3>
      t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1
    t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>
  t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95
  t101: ch,glue = X86ISD::CALL t100, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t100:1
  t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1
  t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1
        t58: ch = CopyToReg t0, Register:i64 %0, t56
        t62: ch = CopyToReg t0, Register:i64 %1, t60
        t66: ch = CopyToReg t0, Register:i64 %2, t64
        t70: ch = CopyToReg t0, Register:i64 %3, t68
        t74: ch = CopyToReg t0, Register:i64 %4, t72
        t79: ch = CopyToReg t0, Register:i64 %5, t77
        t84: ch = CopyToReg t0, Register:i64 %6, t82
        t88: ch = CopyToReg t0, Register:i64 %7, t86
        t93: ch = CopyToReg t0, Register:i64 %8, t91
        t97: ch = CopyToReg t0, Register:i64 %9, t95
        t105: ch = CopyToReg t0, Register:i64 %10, t103
      t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1
      t119: i1 = setcc t56, Constant:i64<1>, setlt:ch
    t117: ch = brcond t110, t119, BasicBlock:ch<._crit_edge 0x7fee590537d0>
  t114: ch = br t117, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>


Legalizing node: t118: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t118: ch = setlt

Legalizing node: t113: ch = BasicBlock<.lr.ph.preheader 0x7fee590536d0>
Analyzing result type: ch
Legal result type
Legally typed node: t113: ch = BasicBlock<.lr.ph.preheader 0x7fee590536d0>

Legalizing node: t111: ch = BasicBlock<._crit_edge 0x7fee590537d0>
Analyzing result type: ch
Legal result type
Legally typed node: t111: ch = BasicBlock<._crit_edge 0x7fee590537d0>

Legalizing node: t104: i64 = Register %10
Ignoring node results
Legally typed node: t104: i64 = Register %10

Legalizing node: t96: i64 = Register %9
Ignoring node results
Legally typed node: t96: i64 = Register %9

Legalizing node: t94: i8 = Constant<3>
Analyzing result type: i8
Legal result type
Legally typed node: t94: i8 = Constant<3>

Legalizing node: t92: i64 = Register %8
Ignoring node results
Legally typed node: t92: i64 = Register %8

Legalizing node: t89: i64 = Constant<64>
Analyzing result type: i64
Legal result type
Legally typed node: t89: i64 = Constant<64>

Legalizing node: t87: i64 = Register %7
Ignoring node results
Legally typed node: t87: i64 = Register %7

Legalizing node: t83: i64 = Register %6
Ignoring node results
Legally typed node: t83: i64 = Register %6

Legalizing node: t80: i64 = Constant<48>
Analyzing result type: i64
Legal result type
Legally typed node: t80: i64 = Constant<48>

Legalizing node: t78: i64 = Register %5
Ignoring node results
Legally typed node: t78: i64 = Register %5

Legalizing node: t75: i64 = Constant<40>
Analyzing result type: i64
Legal result type
Legally typed node: t75: i64 = Constant<40>

Legalizing node: t73: i64 = Register %4
Ignoring node results
Legally typed node: t73: i64 = Register %4

Legalizing node: t69: i64 = Register %3
Ignoring node results
Legally typed node: t69: i64 = Register %3

Legalizing node: t65: i64 = Register %2
Ignoring node results
Legally typed node: t65: i64 = Register %2

Legalizing node: t61: i64 = Register %1
Ignoring node results
Legally typed node: t61: i64 = Register %1

Legalizing node: t57: i64 = Register %0
Ignoring node results
Legally typed node: t57: i64 = Register %0

Legalizing node: t52: i64 = Register $r9
Ignoring node results
Legally typed node: t52: i64 = Register $r9

Legalizing node: t50: i64 = Register $r8
Ignoring node results
Legally typed node: t50: i64 = Register $r8

Legalizing node: t48: i64 = Register $rcx
Ignoring node results
Legally typed node: t48: i64 = Register $rcx

Legalizing node: t46: i64 = Register $rdx
Ignoring node results
Legally typed node: t46: i64 = Register $rdx

Legalizing node: t44: i64 = Register $rsi
Ignoring node results
Legally typed node: t44: i64 = Register $rsi

Legalizing node: t42: i32 = Register $edi
Ignoring node results
Legally typed node: t42: i32 = Register $edi

Legalizing node: t36: i64 = Register $rsp
Ignoring node results
Legally typed node: t36: i64 = Register $rsp

Legalizing node: t34: i64 = TargetConstant<16>
Ignoring node results
Legally typed node: t34: i64 = TargetConstant<16>

Legalizing node: t33: i64 = Constant<-1>
Analyzing result type: i64
Legal result type
Legally typed node: t33: i64 = Constant<-1>

Legalizing node: t32: i64 = Constant<3>
Analyzing result type: i64
Legal result type
Legally typed node: t32: i64 = Constant<3>

Legalizing node: t31: i32 = Constant<1>
Analyzing result type: i32
Legal result type
Legally typed node: t31: i32 = Constant<1>

Legalizing node: t30: i64 = GlobalAddress<ptr @read_input_sizes_2D_f64> 0
Analyzing result type: i64
Legal result type
Legally typed node: t30: i64 = GlobalAddress<ptr @read_input_sizes_2D_f64> 0

Legalizing node: t28: i64 = Constant<1>
Analyzing result type: i64
Legal result type
Legally typed node: t28: i64 = Constant<1>

Legalizing node: t26: i64 = Constant<32>
Analyzing result type: i64
Legal result type
Legally typed node: t26: i64 = Constant<32>

Legalizing node: t24: i64 = Constant<7>
Analyzing result type: i64
Legal result type
Legally typed node: t24: i64 = Constant<7>

Legalizing node: t22: i64 = Constant<24>
Analyzing result type: i64
Legal result type
Legally typed node: t22: i64 = Constant<24>

Legalizing node: t19: i64 = Constant<16>
Analyzing result type: i64
Legal result type
Legally typed node: t19: i64 = Constant<16>

Legalizing node: t16: i64 = Constant<8>
Analyzing result type: i64
Legal result type
Legally typed node: t16: i64 = Constant<8>

Legalizing node: t14: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t14: i64 = undef

Legalizing node: t13: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t13: i64 = Constant<0>

Legalizing node: t12: i64 = FrameIndex<0>
Analyzing result type: i64
Legal result type
Legally typed node: t12: i64 = FrameIndex<0>

Legalizing node: t17: i64 = add nuw FrameIndex:i64<0>, Constant:i64<8>
Analyzing result type: i64
Legal result type
Analyzing operand: t12: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t16: i64 = Constant<8>
Legal operand
Legally typed node: t17: i64 = add nuw FrameIndex:i64<0>, Constant:i64<8>

Legalizing node: t20: i64 = add nuw FrameIndex:i64<0>, Constant:i64<16>
Analyzing result type: i64
Legal result type
Analyzing operand: t12: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t19: i64 = Constant<16>
Legal operand
Legally typed node: t20: i64 = add nuw FrameIndex:i64<0>, Constant:i64<16>

Legalizing node: t23: i64 = add nuw FrameIndex:i64<0>, Constant:i64<24>
Analyzing result type: i64
Legal result type
Analyzing operand: t12: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t22: i64 = Constant<24>
Legal operand
Legally typed node: t23: i64 = add nuw FrameIndex:i64<0>, Constant:i64<24>

Legalizing node: t27: i64 = add nuw FrameIndex:i64<0>, Constant:i64<32>
Analyzing result type: i64
Legal result type
Analyzing operand: t12: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t26: i64 = Constant<32>
Legal operand
Legally typed node: t27: i64 = add nuw FrameIndex:i64<0>, Constant:i64<32>

Legalizing node: t10: i64 = Register $rax
Ignoring node results
Legally typed node: t10: i64 = Register $rax

Legalizing node: t7: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t7: Untyped = RegisterMask

Legalizing node: t5: i64 = Register $rdi
Ignoring node results
Legally typed node: t5: i64 = Register $rdi

Legalizing node: t3: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t3: i64 = TargetConstant<0>

Legalizing node: t2: i64 = Constant<56>
Analyzing result type: i64
Legal result type
Legally typed node: t2: i64 = Constant<56>

Legalizing node: t1: i64 = GlobalAddress<ptr @malloc> 0
Analyzing result type: i64
Legal result type
Legally typed node: t1: i64 = GlobalAddress<ptr @malloc> 0

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<56>
Legal operand
Legally typed node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>

Legalizing node: t8: ch,glue = X86ISD::CALL t6, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>
Legal operand
Analyzing operand: t1: i64 = GlobalAddress<ptr @malloc> 0
Legal operand
Analyzing operand: t7: Untyped = RegisterMask
Legal operand
Analyzing operand: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>
Legal operand
Legally typed node: t8: ch,glue = X86ISD::CALL t6, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1

Legalizing node: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t8: ch,glue = X86ISD::CALL t6, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal operand
Analyzing operand: t8: ch,glue = X86ISD::CALL t6, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal operand
Legally typed node: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1

Legalizing node: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
Legal operand
Analyzing operand: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
Legal operand
Legally typed node: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1

Legalizing node: t15: ch = store<(store (s64) into %ir.2)> t9, t11, FrameIndex:i64<0>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
Legal operand
Analyzing operand: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Legal operand
Analyzing operand: t12: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t15: ch = store<(store (s64) into %ir.2)> t9, t11, FrameIndex:i64<0>, undef:i64

Legalizing node: t18: ch = store<(store (s64) into %ir..fca.1.gep)> t9, t11, t17, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
Legal operand
Analyzing operand: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Legal operand
Analyzing operand: t17: i64 = add nuw FrameIndex:i64<0>, Constant:i64<8>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t18: ch = store<(store (s64) into %ir..fca.1.gep)> t9, t11, t17, undef:i64

Legalizing node: t59: i64 = add t11, Constant:i64<8>
Analyzing result type: i64
Legal result type
Analyzing operand: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Legal operand
Analyzing operand: t16: i64 = Constant<8>
Legal operand
Legally typed node: t59: i64 = add t11, Constant:i64<8>

Legalizing node: t63: i64 = add t11, Constant:i64<16>
Analyzing result type: i64
Legal result type
Analyzing operand: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Legal operand
Analyzing operand: t19: i64 = Constant<16>
Legal operand
Legally typed node: t63: i64 = add t11, Constant:i64<16>

Legalizing node: t67: i64 = add t11, Constant:i64<24>
Analyzing result type: i64
Legal result type
Analyzing operand: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Legal operand
Analyzing operand: t22: i64 = Constant<24>
Legal operand
Legally typed node: t67: i64 = add t11, Constant:i64<24>

Legalizing node: t71: i64 = add t11, Constant:i64<32>
Analyzing result type: i64
Legal result type
Analyzing operand: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Legal operand
Analyzing operand: t26: i64 = Constant<32>
Legal operand
Legally typed node: t71: i64 = add t11, Constant:i64<32>

Legalizing node: t76: i64 = add t11, Constant:i64<40>
Analyzing result type: i64
Legal result type
Analyzing operand: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Legal operand
Analyzing operand: t75: i64 = Constant<40>
Legal operand
Legally typed node: t76: i64 = add t11, Constant:i64<40>

Legalizing node: t81: i64 = add t11, Constant:i64<48>
Analyzing result type: i64
Legal result type
Analyzing operand: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Legal operand
Analyzing operand: t80: i64 = Constant<48>
Legal operand
Legally typed node: t81: i64 = add t11, Constant:i64<48>

Legalizing node: t85: i64 = add t11, Constant:i64<56>
Analyzing result type: i64
Legal result type
Analyzing operand: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Legal operand
Analyzing operand: t2: i64 = Constant<56>
Legal operand
Legally typed node: t85: i64 = add t11, Constant:i64<56>

Legalizing node: t90: i64 = add t11, Constant:i64<64>
Analyzing result type: i64
Legal result type
Analyzing operand: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Legal operand
Analyzing operand: t89: i64 = Constant<64>
Legal operand
Legally typed node: t90: i64 = add t11, Constant:i64<64>

Legalizing node: t21: ch = store<(store (s64) into %ir..fca.2.gep)> t9, Constant:i64<0>, t20, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
Legal operand
Analyzing operand: t13: i64 = Constant<0>
Legal operand
Analyzing operand: t20: i64 = add nuw FrameIndex:i64<0>, Constant:i64<16>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t21: ch = store<(store (s64) into %ir..fca.2.gep)> t9, Constant:i64<0>, t20, undef:i64

Legalizing node: t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t9, Constant:i64<7>, t23, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
Legal operand
Analyzing operand: t24: i64 = Constant<7>
Legal operand
Analyzing operand: t23: i64 = add nuw FrameIndex:i64<0>, Constant:i64<24>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t9, Constant:i64<7>, t23, undef:i64

Legalizing node: t120: ch = store<(store (s64) into %ir..fca.4.0.gep)> t9, Constant:i64<1>, t27, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
Legal operand
Analyzing operand: t28: i64 = Constant<1>
Legal operand
Analyzing operand: t27: i64 = add nuw FrameIndex:i64<0>, Constant:i64<32>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t120: ch = store<(store (s64) into %ir..fca.4.0.gep)> t9, Constant:i64<1>, t27, undef:i64

Legalizing node: t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120
Analyzing result type: ch
Legal result type
Analyzing operand: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Legal operand
Analyzing operand: t15: ch = store<(store (s64) into %ir.2)> t9, t11, FrameIndex:i64<0>, undef:i64
Legal operand
Analyzing operand: t18: ch = store<(store (s64) into %ir..fca.1.gep)> t9, t11, t17, undef:i64
Legal operand
Analyzing operand: t21: ch = store<(store (s64) into %ir..fca.2.gep)> t9, Constant:i64<0>, t20, undef:i64
Legal operand
Analyzing operand: t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t9, Constant:i64<7>, t23, undef:i64
Legal operand
Analyzing operand: t120: ch = store<(store (s64) into %ir..fca.4.0.gep)> t9, Constant:i64<1>, t27, undef:i64
Legal operand
Legally typed node: t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120

Legalizing node: t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120
Legal operand
Legally typed node: t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>

Legalizing node: t37: i64,ch = CopyFromReg t35, Register:i64 $rsp
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>
Legal operand
Legally typed node: t37: i64,ch = CopyFromReg t35, Register:i64 $rsp

Legalizing node: t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t12: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t37: i64,ch = CopyFromReg t35, Register:i64 $rsp
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64

Legalizing node: t39: i64 = add t37, Constant:i64<8>
Analyzing result type: i64
Legal result type
Analyzing operand: t37: i64,ch = CopyFromReg t35, Register:i64 $rsp
Legal operand
Analyzing operand: t16: i64 = Constant<8>
Legal operand
Legally typed node: t39: i64 = add t37, Constant:i64<8>

Legalizing node: t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t31: i32 = Constant<1>
Legal operand
Analyzing operand: t39: i64 = add t37, Constant:i64<8>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64

Legalizing node: t41: ch = TokenFactor t38, t40
Analyzing result type: ch
Legal result type
Analyzing operand: t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64
Legal operand
Analyzing operand: t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64
Legal operand
Legally typed node: t41: ch = TokenFactor t38, t40

Legalizing node: t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t41: ch = TokenFactor t38, t40
Legal operand
Analyzing operand: t31: i32 = Constant<1>
Legal operand
Legally typed node: t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>

Legalizing node: t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>
Legal operand
Analyzing operand: t13: i64 = Constant<0>
Legal operand
Analyzing operand: t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>
Legal operand
Legally typed node: t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1

Legalizing node: t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1
Legal operand
Analyzing operand: t32: i64 = Constant<3>
Legal operand
Analyzing operand: t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1
Legal operand
Legally typed node: t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1

Legalizing node: t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1
Legal operand
Analyzing operand: t13: i64 = Constant<0>
Legal operand
Analyzing operand: t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1
Legal operand
Legally typed node: t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1

Legalizing node: t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1
Legal operand
Analyzing operand: t33: i64 = Constant<-1>
Legal operand
Analyzing operand: t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1
Legal operand
Legally typed node: t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1

Legalizing node: t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1
Legal operand
Analyzing operand: t28: i64 = Constant<1>
Legal operand
Analyzing operand: t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1
Legal operand
Legally typed node: t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1

Legalizing node: t54: ch,glue = X86ISD::CALL t53, GlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1
Legal operand
Analyzing operand: t30: i64 = GlobalAddress<ptr @read_input_sizes_2D_f64> 0
Legal operand
Analyzing operand: t7: Untyped = RegisterMask
Legal operand
Analyzing operand: t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1
Legal operand
Legally typed node: t54: ch,glue = X86ISD::CALL t53, GlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1

Legalizing node: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t54: ch,glue = X86ISD::CALL t53, GlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1
Legal operand
Analyzing operand: t54: ch,glue = X86ISD::CALL t53, GlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1
Legal operand
Legally typed node: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1

Legalizing node: t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
Legal operand
Analyzing operand: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64

Legalizing node: t58: ch = CopyToReg t0, Register:i64 %0, t56
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64
Legal operand
Legally typed node: t58: ch = CopyToReg t0, Register:i64 %0, t56

Legalizing node: t95: i64 = shl t56, Constant:i8<3>
Analyzing result type: i64
Legal result type
Analyzing operand: t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64
Legal operand
Analyzing operand: t94: i8 = Constant<3>
Legal operand
Legally typed node: t95: i64 = shl t56, Constant:i8<3>

Legalizing node: t97: ch = CopyToReg t0, Register:i64 %9, t95
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t95: i64 = shl t56, Constant:i8<3>
Legal operand
Legally typed node: t97: ch = CopyToReg t0, Register:i64 %9, t95

Legalizing node: t119: i1 = setcc t56, Constant:i64<1>, setlt:ch
Analyzing result type: i1
Promote integer result: t119: i1 = setcc t56, Constant:i64<1>, setlt:ch

Creating new node: t122: i8 = setcc t56, Constant:i64<1>, setlt:ch
Legalizing node: t122: i8 = setcc t56, Constant:i64<1>, setlt:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64
Legal operand
Analyzing operand: t28: i64 = Constant<1>
Legal operand
Analyzing operand: t118: ch = setlt
Legal operand
Legally typed node: t122: i8 = setcc t56, Constant:i64<1>, setlt:ch

Legalizing node: t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
Legal operand
Analyzing operand: t59: i64 = add t11, Constant:i64<8>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64

Legalizing node: t62: ch = CopyToReg t0, Register:i64 %1, t60
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64
Legal operand
Legally typed node: t62: ch = CopyToReg t0, Register:i64 %1, t60

Legalizing node: t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
Legal operand
Analyzing operand: t63: i64 = add t11, Constant:i64<16>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64

Legalizing node: t66: ch = CopyToReg t0, Register:i64 %2, t64
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64
Legal operand
Legally typed node: t66: ch = CopyToReg t0, Register:i64 %2, t64

Legalizing node: t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
Legal operand
Analyzing operand: t67: i64 = add t11, Constant:i64<24>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64

Legalizing node: t70: ch = CopyToReg t0, Register:i64 %3, t68
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64
Legal operand
Legally typed node: t70: ch = CopyToReg t0, Register:i64 %3, t68

Legalizing node: t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
Legal operand
Analyzing operand: t71: i64 = add t11, Constant:i64<32>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64

Legalizing node: t74: ch = CopyToReg t0, Register:i64 %4, t72
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64
Legal operand
Legally typed node: t74: ch = CopyToReg t0, Register:i64 %4, t72

Legalizing node: t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
Legal operand
Analyzing operand: t76: i64 = add t11, Constant:i64<40>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64

Legalizing node: t79: ch = CopyToReg t0, Register:i64 %5, t77
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64
Legal operand
Legally typed node: t79: ch = CopyToReg t0, Register:i64 %5, t77

Legalizing node: t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
Legal operand
Analyzing operand: t81: i64 = add t11, Constant:i64<48>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64

Legalizing node: t84: ch = CopyToReg t0, Register:i64 %6, t82
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64
Legal operand
Legally typed node: t84: ch = CopyToReg t0, Register:i64 %6, t82

Legalizing node: t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
Legal operand
Analyzing operand: t85: i64 = add t11, Constant:i64<56>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64

Legalizing node: t88: ch = CopyToReg t0, Register:i64 %7, t86
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64
Legal operand
Legally typed node: t88: ch = CopyToReg t0, Register:i64 %7, t86

Legalizing node: t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
Legal operand
Analyzing operand: t90: i64 = add t11, Constant:i64<64>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64

Legalizing node: t93: ch = CopyToReg t0, Register:i64 %8, t91
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64
Legal operand
Legally typed node: t93: ch = CopyToReg t0, Register:i64 %8, t91

Legalizing node: t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1
Analyzing result type: ch
Legal result type
Analyzing operand: t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64
Legal operand
Analyzing operand: t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64
Legal operand
Analyzing operand: t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64
Legal operand
Analyzing operand: t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64
Legal operand
Analyzing operand: t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64
Legal operand
Analyzing operand: t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64
Legal operand
Analyzing operand: t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64
Legal operand
Analyzing operand: t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64
Legal operand
Analyzing operand: t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64
Legal operand
Legally typed node: t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1

Legalizing node: t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1
Legal operand
Legally typed node: t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t95: i64 = shl t56, Constant:i8<3>
Legal operand
Legally typed node: t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95

Legalizing node: t101: ch,glue = X86ISD::CALL t100, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t100:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95
Legal operand
Analyzing operand: t1: i64 = GlobalAddress<ptr @malloc> 0
Legal operand
Analyzing operand: t7: Untyped = RegisterMask
Legal operand
Analyzing operand: t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95
Legal operand
Legally typed node: t101: ch,glue = X86ISD::CALL t100, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t100:1

Legalizing node: t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t101: ch,glue = X86ISD::CALL t100, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t100:1
Legal operand
Analyzing operand: t101: ch,glue = X86ISD::CALL t100, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t100:1
Legal operand
Legally typed node: t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1

Legalizing node: t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1
Legal operand
Analyzing operand: t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1
Legal operand
Legally typed node: t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1

Legalizing node: t105: ch = CopyToReg t0, Register:i64 %10, t103
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1
Legal operand
Legally typed node: t105: ch = CopyToReg t0, Register:i64 %10, t103

Legalizing node: t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1
Analyzing result type: ch
Legal result type
Analyzing operand: t58: ch = CopyToReg t0, Register:i64 %0, t56
Legal operand
Analyzing operand: t62: ch = CopyToReg t0, Register:i64 %1, t60
Legal operand
Analyzing operand: t66: ch = CopyToReg t0, Register:i64 %2, t64
Legal operand
Analyzing operand: t70: ch = CopyToReg t0, Register:i64 %3, t68
Legal operand
Analyzing operand: t74: ch = CopyToReg t0, Register:i64 %4, t72
Legal operand
Analyzing operand: t79: ch = CopyToReg t0, Register:i64 %5, t77
Legal operand
Analyzing operand: t84: ch = CopyToReg t0, Register:i64 %6, t82
Legal operand
Analyzing operand: t88: ch = CopyToReg t0, Register:i64 %7, t86
Legal operand
Analyzing operand: t93: ch = CopyToReg t0, Register:i64 %8, t91
Legal operand
Analyzing operand: t97: ch = CopyToReg t0, Register:i64 %9, t95
Legal operand
Analyzing operand: t105: ch = CopyToReg t0, Register:i64 %10, t103
Legal operand
Analyzing operand: t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1
Legal operand
Legally typed node: t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1

Legalizing node: t117: ch = brcond t110, t119, BasicBlock:ch<._crit_edge 0x7fee590537d0>
Analyzing result type: ch
Legal result type
Analyzing operand: t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1
Legal operand
Analyzing operand: t119: i1 = setcc t56, Constant:i64<1>, setlt:ch
Promote integer operand: t117: ch = brcond t110, t119, BasicBlock:ch<._crit_edge 0x7fee590537d0>

Creating new node: t123: i8 = zero_extend t119
Legalizing node: t123: i8 = zero_extend t119
Analyzing result type: i8
Legal result type
Analyzing operand: t119: i1 = setcc t56, Constant:i64<1>, setlt:ch
Promote integer operand: t123: i8 = zero_extend t119

Creating constant: t124: i8 = Constant<1>
Creating new node: t125: i8 = and t122, Constant:i8<1>
Replacing: t123: i8 = zero_extend t119
     with: t125: i8 = and t122, Constant:i8<1>
Legalizing node: t124: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t124: i8 = Constant<1>

Legalizing node: t125: i8 = and t122, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t122: i8 = setcc t56, Constant:i64<1>, setlt:ch
Legal operand
Analyzing operand: t124: i8 = Constant<1>
Legal operand
Legally typed node: t125: i8 = and t122, Constant:i8<1>

Legalizing node: t117: ch = brcond t110, t125, BasicBlock:ch<._crit_edge 0x7fee590537d0>
Analyzing result type: ch
Legal result type
Analyzing operand: t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1
Legal operand
Analyzing operand: t125: i8 = and t122, Constant:i8<1>
Legal operand
Analyzing operand: t111: ch = BasicBlock<._crit_edge 0x7fee590537d0>
Legal operand
Legally typed node: t117: ch = brcond t110, t125, BasicBlock:ch<._crit_edge 0x7fee590537d0>

Legalizing node: t114: ch = br t117, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>
Analyzing result type: ch
Legal result type
Analyzing operand: t117: ch = brcond t110, t125, BasicBlock:ch<._crit_edge 0x7fee590537d0>
Legal operand
Analyzing operand: t113: ch = BasicBlock<.lr.ph.preheader 0x7fee590536d0>
Legal operand
Legally typed node: t114: ch = br t117, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>

Legalizing node: t65535: ch = handlenode t114
Analyzing result type: ch
Legal result type
Analyzing operand: t114: ch = br t117, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>
Legal operand
Legally typed node: t65535: ch = handlenode t114

Type-legalized selection DAG: %bb.0 'main:'
SelectionDAG has 116 nodes:
  t0: ch,glue = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>
  t8: ch,glue = X86ISD::CALL t6, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
  t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
      t15: ch = store<(store (s64) into %ir.2)> t9, t11, FrameIndex:i64<0>, undef:i64
        t17: i64 = add nuw FrameIndex:i64<0>, Constant:i64<8>
      t18: ch = store<(store (s64) into %ir..fca.1.gep)> t9, t11, t17, undef:i64
        t20: i64 = add nuw FrameIndex:i64<0>, Constant:i64<16>
      t21: ch = store<(store (s64) into %ir..fca.2.gep)> t9, Constant:i64<0>, t20, undef:i64
        t23: i64 = add nuw FrameIndex:i64<0>, Constant:i64<24>
      t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t9, Constant:i64<7>, t23, undef:i64
        t27: i64 = add nuw FrameIndex:i64<0>, Constant:i64<32>
      t120: ch = store<(store (s64) into %ir..fca.4.0.gep)> t9, Constant:i64<1>, t27, undef:i64
    t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120
  t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>
  t37: i64,ch = CopyFromReg t35, Register:i64 $rsp
      t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64
        t39: i64 = add t37, Constant:i64<8>
      t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64
    t41: ch = TokenFactor t38, t40
  t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>
  t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1
  t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1
  t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1
  t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1
  t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1
  t54: ch,glue = X86ISD::CALL t53, GlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1
  t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
  t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64
    t59: i64 = add t11, Constant:i64<8>
  t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64
    t63: i64 = add t11, Constant:i64<16>
  t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64
    t67: i64 = add t11, Constant:i64<24>
  t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64
    t71: i64 = add t11, Constant:i64<32>
  t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64
    t76: i64 = add t11, Constant:i64<40>
  t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64
    t81: i64 = add t11, Constant:i64<48>
  t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64
    t85: i64 = add t11, Constant:i64<56>
  t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64
    t90: i64 = add t11, Constant:i64<64>
  t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64
  t95: i64 = shl t56, Constant:i8<3>
      t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1
    t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>
  t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95
  t101: ch,glue = X86ISD::CALL t100, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t100:1
  t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1
  t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1
        t58: ch = CopyToReg t0, Register:i64 %0, t56
        t62: ch = CopyToReg t0, Register:i64 %1, t60
        t66: ch = CopyToReg t0, Register:i64 %2, t64
        t70: ch = CopyToReg t0, Register:i64 %3, t68
        t74: ch = CopyToReg t0, Register:i64 %4, t72
        t79: ch = CopyToReg t0, Register:i64 %5, t77
        t84: ch = CopyToReg t0, Register:i64 %6, t82
        t88: ch = CopyToReg t0, Register:i64 %7, t86
        t93: ch = CopyToReg t0, Register:i64 %8, t91
        t97: ch = CopyToReg t0, Register:i64 %9, t95
        t105: ch = CopyToReg t0, Register:i64 %10, t103
      t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1
        t122: i8 = setcc t56, Constant:i64<1>, setlt:ch
      t125: i8 = and t122, Constant:i8<1>
    t117: ch = brcond t110, t125, BasicBlock:ch<._crit_edge 0x7fee590537d0>
  t114: ch = br t117, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>



Combining: t125: i8 = and t122, Constant:i8<1>

Replacing.2 t125: i8 = and t122, Constant:i8<1>

With: t122: i8 = setcc t56, Constant:i64<1>, setlt:ch


Combining: t122: i8 = setcc t56, Constant:i64<1>, setlt:ch

Combining: t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120

Combining: t120: ch = store<(store (s64) into %ir..fca.4.0.gep)> t9, Constant:i64<1>, t27, undef:i64

Combining: t118: ch = setlt

Combining: t117: ch = brcond t110, t122, BasicBlock:ch<._crit_edge 0x7fee590537d0>

Combining: t114: ch = br t117, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>

Combining: t113: ch = BasicBlock<.lr.ph.preheader 0x7fee590536d0>

Combining: t111: ch = BasicBlock<._crit_edge 0x7fee590537d0>

Combining: t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1

Combining: t105: ch = CopyToReg t0, Register:i64 %10, t103

Combining: t104: i64 = Register %10

Combining: t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1

Combining: t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1

Combining: t101: ch,glue = X86ISD::CALL t100, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t100:1

Combining: t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95

Combining: t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1

Combining: t97: ch = CopyToReg t0, Register:i64 %9, t95

Combining: t96: i64 = Register %9

Combining: t95: i64 = shl t56, Constant:i8<3>

Combining: t94: i8 = Constant<3>

Combining: t93: ch = CopyToReg t0, Register:i64 %8, t91

Combining: t92: i64 = Register %8

Combining: t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64

Combining: t90: i64 = add t11, Constant:i64<64>

Combining: t89: i64 = Constant<64>

Combining: t88: ch = CopyToReg t0, Register:i64 %7, t86

Combining: t87: i64 = Register %7

Combining: t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64

Combining: t85: i64 = add t11, Constant:i64<56>

Combining: t84: ch = CopyToReg t0, Register:i64 %6, t82

Combining: t83: i64 = Register %6

Combining: t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64

Combining: t81: i64 = add t11, Constant:i64<48>

Combining: t80: i64 = Constant<48>

Combining: t79: ch = CopyToReg t0, Register:i64 %5, t77

Combining: t78: i64 = Register %5

Combining: t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64

Combining: t76: i64 = add t11, Constant:i64<40>

Combining: t75: i64 = Constant<40>

Combining: t74: ch = CopyToReg t0, Register:i64 %4, t72

Combining: t73: i64 = Register %4

Combining: t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64

Combining: t71: i64 = add t11, Constant:i64<32>

Combining: t70: ch = CopyToReg t0, Register:i64 %3, t68

Combining: t69: i64 = Register %3

Combining: t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64

Combining: t67: i64 = add t11, Constant:i64<24>

Combining: t66: ch = CopyToReg t0, Register:i64 %2, t64

Combining: t65: i64 = Register %2

Combining: t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64

Combining: t63: i64 = add t11, Constant:i64<16>

Combining: t62: ch = CopyToReg t0, Register:i64 %1, t60

Combining: t61: i64 = Register %1

Combining: t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64

Combining: t59: i64 = add t11, Constant:i64<8>

Combining: t58: ch = CopyToReg t0, Register:i64 %0, t56

Combining: t57: i64 = Register %0

Combining: t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64

Combining: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1

Combining: t54: ch,glue = X86ISD::CALL t53, GlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1

Combining: t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1

Combining: t52: i64 = Register $r9

Combining: t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1

Combining: t50: i64 = Register $r8

Combining: t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1

Combining: t48: i64 = Register $rcx

Combining: t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1

Combining: t46: i64 = Register $rdx

Combining: t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1

Combining: t44: i64 = Register $rsi

Combining: t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>

Combining: t42: i32 = Register $edi

Combining: t41: ch = TokenFactor t38, t40

Combining: t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64

Combining: t39: i64 = add t37, Constant:i64<8>

Combining: t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64

Combining: t37: i64,ch = CopyFromReg t35, Register:i64 $rsp

Combining: t36: i64 = Register $rsp

Combining: t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>

Combining: t34: i64 = TargetConstant<16>

Combining: t33: i64 = Constant<-1>

Combining: t32: i64 = Constant<3>

Combining: t31: i32 = Constant<1>

Combining: t30: i64 = GlobalAddress<ptr @read_input_sizes_2D_f64> 0

Combining: t28: i64 = Constant<1>

Combining: t27: i64 = add nuw FrameIndex:i64<0>, Constant:i64<32>

Combining: t26: i64 = Constant<32>

Combining: t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t9, Constant:i64<7>, t23, undef:i64

Combining: t24: i64 = Constant<7>

Combining: t23: i64 = add nuw FrameIndex:i64<0>, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..fca.2.gep)> t9, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw FrameIndex:i64<0>, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..fca.1.gep)> t9, t11, t17, undef:i64

Combining: t17: i64 = add nuw FrameIndex:i64<0>, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.2)> t9, t11, FrameIndex:i64<0>, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64 = Constant<0>

Combining: t12: i64 = FrameIndex<0>

Combining: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1

Combining: t10: i64 = Register $rax

Combining: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1

Combining: t8: ch,glue = X86ISD::CALL t6, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1

Combining: t7: Untyped = RegisterMask

Combining: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>

Combining: t5: i64 = Register $rdi

Combining: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t3: i64 = TargetConstant<0>

Combining: t2: i64 = Constant<56>

Combining: t1: i64 = GlobalAddress<ptr @malloc> 0

Combining: t0: ch,glue = EntryToken
Optimized type-legalized selection DAG: %bb.0 'main:'
SelectionDAG has 114 nodes:
  t0: ch,glue = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>
  t8: ch,glue = X86ISD::CALL t6, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
  t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
      t15: ch = store<(store (s64) into %ir.2)> t9, t11, FrameIndex:i64<0>, undef:i64
        t17: i64 = add nuw FrameIndex:i64<0>, Constant:i64<8>
      t18: ch = store<(store (s64) into %ir..fca.1.gep)> t9, t11, t17, undef:i64
        t20: i64 = add nuw FrameIndex:i64<0>, Constant:i64<16>
      t21: ch = store<(store (s64) into %ir..fca.2.gep)> t9, Constant:i64<0>, t20, undef:i64
        t23: i64 = add nuw FrameIndex:i64<0>, Constant:i64<24>
      t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t9, Constant:i64<7>, t23, undef:i64
        t27: i64 = add nuw FrameIndex:i64<0>, Constant:i64<32>
      t120: ch = store<(store (s64) into %ir..fca.4.0.gep)> t9, Constant:i64<1>, t27, undef:i64
    t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120
  t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>
  t37: i64,ch = CopyFromReg t35, Register:i64 $rsp
      t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64
        t39: i64 = add t37, Constant:i64<8>
      t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64
    t41: ch = TokenFactor t38, t40
  t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>
  t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1
  t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1
  t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1
  t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1
  t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1
  t54: ch,glue = X86ISD::CALL t53, GlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1
  t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
  t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64
    t59: i64 = add t11, Constant:i64<8>
  t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64
    t63: i64 = add t11, Constant:i64<16>
  t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64
    t67: i64 = add t11, Constant:i64<24>
  t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64
    t71: i64 = add t11, Constant:i64<32>
  t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64
    t76: i64 = add t11, Constant:i64<40>
  t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64
    t81: i64 = add t11, Constant:i64<48>
  t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64
    t85: i64 = add t11, Constant:i64<56>
  t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64
    t90: i64 = add t11, Constant:i64<64>
  t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64
  t95: i64 = shl t56, Constant:i8<3>
      t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1
    t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>
  t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95
  t101: ch,glue = X86ISD::CALL t100, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t100:1
  t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1
  t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1
        t58: ch = CopyToReg t0, Register:i64 %0, t56
        t62: ch = CopyToReg t0, Register:i64 %1, t60
        t66: ch = CopyToReg t0, Register:i64 %2, t64
        t70: ch = CopyToReg t0, Register:i64 %3, t68
        t74: ch = CopyToReg t0, Register:i64 %4, t72
        t79: ch = CopyToReg t0, Register:i64 %5, t77
        t84: ch = CopyToReg t0, Register:i64 %6, t82
        t88: ch = CopyToReg t0, Register:i64 %7, t86
        t93: ch = CopyToReg t0, Register:i64 %8, t91
        t97: ch = CopyToReg t0, Register:i64 %9, t95
        t105: ch = CopyToReg t0, Register:i64 %10, t103
      t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1
      t122: i8 = setcc t56, Constant:i64<1>, setlt:ch
    t117: ch = brcond t110, t122, BasicBlock:ch<._crit_edge 0x7fee590537d0>
  t114: ch = br t117, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>



Legalizing: t114: ch = br t117, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>
Legal node: nothing to do

Legalizing: t117: ch = brcond t110, t122, BasicBlock:ch<._crit_edge 0x7fee590537d0>
Trying custom legalization
Creating new node: t126: i32 = X86ISD::CMP t56, Constant:i64<0>
Creating constant: t127: i8 = TargetConstant<14>
Creating new node: t128: ch = X86ISD::BRCOND t110, BasicBlock:ch<._crit_edge 0x7fee590537d0>, TargetConstant:i8<14>, t126
Successfully custom legalized node
 ... replacing: t117: ch = brcond t110, t122, BasicBlock:ch<._crit_edge 0x7fee590537d0>
     with:      t128: ch = X86ISD::BRCOND t110, BasicBlock:ch<._crit_edge 0x7fee590537d0>, TargetConstant:i8<14>, t126

Legalizing: t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1
Legal node: nothing to do

Legalizing: t105: ch = CopyToReg t0, Register:i64 %10, t103
Legal node: nothing to do

Legalizing: t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1
Legal node: nothing to do

Legalizing: t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1

Legalizing: t101: ch,glue = X86ISD::CALL t100, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t100:1
Legal node: nothing to do

Legalizing: t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95
Legal node: nothing to do

Legalizing: t97: ch = CopyToReg t0, Register:i64 %9, t95
Legal node: nothing to do

Legalizing: t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t58: ch = CopyToReg t0, Register:i64 %0, t56
Legal node: nothing to do

Legalizing: t95: i64 = shl t56, Constant:i8<3>
Legal node: nothing to do

Legalizing: t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1
Legal node: nothing to do

Legalizing: t62: ch = CopyToReg t0, Register:i64 %1, t60
Legal node: nothing to do

Legalizing: t66: ch = CopyToReg t0, Register:i64 %2, t64
Legal node: nothing to do

Legalizing: t70: ch = CopyToReg t0, Register:i64 %3, t68
Legal node: nothing to do

Legalizing: t74: ch = CopyToReg t0, Register:i64 %4, t72
Legal node: nothing to do

Legalizing: t79: ch = CopyToReg t0, Register:i64 %5, t77
Legal node: nothing to do

Legalizing: t84: ch = CopyToReg t0, Register:i64 %6, t82
Legal node: nothing to do

Legalizing: t88: ch = CopyToReg t0, Register:i64 %7, t86
Legal node: nothing to do

Legalizing: t93: ch = CopyToReg t0, Register:i64 %8, t91
Legal node: nothing to do

Legalizing: t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64
Legalizing non-extending load operation

Legalizing: t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64
Legalizing non-extending load operation

Legalizing: t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64
Legalizing non-extending load operation

Legalizing: t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64
Legalizing non-extending load operation

Legalizing: t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64
Legalizing non-extending load operation

Legalizing: t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64
Legalizing non-extending load operation

Legalizing: t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64
Legalizing non-extending load operation

Legalizing: t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64
Legalizing non-extending load operation

Legalizing: t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64
Legalizing non-extending load operation

Legalizing: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1

Legalizing: t54: ch,glue = X86ISD::CALL t53, GlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1
Legal node: nothing to do

Legalizing: t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1
Legal node: nothing to do

Legalizing: t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1
Legal node: nothing to do

Legalizing: t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1
Legal node: nothing to do

Legalizing: t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1
Legal node: nothing to do

Legalizing: t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1
Legal node: nothing to do

Legalizing: t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>
Legal node: nothing to do

Legalizing: t41: ch = TokenFactor t38, t40
Legal node: nothing to do

Legalizing: t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t39: i64 = add t37, Constant:i64<8>
Legal node: nothing to do

Legalizing: t37: i64,ch = CopyFromReg t35, Register:i64 $rsp
Legal node: nothing to do

Legalizing: t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>

Legalizing: t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120
Legal node: nothing to do

Legalizing: t15: ch = store<(store (s64) into %ir.2)> t9, t11, FrameIndex:i64<0>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t18: ch = store<(store (s64) into %ir..fca.1.gep)> t9, t11, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t59: i64 = add t11, Constant:i64<8>
Legal node: nothing to do

Legalizing: t63: i64 = add t11, Constant:i64<16>
Legal node: nothing to do

Legalizing: t67: i64 = add t11, Constant:i64<24>
Legal node: nothing to do

Legalizing: t71: i64 = add t11, Constant:i64<32>
Legal node: nothing to do

Legalizing: t76: i64 = add t11, Constant:i64<40>
Legal node: nothing to do

Legalizing: t81: i64 = add t11, Constant:i64<48>
Legal node: nothing to do

Legalizing: t85: i64 = add t11, Constant:i64<56>
Legal node: nothing to do

Legalizing: t90: i64 = add t11, Constant:i64<64>
Legal node: nothing to do

Legalizing: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Legal node: nothing to do

Legalizing: t21: ch = store<(store (s64) into %ir..fca.2.gep)> t9, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t9, Constant:i64<7>, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t120: ch = store<(store (s64) into %ir..fca.4.0.gep)> t9, Constant:i64<1>, t27, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1

Legalizing: t8: ch,glue = X86ISD::CALL t6, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal node: nothing to do

Legalizing: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>
Legal node: nothing to do

Legalizing: t27: i64 = add nuw FrameIndex:i64<0>, Constant:i64<32>
Legal node: nothing to do

Legalizing: t23: i64 = add nuw FrameIndex:i64<0>, Constant:i64<24>
Legal node: nothing to do

Legalizing: t20: i64 = add nuw FrameIndex:i64<0>, Constant:i64<16>
Legal node: nothing to do

Legalizing: t17: i64 = add nuw FrameIndex:i64<0>, Constant:i64<8>
Legal node: nothing to do

Legalizing: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t113: ch = BasicBlock<.lr.ph.preheader 0x7fee590536d0>
Legal node: nothing to do

Legalizing: t111: ch = BasicBlock<._crit_edge 0x7fee590537d0>
Legal node: nothing to do

Legalizing: t104: i64 = Register %10

Legalizing: t96: i64 = Register %9

Legalizing: t94: i8 = Constant<3>
Legal node: nothing to do

Legalizing: t92: i64 = Register %8

Legalizing: t89: i64 = Constant<64>
Legal node: nothing to do

Legalizing: t87: i64 = Register %7

Legalizing: t83: i64 = Register %6

Legalizing: t80: i64 = Constant<48>
Legal node: nothing to do

Legalizing: t78: i64 = Register %5

Legalizing: t75: i64 = Constant<40>
Legal node: nothing to do

Legalizing: t73: i64 = Register %4

Legalizing: t69: i64 = Register %3

Legalizing: t65: i64 = Register %2

Legalizing: t61: i64 = Register %1

Legalizing: t57: i64 = Register %0

Legalizing: t52: i64 = Register $r9

Legalizing: t50: i64 = Register $r8

Legalizing: t48: i64 = Register $rcx

Legalizing: t46: i64 = Register $rdx

Legalizing: t44: i64 = Register $rsi

Legalizing: t42: i32 = Register $edi

Legalizing: t36: i64 = Register $rsp

Legalizing: t34: i64 = TargetConstant<16>

Legalizing: t33: i64 = Constant<-1>
Legal node: nothing to do

Legalizing: t32: i64 = Constant<3>
Legal node: nothing to do

Legalizing: t31: i32 = Constant<1>
Legal node: nothing to do

Legalizing: t30: i64 = GlobalAddress<ptr @read_input_sizes_2D_f64> 0
Trying custom legalization
Creating new node: t130: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0
Successfully custom legalized node
 ... replacing: t30: i64 = GlobalAddress<ptr @read_input_sizes_2D_f64> 0
     with:      t130: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0

Legalizing: t28: i64 = Constant<1>
Legal node: nothing to do

Legalizing: t26: i64 = Constant<32>
Legal node: nothing to do

Legalizing: t24: i64 = Constant<7>
Legal node: nothing to do

Legalizing: t22: i64 = Constant<24>
Legal node: nothing to do

Legalizing: t19: i64 = Constant<16>
Legal node: nothing to do

Legalizing: t16: i64 = Constant<8>
Legal node: nothing to do

Legalizing: t14: i64 = undef
Legal node: nothing to do

Legalizing: t13: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t12: i64 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t10: i64 = Register $rax

Legalizing: t7: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t5: i64 = Register $rdi

Legalizing: t3: i64 = TargetConstant<0>

Legalizing: t2: i64 = Constant<56>
Legal node: nothing to do

Legalizing: t1: i64 = GlobalAddress<ptr @malloc> 0
Trying custom legalization
Creating new node: t132: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Successfully custom legalized node
 ... replacing: t1: i64 = GlobalAddress<ptr @malloc> 0
     with:      t132: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t132: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t131: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t130: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0
Legal node: nothing to do

Legalizing: t129: i64 = TargetGlobalAddress<ptr @read_input_sizes_2D_f64> 0
Legal node: nothing to do

Legalizing: t128: ch = X86ISD::BRCOND t110, BasicBlock:ch<._crit_edge 0x7fee590537d0>, TargetConstant:i8<14>, t126
Legal node: nothing to do

Legalizing: t127: i8 = TargetConstant<14>

Legalizing: t126: i32 = X86ISD::CMP t56, Constant:i64<0>
Legal node: nothing to do
Legalized selection DAG: %bb.0 'main:'
SelectionDAG has 116 nodes:
  t0: ch,glue = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>
  t8: ch,glue = X86ISD::CALL t6, t132, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
  t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
      t15: ch = store<(store (s64) into %ir.2)> t9, t11, FrameIndex:i64<0>, undef:i64
        t17: i64 = add nuw FrameIndex:i64<0>, Constant:i64<8>
      t18: ch = store<(store (s64) into %ir..fca.1.gep)> t9, t11, t17, undef:i64
        t20: i64 = add nuw FrameIndex:i64<0>, Constant:i64<16>
      t21: ch = store<(store (s64) into %ir..fca.2.gep)> t9, Constant:i64<0>, t20, undef:i64
        t23: i64 = add nuw FrameIndex:i64<0>, Constant:i64<24>
      t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t9, Constant:i64<7>, t23, undef:i64
        t27: i64 = add nuw FrameIndex:i64<0>, Constant:i64<32>
      t120: ch = store<(store (s64) into %ir..fca.4.0.gep)> t9, Constant:i64<1>, t27, undef:i64
    t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120
  t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>
  t37: i64,ch = CopyFromReg t35, Register:i64 $rsp
      t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64
        t39: i64 = add t37, Constant:i64<8>
      t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64
    t41: ch = TokenFactor t38, t40
  t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>
  t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1
  t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1
  t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1
  t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1
  t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1
    t130: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0
  t54: ch,glue = X86ISD::CALL t53, t130, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1
  t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
    t90: i64 = add t11, Constant:i64<64>
  t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64
    t85: i64 = add t11, Constant:i64<56>
  t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64
    t81: i64 = add t11, Constant:i64<48>
  t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64
    t76: i64 = add t11, Constant:i64<40>
  t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64
    t71: i64 = add t11, Constant:i64<32>
  t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64
    t67: i64 = add t11, Constant:i64<24>
  t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64
    t63: i64 = add t11, Constant:i64<16>
  t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64
    t59: i64 = add t11, Constant:i64<8>
  t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64
  t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64
  t95: i64 = shl t56, Constant:i8<3>
      t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1
    t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>
  t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95
  t101: ch,glue = X86ISD::CALL t100, t132, Register:i64 $rdi, RegisterMask:Untyped, t100:1
  t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1
  t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1
  t132: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
        t58: ch = CopyToReg t0, Register:i64 %0, t56
        t62: ch = CopyToReg t0, Register:i64 %1, t60
        t66: ch = CopyToReg t0, Register:i64 %2, t64
        t70: ch = CopyToReg t0, Register:i64 %3, t68
        t74: ch = CopyToReg t0, Register:i64 %4, t72
        t79: ch = CopyToReg t0, Register:i64 %5, t77
        t84: ch = CopyToReg t0, Register:i64 %6, t82
        t88: ch = CopyToReg t0, Register:i64 %7, t86
        t93: ch = CopyToReg t0, Register:i64 %8, t91
        t97: ch = CopyToReg t0, Register:i64 %9, t95
        t105: ch = CopyToReg t0, Register:i64 %10, t103
      t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1
      t126: i32 = X86ISD::CMP t56, Constant:i64<0>
    t128: ch = X86ISD::BRCOND t110, BasicBlock:ch<._crit_edge 0x7fee590537d0>, TargetConstant:i8<14>, t126
  t114: ch = br t128, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>



Legalizing: t132: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Combining: t132: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t131: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Combining: t131: i64 = TargetGlobalAddress<ptr @malloc> 0

Legalizing: t130: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0
Legal node: nothing to do

Combining: t130: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0

Legalizing: t129: i64 = TargetGlobalAddress<ptr @read_input_sizes_2D_f64> 0
Legal node: nothing to do

Combining: t129: i64 = TargetGlobalAddress<ptr @read_input_sizes_2D_f64> 0

Legalizing: t128: ch = X86ISD::BRCOND t110, BasicBlock:ch<._crit_edge 0x7fee590537d0>, TargetConstant:i8<14>, t126
Legal node: nothing to do

Combining: t128: ch = X86ISD::BRCOND t110, BasicBlock:ch<._crit_edge 0x7fee590537d0>, TargetConstant:i8<14>, t126

Legalizing: t127: i8 = TargetConstant<14>

Combining: t127: i8 = TargetConstant<14>

Legalizing: t126: i32 = X86ISD::CMP t56, Constant:i64<0>
Legal node: nothing to do

Combining: t126: i32 = X86ISD::CMP t56, Constant:i64<0>

Legalizing: t114: ch = br t128, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>
Legal node: nothing to do

Combining: t114: ch = br t128, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>

Legalizing: t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1
Legal node: nothing to do

Combining: t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1

Legalizing: t105: ch = CopyToReg t0, Register:i64 %10, t103
Legal node: nothing to do

Combining: t105: ch = CopyToReg t0, Register:i64 %10, t103

Legalizing: t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1
Legal node: nothing to do

Combining: t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1

Legalizing: t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1

Combining: t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1

Legalizing: t101: ch,glue = X86ISD::CALL t100, t132, Register:i64 $rdi, RegisterMask:Untyped, t100:1
Legal node: nothing to do

Combining: t101: ch,glue = X86ISD::CALL t100, t132, Register:i64 $rdi, RegisterMask:Untyped, t100:1

Legalizing: t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95
Legal node: nothing to do

Combining: t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95

Legalizing: t97: ch = CopyToReg t0, Register:i64 %9, t95
Legal node: nothing to do

Combining: t97: ch = CopyToReg t0, Register:i64 %9, t95

Legalizing: t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t58: ch = CopyToReg t0, Register:i64 %0, t56
Legal node: nothing to do

Combining: t58: ch = CopyToReg t0, Register:i64 %0, t56

Legalizing: t95: i64 = shl t56, Constant:i8<3>
Legal node: nothing to do

Combining: t95: i64 = shl t56, Constant:i8<3>

Legalizing: t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1
Legal node: nothing to do

Combining: t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1

Legalizing: t62: ch = CopyToReg t0, Register:i64 %1, t60
Legal node: nothing to do

Combining: t62: ch = CopyToReg t0, Register:i64 %1, t60

Legalizing: t66: ch = CopyToReg t0, Register:i64 %2, t64
Legal node: nothing to do

Combining: t66: ch = CopyToReg t0, Register:i64 %2, t64

Legalizing: t70: ch = CopyToReg t0, Register:i64 %3, t68
Legal node: nothing to do

Combining: t70: ch = CopyToReg t0, Register:i64 %3, t68

Legalizing: t74: ch = CopyToReg t0, Register:i64 %4, t72
Legal node: nothing to do

Combining: t74: ch = CopyToReg t0, Register:i64 %4, t72

Legalizing: t79: ch = CopyToReg t0, Register:i64 %5, t77
Legal node: nothing to do

Combining: t79: ch = CopyToReg t0, Register:i64 %5, t77

Legalizing: t84: ch = CopyToReg t0, Register:i64 %6, t82
Legal node: nothing to do

Combining: t84: ch = CopyToReg t0, Register:i64 %6, t82

Legalizing: t88: ch = CopyToReg t0, Register:i64 %7, t86
Legal node: nothing to do

Combining: t88: ch = CopyToReg t0, Register:i64 %7, t86

Legalizing: t93: ch = CopyToReg t0, Register:i64 %8, t91
Legal node: nothing to do

Combining: t93: ch = CopyToReg t0, Register:i64 %8, t91

Legalizing: t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64
Legalizing non-extending load operation

Combining: t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64

Legalizing: t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64
Legalizing non-extending load operation

Combining: t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64

Legalizing: t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64
Legalizing non-extending load operation

Combining: t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64

Legalizing: t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64
Legalizing non-extending load operation

Combining: t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64

Legalizing: t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64
Legalizing non-extending load operation

Combining: t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64

Legalizing: t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64
Legalizing non-extending load operation

Combining: t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64

Legalizing: t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64
Legalizing non-extending load operation

Combining: t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64

Legalizing: t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64
Legalizing non-extending load operation

Combining: t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64

Legalizing: t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64
Legalizing non-extending load operation

Combining: t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64

Legalizing: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1

Combining: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1

Legalizing: t54: ch,glue = X86ISD::CALL t53, t130, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1
Legal node: nothing to do

Combining: t54: ch,glue = X86ISD::CALL t53, t130, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1

Legalizing: t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1
Legal node: nothing to do

Combining: t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1

Legalizing: t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1
Legal node: nothing to do

Combining: t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1

Legalizing: t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1
Legal node: nothing to do

Combining: t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1

Legalizing: t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1
Legal node: nothing to do

Combining: t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1

Legalizing: t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1
Legal node: nothing to do

Combining: t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1

Legalizing: t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>
Legal node: nothing to do

Combining: t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>

Legalizing: t41: ch = TokenFactor t38, t40
Legal node: nothing to do

Combining: t41: ch = TokenFactor t38, t40

Legalizing: t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64

Legalizing: t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64

Legalizing: t39: i64 = add t37, Constant:i64<8>
Legal node: nothing to do

Combining: t39: i64 = add t37, Constant:i64<8>

Legalizing: t37: i64,ch = CopyFromReg t35, Register:i64 $rsp
Legal node: nothing to do

Combining: t37: i64,ch = CopyFromReg t35, Register:i64 $rsp

Legalizing: t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>

Combining: t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>

Legalizing: t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120
Legal node: nothing to do

Combining: t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120

Legalizing: t15: ch = store<(store (s64) into %ir.2)> t9, t11, FrameIndex:i64<0>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t15: ch = store<(store (s64) into %ir.2)> t9, t11, FrameIndex:i64<0>, undef:i64

Legalizing: t18: ch = store<(store (s64) into %ir..fca.1.gep)> t9, t11, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..fca.1.gep)> t9, t11, t17, undef:i64

Legalizing: t59: i64 = add t11, Constant:i64<8>
Legal node: nothing to do

Combining: t59: i64 = add t11, Constant:i64<8>

Legalizing: t63: i64 = add t11, Constant:i64<16>
Legal node: nothing to do

Combining: t63: i64 = add t11, Constant:i64<16>

Legalizing: t67: i64 = add t11, Constant:i64<24>
Legal node: nothing to do

Combining: t67: i64 = add t11, Constant:i64<24>

Legalizing: t71: i64 = add t11, Constant:i64<32>
Legal node: nothing to do

Combining: t71: i64 = add t11, Constant:i64<32>

Legalizing: t76: i64 = add t11, Constant:i64<40>
Legal node: nothing to do

Combining: t76: i64 = add t11, Constant:i64<40>

Legalizing: t81: i64 = add t11, Constant:i64<48>
Legal node: nothing to do

Combining: t81: i64 = add t11, Constant:i64<48>

Legalizing: t85: i64 = add t11, Constant:i64<56>
Legal node: nothing to do

Combining: t85: i64 = add t11, Constant:i64<56>

Legalizing: t90: i64 = add t11, Constant:i64<64>
Legal node: nothing to do

Combining: t90: i64 = add t11, Constant:i64<64>

Legalizing: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
Legal node: nothing to do

Combining: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1

Legalizing: t21: ch = store<(store (s64) into %ir..fca.2.gep)> t9, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..fca.2.gep)> t9, Constant:i64<0>, t20, undef:i64

Legalizing: t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t9, Constant:i64<7>, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t9, Constant:i64<7>, t23, undef:i64

Legalizing: t120: ch = store<(store (s64) into %ir..fca.4.0.gep)> t9, Constant:i64<1>, t27, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t120: ch = store<(store (s64) into %ir..fca.4.0.gep)> t9, Constant:i64<1>, t27, undef:i64

Legalizing: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1

Combining: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1

Legalizing: t8: ch,glue = X86ISD::CALL t6, t132, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal node: nothing to do

Combining: t8: ch,glue = X86ISD::CALL t6, t132, Register:i64 $rdi, RegisterMask:Untyped, t6:1

Legalizing: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>
Legal node: nothing to do

Combining: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>

Legalizing: t27: i64 = add nuw FrameIndex:i64<0>, Constant:i64<32>
Legal node: nothing to do

Combining: t27: i64 = add nuw FrameIndex:i64<0>, Constant:i64<32>

Legalizing: t23: i64 = add nuw FrameIndex:i64<0>, Constant:i64<24>
Legal node: nothing to do

Combining: t23: i64 = add nuw FrameIndex:i64<0>, Constant:i64<24>

Legalizing: t20: i64 = add nuw FrameIndex:i64<0>, Constant:i64<16>
Legal node: nothing to do

Combining: t20: i64 = add nuw FrameIndex:i64<0>, Constant:i64<16>

Legalizing: t17: i64 = add nuw FrameIndex:i64<0>, Constant:i64<8>
Legal node: nothing to do

Combining: t17: i64 = add nuw FrameIndex:i64<0>, Constant:i64<8>

Legalizing: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t113: ch = BasicBlock<.lr.ph.preheader 0x7fee590536d0>
Legal node: nothing to do

Combining: t113: ch = BasicBlock<.lr.ph.preheader 0x7fee590536d0>

Legalizing: t111: ch = BasicBlock<._crit_edge 0x7fee590537d0>
Legal node: nothing to do

Combining: t111: ch = BasicBlock<._crit_edge 0x7fee590537d0>

Legalizing: t104: i64 = Register %10

Combining: t104: i64 = Register %10

Legalizing: t96: i64 = Register %9

Combining: t96: i64 = Register %9

Legalizing: t94: i8 = Constant<3>
Legal node: nothing to do

Combining: t94: i8 = Constant<3>

Legalizing: t92: i64 = Register %8

Combining: t92: i64 = Register %8

Legalizing: t89: i64 = Constant<64>
Legal node: nothing to do

Combining: t89: i64 = Constant<64>

Legalizing: t87: i64 = Register %7

Combining: t87: i64 = Register %7

Legalizing: t83: i64 = Register %6

Combining: t83: i64 = Register %6

Legalizing: t80: i64 = Constant<48>
Legal node: nothing to do

Combining: t80: i64 = Constant<48>

Legalizing: t78: i64 = Register %5

Combining: t78: i64 = Register %5

Legalizing: t75: i64 = Constant<40>
Legal node: nothing to do

Combining: t75: i64 = Constant<40>

Legalizing: t73: i64 = Register %4

Combining: t73: i64 = Register %4

Legalizing: t69: i64 = Register %3

Combining: t69: i64 = Register %3

Legalizing: t65: i64 = Register %2

Combining: t65: i64 = Register %2

Legalizing: t61: i64 = Register %1

Combining: t61: i64 = Register %1

Legalizing: t57: i64 = Register %0

Combining: t57: i64 = Register %0

Legalizing: t52: i64 = Register $r9

Combining: t52: i64 = Register $r9

Legalizing: t50: i64 = Register $r8

Combining: t50: i64 = Register $r8

Legalizing: t48: i64 = Register $rcx

Combining: t48: i64 = Register $rcx

Legalizing: t46: i64 = Register $rdx

Combining: t46: i64 = Register $rdx

Legalizing: t44: i64 = Register $rsi

Combining: t44: i64 = Register $rsi

Legalizing: t42: i32 = Register $edi

Combining: t42: i32 = Register $edi

Legalizing: t36: i64 = Register $rsp

Combining: t36: i64 = Register $rsp

Legalizing: t34: i64 = TargetConstant<16>

Combining: t34: i64 = TargetConstant<16>

Legalizing: t33: i64 = Constant<-1>
Legal node: nothing to do

Combining: t33: i64 = Constant<-1>

Legalizing: t32: i64 = Constant<3>
Legal node: nothing to do

Combining: t32: i64 = Constant<3>

Legalizing: t31: i32 = Constant<1>
Legal node: nothing to do

Combining: t31: i32 = Constant<1>

Legalizing: t28: i64 = Constant<1>
Legal node: nothing to do

Combining: t28: i64 = Constant<1>

Legalizing: t26: i64 = Constant<32>
Legal node: nothing to do

Combining: t26: i64 = Constant<32>

Legalizing: t24: i64 = Constant<7>
Legal node: nothing to do

Combining: t24: i64 = Constant<7>

Legalizing: t22: i64 = Constant<24>
Legal node: nothing to do

Combining: t22: i64 = Constant<24>

Legalizing: t19: i64 = Constant<16>
Legal node: nothing to do

Combining: t19: i64 = Constant<16>

Legalizing: t16: i64 = Constant<8>
Legal node: nothing to do

Combining: t16: i64 = Constant<8>

Legalizing: t14: i64 = undef
Legal node: nothing to do

Combining: t14: i64 = undef

Legalizing: t13: i64 = Constant<0>
Legal node: nothing to do

Combining: t13: i64 = Constant<0>

Legalizing: t12: i64 = FrameIndex<0>
Legal node: nothing to do

Combining: t12: i64 = FrameIndex<0>

Legalizing: t10: i64 = Register $rax

Combining: t10: i64 = Register $rax

Legalizing: t7: Untyped = RegisterMask
Legal node: nothing to do

Combining: t7: Untyped = RegisterMask

Legalizing: t5: i64 = Register $rdi

Combining: t5: i64 = Register $rdi

Legalizing: t3: i64 = TargetConstant<0>

Combining: t3: i64 = TargetConstant<0>

Legalizing: t2: i64 = Constant<56>
Legal node: nothing to do

Combining: t2: i64 = Constant<56>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.0 'main:'
SelectionDAG has 116 nodes:
  t0: ch,glue = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>
  t8: ch,glue = X86ISD::CALL t6, t132, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
  t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
      t15: ch = store<(store (s64) into %ir.2)> t9, t11, FrameIndex:i64<0>, undef:i64
        t17: i64 = add nuw FrameIndex:i64<0>, Constant:i64<8>
      t18: ch = store<(store (s64) into %ir..fca.1.gep)> t9, t11, t17, undef:i64
        t20: i64 = add nuw FrameIndex:i64<0>, Constant:i64<16>
      t21: ch = store<(store (s64) into %ir..fca.2.gep)> t9, Constant:i64<0>, t20, undef:i64
        t23: i64 = add nuw FrameIndex:i64<0>, Constant:i64<24>
      t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t9, Constant:i64<7>, t23, undef:i64
        t27: i64 = add nuw FrameIndex:i64<0>, Constant:i64<32>
      t120: ch = store<(store (s64) into %ir..fca.4.0.gep)> t9, Constant:i64<1>, t27, undef:i64
    t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120
  t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>
  t37: i64,ch = CopyFromReg t35, Register:i64 $rsp
      t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64
        t39: i64 = add t37, Constant:i64<8>
      t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64
    t41: ch = TokenFactor t38, t40
  t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>
  t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1
  t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1
  t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1
  t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1
  t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1
    t130: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0
  t54: ch,glue = X86ISD::CALL t53, t130, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1
  t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
    t90: i64 = add t11, Constant:i64<64>
  t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64
    t85: i64 = add t11, Constant:i64<56>
  t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64
    t81: i64 = add t11, Constant:i64<48>
  t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64
    t76: i64 = add t11, Constant:i64<40>
  t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64
    t71: i64 = add t11, Constant:i64<32>
  t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64
    t67: i64 = add t11, Constant:i64<24>
  t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64
    t63: i64 = add t11, Constant:i64<16>
  t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64
    t59: i64 = add t11, Constant:i64<8>
  t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64
  t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64
  t95: i64 = shl t56, Constant:i8<3>
      t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1
    t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>
  t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95
  t101: ch,glue = X86ISD::CALL t100, t132, Register:i64 $rdi, RegisterMask:Untyped, t100:1
  t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1
  t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1
  t132: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
        t58: ch = CopyToReg t0, Register:i64 %0, t56
        t62: ch = CopyToReg t0, Register:i64 %1, t60
        t66: ch = CopyToReg t0, Register:i64 %2, t64
        t70: ch = CopyToReg t0, Register:i64 %3, t68
        t74: ch = CopyToReg t0, Register:i64 %4, t72
        t79: ch = CopyToReg t0, Register:i64 %5, t77
        t84: ch = CopyToReg t0, Register:i64 %6, t82
        t88: ch = CopyToReg t0, Register:i64 %7, t86
        t93: ch = CopyToReg t0, Register:i64 %8, t91
        t97: ch = CopyToReg t0, Register:i64 %9, t95
        t105: ch = CopyToReg t0, Register:i64 %10, t103
      t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1
      t126: i32 = X86ISD::CMP t56, Constant:i64<0>
    t128: ch = X86ISD::BRCOND t110, BasicBlock:ch<._crit_edge 0x7fee590537d0>, TargetConstant:i8<14>, t126
  t114: ch = br t128, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>


===== Instruction selection begins: %bb.0 ''

ISEL: Starting selection on root node: t114: ch = br t128, BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>
ISEL: Starting pattern match
  Morphed node: t114: ch = JMP_1 BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>, t128
ISEL: Match complete!

ISEL: Starting selection on root node: t128: ch = X86ISD::BRCOND t110, BasicBlock:ch<._crit_edge 0x7fee590537d0>, TargetConstant:i8<14>, t126
ISEL: Starting pattern match
  Initial Opcode index to 131614
Creating new node: t134: ch,glue = CopyToReg t110, Register:i32 $eflags, t126
  Morphed node: t128: ch = JCC_1 BasicBlock:ch<._crit_edge 0x7fee590537d0>, TargetConstant:i8<14>, t134, t134:1
ISEL: Match complete!

ISEL: Starting selection on root node: t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1

ISEL: Starting selection on root node: t105: ch = CopyToReg t0, Register:i64 %10, t103

ISEL: Starting selection on root node: t103: i64,ch,glue = CopyFromReg t102, Register:i64 $rax, t102:1

ISEL: Starting selection on root node: t102: ch,glue = callseq_end t101, TargetConstant:i64<0>, TargetConstant:i64<0>, t101:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t102: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t101, t101:1
ISEL: Match complete!

ISEL: Starting selection on root node: t101: ch,glue = X86ISD::CALL t100, t132, Register:i64 $rdi, RegisterMask:Untyped, t100:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t101: ch,glue = CALL64r t132, Register:i64 $rdi, RegisterMask:Untyped, t100, t100:1
ISEL: Match complete!

ISEL: Starting selection on root node: t100: ch,glue = CopyToReg t99, Register:i64 $rdi, t95

ISEL: Starting selection on root node: t97: ch = CopyToReg t0, Register:i64 %9, t95

ISEL: Starting selection on root node: t99: ch,glue = callseq_start t98, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t135: i32 = TargetConstant<0>
  Morphed node: t99: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t98
ISEL: Match complete!

ISEL: Starting selection on root node: t58: ch = CopyToReg t0, Register:i64 %0, t56

ISEL: Starting selection on root node: t95: i64 = shl t56, Constant:i8<3>
ISEL: Starting pattern match
  Initial Opcode index to 44725
  Match failed at index 44734
  Continuing at 44944
  TypeSwitch[i64] from 44946 to 44987
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 44987
  Continuing at 45002
  Match failed at index 45009
  Continuing at 45152
  Match failed at index 45153
  Continuing at 45203
  TypeSwitch[i64] from 45215 to 45257
Creating constant: t137: i8 = TargetConstant<3>
  Morphed node: t95: i64,i32 = SHL64ri t56, TargetConstant:i8<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1

ISEL: Starting selection on root node: t126: i32 = X86ISD::CMP t56, Constant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 25710
  OpcodeSwitch from 25714 to 26213
  Match failed at index 26215
  Continuing at 26614
  Skipped scope entry (due to false predicate) at index 26619, continuing at 26650
  Skipped scope entry (due to false predicate) at index 26651, continuing at 26682
  Skipped scope entry (due to false predicate) at index 26683, continuing at 26714
  Match failed at index 26718
  Continuing at 26746
  Continuing at 26747
  OpcodeSwitch from 26750 to 26754
  Match failed at index 26756
  Continuing at 27134
  Skipped scope entry (due to false predicate) at index 27139, continuing at 27203
  Skipped scope entry (due to false predicate) at index 27204, continuing at 27304
  Skipped scope entry (due to false predicate) at index 27305, continuing at 27405
  Morphed node: t126: i32 = TEST64rr t56, t56
ISEL: Match complete!

ISEL: Starting selection on root node: t62: ch = CopyToReg t0, Register:i64 %1, t60

ISEL: Starting selection on root node: t66: ch = CopyToReg t0, Register:i64 %2, t64

ISEL: Starting selection on root node: t70: ch = CopyToReg t0, Register:i64 %3, t68

ISEL: Starting selection on root node: t74: ch = CopyToReg t0, Register:i64 %4, t72

ISEL: Starting selection on root node: t79: ch = CopyToReg t0, Register:i64 %5, t77

ISEL: Starting selection on root node: t84: ch = CopyToReg t0, Register:i64 %6, t82

ISEL: Starting selection on root node: t88: ch = CopyToReg t0, Register:i64 %7, t86

ISEL: Starting selection on root node: t93: ch = CopyToReg t0, Register:i64 %8, t91

ISEL: Starting selection on root node: t56: i64,ch = load<(load (s64) from %ir.1, align 4)> t55, t11, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 118182
  Match failed at index 118191
  Continuing at 118208
  Match failed at index 118211
  Continuing at 118228
  Match failed at index 118231
  Continuing at 118248
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t138: i8 = TargetConstant<1>
  Morphed node: t56: i64,ch = MOV64rm<Mem:(load (s64) from %ir.1, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t55
ISEL: Match complete!

ISEL: Starting selection on root node: t60: i64,ch = load<(load (s64) from %ir.4, align 4)> t55, t59, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 118182
  Match failed at index 118191
  Continuing at 118208
  Match failed at index 118211
  Continuing at 118228
  Match failed at index 118231
  Continuing at 118248
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t141: i32 = TargetConstant<8>
  Morphed node: t60: i64,ch = MOV64rm<Mem:(load (s64) from %ir.4, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, t55
ISEL: Match complete!

ISEL: Starting selection on root node: t64: i64,ch = load<(load (s64) from %ir.6, align 4)> t55, t63, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 118182
  Match failed at index 118191
  Continuing at 118208
  Match failed at index 118211
  Continuing at 118228
  Match failed at index 118231
  Continuing at 118248
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t142: i32 = TargetConstant<16>
  Morphed node: t64: i64,ch = MOV64rm<Mem:(load (s64) from %ir.6, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t55
ISEL: Match complete!

ISEL: Starting selection on root node: t68: i64,ch = load<(load (s64) from %ir.8, align 4)> t55, t67, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 118182
  Match failed at index 118191
  Continuing at 118208
  Match failed at index 118211
  Continuing at 118228
  Match failed at index 118231
  Continuing at 118248
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t143: i32 = TargetConstant<24>
  Morphed node: t68: i64,ch = MOV64rm<Mem:(load (s64) from %ir.8, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, t55
ISEL: Match complete!

ISEL: Starting selection on root node: t72: i64,ch = load<(load (s64) from %ir.10, align 4)> t55, t71, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 118182
  Match failed at index 118191
  Continuing at 118208
  Match failed at index 118211
  Continuing at 118228
  Match failed at index 118231
  Continuing at 118248
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t144: i32 = TargetConstant<32>
  Morphed node: t72: i64,ch = MOV64rm<Mem:(load (s64) from %ir.10, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t55
ISEL: Match complete!

ISEL: Starting selection on root node: t77: i64,ch = load<(load (s64) from %ir.12, align 4)> t55, t76, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 118182
  Match failed at index 118191
  Continuing at 118208
  Match failed at index 118211
  Continuing at 118228
  Match failed at index 118231
  Continuing at 118248
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t145: i32 = TargetConstant<40>
  Morphed node: t77: i64,ch = MOV64rm<Mem:(load (s64) from %ir.12, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, t55
ISEL: Match complete!

ISEL: Starting selection on root node: t82: i64,ch = load<(load (s64) from %ir.14, align 4)> t55, t81, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 118182
  Match failed at index 118191
  Continuing at 118208
  Match failed at index 118211
  Continuing at 118228
  Match failed at index 118231
  Continuing at 118248
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t146: i32 = TargetConstant<48>
  Morphed node: t82: i64,ch = MOV64rm<Mem:(load (s64) from %ir.14, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t55
ISEL: Match complete!

ISEL: Starting selection on root node: t86: i64,ch = load<(load (s64) from %ir.16, align 4)> t55, t85, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 118182
  Match failed at index 118191
  Continuing at 118208
  Match failed at index 118211
  Continuing at 118228
  Match failed at index 118231
  Continuing at 118248
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t147: i32 = TargetConstant<56>
  Morphed node: t86: i64,ch = MOV64rm<Mem:(load (s64) from %ir.16, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, t55
ISEL: Match complete!

ISEL: Starting selection on root node: t91: i64,ch = load<(load (s64) from %ir.18, align 4)> t55, t90, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 118182
  Match failed at index 118191
  Continuing at 118208
  Match failed at index 118211
  Continuing at 118228
  Match failed at index 118231
  Continuing at 118248
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t148: i32 = TargetConstant<64>
  Morphed node: t91: i64,ch = MOV64rm<Mem:(load (s64) from %ir.18, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t55
ISEL: Match complete!

ISEL: Starting selection on root node: t55: ch,glue = callseq_end t54, TargetConstant:i64<16>, TargetConstant:i64<0>, t54:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t55: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<16>, TargetConstant:i64<0>, t54, t54:1
ISEL: Match complete!

ISEL: Starting selection on root node: t54: ch,glue = X86ISD::CALL t53, t130, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t54: ch,glue = CALL64r t130, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53, t53:1
ISEL: Match complete!

ISEL: Starting selection on root node: t53: ch,glue = CopyToReg t51, Register:i64 $r9, Constant:i64<1>, t51:1

ISEL: Starting selection on root node: t51: ch,glue = CopyToReg t49, Register:i64 $r8, Constant:i64<-1>, t49:1

ISEL: Starting selection on root node: t49: ch,glue = CopyToReg t47, Register:i64 $rcx, Constant:i64<0>, t47:1

ISEL: Starting selection on root node: t47: ch,glue = CopyToReg t45, Register:i64 $rdx, Constant:i64<3>, t45:1

ISEL: Starting selection on root node: t45: ch,glue = CopyToReg t43, Register:i64 $rsi, Constant:i64<0>, t43:1

ISEL: Starting selection on root node: t43: ch,glue = CopyToReg t41, Register:i32 $edi, Constant:i32<1>

ISEL: Starting selection on root node: t41: ch = TokenFactor t38, t40

ISEL: Starting selection on root node: t40: ch = store<(store (s32) into stack + 8)> t35, Constant:i32<1>, t39, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  TypeSwitch[i32] from 16336 to 16389
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t37: i64,ch = CopyFromReg t35, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t149: i32 = TargetConstant<1>
  Morphed node: t40: ch = MOV32mi<Mem:(store (s32) into stack + 8)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i32<1>, t35
ISEL: Match complete!

ISEL: Starting selection on root node: t38: ch = store<(store (s64) into stack)> t35, FrameIndex:i64<0>, t37, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Morphed node: t38: ch = MOV64mr<Mem:(store (s64) into stack)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, FrameIndex:i64<0>, t35
ISEL: Match complete!

ISEL: Starting selection on root node: t37: i64,ch = CopyFromReg t35, Register:i64 $rsp

ISEL: Starting selection on root node: t35: ch,glue = callseq_start t121, TargetConstant:i64<16>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t35: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<16>, TargetConstant:i64<0>, TargetConstant:i32<0>, t121
ISEL: Match complete!

ISEL: Starting selection on root node: t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120

ISEL: Starting selection on root node: t15: ch = store<(store (s64) into %ir.2)> t9, t11, FrameIndex:i64<0>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Morphed node: t15: ch = MOV64mr<Mem:(store (s64) into %ir.2)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11, t9
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch = store<(store (s64) into %ir..fca.1.gep)> t9, t11, t17, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Base.FrameIndex 0
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Morphed node: t18: ch = MOV64mr<Mem:(store (s64) into %ir..fca.1.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, t11, t9
ISEL: Match complete!

ISEL: Starting selection on root node: t11: i64,ch,glue = CopyFromReg t9, Register:i64 $rax, t9:1

ISEL: Starting selection on root node: t21: ch = store<(store (s64) into %ir..fca.2.gep)> t9, Constant:i64<0>, t20, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Skipped scope entry (due to false predicate) at index 16132, continuing at 16162
  Skipped scope entry (due to false predicate) at index 16163, continuing at 16193
  Match failed at index 16203
  Continuing at 16224
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Base.FrameIndex 0
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Morphed node: t21: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.2.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, TargetConstant:i64<0>, t9
ISEL: Match complete!

ISEL: Starting selection on root node: t25: ch = store<(store (s64) into %ir..fca.3.0.gep)> t9, Constant:i64<7>, t23, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Base.FrameIndex 0
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t151: i64 = TargetConstant<7>
  Morphed node: t25: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.3.0.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<7>, t9
ISEL: Match complete!

ISEL: Starting selection on root node: t120: ch = store<(store (s64) into %ir..fca.4.0.gep)> t9, Constant:i64<1>, t27, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Base.FrameIndex 0
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t152: i64 = TargetConstant<1>
  Morphed node: t120: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.4.0.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, TargetConstant:i64<1>, t9
ISEL: Match complete!

ISEL: Starting selection on root node: t9: ch,glue = callseq_end t8, TargetConstant:i64<0>, TargetConstant:i64<0>, t8:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t9: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t8, t8:1
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch,glue = X86ISD::CALL t6, t132, Register:i64 $rdi, RegisterMask:Untyped, t6:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t8: ch,glue = CALL64r t132, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<56>

ISEL: Starting selection on root node: t132: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132007
  Match failed at index 132010
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t132: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t130: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132007
  Match failed at index 132010
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t130: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t131: i64 = TargetGlobalAddress<ptr @malloc> 0

ISEL: Starting selection on root node: t129: i64 = TargetGlobalAddress<ptr @read_input_sizes_2D_f64> 0

ISEL: Starting selection on root node: t127: i8 = TargetConstant<14>

ISEL: Starting selection on root node: t113: ch = BasicBlock<.lr.ph.preheader 0x7fee590536d0>

ISEL: Starting selection on root node: t111: ch = BasicBlock<._crit_edge 0x7fee590537d0>

ISEL: Starting selection on root node: t104: i64 = Register %10

ISEL: Starting selection on root node: t96: i64 = Register %9

ISEL: Starting selection on root node: t92: i64 = Register %8

ISEL: Starting selection on root node: t87: i64 = Register %7

ISEL: Starting selection on root node: t83: i64 = Register %6

ISEL: Starting selection on root node: t78: i64 = Register %5

ISEL: Starting selection on root node: t73: i64 = Register %4

ISEL: Starting selection on root node: t69: i64 = Register %3

ISEL: Starting selection on root node: t65: i64 = Register %2

ISEL: Starting selection on root node: t61: i64 = Register %1

ISEL: Starting selection on root node: t57: i64 = Register %0

ISEL: Starting selection on root node: t52: i64 = Register $r9

ISEL: Starting selection on root node: t50: i64 = Register $r8

ISEL: Starting selection on root node: t48: i64 = Register $rcx

ISEL: Starting selection on root node: t46: i64 = Register $rdx

ISEL: Starting selection on root node: t44: i64 = Register $rsi

ISEL: Starting selection on root node: t42: i32 = Register $edi

ISEL: Starting selection on root node: t36: i64 = Register $rsp

ISEL: Starting selection on root node: t34: i64 = TargetConstant<16>

ISEL: Starting selection on root node: t33: i64 = Constant<-1>
ISEL: Starting pattern match
  Initial Opcode index to 127987
  Skipped scope entry (due to false predicate) at index 127989, continuing at 128066
  Skipped scope entry (due to false predicate) at index 128067, continuing at 128104
  Match failed at index 128107
  Continuing at 128142
  TypeSwitch[i64] from 128144 to 128175
  Match failed at index 128179
  Continuing at 128190
  Match failed at index 128191
  Continuing at 128202
Creating constant: t153: i64 = TargetConstant<-1>
  Morphed node: t33: i64 = MOV64ri32 TargetConstant:i64<-1>
ISEL: Match complete!

ISEL: Starting selection on root node: t32: i64 = Constant<3>
ISEL: Starting pattern match
  Initial Opcode index to 127987
  Skipped scope entry (due to false predicate) at index 127989, continuing at 128066
  Skipped scope entry (due to false predicate) at index 128067, continuing at 128104
  Skipped scope entry (due to false predicate) at index 128105, continuing at 128142
  TypeSwitch[i64] from 128144 to 128175
  Match failed at index 128179
  Continuing at 128190
Creating constant: t154: i64 = TargetConstant<3>
  Morphed node: t32: i64 = MOV32ri64 TargetConstant:i64<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t31: i32 = Constant<1>
ISEL: Starting pattern match
  Initial Opcode index to 127987
  Skipped scope entry (due to false predicate) at index 127989, continuing at 128066
  TypeSwitch[i32] from 128069 to 128072
  Match failed at index 128072
  Continuing at 128104
  Match failed at index 128105
  Continuing at 128142
  TypeSwitch[i32] from 128144 to 128147
  Match failed at index 128151
  Continuing at 128162
  Morphed node: t31: i32 = MOV32ri TargetConstant:i32<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t28: i64 = Constant<1>
ISEL: Starting pattern match
  Initial Opcode index to 127987
  Skipped scope entry (due to false predicate) at index 127989, continuing at 128066
  Match failed at index 128069
  Continuing at 128104
  Match failed at index 128105
  Continuing at 128142
  TypeSwitch[i64] from 128144 to 128175
  Match failed at index 128179
  Continuing at 128190
  Morphed node: t28: i64 = MOV32ri64 TargetConstant:i64<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t13: i64 = Constant<0>
ISEL: Starting pattern match
  Initial Opcode index to 127987
  TypeSwitch[i64] from 127991 to 128043
Creating new machine node: t155: i32,i32 = MOV32r0
  Created node: t155: i32,i32 = MOV32r0
Creating constant: t156: i32 = TargetConstant<6>
  Morphed node: t13: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>
ISEL: Match complete!

ISEL: Starting selection on root node: t12: i64 = FrameIndex<0>
ISEL: Starting pattern match
  Initial Opcode index to 127314
  TypeSwitch[i64] from 127315 to 127356
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Morphed node: t12: i64 = LEA64r TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg
ISEL: Match complete!

ISEL: Starting selection on root node: t10: i64 = Register $rax

ISEL: Starting selection on root node: t7: Untyped = RegisterMask

ISEL: Starting selection on root node: t5: i64 = Register $rdi

ISEL: Starting selection on root node: t3: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t2: i64 = Constant<56>
ISEL: Starting pattern match
  Initial Opcode index to 127987
  Skipped scope entry (due to false predicate) at index 127989, continuing at 128066
  Skipped scope entry (due to false predicate) at index 128067, continuing at 128104
  Skipped scope entry (due to false predicate) at index 128105, continuing at 128142
  TypeSwitch[i64] from 128144 to 128175
  Match failed at index 128179
  Continuing at 128190
Creating constant: t157: i64 = TargetConstant<56>
  Morphed node: t2: i64 = MOV32ri64 TargetConstant:i64<56>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'main:'
SelectionDAG has 118 nodes:
  t0: ch,glue = EntryToken
  t13: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>
  t132: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
    t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t2: i64 = MOV32ri64 TargetConstant:i64<56>
  t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t2
  t8: ch,glue = CALL64r t132, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1
  t9: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t8, t8:1
  t11: i64,ch,glue = CopyFromReg t9:1, Register:i64 $rax, t9:2
      t15: ch = MOV64mr<Mem:(store (s64) into %ir.2)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11, t9:1
      t18: ch = MOV64mr<Mem:(store (s64) into %ir..fca.1.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, t11, t9:1
      t21: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.2.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, TargetConstant:i64<0>, t9:1
      t25: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.3.0.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<7>, t9:1
      t120: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.4.0.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, TargetConstant:i64<1>, t9:1
    t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120
  t35: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<16>, TargetConstant:i64<0>, TargetConstant:i32<0>, t121
  t37: i64,ch = CopyFromReg t35:1, Register:i64 $rsp
        t12: i64 = LEA64r TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg
      t38: ch = MOV64mr<Mem:(store (s64) into stack)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t12, t35:1
      t40: ch = MOV32mi<Mem:(store (s32) into stack + 8)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i32<1>, t35:1
    t41: ch = TokenFactor t38, t40
    t31: i32 = MOV32ri TargetConstant:i32<1>
  t43: ch,glue = CopyToReg t41, Register:i32 $edi, t31
  t45: ch,glue = CopyToReg t43, Register:i64 $rsi, t13, t43:1
    t32: i64 = MOV32ri64 TargetConstant:i64<3>
  t47: ch,glue = CopyToReg t45, Register:i64 $rdx, t32, t45:1
  t49: ch,glue = CopyToReg t47, Register:i64 $rcx, t13, t47:1
    t33: i64 = MOV64ri32 TargetConstant:i64<-1>
  t51: ch,glue = CopyToReg t49, Register:i64 $r8, t33, t49:1
    t28: i64 = MOV32ri64 TargetConstant:i64<1>
  t53: ch,glue = CopyToReg t51, Register:i64 $r9, t28, t51:1
    t130: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0
  t54: ch,glue = CALL64r t130, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53, t53:1
  t55: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<16>, TargetConstant:i64<0>, t54, t54:1
  t91: i64,ch = MOV64rm<Mem:(load (s64) from %ir.18, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t55:1
  t86: i64,ch = MOV64rm<Mem:(load (s64) from %ir.16, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, t55:1
  t82: i64,ch = MOV64rm<Mem:(load (s64) from %ir.14, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t55:1
  t77: i64,ch = MOV64rm<Mem:(load (s64) from %ir.12, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, t55:1
  t72: i64,ch = MOV64rm<Mem:(load (s64) from %ir.10, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t55:1
  t68: i64,ch = MOV64rm<Mem:(load (s64) from %ir.8, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, t55:1
  t64: i64,ch = MOV64rm<Mem:(load (s64) from %ir.6, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t55:1
  t60: i64,ch = MOV64rm<Mem:(load (s64) from %ir.4, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, t55:1
  t56: i64,ch = MOV64rm<Mem:(load (s64) from %ir.1, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t55:1
  t95: i64,i32 = SHL64ri t56, TargetConstant:i8<3>
      t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1
    t99: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t98
  t100: ch,glue = CopyToReg t99:1, Register:i64 $rdi, t95
  t101: ch,glue = CALL64r t132, Register:i64 $rdi, RegisterMask:Untyped, t100, t100:1
  t102: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t101, t101:1
  t103: i64,ch,glue = CopyFromReg t102:1, Register:i64 $rax, t102:2
      t58: ch = CopyToReg t0, Register:i64 %0, t56
      t62: ch = CopyToReg t0, Register:i64 %1, t60
      t66: ch = CopyToReg t0, Register:i64 %2, t64
      t70: ch = CopyToReg t0, Register:i64 %3, t68
      t74: ch = CopyToReg t0, Register:i64 %4, t72
      t79: ch = CopyToReg t0, Register:i64 %5, t77
      t84: ch = CopyToReg t0, Register:i64 %6, t82
      t88: ch = CopyToReg t0, Register:i64 %7, t86
      t93: ch = CopyToReg t0, Register:i64 %8, t91
      t97: ch = CopyToReg t0, Register:i64 %9, t95
      t105: ch = CopyToReg t0, Register:i64 %10, t103
    t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1
    t126: i32 = TEST64rr t56, t56
  t134: ch,glue = CopyToReg t110, Register:i32 $eflags, t126
  t136: i32 = Register $noreg
    t128: ch = JCC_1 BasicBlock:ch<._crit_edge 0x7fee590537d0>, TargetConstant:i8<14>, t134, t134:1
  t114: ch = JMP_1 BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>, t128


********** List Scheduling %bb.0 '' **********
SU(0): t114: ch = JMP_1 BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>, t128

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t128: ch = JCC_1 BasicBlock:ch<._crit_edge 0x7fee590537d0>, TargetConstant:i8<14>, t134, t134:1

    t134: ch,glue = CopyToReg t110, Register:i32 $eflags, t126

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 11
  Height             : 1
  Predecessors:
    SU(28): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t126: i32 = TEST64rr t56, t56

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t60: i64,ch = MOV64rm<Mem:(load (s64) from %ir.4, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, t55:1, t56:2

    t56: i64,ch,glue = MOV64rm<Mem:(load (s64) from %ir.1, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t55:1

  # preds left       : 2
  # succs left       : 5
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 5
  Predecessors:
    SU(16): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(2): Data Latency=1
    SU(30): Data Latency=1
    SU(32): Ord  Latency=1 Barrier
    SU(49): Data Latency=1
    SU(50): Data Latency=1
SU(4): t55: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<16>, TargetConstant:i64<0>, t54, t54:1

    t43: ch,glue = CopyToReg t41, Register:i32 $edi, t31

    t45: ch,glue = CopyToReg t43, Register:i64 $rsi, t13, t43:1

    t47: ch,glue = CopyToReg t45, Register:i64 $rdx, t32, t45:1

    t49: ch,glue = CopyToReg t47, Register:i64 $rcx, t13, t47:1

    t51: ch,glue = CopyToReg t49, Register:i64 $r8, t33, t49:1

    t53: ch,glue = CopyToReg t51, Register:i64 $r9, t28, t51:1

    t54: ch,glue = CALL64r t130, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53, t53:1

  # preds left       : 7
  # succs left       : 8
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 6
  Predecessors:
    SU(27): Data Latency=1
    SU(5): Data Latency=1
    SU(6): Data Latency=1
    SU(7): Data Latency=1
    SU(9): Data Latency=1
    SU(11): Ord  Latency=0 Barrier
    SU(10): Data Latency=1
  Successors:
    SU(3): Ord  Latency=1 Barrier
    SU(33): Ord  Latency=1 Barrier
    SU(34): Ord  Latency=1 Barrier
    SU(35): Ord  Latency=1 Barrier
    SU(36): Ord  Latency=1 Barrier
    SU(37): Ord  Latency=1 Barrier
    SU(38): Ord  Latency=1 Barrier
    SU(39): Ord  Latency=1 Barrier
SU(5): t28: i64 = MOV32ri64 TargetConstant:i64<1>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(4): Data Latency=1
SU(6): t33: i64 = MOV64ri32 TargetConstant:i64<-1>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(4): Data Latency=1
SU(7): t13: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 7
  Predecessors:
    SU(8): Data Latency=1
  Successors:
    SU(4): Data Latency=1
SU(8): t155: i32,i32 = MOV32r0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 8
  Successors:
    SU(7): Data Latency=1
SU(9): t32: i64 = MOV32ri64 TargetConstant:i64<3>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(4): Data Latency=1
SU(10): t31: i32 = MOV32ri TargetConstant:i32<1>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(4): Data Latency=1
SU(11): t41: ch = TokenFactor t38, t40

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 6
  Predecessors:
    SU(25): Ord  Latency=1 Barrier
    SU(12): Ord  Latency=1 Barrier
  Successors:
    SU(4): Ord  Latency=0 Barrier
SU(12): t40: ch = MOV32mi<Mem:(store (s32) into stack + 8)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i32<1>, t35:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 7
  Predecessors:
    SU(24): Data Latency=1
    SU(13): Ord  Latency=1 Barrier
  Successors:
    SU(11): Ord  Latency=1 Barrier
SU(13): t35: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<16>, TargetConstant:i64<0>, TargetConstant:i32<0>, t121

  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 9
  Predecessors:
    SU(14): Ord  Latency=0 Barrier
  Successors:
    SU(12): Ord  Latency=1 Barrier
    SU(24): Ord  Latency=1 Barrier
    SU(25): Ord  Latency=1 Barrier
SU(14): t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120

  # preds left       : 6
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 9
  Predecessors:
    SU(16): Ord  Latency=1 Barrier
    SU(23): Ord  Latency=1 Barrier
    SU(22): Ord  Latency=1 Barrier
    SU(21): Ord  Latency=1 Barrier
    SU(20): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
  Successors:
    SU(13): Ord  Latency=0 Barrier
SU(15): t120: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.4.0.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, TargetConstant:i64<1>, t9:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 10
  Predecessors:
    SU(16): Ord  Latency=1 Barrier
  Successors:
    SU(14): Ord  Latency=1 Barrier
SU(16): t11: i64,ch,glue = CopyFromReg t9:1, Register:i64 $rax, t9:2

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t2

    t8: ch,glue = CALL64r t132, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1

    t9: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t8, t8:1

  # preds left       : 3
  # succs left       : 16
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 11
  Predecessors:
    SU(19): Data Latency=1
    SU(18): Ord  Latency=1 Barrier
    SU(17): Data Latency=1
  Successors:
    SU(3): Data Latency=1
    SU(14): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(20): Ord  Latency=1 Barrier
    SU(21): Ord  Latency=1 Barrier
    SU(22): Data Latency=1
    SU(22): Ord  Latency=1 Barrier
    SU(23): Data Latency=1
    SU(23): Ord  Latency=1 Barrier
    SU(33): Data Latency=1
    SU(34): Data Latency=1
    SU(35): Data Latency=1
    SU(36): Data Latency=1
    SU(37): Data Latency=1
    SU(38): Data Latency=1
    SU(39): Data Latency=1
SU(17): t2: i64 = MOV32ri64 TargetConstant:i64<56>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 12
  Successors:
    SU(16): Data Latency=1
SU(18): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 12
  Successors:
    SU(16): Ord  Latency=1 Barrier
SU(19): t132: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 12
  Successors:
    SU(16): Data Latency=1
    SU(29): Data Latency=1
SU(20): t25: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.3.0.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<7>, t9:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 10
  Predecessors:
    SU(16): Ord  Latency=1 Barrier
  Successors:
    SU(14): Ord  Latency=1 Barrier
SU(21): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.2.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, TargetConstant:i64<0>, t9:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 10
  Predecessors:
    SU(16): Ord  Latency=1 Barrier
  Successors:
    SU(14): Ord  Latency=1 Barrier
SU(22): t18: ch = MOV64mr<Mem:(store (s64) into %ir..fca.1.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, t11, t9:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 10
  Predecessors:
    SU(16): Data Latency=1
    SU(16): Ord  Latency=1 Barrier
  Successors:
    SU(14): Ord  Latency=1 Barrier
SU(23): t15: ch = MOV64mr<Mem:(store (s64) into %ir.2)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11, t9:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 10
  Predecessors:
    SU(16): Data Latency=1
    SU(16): Ord  Latency=1 Barrier
  Successors:
    SU(14): Ord  Latency=1 Barrier
SU(24): t37: i64,ch = CopyFromReg t35:1, Register:i64 $rsp

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 8
  Predecessors:
    SU(13): Ord  Latency=1 Barrier
  Successors:
    SU(12): Data Latency=1
    SU(25): Data Latency=1
SU(25): t38: ch = MOV64mr<Mem:(store (s64) into stack)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t12, t35:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 7
  Predecessors:
    SU(24): Data Latency=1
    SU(26): Data Latency=1
    SU(13): Ord  Latency=1 Barrier
  Successors:
    SU(11): Ord  Latency=1 Barrier
SU(26): t12: i64 = LEA64r TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 8
  Successors:
    SU(25): Data Latency=1
SU(27): t130: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(4): Data Latency=1
SU(28): t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1

  # preds left       : 12
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 11
  Height             : 1
  Predecessors:
    SU(50): Ord  Latency=1 Barrier
    SU(49): Ord  Latency=1 Barrier
    SU(48): Ord  Latency=1 Barrier
    SU(47): Ord  Latency=1 Barrier
    SU(46): Ord  Latency=1 Barrier
    SU(45): Ord  Latency=1 Barrier
    SU(44): Ord  Latency=1 Barrier
    SU(43): Ord  Latency=1 Barrier
    SU(42): Ord  Latency=1 Barrier
    SU(41): Ord  Latency=1 Barrier
    SU(40): Ord  Latency=1 Barrier
    SU(29): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(29): t103: i64,ch,glue = CopyFromReg t102:1, Register:i64 $rax, t102:2

    t100: ch,glue = CopyToReg t99:1, Register:i64 $rdi, t95

    t101: ch,glue = CALL64r t132, Register:i64 $rdi, RegisterMask:Untyped, t100, t100:1

    t102: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t101, t101:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 9
  Height             : 3
  Predecessors:
    SU(19): Data Latency=1
    SU(31): Ord  Latency=1 Barrier
    SU(30): Data Latency=1
  Successors:
    SU(28): Ord  Latency=1 Barrier
    SU(40): Data Latency=1
SU(30): t95: i64,i32 = SHL64ri t56, TargetConstant:i8<3>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(29): Data Latency=1
    SU(41): Data Latency=1
SU(31): t99: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t98

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(32): Ord  Latency=0 Barrier
  Successors:
    SU(29): Ord  Latency=1 Barrier
SU(32): t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1

  # preds left       : 8
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
    SU(39): Ord  Latency=1 Barrier
    SU(38): Ord  Latency=1 Barrier
    SU(37): Ord  Latency=1 Barrier
    SU(36): Ord  Latency=1 Barrier
    SU(35): Ord  Latency=1 Barrier
    SU(34): Ord  Latency=1 Barrier
    SU(33): Ord  Latency=1 Barrier
  Successors:
    SU(31): Ord  Latency=0 Barrier
SU(33): t91: i64,ch = MOV64rm<Mem:(load (s64) from %ir.18, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t55:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 5
  Predecessors:
    SU(16): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(32): Ord  Latency=1 Barrier
    SU(42): Data Latency=1
SU(34): t86: i64,ch = MOV64rm<Mem:(load (s64) from %ir.16, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, t55:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 5
  Predecessors:
    SU(16): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(32): Ord  Latency=1 Barrier
    SU(43): Data Latency=1
SU(35): t82: i64,ch = MOV64rm<Mem:(load (s64) from %ir.14, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t55:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 5
  Predecessors:
    SU(16): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(32): Ord  Latency=1 Barrier
    SU(44): Data Latency=1
SU(36): t77: i64,ch = MOV64rm<Mem:(load (s64) from %ir.12, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, t55:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 5
  Predecessors:
    SU(16): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(32): Ord  Latency=1 Barrier
    SU(45): Data Latency=1
SU(37): t72: i64,ch = MOV64rm<Mem:(load (s64) from %ir.10, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t55:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 5
  Predecessors:
    SU(16): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(32): Ord  Latency=1 Barrier
    SU(46): Data Latency=1
SU(38): t68: i64,ch = MOV64rm<Mem:(load (s64) from %ir.8, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, t55:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 5
  Predecessors:
    SU(16): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(32): Ord  Latency=1 Barrier
    SU(47): Data Latency=1
SU(39): t64: i64,ch = MOV64rm<Mem:(load (s64) from %ir.6, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t55:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 5
  Predecessors:
    SU(16): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(32): Ord  Latency=1 Barrier
    SU(48): Data Latency=1
SU(40): t105: ch = CopyToReg t0, Register:i64 %10, t103

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 2
  Predecessors:
    SU(29): Data Latency=1
  Successors:
    SU(28): Ord  Latency=1 Barrier
SU(41): t97: ch = CopyToReg t0, Register:i64 %9, t95

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 2
  Predecessors:
    SU(30): Data Latency=1
  Successors:
    SU(28): Ord  Latency=1 Barrier
SU(42): t93: ch = CopyToReg t0, Register:i64 %8, t91

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(33): Data Latency=1
  Successors:
    SU(28): Ord  Latency=1 Barrier
SU(43): t88: ch = CopyToReg t0, Register:i64 %7, t86

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(34): Data Latency=1
  Successors:
    SU(28): Ord  Latency=1 Barrier
SU(44): t84: ch = CopyToReg t0, Register:i64 %6, t82

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(35): Data Latency=1
  Successors:
    SU(28): Ord  Latency=1 Barrier
SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(36): Data Latency=1
  Successors:
    SU(28): Ord  Latency=1 Barrier
SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(37): Data Latency=1
  Successors:
    SU(28): Ord  Latency=1 Barrier
SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(38): Data Latency=1
  Successors:
    SU(28): Ord  Latency=1 Barrier
SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(39): Data Latency=1
  Successors:
    SU(28): Ord  Latency=1 Barrier
SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(28): Ord  Latency=1 Barrier
SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(28): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t114: ch = JMP_1 BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>, t128


*** Scheduling [0]: SU(0): t114: ch = JMP_1 BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>, t128


Examining Available:
Height 1: SU(1): t128: ch = JCC_1 BasicBlock:ch<._crit_edge 0x7fee590537d0>, TargetConstant:i8<14>, t134, t134:1

    t134: ch,glue = CopyToReg t110, Register:i32 $eflags, t126


*** Scheduling [1]: SU(1): t128: ch = JCC_1 BasicBlock:ch<._crit_edge 0x7fee590537d0>, TargetConstant:i8<14>, t134, t134:1

    t134: ch,glue = CopyToReg t110, Register:i32 $eflags, t126


Examining Available:
Height 1: SU(28): t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1

Height 2: SU(2): t126: i32 = TEST64rr t56, t56


*** Scheduling [2]: SU(28): t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1


Examining Available:
Height 2: SU(2): t126: i32 = TEST64rr t56, t56

Height 3: SU(40): t105: ch = CopyToReg t0, Register:i64 %10, t103

Height 3: SU(41): t97: ch = CopyToReg t0, Register:i64 %9, t95

Height 3: SU(42): t93: ch = CopyToReg t0, Register:i64 %8, t91

Height 3: SU(43): t88: ch = CopyToReg t0, Register:i64 %7, t86

Height 3: SU(44): t84: ch = CopyToReg t0, Register:i64 %6, t82

Height 3: SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [3]: SU(2): t126: i32 = TEST64rr t56, t56


Examining Available:
Height 3: SU(40): t105: ch = CopyToReg t0, Register:i64 %10, t103

Height 3: SU(41): t97: ch = CopyToReg t0, Register:i64 %9, t95

Height 3: SU(42): t93: ch = CopyToReg t0, Register:i64 %8, t91

Height 3: SU(43): t88: ch = CopyToReg t0, Register:i64 %7, t86

Height 3: SU(44): t84: ch = CopyToReg t0, Register:i64 %6, t82

Height 3: SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [4]: SU(40): t105: ch = CopyToReg t0, Register:i64 %10, t103


Examining Available:
Height 5: SU(29): t103: i64,ch,glue = CopyFromReg t102:1, Register:i64 $rax, t102:2

    t100: ch,glue = CopyToReg t99:1, Register:i64 $rdi, t95

    t101: ch,glue = CALL64r t132, Register:i64 $rdi, RegisterMask:Untyped, t100, t100:1

    t102: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t101, t101:1

Height 3: SU(41): t97: ch = CopyToReg t0, Register:i64 %9, t95

Height 3: SU(42): t93: ch = CopyToReg t0, Register:i64 %8, t91

Height 3: SU(43): t88: ch = CopyToReg t0, Register:i64 %7, t86

Height 3: SU(44): t84: ch = CopyToReg t0, Register:i64 %6, t82

Height 3: SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [5]: SU(29): t103: i64,ch,glue = CopyFromReg t102:1, Register:i64 $rax, t102:2

    t100: ch,glue = CopyToReg t99:1, Register:i64 $rdi, t95

    t101: ch,glue = CALL64r t132, Register:i64 $rdi, RegisterMask:Untyped, t100, t100:1

    t102: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t101, t101:1


Examining Available:
Height 6: SU(31): t99: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t98

Height 3: SU(41): t97: ch = CopyToReg t0, Register:i64 %9, t95

Height 3: SU(42): t93: ch = CopyToReg t0, Register:i64 %8, t91

Height 3: SU(43): t88: ch = CopyToReg t0, Register:i64 %7, t86

Height 3: SU(44): t84: ch = CopyToReg t0, Register:i64 %6, t82

Height 3: SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [6]: SU(31): t99: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t98


Examining Available:
Height 6: SU(32): t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1

Height 3: SU(41): t97: ch = CopyToReg t0, Register:i64 %9, t95

Height 3: SU(42): t93: ch = CopyToReg t0, Register:i64 %8, t91

Height 3: SU(43): t88: ch = CopyToReg t0, Register:i64 %7, t86

Height 3: SU(44): t84: ch = CopyToReg t0, Register:i64 %6, t82

Height 3: SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [7]: SU(32): t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1


Examining Available:
Height 3: SU(41): t97: ch = CopyToReg t0, Register:i64 %9, t95

Height 3: SU(42): t93: ch = CopyToReg t0, Register:i64 %8, t91

Height 3: SU(43): t88: ch = CopyToReg t0, Register:i64 %7, t86

Height 3: SU(44): t84: ch = CopyToReg t0, Register:i64 %6, t82

Height 3: SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [8]: SU(41): t97: ch = CopyToReg t0, Register:i64 %9, t95


Examining Available:
Height 9: SU(30): t95: i64,i32 = SHL64ri t56, TargetConstant:i8<3>

Height 3: SU(42): t93: ch = CopyToReg t0, Register:i64 %8, t91

Height 3: SU(43): t88: ch = CopyToReg t0, Register:i64 %7, t86

Height 3: SU(44): t84: ch = CopyToReg t0, Register:i64 %6, t82

Height 3: SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [9]: SU(30): t95: i64,i32 = SHL64ri t56, TargetConstant:i8<3>


Examining Available:
Height 3: SU(42): t93: ch = CopyToReg t0, Register:i64 %8, t91

Height 3: SU(43): t88: ch = CopyToReg t0, Register:i64 %7, t86

Height 3: SU(44): t84: ch = CopyToReg t0, Register:i64 %6, t82

Height 3: SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [10]: SU(42): t93: ch = CopyToReg t0, Register:i64 %8, t91


Examining Available:
Height 11: SU(33): t91: i64,ch = MOV64rm<Mem:(load (s64) from %ir.18, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t55:1

Height 3: SU(43): t88: ch = CopyToReg t0, Register:i64 %7, t86

Height 3: SU(44): t84: ch = CopyToReg t0, Register:i64 %6, t82

Height 3: SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [11]: SU(33): t91: i64,ch = MOV64rm<Mem:(load (s64) from %ir.18, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t55:1


Examining Available:
Height 3: SU(43): t88: ch = CopyToReg t0, Register:i64 %7, t86

Height 3: SU(44): t84: ch = CopyToReg t0, Register:i64 %6, t82

Height 3: SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [12]: SU(43): t88: ch = CopyToReg t0, Register:i64 %7, t86


Examining Available:
Height 13: SU(34): t86: i64,ch = MOV64rm<Mem:(load (s64) from %ir.16, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, t55:1

Height 3: SU(44): t84: ch = CopyToReg t0, Register:i64 %6, t82

Height 3: SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [13]: SU(34): t86: i64,ch = MOV64rm<Mem:(load (s64) from %ir.16, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, t55:1


Examining Available:
Height 3: SU(44): t84: ch = CopyToReg t0, Register:i64 %6, t82

Height 3: SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [14]: SU(44): t84: ch = CopyToReg t0, Register:i64 %6, t82


Examining Available:
Height 15: SU(35): t82: i64,ch = MOV64rm<Mem:(load (s64) from %ir.14, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t55:1

Height 3: SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [15]: SU(35): t82: i64,ch = MOV64rm<Mem:(load (s64) from %ir.14, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t55:1


Examining Available:
Height 3: SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [16]: SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77


Examining Available:
Height 17: SU(36): t77: i64,ch = MOV64rm<Mem:(load (s64) from %ir.12, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, t55:1

Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [17]: SU(36): t77: i64,ch = MOV64rm<Mem:(load (s64) from %ir.12, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, t55:1


Examining Available:
Height 3: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [18]: SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72


Examining Available:
Height 19: SU(37): t72: i64,ch = MOV64rm<Mem:(load (s64) from %ir.10, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t55:1

Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [19]: SU(37): t72: i64,ch = MOV64rm<Mem:(load (s64) from %ir.10, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t55:1


Examining Available:
Height 3: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [20]: SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68


Examining Available:
Height 21: SU(38): t68: i64,ch = MOV64rm<Mem:(load (s64) from %ir.8, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, t55:1

Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [21]: SU(38): t68: i64,ch = MOV64rm<Mem:(load (s64) from %ir.8, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, t55:1


Examining Available:
Height 3: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [22]: SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64


Examining Available:
Height 23: SU(39): t64: i64,ch = MOV64rm<Mem:(load (s64) from %ir.6, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t55:1

Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [23]: SU(39): t64: i64,ch = MOV64rm<Mem:(load (s64) from %ir.6, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t55:1


Examining Available:
Height 3: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [24]: SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60


Examining Available:
Height 3: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


*** Scheduling [25]: SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56


Examining Available:
Height 26: SU(3): t60: i64,ch = MOV64rm<Mem:(load (s64) from %ir.4, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, t55:1, t56:2

    t56: i64,ch,glue = MOV64rm<Mem:(load (s64) from %ir.1, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t55:1


*** Scheduling [26]: SU(3): t60: i64,ch = MOV64rm<Mem:(load (s64) from %ir.4, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, t55:1, t56:2

    t56: i64,ch,glue = MOV64rm<Mem:(load (s64) from %ir.1, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t55:1


Examining Available:
Height 27: SU(4): t55: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<16>, TargetConstant:i64<0>, t54, t54:1

    t43: ch,glue = CopyToReg t41, Register:i32 $edi, t31

    t45: ch,glue = CopyToReg t43, Register:i64 $rsi, t13, t43:1

    t47: ch,glue = CopyToReg t45, Register:i64 $rdx, t32, t45:1

    t49: ch,glue = CopyToReg t47, Register:i64 $rcx, t13, t47:1

    t51: ch,glue = CopyToReg t49, Register:i64 $r8, t33, t49:1

    t53: ch,glue = CopyToReg t51, Register:i64 $r9, t28, t51:1

    t54: ch,glue = CALL64r t130, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53, t53:1


*** Scheduling [27]: SU(4): t55: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<16>, TargetConstant:i64<0>, t54, t54:1

    t43: ch,glue = CopyToReg t41, Register:i32 $edi, t31

    t45: ch,glue = CopyToReg t43, Register:i64 $rsi, t13, t43:1

    t47: ch,glue = CopyToReg t45, Register:i64 $rdx, t32, t45:1

    t49: ch,glue = CopyToReg t47, Register:i64 $rcx, t13, t47:1

    t51: ch,glue = CopyToReg t49, Register:i64 $r8, t33, t49:1

    t53: ch,glue = CopyToReg t51, Register:i64 $r9, t28, t51:1

    t54: ch,glue = CALL64r t130, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53, t53:1


Examining Available:
Height 27: SU(11): t41: ch = TokenFactor t38, t40

Height 28: SU(5): t28: i64 = MOV32ri64 TargetConstant:i64<1>

Height 28: SU(6): t33: i64 = MOV64ri32 TargetConstant:i64<-1>

Height 28: SU(9): t32: i64 = MOV32ri64 TargetConstant:i64<3>

Height 28: SU(10): t31: i32 = MOV32ri TargetConstant:i32<1>

Height 28: SU(7): t13: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

Height 28: SU(27): t130: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0


*** Scheduling [28]: SU(11): t41: ch = TokenFactor t38, t40


Examining Available:
Height 28: SU(5): t28: i64 = MOV32ri64 TargetConstant:i64<1>

Height 28: SU(6): t33: i64 = MOV64ri32 TargetConstant:i64<-1>

Height 28: SU(9): t32: i64 = MOV32ri64 TargetConstant:i64<3>

Height 28: SU(10): t31: i32 = MOV32ri TargetConstant:i32<1>

Height 28: SU(7): t13: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

Height 28: SU(27): t130: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0

Height 29: SU(12): t40: ch = MOV32mi<Mem:(store (s32) into stack + 8)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i32<1>, t35:1

Height 29: SU(25): t38: ch = MOV64mr<Mem:(store (s64) into stack)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t12, t35:1


*** Scheduling [29]: SU(5): t28: i64 = MOV32ri64 TargetConstant:i64<1>


Examining Available:
Height 28: SU(6): t33: i64 = MOV64ri32 TargetConstant:i64<-1>

Height 28: SU(9): t32: i64 = MOV32ri64 TargetConstant:i64<3>

Height 28: SU(10): t31: i32 = MOV32ri TargetConstant:i32<1>

Height 28: SU(7): t13: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

Height 28: SU(27): t130: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0

Height 29: SU(12): t40: ch = MOV32mi<Mem:(store (s32) into stack + 8)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i32<1>, t35:1

Height 29: SU(25): t38: ch = MOV64mr<Mem:(store (s64) into stack)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t12, t35:1


*** Scheduling [30]: SU(6): t33: i64 = MOV64ri32 TargetConstant:i64<-1>


Examining Available:
Height 28: SU(9): t32: i64 = MOV32ri64 TargetConstant:i64<3>

Height 28: SU(10): t31: i32 = MOV32ri TargetConstant:i32<1>

Height 28: SU(7): t13: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

Height 28: SU(27): t130: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0

Height 29: SU(12): t40: ch = MOV32mi<Mem:(store (s32) into stack + 8)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i32<1>, t35:1

Height 29: SU(25): t38: ch = MOV64mr<Mem:(store (s64) into stack)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t12, t35:1


*** Scheduling [31]: SU(9): t32: i64 = MOV32ri64 TargetConstant:i64<3>


Examining Available:
Height 28: SU(10): t31: i32 = MOV32ri TargetConstant:i32<1>

Height 28: SU(7): t13: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

Height 28: SU(27): t130: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0

Height 29: SU(12): t40: ch = MOV32mi<Mem:(store (s32) into stack + 8)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i32<1>, t35:1

Height 29: SU(25): t38: ch = MOV64mr<Mem:(store (s64) into stack)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t12, t35:1


*** Scheduling [32]: SU(10): t31: i32 = MOV32ri TargetConstant:i32<1>


Examining Available:
Height 28: SU(7): t13: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

Height 28: SU(27): t130: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0

Height 29: SU(12): t40: ch = MOV32mi<Mem:(store (s32) into stack + 8)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i32<1>, t35:1

Height 29: SU(25): t38: ch = MOV64mr<Mem:(store (s64) into stack)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t12, t35:1


*** Scheduling [33]: SU(7): t13: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>


Examining Available:
Height 34: SU(8): t155: i32,i32 = MOV32r0

Height 28: SU(27): t130: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0

Height 29: SU(12): t40: ch = MOV32mi<Mem:(store (s32) into stack + 8)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i32<1>, t35:1

Height 29: SU(25): t38: ch = MOV64mr<Mem:(store (s64) into stack)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t12, t35:1


*** Scheduling [34]: SU(8): t155: i32,i32 = MOV32r0


Examining Available:
Height 28: SU(27): t130: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0

Height 29: SU(12): t40: ch = MOV32mi<Mem:(store (s32) into stack + 8)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i32<1>, t35:1

Height 29: SU(25): t38: ch = MOV64mr<Mem:(store (s64) into stack)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t12, t35:1


*** Scheduling [35]: SU(27): t130: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0


Examining Available:
Height 29: SU(12): t40: ch = MOV32mi<Mem:(store (s32) into stack + 8)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i32<1>, t35:1

Height 29: SU(25): t38: ch = MOV64mr<Mem:(store (s64) into stack)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t12, t35:1


*** Scheduling [36]: SU(12): t40: ch = MOV32mi<Mem:(store (s32) into stack + 8)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i32<1>, t35:1


Examining Available:
Height 29: SU(25): t38: ch = MOV64mr<Mem:(store (s64) into stack)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t12, t35:1


*** Scheduling [37]: SU(25): t38: ch = MOV64mr<Mem:(store (s64) into stack)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t12, t35:1


Examining Available:
Height 38: SU(26): t12: i64 = LEA64r TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg

Height 38: SU(24): t37: i64,ch = CopyFromReg t35:1, Register:i64 $rsp


*** Scheduling [38]: SU(26): t12: i64 = LEA64r TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg


Examining Available:
Height 38: SU(24): t37: i64,ch = CopyFromReg t35:1, Register:i64 $rsp


*** Scheduling [39]: SU(24): t37: i64,ch = CopyFromReg t35:1, Register:i64 $rsp


Examining Available:
Height 40: SU(13): t35: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<16>, TargetConstant:i64<0>, TargetConstant:i32<0>, t121


*** Scheduling [40]: SU(13): t35: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<16>, TargetConstant:i64<0>, TargetConstant:i32<0>, t121


Examining Available:
Height 40: SU(14): t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120


*** Scheduling [41]: SU(14): t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120


Examining Available:
Height 42: SU(15): t120: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.4.0.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, TargetConstant:i64<1>, t9:1

Height 42: SU(20): t25: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.3.0.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<7>, t9:1

Height 42: SU(21): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.2.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, TargetConstant:i64<0>, t9:1

Height 42: SU(22): t18: ch = MOV64mr<Mem:(store (s64) into %ir..fca.1.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, t11, t9:1

Height 42: SU(23): t15: ch = MOV64mr<Mem:(store (s64) into %ir.2)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11, t9:1


*** Scheduling [42]: SU(15): t120: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.4.0.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, TargetConstant:i64<1>, t9:1


Examining Available:
Height 42: SU(20): t25: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.3.0.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<7>, t9:1

Height 42: SU(21): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.2.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, TargetConstant:i64<0>, t9:1

Height 42: SU(22): t18: ch = MOV64mr<Mem:(store (s64) into %ir..fca.1.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, t11, t9:1

Height 42: SU(23): t15: ch = MOV64mr<Mem:(store (s64) into %ir.2)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11, t9:1


*** Scheduling [43]: SU(20): t25: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.3.0.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<7>, t9:1


Examining Available:
Height 42: SU(21): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.2.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, TargetConstant:i64<0>, t9:1

Height 42: SU(22): t18: ch = MOV64mr<Mem:(store (s64) into %ir..fca.1.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, t11, t9:1

Height 42: SU(23): t15: ch = MOV64mr<Mem:(store (s64) into %ir.2)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11, t9:1


*** Scheduling [44]: SU(21): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.2.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, TargetConstant:i64<0>, t9:1


Examining Available:
Height 42: SU(22): t18: ch = MOV64mr<Mem:(store (s64) into %ir..fca.1.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, t11, t9:1

Height 42: SU(23): t15: ch = MOV64mr<Mem:(store (s64) into %ir.2)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11, t9:1


*** Scheduling [45]: SU(22): t18: ch = MOV64mr<Mem:(store (s64) into %ir..fca.1.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, t11, t9:1


Examining Available:
Height 42: SU(23): t15: ch = MOV64mr<Mem:(store (s64) into %ir.2)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11, t9:1


*** Scheduling [46]: SU(23): t15: ch = MOV64mr<Mem:(store (s64) into %ir.2)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11, t9:1


Examining Available:
Height 47: SU(16): t11: i64,ch,glue = CopyFromReg t9:1, Register:i64 $rax, t9:2

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t2

    t8: ch,glue = CALL64r t132, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1

    t9: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t8, t8:1


*** Scheduling [47]: SU(16): t11: i64,ch,glue = CopyFromReg t9:1, Register:i64 $rax, t9:2

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t2

    t8: ch,glue = CALL64r t132, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1

    t9: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t8, t8:1


Examining Available:
Height 48: SU(17): t2: i64 = MOV32ri64 TargetConstant:i64<56>

Height 48: SU(19): t132: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

Height 48: SU(18): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [48]: SU(17): t2: i64 = MOV32ri64 TargetConstant:i64<56>


Examining Available:
Height 48: SU(19): t132: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

Height 48: SU(18): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [49]: SU(19): t132: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0


Examining Available:
Height 48: SU(18): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [50]: SU(18): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(18): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(19): t132: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

SU(17): t2: i64 = MOV32ri64 TargetConstant:i64<56>

SU(16): t11: i64,ch,glue = CopyFromReg t9:1, Register:i64 $rax, t9:2

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t2

    t8: ch,glue = CALL64r t132, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1

    t9: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t8, t8:1

SU(23): t15: ch = MOV64mr<Mem:(store (s64) into %ir.2)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11, t9:1

SU(22): t18: ch = MOV64mr<Mem:(store (s64) into %ir..fca.1.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, t11, t9:1

SU(21): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.2.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, TargetConstant:i64<0>, t9:1

SU(20): t25: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.3.0.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<7>, t9:1

SU(15): t120: ch = MOV64mi32<Mem:(store (s64) into %ir..fca.4.0.gep)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, TargetConstant:i64<1>, t9:1

SU(14): t121: ch = TokenFactor t11:1, t15, t18, t21, t25, t120

SU(13): t35: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<16>, TargetConstant:i64<0>, TargetConstant:i32<0>, t121

SU(24): t37: i64,ch = CopyFromReg t35:1, Register:i64 $rsp

SU(26): t12: i64 = LEA64r TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg

SU(25): t38: ch = MOV64mr<Mem:(store (s64) into stack)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t12, t35:1

SU(12): t40: ch = MOV32mi<Mem:(store (s32) into stack + 8)> t37, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i32<1>, t35:1

SU(27): t130: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_sizes_2D_f64> 0

SU(8): t155: i32,i32 = MOV32r0

SU(7): t13: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

SU(10): t31: i32 = MOV32ri TargetConstant:i32<1>

SU(9): t32: i64 = MOV32ri64 TargetConstant:i64<3>

SU(6): t33: i64 = MOV64ri32 TargetConstant:i64<-1>

SU(5): t28: i64 = MOV32ri64 TargetConstant:i64<1>

SU(11): t41: ch = TokenFactor t38, t40

SU(4): t55: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<16>, TargetConstant:i64<0>, t54, t54:1

    t43: ch,glue = CopyToReg t41, Register:i32 $edi, t31

    t45: ch,glue = CopyToReg t43, Register:i64 $rsi, t13, t43:1

    t47: ch,glue = CopyToReg t45, Register:i64 $rdx, t32, t45:1

    t49: ch,glue = CopyToReg t47, Register:i64 $rcx, t13, t47:1

    t51: ch,glue = CopyToReg t49, Register:i64 $r8, t33, t49:1

    t53: ch,glue = CopyToReg t51, Register:i64 $r9, t28, t51:1

    t54: ch,glue = CALL64r t130, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t53, t53:1

SU(3): t60: i64,ch = MOV64rm<Mem:(load (s64) from %ir.4, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, t55:1, t56:2

    t56: i64,ch,glue = MOV64rm<Mem:(load (s64) from %ir.1, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t55:1

SU(50): t58: ch = CopyToReg t0, Register:i64 %0, t56

SU(49): t62: ch = CopyToReg t0, Register:i64 %1, t60

SU(39): t64: i64,ch = MOV64rm<Mem:(load (s64) from %ir.6, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t55:1

SU(48): t66: ch = CopyToReg t0, Register:i64 %2, t64

SU(38): t68: i64,ch = MOV64rm<Mem:(load (s64) from %ir.8, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, t55:1

SU(47): t70: ch = CopyToReg t0, Register:i64 %3, t68

SU(37): t72: i64,ch = MOV64rm<Mem:(load (s64) from %ir.10, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t55:1

SU(46): t74: ch = CopyToReg t0, Register:i64 %4, t72

SU(36): t77: i64,ch = MOV64rm<Mem:(load (s64) from %ir.12, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, t55:1

SU(45): t79: ch = CopyToReg t0, Register:i64 %5, t77

SU(35): t82: i64,ch = MOV64rm<Mem:(load (s64) from %ir.14, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t55:1

SU(44): t84: ch = CopyToReg t0, Register:i64 %6, t82

SU(34): t86: i64,ch = MOV64rm<Mem:(load (s64) from %ir.16, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, t55:1

SU(43): t88: ch = CopyToReg t0, Register:i64 %7, t86

SU(33): t91: i64,ch = MOV64rm<Mem:(load (s64) from %ir.18, align 4)> t11, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t55:1

SU(42): t93: ch = CopyToReg t0, Register:i64 %8, t91

SU(30): t95: i64,i32 = SHL64ri t56, TargetConstant:i8<3>

SU(41): t97: ch = CopyToReg t0, Register:i64 %9, t95

SU(32): t98: ch = TokenFactor t56:1, t60:1, t64:1, t68:1, t72:1, t77:1, t82:1, t86:1, t91:1

SU(31): t99: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t98

SU(29): t103: i64,ch,glue = CopyFromReg t102:1, Register:i64 $rax, t102:2

    t100: ch,glue = CopyToReg t99:1, Register:i64 $rdi, t95

    t101: ch,glue = CALL64r t132, Register:i64 $rdi, RegisterMask:Untyped, t100, t100:1

    t102: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t101, t101:1

SU(40): t105: ch = CopyToReg t0, Register:i64 %10, t103

SU(2): t126: i32 = TEST64rr t56, t56

SU(28): t110: ch = TokenFactor t58, t62, t66, t70, t74, t79, t84, t88, t93, t97, t105, t103:1

SU(1): t128: ch = JCC_1 BasicBlock:ch<._crit_edge 0x7fee590537d0>, TargetConstant:i8<14>, t134, t134:1

    t134: ch,glue = CopyToReg t110, Register:i32 $eflags, t126

SU(0): t114: ch = JMP_1 BasicBlock:ch<.lr.ph.preheader 0x7fee590536d0>, t128


Total amount of phi nodes to update: 0
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %10
Creating constant: t3: i8 = Constant<0>
Creating new node: t5: i64,ch = CopyFromReg t0, Register:i64 %9
Creating constant: t7: i64 = TargetConstant<0>
Creating new node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Creating new node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Creating new node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Creating new node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Initial selection DAG: %bb.1 'main:.lr.ph.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t3: i8 = Constant<0>
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %10
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %9
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Combining: t13: Untyped = RegisterMask

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Combining: t11: i64 = Register $rsi

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Combining: t9: i64 = Register $rdi

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t7: i64 = TargetConstant<0>

Combining: t6: i64 = ExternalSymbol'__bzero'

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %9

Combining: t4: i64 = Register %9

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %10

Combining: t1: i64 = Register %10

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.1 'main:.lr.ph.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %10
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %9
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


Legalizing node: t13: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t13: Untyped = RegisterMask

Legalizing node: t11: i64 = Register $rsi
Ignoring node results
Legally typed node: t11: i64 = Register $rsi

Legalizing node: t9: i64 = Register $rdi
Ignoring node results
Legally typed node: t9: i64 = Register $rdi

Legalizing node: t7: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t7: i64 = TargetConstant<0>

Legalizing node: t6: i64 = ExternalSymbol'__bzero'
Analyzing result type: i64
Legal result type
Legally typed node: t6: i64 = ExternalSymbol'__bzero'

Legalizing node: t4: i64 = Register %9
Ignoring node results
Legally typed node: t4: i64 = Register %9

Legalizing node: t1: i64 = Register %10
Ignoring node results
Legally typed node: t1: i64 = Register %10

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %10
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %10

Legalizing node: t5: i64,ch = CopyFromReg t0, Register:i64 %9
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t5: i64,ch = CopyFromReg t0, Register:i64 %9

Legalizing node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %10
Legal operand
Legally typed node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Analyzing operand: t5: i64,ch = CopyFromReg t0, Register:i64 %9
Legal operand
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Legally typed node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Analyzing operand: t6: i64 = ExternalSymbol'__bzero'
Legal operand
Analyzing operand: t13: Untyped = RegisterMask
Legal operand
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Legally typed node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Legally typed node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.1 'main:.lr.ph.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %10
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %9
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %9
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %10
Legal node: nothing to do

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Legalizing: t6: i64 = ExternalSymbol'__bzero'
Trying custom legalization
Creating new node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Successfully custom legalized node
 ... replacing: t6: i64 = ExternalSymbol'__bzero'
     with:      t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t4: i64 = Register %9

Legalizing: t1: i64 = Register %10

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do
Legalized selection DAG: %bb.1 'main:.lr.ph.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %10
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %9
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Combining: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do

Combining: t16: i64 = TargetExternalSymbol'__bzero'

Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Combining: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %9
Legal node: nothing to do

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %9

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %10
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %10

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Combining: t13: Untyped = RegisterMask

Legalizing: t11: i64 = Register $rsi

Combining: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Combining: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Combining: t7: i64 = TargetConstant<0>

Legalizing: t4: i64 = Register %9

Combining: t4: i64 = Register %9

Legalizing: t1: i64 = Register %10

Combining: t1: i64 = Register %10

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.1 'main:.lr.ph.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %10
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %9
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


===== Instruction selection begins: %bb.1 '.lr.ph.preheader'

ISEL: Starting selection on root node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

ISEL: Starting selection on root node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

ISEL: Starting selection on root node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132022
  Match failed at index 132025
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t18: i32 = TargetConstant<0>
  Morphed node: t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i64,ch = CopyFromReg t0, Register:i64 %9

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %10

ISEL: Starting selection on root node: t16: i64 = TargetExternalSymbol'__bzero'

ISEL: Starting selection on root node: t13: Untyped = RegisterMask

ISEL: Starting selection on root node: t11: i64 = Register $rsi

ISEL: Starting selection on root node: t9: i64 = Register $rdi

ISEL: Starting selection on root node: t7: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t4: i64 = Register %9

ISEL: Starting selection on root node: t1: i64 = Register %10

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.1 'main:.lr.ph.preheader'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
    t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t2: i64,ch = CopyFromReg t0, Register:i64 %10
  t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %9
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
  t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1


********** List Scheduling %bb.1 '.lr.ph.preheader' **********
SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1

  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Data Latency=1
    SU(1): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %9

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %10

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1

Examining Available:
Height 0: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


*** Scheduling [0]: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Examining Available:
Height 1: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %9

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %10

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [1]: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'


Examining Available:
Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %9

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %10

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [2]: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %9


Examining Available:
Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %10

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [3]: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %10


Examining Available:
Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [4]: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %10

SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %9

SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<1>
Creating constant: t2: i64 = Constant<1>
Creating constant: t3: i64 = Constant<40>
Creating constant: t4: i64 = Constant<15>
Creating constant: t5: i64 = Constant<55>
Creating constant: t6: i64 = Constant<-16>
Creating constant: t7: i64 = Constant<48>
Creating constant: t8: i64 = Constant<0>
Creating new node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Creating new node: t11: ch = CopyToReg t0, Register:i64 %11, t9
Creating new node: t13: i64,ch = CopyFromReg t0, Register:i64 %10
Creating new node: t14: i64 = undef
Creating new node: t15: ch = store<(store (s64) into %ir.22)> t9:1, t13, t9, undef:i64
Creating constant: t16: i64 = Constant<8>
Creating new node: t17: i64 = add nuw t9, Constant:i64<8>
Creating new node: t18: ch = store<(store (s64) into %ir..repack9)> t15, t13, t17, undef:i64
Creating constant: t19: i64 = Constant<16>
Creating new node: t20: i64 = add nuw t9, Constant:i64<16>
Creating new node: t21: ch = store<(store (s64) into %ir..repack11)> t18, Constant:i64<0>, t20, undef:i64
Creating constant: t22: i64 = Constant<24>
Creating new node: t23: i64 = add nuw t9, Constant:i64<24>
Creating new node: t25: i64,ch = CopyFromReg t0, Register:i64 %0
Creating new node: t26: ch = store<(store (s64) into %ir..repack13)> t21, t25, t23, undef:i64
Creating constant: t27: i64 = Constant<32>
Creating new node: t28: i64 = add nuw t9, Constant:i64<32>
Creating new node: t29: ch = store<(store (s64) into %ir..repack15)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t31: i64,ch = CopyFromReg t0, Register:i64 %1
Creating constant: t32: i64 = Constant<3>
Creating constant: t33: i8 = Constant<3>
Creating new node: t34: i64 = shl t31, Constant:i8<3>
Creating new node: t36: ch = CopyToReg t0, Register:i64 %12, t34
Creating constant: t38: i64 = TargetConstant<0>
Creating new node: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Creating new node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Creating new node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Creating new node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Creating new node: t48: ch = CopyToReg t0, Register:i64 %13, t46
Creating new node: t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
Creating constant: t51: i1 = Constant<-1>
Creating new node: t52: i1 = xor t50, Constant:i1<-1>
Creating new node: t53: ch = TokenFactor t11, t36, t48, t46:1
Creating new node: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge91 0x7fee590539d0>
Creating new node: t57: ch = br t55, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>
Initial selection DAG: %bb.2 'main:._crit_edge'
SelectionDAG has 58 nodes:
  t0: ch,glue = EntryToken
  t1: i32 = Constant<1>
  t3: i64 = Constant<40>
  t4: i64 = Constant<15>
  t5: i64 = Constant<55>
  t6: i64 = Constant<-16>
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %10
  t31: i64,ch = CopyFromReg t0, Register:i64 %1
  t32: i64 = Constant<3>
  t34: i64 = shl t31, Constant:i8<3>
              t15: ch = store<(store (s64) into %ir.22)> t9:1, t13, t9, undef:i64
              t17: i64 = add nuw t9, Constant:i64<8>
            t18: ch = store<(store (s64) into %ir..repack9)> t15, t13, t17, undef:i64
            t20: i64 = add nuw t9, Constant:i64<16>
          t21: ch = store<(store (s64) into %ir..repack11)> t18, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %0
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack13)> t21, t25, t23, undef:i64
        t28: i64 = add nuw t9, Constant:i64<32>
      t29: ch = store<(store (s64) into %ir..repack15)> t26, Constant:i64<1>, t28, undef:i64
    t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %11, t9
        t36: ch = CopyToReg t0, Register:i64 %12, t34
        t48: ch = CopyToReg t0, Register:i64 %13, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
      t52: i1 = xor t50, Constant:i1<-1>
    t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge91 0x7fee590539d0>
  t57: ch = br t55, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>



Combining: t57: ch = br t55, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>

Combining: t56: ch = BasicBlock<.lr.ph90.preheader 0x7fee590538d0>

Combining: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge91 0x7fee590539d0>
Creating new node: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge91 0x7fee590539d0>
 ... into: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge91 0x7fee590539d0>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>

Combining: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge91 0x7fee590539d0>

Combining: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
 ... into: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge91 0x7fee590539d0>

Combining: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t61: ch = setlt

Combining: t54: ch = BasicBlock<._crit_edge91 0x7fee590539d0>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %13, t46

Combining: t47: i64 = Register %13

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %12, t34

Combining: t35: i64 = Register %12

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %1

Combining: t30: i64 = Register %1

Combining: t29: ch = store<(store (s64) into %ir..repack15)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t63: ch = store<(store (s64) into %ir..repack15)> t9:1, Constant:i64<1>, t28, undef:i64
Creating new node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Replacing.1 t29: ch = store<(store (s64) into %ir..repack15)> t26, Constant:i64<1>, t28, undef:i64

With: t64: ch = TokenFactor t15, t18, t21, t26, t63
 and 0 other values

Combining: t63: ch = store<(store (s64) into %ir..repack15)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack13)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %0

Combining: t24: i64 = Register %0

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack11)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack9)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.22)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %10

Combining: t12: i64 = Register %10

Combining: t11: ch = CopyToReg t0, Register:i64 %11, t9

Combining: t10: i64 = Register %11

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.2 'main:._crit_edge'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %10
  t31: i64,ch = CopyFromReg t0, Register:i64 %1
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.22)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack9)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack11)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %0
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack13)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack15)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %11, t9
        t36: ch = CopyToReg t0, Register:i64 %12, t34
        t48: ch = CopyToReg t0, Register:i64 %13, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge91 0x7fee590539d0>
  t57: ch = br t60, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>


Legalizing node: t61: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t61: ch = setlt

Legalizing node: t56: ch = BasicBlock<.lr.ph90.preheader 0x7fee590538d0>
Analyzing result type: ch
Legal result type
Legally typed node: t56: ch = BasicBlock<.lr.ph90.preheader 0x7fee590538d0>

Legalizing node: t54: ch = BasicBlock<._crit_edge91 0x7fee590539d0>
Analyzing result type: ch
Legal result type
Legally typed node: t54: ch = BasicBlock<._crit_edge91 0x7fee590539d0>

Legalizing node: t47: i64 = Register %13
Ignoring node results
Legally typed node: t47: i64 = Register %13

Legalizing node: t45: i64 = Register $rax
Ignoring node results
Legally typed node: t45: i64 = Register $rax

Legalizing node: t42: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t42: Untyped = RegisterMask

Legalizing node: t40: i64 = Register $rdi
Ignoring node results
Legally typed node: t40: i64 = Register $rdi

Legalizing node: t38: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t38: i64 = TargetConstant<0>

Legalizing node: t37: i64 = GlobalAddress<ptr @malloc> 0
Analyzing result type: i64
Legal result type
Legally typed node: t37: i64 = GlobalAddress<ptr @malloc> 0

Legalizing node: t35: i64 = Register %12
Ignoring node results
Legally typed node: t35: i64 = Register %12

Legalizing node: t33: i8 = Constant<3>
Analyzing result type: i8
Legal result type
Legally typed node: t33: i8 = Constant<3>

Legalizing node: t30: i64 = Register %1
Ignoring node results
Legally typed node: t30: i64 = Register %1

Legalizing node: t27: i64 = Constant<32>
Analyzing result type: i64
Legal result type
Legally typed node: t27: i64 = Constant<32>

Legalizing node: t24: i64 = Register %0
Ignoring node results
Legally typed node: t24: i64 = Register %0

Legalizing node: t22: i64 = Constant<24>
Analyzing result type: i64
Legal result type
Legally typed node: t22: i64 = Constant<24>

Legalizing node: t19: i64 = Constant<16>
Analyzing result type: i64
Legal result type
Legally typed node: t19: i64 = Constant<16>

Legalizing node: t16: i64 = Constant<8>
Analyzing result type: i64
Legal result type
Legally typed node: t16: i64 = Constant<8>

Legalizing node: t14: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t14: i64 = undef

Legalizing node: t12: i64 = Register %10
Ignoring node results
Legally typed node: t12: i64 = Register %10

Legalizing node: t10: i64 = Register %11
Ignoring node results
Legally typed node: t10: i64 = Register %11

Legalizing node: t8: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t8: i64 = Constant<0>

Legalizing node: t7: i64 = Constant<48>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<48>

Legalizing node: t2: i64 = Constant<1>
Analyzing result type: i64
Legal result type
Legally typed node: t2: i64 = Constant<1>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t7: i64 = Constant<48>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Legally typed node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Legalizing node: t11: ch = CopyToReg t0, Register:i64 %11, t9
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Legally typed node: t11: ch = CopyToReg t0, Register:i64 %11, t9

Legalizing node: t17: i64 = add nuw t9, Constant:i64<8>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t16: i64 = Constant<8>
Legal operand
Legally typed node: t17: i64 = add nuw t9, Constant:i64<8>

Legalizing node: t20: i64 = add nuw t9, Constant:i64<16>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t19: i64 = Constant<16>
Legal operand
Legally typed node: t20: i64 = add nuw t9, Constant:i64<16>

Legalizing node: t21: ch = store<(store (s64) into %ir..repack11)> t9:1, Constant:i64<0>, t20, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Analyzing operand: t20: i64 = add nuw t9, Constant:i64<16>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t21: ch = store<(store (s64) into %ir..repack11)> t9:1, Constant:i64<0>, t20, undef:i64

Legalizing node: t23: i64 = add nuw t9, Constant:i64<24>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t22: i64 = Constant<24>
Legal operand
Legally typed node: t23: i64 = add nuw t9, Constant:i64<24>

Legalizing node: t28: i64 = add nuw t9, Constant:i64<32>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t27: i64 = Constant<32>
Legal operand
Legally typed node: t28: i64 = add nuw t9, Constant:i64<32>

Legalizing node: t63: ch = store<(store (s64) into %ir..repack15)> t9:1, Constant:i64<1>, t28, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t28: i64 = add nuw t9, Constant:i64<32>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t63: ch = store<(store (s64) into %ir..repack15)> t9:1, Constant:i64<1>, t28, undef:i64

Legalizing node: t13: i64,ch = CopyFromReg t0, Register:i64 %10
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t13: i64,ch = CopyFromReg t0, Register:i64 %10

Legalizing node: t15: ch = store<(store (s64) into %ir.22)> t9:1, t13, t9, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %10
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t15: ch = store<(store (s64) into %ir.22)> t9:1, t13, t9, undef:i64

Legalizing node: t18: ch = store<(store (s64) into %ir..repack9)> t9:1, t13, t17, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %10
Legal operand
Analyzing operand: t17: i64 = add nuw t9, Constant:i64<8>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t18: ch = store<(store (s64) into %ir..repack9)> t9:1, t13, t17, undef:i64

Legalizing node: t25: i64,ch = CopyFromReg t0, Register:i64 %0
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t25: i64,ch = CopyFromReg t0, Register:i64 %0

Legalizing node: t26: ch = store<(store (s64) into %ir..repack13)> t9:1, t25, t23, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t25: i64,ch = CopyFromReg t0, Register:i64 %0
Legal operand
Analyzing operand: t23: i64 = add nuw t9, Constant:i64<24>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t26: ch = store<(store (s64) into %ir..repack13)> t9:1, t25, t23, undef:i64

Legalizing node: t64: ch = TokenFactor t15, t18, t21, t26, t63
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = store<(store (s64) into %ir.22)> t9:1, t13, t9, undef:i64
Legal operand
Analyzing operand: t18: ch = store<(store (s64) into %ir..repack9)> t9:1, t13, t17, undef:i64
Legal operand
Analyzing operand: t21: ch = store<(store (s64) into %ir..repack11)> t9:1, Constant:i64<0>, t20, undef:i64
Legal operand
Analyzing operand: t26: ch = store<(store (s64) into %ir..repack13)> t9:1, t25, t23, undef:i64
Legal operand
Analyzing operand: t63: ch = store<(store (s64) into %ir..repack15)> t9:1, Constant:i64<1>, t28, undef:i64
Legal operand
Legally typed node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal operand
Legally typed node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t31: i64,ch = CopyFromReg t0, Register:i64 %1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t31: i64,ch = CopyFromReg t0, Register:i64 %1

Legalizing node: t34: i64 = shl t31, Constant:i8<3>
Analyzing result type: i64
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %1
Legal operand
Analyzing operand: t33: i8 = Constant<3>
Legal operand
Legally typed node: t34: i64 = shl t31, Constant:i8<3>

Legalizing node: t36: ch = CopyToReg t0, Register:i64 %12, t34
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t36: ch = CopyToReg t0, Register:i64 %12, t34

Legalizing node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Analyzing operand: t37: i64 = GlobalAddress<ptr @malloc> 0
Legal operand
Analyzing operand: t42: Untyped = RegisterMask
Legal operand
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Legally typed node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Legally typed node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Legally typed node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing node: t48: ch = CopyToReg t0, Register:i64 %13, t46
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t48: ch = CopyToReg t0, Register:i64 %13, t46

Legalizing node: t53: ch = TokenFactor t11, t36, t48, t46:1
Analyzing result type: ch
Legal result type
Analyzing operand: t11: ch = CopyToReg t0, Register:i64 %11, t9
Legal operand
Analyzing operand: t36: ch = CopyToReg t0, Register:i64 %12, t34
Legal operand
Analyzing operand: t48: ch = CopyToReg t0, Register:i64 %13, t46
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i1
Promote integer result: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Creating new node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legalizing node: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge91 0x7fee590539d0>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge91 0x7fee590539d0>

Creating new node: t66: i8 = zero_extend t62
Legalizing node: t66: i8 = zero_extend t62
Analyzing result type: i8
Legal result type
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t66: i8 = zero_extend t62

Creating constant: t67: i8 = Constant<1>
Creating new node: t68: i8 = and t65, Constant:i8<1>
Replacing: t66: i8 = zero_extend t62
     with: t68: i8 = and t65, Constant:i8<1>
Legalizing node: t67: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t67: i8 = Constant<1>

Legalizing node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %1
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t61: ch = setlt
Legal operand
Legally typed node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Legalizing node: t68: i8 = and t65, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legal operand
Analyzing operand: t67: i8 = Constant<1>
Legal operand
Legally typed node: t68: i8 = and t65, Constant:i8<1>

Legalizing node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge91 0x7fee590539d0>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t68: i8 = and t65, Constant:i8<1>
Legal operand
Analyzing operand: t54: ch = BasicBlock<._crit_edge91 0x7fee590539d0>
Legal operand
Legally typed node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge91 0x7fee590539d0>

Legalizing node: t57: ch = br t60, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>
Analyzing result type: ch
Legal result type
Analyzing operand: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge91 0x7fee590539d0>
Legal operand
Analyzing operand: t56: ch = BasicBlock<.lr.ph90.preheader 0x7fee590538d0>
Legal operand
Legally typed node: t57: ch = br t60, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>

Legalizing node: t65535: ch = handlenode t57
Analyzing result type: ch
Legal result type
Analyzing operand: t57: ch = br t60, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>
Legal operand
Legally typed node: t65535: ch = handlenode t57

Type-legalized selection DAG: %bb.2 'main:._crit_edge'
SelectionDAG has 53 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %10
  t31: i64,ch = CopyFromReg t0, Register:i64 %1
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.22)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack9)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack11)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %0
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack13)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack15)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %11, t9
        t36: ch = CopyToReg t0, Register:i64 %12, t34
        t48: ch = CopyToReg t0, Register:i64 %13, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
      t68: i8 = and t65, Constant:i8<1>
    t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge91 0x7fee590539d0>
  t57: ch = br t60, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>



Combining: t68: i8 = and t65, Constant:i8<1>

Replacing.2 t68: i8 = and t65, Constant:i8<1>

With: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch


Combining: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t63: ch = store<(store (s64) into %ir..repack15)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t61: ch = setlt

Combining: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge91 0x7fee590539d0>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>

Combining: t56: ch = BasicBlock<.lr.ph90.preheader 0x7fee590538d0>

Combining: t54: ch = BasicBlock<._crit_edge91 0x7fee590539d0>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %13, t46

Combining: t47: i64 = Register %13

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %12, t34

Combining: t35: i64 = Register %12

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %1

Combining: t30: i64 = Register %1

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack13)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %0

Combining: t24: i64 = Register %0

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack11)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack9)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.22)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %10

Combining: t12: i64 = Register %10

Combining: t11: ch = CopyToReg t0, Register:i64 %11, t9

Combining: t10: i64 = Register %11

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized type-legalized selection DAG: %bb.2 'main:._crit_edge'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %10
  t31: i64,ch = CopyFromReg t0, Register:i64 %1
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.22)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack9)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack11)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %0
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack13)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack15)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %11, t9
        t36: ch = CopyToReg t0, Register:i64 %12, t34
        t48: ch = CopyToReg t0, Register:i64 %13, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge91 0x7fee590539d0>
  t57: ch = br t60, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>



Legalizing: t57: ch = br t60, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>
Legal node: nothing to do

Legalizing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge91 0x7fee590539d0>
Trying custom legalization
Creating new node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Creating constant: t70: i8 = TargetConstant<14>
Creating new node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge91 0x7fee590539d0>, TargetConstant:i8<14>, t69
Successfully custom legalized node
 ... replacing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge91 0x7fee590539d0>
     with:      t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge91 0x7fee590539d0>, TargetConstant:i8<14>, t69

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Legalizing: t48: ch = CopyToReg t0, Register:i64 %13, t46
Legal node: nothing to do

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Legalizing: t36: ch = CopyToReg t0, Register:i64 %12, t34
Legal node: nothing to do

Legalizing: t18: ch = store<(store (s64) into %ir..repack9)> t9:1, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t21: ch = store<(store (s64) into %ir..repack11)> t9:1, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t26: ch = store<(store (s64) into %ir..repack13)> t9:1, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t63: ch = store<(store (s64) into %ir..repack15)> t9:1, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Legalizing: t15: ch = store<(store (s64) into %ir.22)> t9:1, t13, t9, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t11: ch = CopyToReg t0, Register:i64 %11, t9
Legal node: nothing to do

Legalizing: t17: i64 = add nuw t9, Constant:i64<8>
Legal node: nothing to do

Legalizing: t20: i64 = add nuw t9, Constant:i64<16>
Legal node: nothing to do

Legalizing: t23: i64 = add nuw t9, Constant:i64<24>
Legal node: nothing to do

Legalizing: t28: i64 = add nuw t9, Constant:i64<32>
Legal node: nothing to do

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %1
Legal node: nothing to do

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %0
Legal node: nothing to do

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %10
Legal node: nothing to do

Legalizing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Trying custom legalization
Creating new node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Creating new node: t75: i64 = sub t74, Constant:i64<48>
Creating new node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Creating new node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t78: i64,ch = merge_values t75, t77
Successfully custom legalized node
 ... replacing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
     with:      t78: i64,ch = merge_values t75, t77
      and:      t78: i64,ch = merge_values t75, t77

Legalizing: t56: ch = BasicBlock<.lr.ph90.preheader 0x7fee590538d0>
Legal node: nothing to do

Legalizing: t54: ch = BasicBlock<._crit_edge91 0x7fee590539d0>
Legal node: nothing to do

Legalizing: t47: i64 = Register %13

Legalizing: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Legalizing: t37: i64 = GlobalAddress<ptr @malloc> 0
Trying custom legalization
Creating new node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Successfully custom legalized node
 ... replacing: t37: i64 = GlobalAddress<ptr @malloc> 0
     with:      t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t35: i64 = Register %12

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Legalizing: t30: i64 = Register %1

Legalizing: t27: i64 = Constant<32>
Legal node: nothing to do

Legalizing: t24: i64 = Register %0

Legalizing: t22: i64 = Constant<24>
Legal node: nothing to do

Legalizing: t19: i64 = Constant<16>
Legal node: nothing to do

Legalizing: t16: i64 = Constant<8>
Legal node: nothing to do

Legalizing: t14: i64 = undef
Legal node: nothing to do

Legalizing: t12: i64 = Register %10

Legalizing: t10: i64 = Register %11

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t7: i64 = Constant<48>
Legal node: nothing to do

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t78: i64,ch = merge_values t75, t77
Trying to expand node
Successfully expanded node
 ... replacing: t78: i64,ch = merge_values t75, t77
     with:      t75: i64 = sub t74, Constant:i64<48>
      and:      t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Legalizing: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge91 0x7fee590539d0>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Legalizing: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do
Legalized selection DAG: %bb.2 'main:._crit_edge'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %10
  t31: i64,ch = CopyFromReg t0, Register:i64 %1
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.22)> t77, t13, t75, undef:i64
          t17: i64 = add nuw t75, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack9)> t77, t13, t17, undef:i64
          t20: i64 = add nuw t75, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack11)> t77, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %0
          t23: i64 = add nuw t75, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack13)> t77, t25, t23, undef:i64
          t28: i64 = add nuw t75, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack15)> t77, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
  t75: i64 = sub t74, Constant:i64<48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
        t11: ch = CopyToReg t0, Register:i64 %11, t75
        t36: ch = CopyToReg t0, Register:i64 %12, t34
        t48: ch = CopyToReg t0, Register:i64 %13, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge91 0x7fee590539d0>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>



Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Combining: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Combining: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Combining: t75: i64 = sub t74, Constant:i64<48>
Creating constant: t81: i64 = Constant<-48>
Creating new node: t82: i64 = add t74, Constant:i64<-48>
 ... into: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t81: i64 = Constant<-48>
Legal node: nothing to do

Combining: t81: i64 = Constant<-48>

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Combining: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

Legalizing: t73: i64 = Register $rsp

Combining: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge91 0x7fee590539d0>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Combining: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge91 0x7fee590539d0>, TargetConstant:i8<14>, t69

Legalizing: t70: i8 = TargetConstant<14>

Combining: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do

Combining: t69: i32 = X86ISD::CMP t31, Constant:i64<0>

Legalizing: t57: ch = br t71, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>
Legal node: nothing to do

Combining: t57: ch = br t71, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing: t48: ch = CopyToReg t0, Register:i64 %13, t46
Legal node: nothing to do

Combining: t48: ch = CopyToReg t0, Register:i64 %13, t46

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Combining: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing: t36: ch = CopyToReg t0, Register:i64 %12, t34
Legal node: nothing to do

Combining: t36: ch = CopyToReg t0, Register:i64 %12, t34

Legalizing: t18: ch = store<(store (s64) into %ir..repack9)> t77, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack9)> t77, t13, t17, undef:i64

Legalizing: t21: ch = store<(store (s64) into %ir..repack11)> t77, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack11)> t77, Constant:i64<0>, t20, undef:i64

Legalizing: t26: ch = store<(store (s64) into %ir..repack13)> t77, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack13)> t77, t25, t23, undef:i64

Legalizing: t63: ch = store<(store (s64) into %ir..repack15)> t77, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack15)> t77, Constant:i64<1>, t28, undef:i64

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Combining: t34: i64 = shl t31, Constant:i8<3>

Legalizing: t15: ch = store<(store (s64) into %ir.22)> t77, t13, t82, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t15: ch = store<(store (s64) into %ir.22)> t77, t13, t82, undef:i64

Legalizing: t11: ch = CopyToReg t0, Register:i64 %11, t82
Legal node: nothing to do

Combining: t11: ch = CopyToReg t0, Register:i64 %11, t82

Legalizing: t17: i64 = add nuw t82, Constant:i64<8>
Legal node: nothing to do

Combining: t17: i64 = add nuw t82, Constant:i64<8>
Creating constant: t83: i64 = Constant<-40>
Creating new node: t84: i64 = add t74, Constant:i64<-40>
 ... into: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t18: ch = store<(store (s64) into %ir..repack9)> t77, t13, t84, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack9)> t77, t13, t84, undef:i64

Legalizing: t84: i64 = add t74, Constant:i64<-40>
Legal node: nothing to do

Combining: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t83: i64 = Constant<-40>
Legal node: nothing to do

Combining: t83: i64 = Constant<-40>

Legalizing: t20: i64 = add nuw t82, Constant:i64<16>
Legal node: nothing to do

Combining: t20: i64 = add nuw t82, Constant:i64<16>
Creating constant: t85: i64 = Constant<-32>
Creating new node: t86: i64 = add t74, Constant:i64<-32>
 ... into: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t21: ch = store<(store (s64) into %ir..repack11)> t77, Constant:i64<0>, t86, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack11)> t77, Constant:i64<0>, t86, undef:i64

Legalizing: t86: i64 = add t74, Constant:i64<-32>
Legal node: nothing to do

Combining: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t85: i64 = Constant<-32>
Legal node: nothing to do

Combining: t85: i64 = Constant<-32>

Legalizing: t23: i64 = add nuw t82, Constant:i64<24>
Legal node: nothing to do

Combining: t23: i64 = add nuw t82, Constant:i64<24>
Creating constant: t87: i64 = Constant<-24>
Creating new node: t88: i64 = add t74, Constant:i64<-24>
 ... into: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t26: ch = store<(store (s64) into %ir..repack13)> t77, t25, t88, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack13)> t77, t25, t88, undef:i64

Legalizing: t88: i64 = add t74, Constant:i64<-24>
Legal node: nothing to do

Combining: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t87: i64 = Constant<-24>
Legal node: nothing to do

Combining: t87: i64 = Constant<-24>

Legalizing: t28: i64 = add nuw t82, Constant:i64<32>
Legal node: nothing to do

Combining: t28: i64 = add nuw t82, Constant:i64<32>
Creating constant: t89: i64 = Constant<-16>
Creating new node: t90: i64 = add t74, Constant:i64<-16>
 ... into: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t63: ch = store<(store (s64) into %ir..repack15)> t77, Constant:i64<1>, t90, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack15)> t77, Constant:i64<1>, t90, undef:i64

Legalizing: t90: i64 = add t74, Constant:i64<-16>
Legal node: nothing to do

Combining: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t89: i64 = Constant<-16>
Legal node: nothing to do

Combining: t89: i64 = Constant<-16>

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %1
Legal node: nothing to do

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %1

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %0
Legal node: nothing to do

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %0

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %10
Legal node: nothing to do

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %10

Legalizing: t56: ch = BasicBlock<.lr.ph90.preheader 0x7fee590538d0>
Legal node: nothing to do

Combining: t56: ch = BasicBlock<.lr.ph90.preheader 0x7fee590538d0>

Legalizing: t54: ch = BasicBlock<._crit_edge91 0x7fee590539d0>
Legal node: nothing to do

Combining: t54: ch = BasicBlock<._crit_edge91 0x7fee590539d0>

Legalizing: t47: i64 = Register %13

Combining: t47: i64 = Register %13

Legalizing: t45: i64 = Register $rax

Combining: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Combining: t42: Untyped = RegisterMask

Legalizing: t40: i64 = Register $rdi

Combining: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Combining: t38: i64 = TargetConstant<0>

Legalizing: t35: i64 = Register %12

Combining: t35: i64 = Register %12

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Combining: t33: i8 = Constant<3>

Legalizing: t30: i64 = Register %1

Combining: t30: i64 = Register %1

Legalizing: t24: i64 = Register %0

Combining: t24: i64 = Register %0

Legalizing: t14: i64 = undef
Legal node: nothing to do

Combining: t14: i64 = undef

Legalizing: t12: i64 = Register %10

Combining: t12: i64 = Register %10

Legalizing: t10: i64 = Register %11

Combining: t10: i64 = Register %11

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Combining: t8: i64 = Constant<0>

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Combining: t2: i64 = Constant<1>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.2 'main:._crit_edge'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %10
  t31: i64,ch = CopyFromReg t0, Register:i64 %1
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.22)> t77, t13, t82, undef:i64
          t84: i64 = add t74, Constant:i64<-40>
        t18: ch = store<(store (s64) into %ir..repack9)> t77, t13, t84, undef:i64
          t86: i64 = add t74, Constant:i64<-32>
        t21: ch = store<(store (s64) into %ir..repack11)> t77, Constant:i64<0>, t86, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %0
          t88: i64 = add t74, Constant:i64<-24>
        t26: ch = store<(store (s64) into %ir..repack13)> t77, t25, t88, undef:i64
          t90: i64 = add t74, Constant:i64<-16>
        t63: ch = store<(store (s64) into %ir..repack15)> t77, Constant:i64<1>, t90, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
  t82: i64 = add t74, Constant:i64<-48>
        t11: ch = CopyToReg t0, Register:i64 %11, t82
        t36: ch = CopyToReg t0, Register:i64 %12, t34
        t48: ch = CopyToReg t0, Register:i64 %13, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge91 0x7fee590539d0>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>


===== Instruction selection begins: %bb.2 '._crit_edge'

ISEL: Starting selection on root node: t57: ch = br t71, BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>
ISEL: Starting pattern match
  Initial Opcode index to 134414
  Morphed node: t57: ch = JMP_1 BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>, t71
ISEL: Match complete!

ISEL: Starting selection on root node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge91 0x7fee590539d0>, TargetConstant:i8<14>, t69
ISEL: Starting pattern match
  Initial Opcode index to 131614
Creating new node: t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  Morphed node: t71: ch = JCC_1 BasicBlock:ch<._crit_edge91 0x7fee590539d0>, TargetConstant:i8<14>, t92, t92:1
ISEL: Match complete!

ISEL: Starting selection on root node: t53: ch = TokenFactor t11, t36, t48, t46:1

ISEL: Starting selection on root node: t48: ch = CopyToReg t0, Register:i64 %13, t46

ISEL: Starting selection on root node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

ISEL: Starting selection on root node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
ISEL: Match complete!

ISEL: Starting selection on root node: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
ISEL: Match complete!

ISEL: Starting selection on root node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

ISEL: Starting selection on root node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t93: i32 = TargetConstant<0>
  Morphed node: t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
ISEL: Match complete!

ISEL: Starting selection on root node: t64: ch = TokenFactor t15, t18, t21, t26, t63

ISEL: Starting selection on root node: t15: ch = store<(store (s64) into %ir.22)> t77, t13, t82, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t94: i8 = TargetConstant<1>
Creating constant: t96: i32 = TargetConstant<-48>
  Morphed node: t15: ch = MOV64mr<Mem:(store (s64) into %ir.22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch = store<(store (s64) into %ir..repack9)> t77, t13, t84, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t98: i32 = TargetConstant<-40>
  Morphed node: t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack9)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = store<(store (s64) into %ir..repack11)> t77, Constant:i64<0>, t86, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Skipped scope entry (due to false predicate) at index 16132, continuing at 16162
  Skipped scope entry (due to false predicate) at index 16163, continuing at 16193
  Match failed at index 16203
  Continuing at 16224
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t99: i32 = TargetConstant<-32>
  Morphed node: t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack11)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t26: ch = store<(store (s64) into %ir..repack13)> t77, t25, t88, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t100: i32 = TargetConstant<-24>
  Morphed node: t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack13)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t63: ch = store<(store (s64) into %ir..repack15)> t77, Constant:i64<1>, t90, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t101: i32 = TargetConstant<-16>
Creating constant: t102: i64 = TargetConstant<1>
  Morphed node: t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack15)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
ISEL: Match complete!

ISEL: Starting selection on root node: t11: ch = CopyToReg t0, Register:i64 %11, t82

ISEL: Starting selection on root node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

ISEL: Starting selection on root node: t82: i64 = add t74, Constant:i64<-48>
ISEL: Starting pattern match
  Initial Opcode index to 102161
  Match failed at index 102165
  Continuing at 102268
  Match failed at index 102270
  Continuing at 102377
  TypeSwitch[i64] from 102379 to 102420
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 102420
  Continuing at 102435
  Match failed at index 102438
  Continuing at 102459
  Match failed at index 102461
  Continuing at 102483
  Skipped scope entry (due to false predicate) at index 102488, continuing at 102540
  Skipped scope entry (due to false predicate) at index 102541, continuing at 102593
  Skipped scope entry (due to false predicate) at index 102594, continuing at 102644
  Skipped scope entry (due to false predicate) at index 102645, continuing at 102669
  Match failed at index 102683
  Continuing at 102696
  Match failed at index 102700
  Continuing at 102713
Creating constant: t104: i64 = TargetConstant<-48>
  Morphed node: t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
ISEL: Match complete!

ISEL: Starting selection on root node: t36: ch = CopyToReg t0, Register:i64 %12, t34

ISEL: Starting selection on root node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

ISEL: Starting selection on root node: t34: i64 = shl t31, Constant:i8<3>
ISEL: Starting pattern match
  Initial Opcode index to 44725
  Match failed at index 44729
  Continuing at 44944
  TypeSwitch[i64] from 44946 to 44987
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 44987
  Continuing at 45002
  Match failed at index 45009
  Continuing at 45152
  Match failed at index 45153
  Continuing at 45203
  TypeSwitch[i64] from 45215 to 45257
Creating constant: t105: i8 = TargetConstant<3>
  Morphed node: t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 25710
  Match failed at index 25714
  Continuing at 26614
  Skipped scope entry (due to false predicate) at index 26619, continuing at 26650
  Skipped scope entry (due to false predicate) at index 26651, continuing at 26682
  Skipped scope entry (due to false predicate) at index 26683, continuing at 26714
  Match failed at index 26718
  Continuing at 26746
  Continuing at 26747
  Match failed at index 26750
  Continuing at 27134
  Skipped scope entry (due to false predicate) at index 27139, continuing at 27203
  Skipped scope entry (due to false predicate) at index 27204, continuing at 27304
  Skipped scope entry (due to false predicate) at index 27305, continuing at 27405
  Morphed node: t69: i32 = TEST64rr t31, t31
ISEL: Match complete!

ISEL: Starting selection on root node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132007
  Match failed at index 132010
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t31: i64,ch = CopyFromReg t0, Register:i64 %1

ISEL: Starting selection on root node: t25: i64,ch = CopyFromReg t0, Register:i64 %0

ISEL: Starting selection on root node: t13: i64,ch = CopyFromReg t0, Register:i64 %10

ISEL: Starting selection on root node: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

ISEL: Starting selection on root node: t73: i64 = Register $rsp

ISEL: Starting selection on root node: t70: i8 = TargetConstant<14>

ISEL: Starting selection on root node: t56: ch = BasicBlock<.lr.ph90.preheader 0x7fee590538d0>

ISEL: Starting selection on root node: t54: ch = BasicBlock<._crit_edge91 0x7fee590539d0>

ISEL: Starting selection on root node: t47: i64 = Register %13

ISEL: Starting selection on root node: t45: i64 = Register $rax

ISEL: Starting selection on root node: t42: Untyped = RegisterMask

ISEL: Starting selection on root node: t40: i64 = Register $rdi

ISEL: Starting selection on root node: t38: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t35: i64 = Register %12

ISEL: Starting selection on root node: t30: i64 = Register %1

ISEL: Starting selection on root node: t24: i64 = Register %0

ISEL: Starting selection on root node: t12: i64 = Register %10

ISEL: Starting selection on root node: t10: i64 = Register %11

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.2 'main:._crit_edge'
SelectionDAG has 59 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %10
  t31: i64,ch = CopyFromReg t0, Register:i64 %1
  t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
    t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
  t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp
  t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
        t15: ch = MOV64mr<Mem:(store (s64) into %ir.22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1
        t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack9)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1
        t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack11)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1
          t25: i64,ch = CopyFromReg t0, Register:i64 %0
        t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack13)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1
        t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack15)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
  t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34
    t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
  t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
  t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2
      t11: ch = CopyToReg t0, Register:i64 %11, t82
      t36: ch = CopyToReg t0, Register:i64 %12, t34
      t48: ch = CopyToReg t0, Register:i64 %13, t46
    t53: ch = TokenFactor t11, t36, t48, t46:1
    t69: i32 = TEST64rr t31, t31
  t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  t103: i32 = Register $noreg
    t71: ch = JCC_1 BasicBlock:ch<._crit_edge91 0x7fee590539d0>, TargetConstant:i8<14>, t92, t92:1
  t57: ch = JMP_1 BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>, t71


********** List Scheduling %bb.2 '._crit_edge' **********
SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>, t71

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge91 0x7fee590539d0>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(4): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t69: i32 = TEST64rr t31, t31

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %1

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(6): Data Latency=1
SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(24): Ord  Latency=1 Barrier
    SU(23): Ord  Latency=1 Barrier
    SU(22): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(21): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(22): Data Latency=1
SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(5): Data Latency=1
    SU(23): Data Latency=1
SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(8): Ord  Latency=0 Barrier
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(20): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(9): Ord  Latency=1 Barrier
  Successors:
    SU(7): Ord  Latency=0 Barrier
SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack15)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

  # preds left       : 1
  # succs left       : 5
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(11): Ord  Latency=1 Barrier
  Successors:
    SU(9): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(20): Ord  Latency=1 Barrier
SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 7
  Predecessors:
    SU(13): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
  Successors:
    SU(10): Ord  Latency=1 Barrier
SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(13): Data Latency=1
  Successors:
    SU(11): Data Latency=1
    SU(24): Data Latency=1
SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

  # preds left       : 1
  # succs left       : 7
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 9
  Predecessors:
    SU(14): Ord  Latency=1 Barrier
  Successors:
    SU(9): Data Latency=1
    SU(11): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
    SU(15): Data Latency=1
    SU(17): Data Latency=1
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(13): Ord  Latency=1 Barrier
SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack13)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(16): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(15): Data Latency=1
SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack11)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack9)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %10

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(22): t48: ch = CopyToReg t0, Register:i64 %13, t46

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(23): t36: ch = CopyToReg t0, Register:i64 %12, t34

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>, t71


*** Scheduling [0]: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>, t71


Examining Available:
Height 1: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge91 0x7fee590539d0>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


*** Scheduling [1]: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge91 0x7fee590539d0>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


Examining Available:
Height 1: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

Height 2: SU(2): t69: i32 = TEST64rr t31, t31


*** Scheduling [2]: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1


Examining Available:
Height 2: SU(2): t69: i32 = TEST64rr t31, t31

Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %13, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %12, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


*** Scheduling [3]: SU(2): t69: i32 = TEST64rr t31, t31


Examining Available:
Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %13, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %12, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


*** Scheduling [4]: SU(22): t48: ch = CopyToReg t0, Register:i64 %13, t46


Examining Available:
Height 5: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %12, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


*** Scheduling [5]: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1


Examining Available:
Height 6: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %12, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


*** Scheduling [6]: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0


Examining Available:
Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %12, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


*** Scheduling [7]: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64


Examining Available:
Height 7: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %12, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


*** Scheduling [8]: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63


Examining Available:
Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %12, t34

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack15)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack13)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack11)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack9)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


*** Scheduling [9]: SU(23): t36: ch = CopyToReg t0, Register:i64 %12, t34


Examining Available:
Height 10: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack15)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack13)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack11)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack9)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


*** Scheduling [10]: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>


Examining Available:
Height 11: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %1

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack15)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack13)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack11)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack9)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


*** Scheduling [11]: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %1


Examining Available:
Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack15)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack13)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack11)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack9)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


*** Scheduling [12]: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack15)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1


Examining Available:
Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack13)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack11)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack9)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


*** Scheduling [13]: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack13)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1


Examining Available:
Height 14: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %0

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack11)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack9)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


*** Scheduling [14]: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %0


Examining Available:
Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack11)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack9)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


*** Scheduling [15]: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack11)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1


Examining Available:
Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack9)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


*** Scheduling [16]: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack9)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


*** Scheduling [17]: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 18: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %10

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [18]: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %10


Examining Available:
Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [19]: SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82


Examining Available:
Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [20]: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


Examining Available:
Height 21: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


*** Scheduling [21]: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


Examining Available:
Height 22: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


*** Scheduling [22]: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


Examining Available:
Height 23: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


*** Scheduling [23]: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


Examining Available:
Height 24: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [24]: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

SU(24): t11: ch = CopyToReg t0, Register:i64 %11, t82

SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %10

SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack9)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack11)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %0

SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack13)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack15)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %1

SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

SU(23): t36: ch = CopyToReg t0, Register:i64 %12, t34

SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

SU(22): t48: ch = CopyToReg t0, Register:i64 %13, t46

SU(2): t69: i32 = TEST64rr t31, t31

SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge91 0x7fee590539d0>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph90.preheader 0x7fee590538d0>, t71


Total amount of phi nodes to update: 0
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %13
Creating constant: t3: i8 = Constant<0>
Creating new node: t5: i64,ch = CopyFromReg t0, Register:i64 %12
Creating constant: t7: i64 = TargetConstant<0>
Creating new node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Creating new node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Creating new node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Creating new node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Initial selection DAG: %bb.3 'main:.lr.ph90.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t3: i8 = Constant<0>
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %13
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %12
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Combining: t13: Untyped = RegisterMask

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Combining: t11: i64 = Register $rsi

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Combining: t9: i64 = Register $rdi

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t7: i64 = TargetConstant<0>

Combining: t6: i64 = ExternalSymbol'__bzero'

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %12

Combining: t4: i64 = Register %12

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %13

Combining: t1: i64 = Register %13

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.3 'main:.lr.ph90.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %13
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %12
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


Legalizing node: t13: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t13: Untyped = RegisterMask

Legalizing node: t11: i64 = Register $rsi
Ignoring node results
Legally typed node: t11: i64 = Register $rsi

Legalizing node: t9: i64 = Register $rdi
Ignoring node results
Legally typed node: t9: i64 = Register $rdi

Legalizing node: t7: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t7: i64 = TargetConstant<0>

Legalizing node: t6: i64 = ExternalSymbol'__bzero'
Analyzing result type: i64
Legal result type
Legally typed node: t6: i64 = ExternalSymbol'__bzero'

Legalizing node: t4: i64 = Register %12
Ignoring node results
Legally typed node: t4: i64 = Register %12

Legalizing node: t1: i64 = Register %13
Ignoring node results
Legally typed node: t1: i64 = Register %13

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %13
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %13

Legalizing node: t5: i64,ch = CopyFromReg t0, Register:i64 %12
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t5: i64,ch = CopyFromReg t0, Register:i64 %12

Legalizing node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %13
Legal operand
Legally typed node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Analyzing operand: t5: i64,ch = CopyFromReg t0, Register:i64 %12
Legal operand
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Legally typed node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Analyzing operand: t6: i64 = ExternalSymbol'__bzero'
Legal operand
Analyzing operand: t13: Untyped = RegisterMask
Legal operand
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Legally typed node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Legally typed node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.3 'main:.lr.ph90.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %13
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %12
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %12
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %13
Legal node: nothing to do

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Legalizing: t6: i64 = ExternalSymbol'__bzero'
Trying custom legalization
Creating new node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Successfully custom legalized node
 ... replacing: t6: i64 = ExternalSymbol'__bzero'
     with:      t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t4: i64 = Register %12

Legalizing: t1: i64 = Register %13

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do
Legalized selection DAG: %bb.3 'main:.lr.ph90.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %13
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %12
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Combining: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do

Combining: t16: i64 = TargetExternalSymbol'__bzero'

Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Combining: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %12
Legal node: nothing to do

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %12

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %13
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %13

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Combining: t13: Untyped = RegisterMask

Legalizing: t11: i64 = Register $rsi

Combining: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Combining: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Combining: t7: i64 = TargetConstant<0>

Legalizing: t4: i64 = Register %12

Combining: t4: i64 = Register %12

Legalizing: t1: i64 = Register %13

Combining: t1: i64 = Register %13

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.3 'main:.lr.ph90.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %13
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %12
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


===== Instruction selection begins: %bb.3 '.lr.ph90.preheader'

ISEL: Starting selection on root node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

ISEL: Starting selection on root node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

ISEL: Starting selection on root node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132022
  Match failed at index 132025
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t18: i32 = TargetConstant<0>
  Morphed node: t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i64,ch = CopyFromReg t0, Register:i64 %12

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %13

ISEL: Starting selection on root node: t16: i64 = TargetExternalSymbol'__bzero'

ISEL: Starting selection on root node: t13: Untyped = RegisterMask

ISEL: Starting selection on root node: t11: i64 = Register $rsi

ISEL: Starting selection on root node: t9: i64 = Register $rdi

ISEL: Starting selection on root node: t7: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t4: i64 = Register %12

ISEL: Starting selection on root node: t1: i64 = Register %13

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.3 'main:.lr.ph90.preheader'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
    t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t2: i64,ch = CopyFromReg t0, Register:i64 %13
  t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %12
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
  t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1


********** List Scheduling %bb.3 '.lr.ph90.preheader' **********
SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1

  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Data Latency=1
    SU(1): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %12

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %13

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1

Examining Available:
Height 0: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


*** Scheduling [0]: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Examining Available:
Height 1: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %12

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %13

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [1]: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'


Examining Available:
Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %12

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %13

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [2]: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %12


Examining Available:
Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %13

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [3]: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %13


Examining Available:
Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [4]: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %13

SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %12

SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<1>
Creating constant: t2: i64 = Constant<1>
Creating constant: t3: i64 = Constant<40>
Creating constant: t4: i64 = Constant<15>
Creating constant: t5: i64 = Constant<55>
Creating constant: t6: i64 = Constant<-16>
Creating constant: t7: i64 = Constant<48>
Creating constant: t8: i64 = Constant<0>
Creating new node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Creating new node: t11: ch = CopyToReg t0, Register:i64 %14, t9
Creating new node: t13: i64,ch = CopyFromReg t0, Register:i64 %13
Creating new node: t14: i64 = undef
Creating new node: t15: ch = store<(store (s64) into %ir.25)> t9:1, t13, t9, undef:i64
Creating constant: t16: i64 = Constant<8>
Creating new node: t17: i64 = add nuw t9, Constant:i64<8>
Creating new node: t18: ch = store<(store (s64) into %ir..repack18)> t15, t13, t17, undef:i64
Creating constant: t19: i64 = Constant<16>
Creating new node: t20: i64 = add nuw t9, Constant:i64<16>
Creating new node: t21: ch = store<(store (s64) into %ir..repack20)> t18, Constant:i64<0>, t20, undef:i64
Creating constant: t22: i64 = Constant<24>
Creating new node: t23: i64 = add nuw t9, Constant:i64<24>
Creating new node: t25: i64,ch = CopyFromReg t0, Register:i64 %1
Creating new node: t26: ch = store<(store (s64) into %ir..repack22)> t21, t25, t23, undef:i64
Creating constant: t27: i64 = Constant<32>
Creating new node: t28: i64 = add nuw t9, Constant:i64<32>
Creating new node: t29: ch = store<(store (s64) into %ir..repack24)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t31: i64,ch = CopyFromReg t0, Register:i64 %2
Creating constant: t32: i64 = Constant<3>
Creating constant: t33: i8 = Constant<3>
Creating new node: t34: i64 = shl t31, Constant:i8<3>
Creating new node: t36: ch = CopyToReg t0, Register:i64 %15, t34
Creating constant: t38: i64 = TargetConstant<0>
Creating new node: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Creating new node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Creating new node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Creating new node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Creating new node: t48: ch = CopyToReg t0, Register:i64 %16, t46
Creating new node: t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
Creating constant: t51: i1 = Constant<-1>
Creating new node: t52: i1 = xor t50, Constant:i1<-1>
Creating new node: t53: ch = TokenFactor t11, t36, t48, t46:1
Creating new node: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>
Creating new node: t57: ch = br t55, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>
Initial selection DAG: %bb.4 'main:._crit_edge91'
SelectionDAG has 58 nodes:
  t0: ch,glue = EntryToken
  t1: i32 = Constant<1>
  t3: i64 = Constant<40>
  t4: i64 = Constant<15>
  t5: i64 = Constant<55>
  t6: i64 = Constant<-16>
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %13
  t31: i64,ch = CopyFromReg t0, Register:i64 %2
  t32: i64 = Constant<3>
  t34: i64 = shl t31, Constant:i8<3>
              t15: ch = store<(store (s64) into %ir.25)> t9:1, t13, t9, undef:i64
              t17: i64 = add nuw t9, Constant:i64<8>
            t18: ch = store<(store (s64) into %ir..repack18)> t15, t13, t17, undef:i64
            t20: i64 = add nuw t9, Constant:i64<16>
          t21: ch = store<(store (s64) into %ir..repack20)> t18, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %1
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack22)> t21, t25, t23, undef:i64
        t28: i64 = add nuw t9, Constant:i64<32>
      t29: ch = store<(store (s64) into %ir..repack24)> t26, Constant:i64<1>, t28, undef:i64
    t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %14, t9
        t36: ch = CopyToReg t0, Register:i64 %15, t34
        t48: ch = CopyToReg t0, Register:i64 %16, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
      t52: i1 = xor t50, Constant:i1<-1>
    t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>
  t57: ch = br t55, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>



Combining: t57: ch = br t55, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>

Combining: t56: ch = BasicBlock<.lr.ph93.preheader 0x7fee59053ad0>

Combining: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>
Creating new node: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>
 ... into: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>

Combining: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>

Combining: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
 ... into: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>

Combining: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t61: ch = setlt

Combining: t54: ch = BasicBlock<._crit_edge94 0x7fee59053bd0>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %16, t46

Combining: t47: i64 = Register %16

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %15, t34

Combining: t35: i64 = Register %15

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %2

Combining: t30: i64 = Register %2

Combining: t29: ch = store<(store (s64) into %ir..repack24)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t63: ch = store<(store (s64) into %ir..repack24)> t9:1, Constant:i64<1>, t28, undef:i64
Creating new node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Replacing.1 t29: ch = store<(store (s64) into %ir..repack24)> t26, Constant:i64<1>, t28, undef:i64

With: t64: ch = TokenFactor t15, t18, t21, t26, t63
 and 0 other values

Combining: t63: ch = store<(store (s64) into %ir..repack24)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack22)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %1

Combining: t24: i64 = Register %1

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack20)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack18)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.25)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %13

Combining: t12: i64 = Register %13

Combining: t11: ch = CopyToReg t0, Register:i64 %14, t9

Combining: t10: i64 = Register %14

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.4 'main:._crit_edge91'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %13
  t31: i64,ch = CopyFromReg t0, Register:i64 %2
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.25)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack18)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack20)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %1
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack22)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack24)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %14, t9
        t36: ch = CopyToReg t0, Register:i64 %15, t34
        t48: ch = CopyToReg t0, Register:i64 %16, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>
  t57: ch = br t60, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>


Legalizing node: t61: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t61: ch = setlt

Legalizing node: t56: ch = BasicBlock<.lr.ph93.preheader 0x7fee59053ad0>
Analyzing result type: ch
Legal result type
Legally typed node: t56: ch = BasicBlock<.lr.ph93.preheader 0x7fee59053ad0>

Legalizing node: t54: ch = BasicBlock<._crit_edge94 0x7fee59053bd0>
Analyzing result type: ch
Legal result type
Legally typed node: t54: ch = BasicBlock<._crit_edge94 0x7fee59053bd0>

Legalizing node: t47: i64 = Register %16
Ignoring node results
Legally typed node: t47: i64 = Register %16

Legalizing node: t45: i64 = Register $rax
Ignoring node results
Legally typed node: t45: i64 = Register $rax

Legalizing node: t42: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t42: Untyped = RegisterMask

Legalizing node: t40: i64 = Register $rdi
Ignoring node results
Legally typed node: t40: i64 = Register $rdi

Legalizing node: t38: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t38: i64 = TargetConstant<0>

Legalizing node: t37: i64 = GlobalAddress<ptr @malloc> 0
Analyzing result type: i64
Legal result type
Legally typed node: t37: i64 = GlobalAddress<ptr @malloc> 0

Legalizing node: t35: i64 = Register %15
Ignoring node results
Legally typed node: t35: i64 = Register %15

Legalizing node: t33: i8 = Constant<3>
Analyzing result type: i8
Legal result type
Legally typed node: t33: i8 = Constant<3>

Legalizing node: t30: i64 = Register %2
Ignoring node results
Legally typed node: t30: i64 = Register %2

Legalizing node: t27: i64 = Constant<32>
Analyzing result type: i64
Legal result type
Legally typed node: t27: i64 = Constant<32>

Legalizing node: t24: i64 = Register %1
Ignoring node results
Legally typed node: t24: i64 = Register %1

Legalizing node: t22: i64 = Constant<24>
Analyzing result type: i64
Legal result type
Legally typed node: t22: i64 = Constant<24>

Legalizing node: t19: i64 = Constant<16>
Analyzing result type: i64
Legal result type
Legally typed node: t19: i64 = Constant<16>

Legalizing node: t16: i64 = Constant<8>
Analyzing result type: i64
Legal result type
Legally typed node: t16: i64 = Constant<8>

Legalizing node: t14: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t14: i64 = undef

Legalizing node: t12: i64 = Register %13
Ignoring node results
Legally typed node: t12: i64 = Register %13

Legalizing node: t10: i64 = Register %14
Ignoring node results
Legally typed node: t10: i64 = Register %14

Legalizing node: t8: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t8: i64 = Constant<0>

Legalizing node: t7: i64 = Constant<48>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<48>

Legalizing node: t2: i64 = Constant<1>
Analyzing result type: i64
Legal result type
Legally typed node: t2: i64 = Constant<1>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t7: i64 = Constant<48>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Legally typed node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Legalizing node: t11: ch = CopyToReg t0, Register:i64 %14, t9
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Legally typed node: t11: ch = CopyToReg t0, Register:i64 %14, t9

Legalizing node: t17: i64 = add nuw t9, Constant:i64<8>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t16: i64 = Constant<8>
Legal operand
Legally typed node: t17: i64 = add nuw t9, Constant:i64<8>

Legalizing node: t20: i64 = add nuw t9, Constant:i64<16>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t19: i64 = Constant<16>
Legal operand
Legally typed node: t20: i64 = add nuw t9, Constant:i64<16>

Legalizing node: t21: ch = store<(store (s64) into %ir..repack20)> t9:1, Constant:i64<0>, t20, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Analyzing operand: t20: i64 = add nuw t9, Constant:i64<16>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t21: ch = store<(store (s64) into %ir..repack20)> t9:1, Constant:i64<0>, t20, undef:i64

Legalizing node: t23: i64 = add nuw t9, Constant:i64<24>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t22: i64 = Constant<24>
Legal operand
Legally typed node: t23: i64 = add nuw t9, Constant:i64<24>

Legalizing node: t28: i64 = add nuw t9, Constant:i64<32>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t27: i64 = Constant<32>
Legal operand
Legally typed node: t28: i64 = add nuw t9, Constant:i64<32>

Legalizing node: t63: ch = store<(store (s64) into %ir..repack24)> t9:1, Constant:i64<1>, t28, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t28: i64 = add nuw t9, Constant:i64<32>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t63: ch = store<(store (s64) into %ir..repack24)> t9:1, Constant:i64<1>, t28, undef:i64

Legalizing node: t13: i64,ch = CopyFromReg t0, Register:i64 %13
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t13: i64,ch = CopyFromReg t0, Register:i64 %13

Legalizing node: t15: ch = store<(store (s64) into %ir.25)> t9:1, t13, t9, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %13
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t15: ch = store<(store (s64) into %ir.25)> t9:1, t13, t9, undef:i64

Legalizing node: t18: ch = store<(store (s64) into %ir..repack18)> t9:1, t13, t17, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %13
Legal operand
Analyzing operand: t17: i64 = add nuw t9, Constant:i64<8>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t18: ch = store<(store (s64) into %ir..repack18)> t9:1, t13, t17, undef:i64

Legalizing node: t25: i64,ch = CopyFromReg t0, Register:i64 %1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t25: i64,ch = CopyFromReg t0, Register:i64 %1

Legalizing node: t26: ch = store<(store (s64) into %ir..repack22)> t9:1, t25, t23, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t25: i64,ch = CopyFromReg t0, Register:i64 %1
Legal operand
Analyzing operand: t23: i64 = add nuw t9, Constant:i64<24>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t26: ch = store<(store (s64) into %ir..repack22)> t9:1, t25, t23, undef:i64

Legalizing node: t64: ch = TokenFactor t15, t18, t21, t26, t63
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = store<(store (s64) into %ir.25)> t9:1, t13, t9, undef:i64
Legal operand
Analyzing operand: t18: ch = store<(store (s64) into %ir..repack18)> t9:1, t13, t17, undef:i64
Legal operand
Analyzing operand: t21: ch = store<(store (s64) into %ir..repack20)> t9:1, Constant:i64<0>, t20, undef:i64
Legal operand
Analyzing operand: t26: ch = store<(store (s64) into %ir..repack22)> t9:1, t25, t23, undef:i64
Legal operand
Analyzing operand: t63: ch = store<(store (s64) into %ir..repack24)> t9:1, Constant:i64<1>, t28, undef:i64
Legal operand
Legally typed node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal operand
Legally typed node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t31: i64,ch = CopyFromReg t0, Register:i64 %2
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t31: i64,ch = CopyFromReg t0, Register:i64 %2

Legalizing node: t34: i64 = shl t31, Constant:i8<3>
Analyzing result type: i64
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %2
Legal operand
Analyzing operand: t33: i8 = Constant<3>
Legal operand
Legally typed node: t34: i64 = shl t31, Constant:i8<3>

Legalizing node: t36: ch = CopyToReg t0, Register:i64 %15, t34
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t36: ch = CopyToReg t0, Register:i64 %15, t34

Legalizing node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Analyzing operand: t37: i64 = GlobalAddress<ptr @malloc> 0
Legal operand
Analyzing operand: t42: Untyped = RegisterMask
Legal operand
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Legally typed node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Legally typed node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Legally typed node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing node: t48: ch = CopyToReg t0, Register:i64 %16, t46
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t48: ch = CopyToReg t0, Register:i64 %16, t46

Legalizing node: t53: ch = TokenFactor t11, t36, t48, t46:1
Analyzing result type: ch
Legal result type
Analyzing operand: t11: ch = CopyToReg t0, Register:i64 %14, t9
Legal operand
Analyzing operand: t36: ch = CopyToReg t0, Register:i64 %15, t34
Legal operand
Analyzing operand: t48: ch = CopyToReg t0, Register:i64 %16, t46
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i1
Promote integer result: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Creating new node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legalizing node: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>

Creating new node: t66: i8 = zero_extend t62
Legalizing node: t66: i8 = zero_extend t62
Analyzing result type: i8
Legal result type
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t66: i8 = zero_extend t62

Creating constant: t67: i8 = Constant<1>
Creating new node: t68: i8 = and t65, Constant:i8<1>
Replacing: t66: i8 = zero_extend t62
     with: t68: i8 = and t65, Constant:i8<1>
Legalizing node: t67: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t67: i8 = Constant<1>

Legalizing node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %2
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t61: ch = setlt
Legal operand
Legally typed node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Legalizing node: t68: i8 = and t65, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legal operand
Analyzing operand: t67: i8 = Constant<1>
Legal operand
Legally typed node: t68: i8 = and t65, Constant:i8<1>

Legalizing node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t68: i8 = and t65, Constant:i8<1>
Legal operand
Analyzing operand: t54: ch = BasicBlock<._crit_edge94 0x7fee59053bd0>
Legal operand
Legally typed node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>

Legalizing node: t57: ch = br t60, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>
Analyzing result type: ch
Legal result type
Analyzing operand: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>
Legal operand
Analyzing operand: t56: ch = BasicBlock<.lr.ph93.preheader 0x7fee59053ad0>
Legal operand
Legally typed node: t57: ch = br t60, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>

Legalizing node: t65535: ch = handlenode t57
Analyzing result type: ch
Legal result type
Analyzing operand: t57: ch = br t60, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>
Legal operand
Legally typed node: t65535: ch = handlenode t57

Type-legalized selection DAG: %bb.4 'main:._crit_edge91'
SelectionDAG has 53 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %13
  t31: i64,ch = CopyFromReg t0, Register:i64 %2
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.25)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack18)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack20)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %1
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack22)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack24)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %14, t9
        t36: ch = CopyToReg t0, Register:i64 %15, t34
        t48: ch = CopyToReg t0, Register:i64 %16, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
      t68: i8 = and t65, Constant:i8<1>
    t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>
  t57: ch = br t60, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>



Combining: t68: i8 = and t65, Constant:i8<1>

Replacing.2 t68: i8 = and t65, Constant:i8<1>

With: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch


Combining: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t63: ch = store<(store (s64) into %ir..repack24)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t61: ch = setlt

Combining: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>

Combining: t56: ch = BasicBlock<.lr.ph93.preheader 0x7fee59053ad0>

Combining: t54: ch = BasicBlock<._crit_edge94 0x7fee59053bd0>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %16, t46

Combining: t47: i64 = Register %16

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %15, t34

Combining: t35: i64 = Register %15

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %2

Combining: t30: i64 = Register %2

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack22)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %1

Combining: t24: i64 = Register %1

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack20)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack18)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.25)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %13

Combining: t12: i64 = Register %13

Combining: t11: ch = CopyToReg t0, Register:i64 %14, t9

Combining: t10: i64 = Register %14

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized type-legalized selection DAG: %bb.4 'main:._crit_edge91'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %13
  t31: i64,ch = CopyFromReg t0, Register:i64 %2
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.25)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack18)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack20)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %1
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack22)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack24)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %14, t9
        t36: ch = CopyToReg t0, Register:i64 %15, t34
        t48: ch = CopyToReg t0, Register:i64 %16, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>
  t57: ch = br t60, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>



Legalizing: t57: ch = br t60, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>
Legal node: nothing to do

Legalizing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>
Trying custom legalization
Creating new node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Creating constant: t70: i8 = TargetConstant<14>
Creating new node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>, TargetConstant:i8<14>, t69
Successfully custom legalized node
 ... replacing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>
     with:      t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>, TargetConstant:i8<14>, t69

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Legalizing: t48: ch = CopyToReg t0, Register:i64 %16, t46
Legal node: nothing to do

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Legalizing: t36: ch = CopyToReg t0, Register:i64 %15, t34
Legal node: nothing to do

Legalizing: t18: ch = store<(store (s64) into %ir..repack18)> t9:1, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t21: ch = store<(store (s64) into %ir..repack20)> t9:1, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t26: ch = store<(store (s64) into %ir..repack22)> t9:1, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t63: ch = store<(store (s64) into %ir..repack24)> t9:1, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Legalizing: t15: ch = store<(store (s64) into %ir.25)> t9:1, t13, t9, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t11: ch = CopyToReg t0, Register:i64 %14, t9
Legal node: nothing to do

Legalizing: t17: i64 = add nuw t9, Constant:i64<8>
Legal node: nothing to do

Legalizing: t20: i64 = add nuw t9, Constant:i64<16>
Legal node: nothing to do

Legalizing: t23: i64 = add nuw t9, Constant:i64<24>
Legal node: nothing to do

Legalizing: t28: i64 = add nuw t9, Constant:i64<32>
Legal node: nothing to do

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %2
Legal node: nothing to do

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %1
Legal node: nothing to do

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %13
Legal node: nothing to do

Legalizing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Trying custom legalization
Creating new node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Creating new node: t75: i64 = sub t74, Constant:i64<48>
Creating new node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Creating new node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t78: i64,ch = merge_values t75, t77
Successfully custom legalized node
 ... replacing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
     with:      t78: i64,ch = merge_values t75, t77
      and:      t78: i64,ch = merge_values t75, t77

Legalizing: t56: ch = BasicBlock<.lr.ph93.preheader 0x7fee59053ad0>
Legal node: nothing to do

Legalizing: t54: ch = BasicBlock<._crit_edge94 0x7fee59053bd0>
Legal node: nothing to do

Legalizing: t47: i64 = Register %16

Legalizing: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Legalizing: t37: i64 = GlobalAddress<ptr @malloc> 0
Trying custom legalization
Creating new node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Successfully custom legalized node
 ... replacing: t37: i64 = GlobalAddress<ptr @malloc> 0
     with:      t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t35: i64 = Register %15

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Legalizing: t30: i64 = Register %2

Legalizing: t27: i64 = Constant<32>
Legal node: nothing to do

Legalizing: t24: i64 = Register %1

Legalizing: t22: i64 = Constant<24>
Legal node: nothing to do

Legalizing: t19: i64 = Constant<16>
Legal node: nothing to do

Legalizing: t16: i64 = Constant<8>
Legal node: nothing to do

Legalizing: t14: i64 = undef
Legal node: nothing to do

Legalizing: t12: i64 = Register %13

Legalizing: t10: i64 = Register %14

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t7: i64 = Constant<48>
Legal node: nothing to do

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t78: i64,ch = merge_values t75, t77
Trying to expand node
Successfully expanded node
 ... replacing: t78: i64,ch = merge_values t75, t77
     with:      t75: i64 = sub t74, Constant:i64<48>
      and:      t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Legalizing: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Legalizing: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do
Legalized selection DAG: %bb.4 'main:._crit_edge91'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %13
  t31: i64,ch = CopyFromReg t0, Register:i64 %2
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.25)> t77, t13, t75, undef:i64
          t17: i64 = add nuw t75, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack18)> t77, t13, t17, undef:i64
          t20: i64 = add nuw t75, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack20)> t77, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %1
          t23: i64 = add nuw t75, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack22)> t77, t25, t23, undef:i64
          t28: i64 = add nuw t75, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack24)> t77, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
  t75: i64 = sub t74, Constant:i64<48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
        t11: ch = CopyToReg t0, Register:i64 %14, t75
        t36: ch = CopyToReg t0, Register:i64 %15, t34
        t48: ch = CopyToReg t0, Register:i64 %16, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>



Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Combining: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Combining: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Combining: t75: i64 = sub t74, Constant:i64<48>
Creating constant: t81: i64 = Constant<-48>
Creating new node: t82: i64 = add t74, Constant:i64<-48>
 ... into: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t81: i64 = Constant<-48>
Legal node: nothing to do

Combining: t81: i64 = Constant<-48>

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Combining: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

Legalizing: t73: i64 = Register $rsp

Combining: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Combining: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>, TargetConstant:i8<14>, t69

Legalizing: t70: i8 = TargetConstant<14>

Combining: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do

Combining: t69: i32 = X86ISD::CMP t31, Constant:i64<0>

Legalizing: t57: ch = br t71, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>
Legal node: nothing to do

Combining: t57: ch = br t71, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing: t48: ch = CopyToReg t0, Register:i64 %16, t46
Legal node: nothing to do

Combining: t48: ch = CopyToReg t0, Register:i64 %16, t46

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Combining: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing: t36: ch = CopyToReg t0, Register:i64 %15, t34
Legal node: nothing to do

Combining: t36: ch = CopyToReg t0, Register:i64 %15, t34

Legalizing: t18: ch = store<(store (s64) into %ir..repack18)> t77, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack18)> t77, t13, t17, undef:i64

Legalizing: t21: ch = store<(store (s64) into %ir..repack20)> t77, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack20)> t77, Constant:i64<0>, t20, undef:i64

Legalizing: t26: ch = store<(store (s64) into %ir..repack22)> t77, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack22)> t77, t25, t23, undef:i64

Legalizing: t63: ch = store<(store (s64) into %ir..repack24)> t77, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack24)> t77, Constant:i64<1>, t28, undef:i64

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Combining: t34: i64 = shl t31, Constant:i8<3>

Legalizing: t15: ch = store<(store (s64) into %ir.25)> t77, t13, t82, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t15: ch = store<(store (s64) into %ir.25)> t77, t13, t82, undef:i64

Legalizing: t11: ch = CopyToReg t0, Register:i64 %14, t82
Legal node: nothing to do

Combining: t11: ch = CopyToReg t0, Register:i64 %14, t82

Legalizing: t17: i64 = add nuw t82, Constant:i64<8>
Legal node: nothing to do

Combining: t17: i64 = add nuw t82, Constant:i64<8>
Creating constant: t83: i64 = Constant<-40>
Creating new node: t84: i64 = add t74, Constant:i64<-40>
 ... into: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t18: ch = store<(store (s64) into %ir..repack18)> t77, t13, t84, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack18)> t77, t13, t84, undef:i64

Legalizing: t84: i64 = add t74, Constant:i64<-40>
Legal node: nothing to do

Combining: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t83: i64 = Constant<-40>
Legal node: nothing to do

Combining: t83: i64 = Constant<-40>

Legalizing: t20: i64 = add nuw t82, Constant:i64<16>
Legal node: nothing to do

Combining: t20: i64 = add nuw t82, Constant:i64<16>
Creating constant: t85: i64 = Constant<-32>
Creating new node: t86: i64 = add t74, Constant:i64<-32>
 ... into: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t21: ch = store<(store (s64) into %ir..repack20)> t77, Constant:i64<0>, t86, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack20)> t77, Constant:i64<0>, t86, undef:i64

Legalizing: t86: i64 = add t74, Constant:i64<-32>
Legal node: nothing to do

Combining: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t85: i64 = Constant<-32>
Legal node: nothing to do

Combining: t85: i64 = Constant<-32>

Legalizing: t23: i64 = add nuw t82, Constant:i64<24>
Legal node: nothing to do

Combining: t23: i64 = add nuw t82, Constant:i64<24>
Creating constant: t87: i64 = Constant<-24>
Creating new node: t88: i64 = add t74, Constant:i64<-24>
 ... into: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t26: ch = store<(store (s64) into %ir..repack22)> t77, t25, t88, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack22)> t77, t25, t88, undef:i64

Legalizing: t88: i64 = add t74, Constant:i64<-24>
Legal node: nothing to do

Combining: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t87: i64 = Constant<-24>
Legal node: nothing to do

Combining: t87: i64 = Constant<-24>

Legalizing: t28: i64 = add nuw t82, Constant:i64<32>
Legal node: nothing to do

Combining: t28: i64 = add nuw t82, Constant:i64<32>
Creating constant: t89: i64 = Constant<-16>
Creating new node: t90: i64 = add t74, Constant:i64<-16>
 ... into: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t63: ch = store<(store (s64) into %ir..repack24)> t77, Constant:i64<1>, t90, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack24)> t77, Constant:i64<1>, t90, undef:i64

Legalizing: t90: i64 = add t74, Constant:i64<-16>
Legal node: nothing to do

Combining: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t89: i64 = Constant<-16>
Legal node: nothing to do

Combining: t89: i64 = Constant<-16>

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %2
Legal node: nothing to do

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %2

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %1
Legal node: nothing to do

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %1

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %13
Legal node: nothing to do

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %13

Legalizing: t56: ch = BasicBlock<.lr.ph93.preheader 0x7fee59053ad0>
Legal node: nothing to do

Combining: t56: ch = BasicBlock<.lr.ph93.preheader 0x7fee59053ad0>

Legalizing: t54: ch = BasicBlock<._crit_edge94 0x7fee59053bd0>
Legal node: nothing to do

Combining: t54: ch = BasicBlock<._crit_edge94 0x7fee59053bd0>

Legalizing: t47: i64 = Register %16

Combining: t47: i64 = Register %16

Legalizing: t45: i64 = Register $rax

Combining: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Combining: t42: Untyped = RegisterMask

Legalizing: t40: i64 = Register $rdi

Combining: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Combining: t38: i64 = TargetConstant<0>

Legalizing: t35: i64 = Register %15

Combining: t35: i64 = Register %15

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Combining: t33: i8 = Constant<3>

Legalizing: t30: i64 = Register %2

Combining: t30: i64 = Register %2

Legalizing: t24: i64 = Register %1

Combining: t24: i64 = Register %1

Legalizing: t14: i64 = undef
Legal node: nothing to do

Combining: t14: i64 = undef

Legalizing: t12: i64 = Register %13

Combining: t12: i64 = Register %13

Legalizing: t10: i64 = Register %14

Combining: t10: i64 = Register %14

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Combining: t8: i64 = Constant<0>

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Combining: t2: i64 = Constant<1>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.4 'main:._crit_edge91'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %13
  t31: i64,ch = CopyFromReg t0, Register:i64 %2
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.25)> t77, t13, t82, undef:i64
          t84: i64 = add t74, Constant:i64<-40>
        t18: ch = store<(store (s64) into %ir..repack18)> t77, t13, t84, undef:i64
          t86: i64 = add t74, Constant:i64<-32>
        t21: ch = store<(store (s64) into %ir..repack20)> t77, Constant:i64<0>, t86, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %1
          t88: i64 = add t74, Constant:i64<-24>
        t26: ch = store<(store (s64) into %ir..repack22)> t77, t25, t88, undef:i64
          t90: i64 = add t74, Constant:i64<-16>
        t63: ch = store<(store (s64) into %ir..repack24)> t77, Constant:i64<1>, t90, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
  t82: i64 = add t74, Constant:i64<-48>
        t11: ch = CopyToReg t0, Register:i64 %14, t82
        t36: ch = CopyToReg t0, Register:i64 %15, t34
        t48: ch = CopyToReg t0, Register:i64 %16, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>


===== Instruction selection begins: %bb.4 '._crit_edge91'

ISEL: Starting selection on root node: t57: ch = br t71, BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>
ISEL: Starting pattern match
  Initial Opcode index to 134414
  Morphed node: t57: ch = JMP_1 BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>, t71
ISEL: Match complete!

ISEL: Starting selection on root node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge94 0x7fee59053bd0>, TargetConstant:i8<14>, t69
ISEL: Starting pattern match
  Initial Opcode index to 131614
Creating new node: t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  Morphed node: t71: ch = JCC_1 BasicBlock:ch<._crit_edge94 0x7fee59053bd0>, TargetConstant:i8<14>, t92, t92:1
ISEL: Match complete!

ISEL: Starting selection on root node: t53: ch = TokenFactor t11, t36, t48, t46:1

ISEL: Starting selection on root node: t48: ch = CopyToReg t0, Register:i64 %16, t46

ISEL: Starting selection on root node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

ISEL: Starting selection on root node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
ISEL: Match complete!

ISEL: Starting selection on root node: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
ISEL: Match complete!

ISEL: Starting selection on root node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

ISEL: Starting selection on root node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t93: i32 = TargetConstant<0>
  Morphed node: t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
ISEL: Match complete!

ISEL: Starting selection on root node: t64: ch = TokenFactor t15, t18, t21, t26, t63

ISEL: Starting selection on root node: t15: ch = store<(store (s64) into %ir.25)> t77, t13, t82, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t94: i8 = TargetConstant<1>
Creating constant: t96: i32 = TargetConstant<-48>
  Morphed node: t15: ch = MOV64mr<Mem:(store (s64) into %ir.25)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch = store<(store (s64) into %ir..repack18)> t77, t13, t84, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t98: i32 = TargetConstant<-40>
  Morphed node: t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack18)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = store<(store (s64) into %ir..repack20)> t77, Constant:i64<0>, t86, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Skipped scope entry (due to false predicate) at index 16132, continuing at 16162
  Skipped scope entry (due to false predicate) at index 16163, continuing at 16193
  Match failed at index 16203
  Continuing at 16224
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t99: i32 = TargetConstant<-32>
  Morphed node: t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack20)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t26: ch = store<(store (s64) into %ir..repack22)> t77, t25, t88, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t100: i32 = TargetConstant<-24>
  Morphed node: t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t63: ch = store<(store (s64) into %ir..repack24)> t77, Constant:i64<1>, t90, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t101: i32 = TargetConstant<-16>
Creating constant: t102: i64 = TargetConstant<1>
  Morphed node: t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack24)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
ISEL: Match complete!

ISEL: Starting selection on root node: t11: ch = CopyToReg t0, Register:i64 %14, t82

ISEL: Starting selection on root node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

ISEL: Starting selection on root node: t82: i64 = add t74, Constant:i64<-48>
ISEL: Starting pattern match
  Initial Opcode index to 102161
  Match failed at index 102165
  Continuing at 102268
  Match failed at index 102270
  Continuing at 102377
  TypeSwitch[i64] from 102379 to 102420
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 102420
  Continuing at 102435
  Match failed at index 102438
  Continuing at 102459
  Match failed at index 102461
  Continuing at 102483
  Skipped scope entry (due to false predicate) at index 102488, continuing at 102540
  Skipped scope entry (due to false predicate) at index 102541, continuing at 102593
  Skipped scope entry (due to false predicate) at index 102594, continuing at 102644
  Skipped scope entry (due to false predicate) at index 102645, continuing at 102669
  Match failed at index 102683
  Continuing at 102696
  Match failed at index 102700
  Continuing at 102713
Creating constant: t104: i64 = TargetConstant<-48>
  Morphed node: t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
ISEL: Match complete!

ISEL: Starting selection on root node: t36: ch = CopyToReg t0, Register:i64 %15, t34

ISEL: Starting selection on root node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

ISEL: Starting selection on root node: t34: i64 = shl t31, Constant:i8<3>
ISEL: Starting pattern match
  Initial Opcode index to 44725
  Match failed at index 44729
  Continuing at 44944
  TypeSwitch[i64] from 44946 to 44987
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 44987
  Continuing at 45002
  Match failed at index 45009
  Continuing at 45152
  Match failed at index 45153
  Continuing at 45203
  TypeSwitch[i64] from 45215 to 45257
Creating constant: t105: i8 = TargetConstant<3>
  Morphed node: t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 25710
  Match failed at index 25714
  Continuing at 26614
  Skipped scope entry (due to false predicate) at index 26619, continuing at 26650
  Skipped scope entry (due to false predicate) at index 26651, continuing at 26682
  Skipped scope entry (due to false predicate) at index 26683, continuing at 26714
  Match failed at index 26718
  Continuing at 26746
  Continuing at 26747
  Match failed at index 26750
  Continuing at 27134
  Skipped scope entry (due to false predicate) at index 27139, continuing at 27203
  Skipped scope entry (due to false predicate) at index 27204, continuing at 27304
  Skipped scope entry (due to false predicate) at index 27305, continuing at 27405
  Morphed node: t69: i32 = TEST64rr t31, t31
ISEL: Match complete!

ISEL: Starting selection on root node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132007
  Match failed at index 132010
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t31: i64,ch = CopyFromReg t0, Register:i64 %2

ISEL: Starting selection on root node: t25: i64,ch = CopyFromReg t0, Register:i64 %1

ISEL: Starting selection on root node: t13: i64,ch = CopyFromReg t0, Register:i64 %13

ISEL: Starting selection on root node: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

ISEL: Starting selection on root node: t73: i64 = Register $rsp

ISEL: Starting selection on root node: t70: i8 = TargetConstant<14>

ISEL: Starting selection on root node: t56: ch = BasicBlock<.lr.ph93.preheader 0x7fee59053ad0>

ISEL: Starting selection on root node: t54: ch = BasicBlock<._crit_edge94 0x7fee59053bd0>

ISEL: Starting selection on root node: t47: i64 = Register %16

ISEL: Starting selection on root node: t45: i64 = Register $rax

ISEL: Starting selection on root node: t42: Untyped = RegisterMask

ISEL: Starting selection on root node: t40: i64 = Register $rdi

ISEL: Starting selection on root node: t38: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t35: i64 = Register %15

ISEL: Starting selection on root node: t30: i64 = Register %2

ISEL: Starting selection on root node: t24: i64 = Register %1

ISEL: Starting selection on root node: t12: i64 = Register %13

ISEL: Starting selection on root node: t10: i64 = Register %14

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.4 'main:._crit_edge91'
SelectionDAG has 59 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %13
  t31: i64,ch = CopyFromReg t0, Register:i64 %2
  t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
    t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
  t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp
  t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
        t15: ch = MOV64mr<Mem:(store (s64) into %ir.25)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1
        t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack18)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1
        t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack20)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1
          t25: i64,ch = CopyFromReg t0, Register:i64 %1
        t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1
        t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack24)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
  t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34
    t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
  t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
  t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2
      t11: ch = CopyToReg t0, Register:i64 %14, t82
      t36: ch = CopyToReg t0, Register:i64 %15, t34
      t48: ch = CopyToReg t0, Register:i64 %16, t46
    t53: ch = TokenFactor t11, t36, t48, t46:1
    t69: i32 = TEST64rr t31, t31
  t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  t103: i32 = Register $noreg
    t71: ch = JCC_1 BasicBlock:ch<._crit_edge94 0x7fee59053bd0>, TargetConstant:i8<14>, t92, t92:1
  t57: ch = JMP_1 BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>, t71


********** List Scheduling %bb.4 '._crit_edge91' **********
SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>, t71

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge94 0x7fee59053bd0>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(4): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t69: i32 = TEST64rr t31, t31

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %2

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(6): Data Latency=1
SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(24): Ord  Latency=1 Barrier
    SU(23): Ord  Latency=1 Barrier
    SU(22): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(21): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(22): Data Latency=1
SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(5): Data Latency=1
    SU(23): Data Latency=1
SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(8): Ord  Latency=0 Barrier
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(20): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(9): Ord  Latency=1 Barrier
  Successors:
    SU(7): Ord  Latency=0 Barrier
SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack24)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

  # preds left       : 1
  # succs left       : 5
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(11): Ord  Latency=1 Barrier
  Successors:
    SU(9): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(20): Ord  Latency=1 Barrier
SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 7
  Predecessors:
    SU(13): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
  Successors:
    SU(10): Ord  Latency=1 Barrier
SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(13): Data Latency=1
  Successors:
    SU(11): Data Latency=1
    SU(24): Data Latency=1
SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

  # preds left       : 1
  # succs left       : 7
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 9
  Predecessors:
    SU(14): Ord  Latency=1 Barrier
  Successors:
    SU(9): Data Latency=1
    SU(11): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
    SU(15): Data Latency=1
    SU(17): Data Latency=1
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(13): Ord  Latency=1 Barrier
SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(16): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %1

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(15): Data Latency=1
SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack20)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack18)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %13

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.25)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(22): t48: ch = CopyToReg t0, Register:i64 %16, t46

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(23): t36: ch = CopyToReg t0, Register:i64 %15, t34

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>, t71


*** Scheduling [0]: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>, t71


Examining Available:
Height 1: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge94 0x7fee59053bd0>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


*** Scheduling [1]: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge94 0x7fee59053bd0>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


Examining Available:
Height 1: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

Height 2: SU(2): t69: i32 = TEST64rr t31, t31


*** Scheduling [2]: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1


Examining Available:
Height 2: SU(2): t69: i32 = TEST64rr t31, t31

Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %16, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %15, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


*** Scheduling [3]: SU(2): t69: i32 = TEST64rr t31, t31


Examining Available:
Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %16, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %15, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


*** Scheduling [4]: SU(22): t48: ch = CopyToReg t0, Register:i64 %16, t46


Examining Available:
Height 5: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %15, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


*** Scheduling [5]: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1


Examining Available:
Height 6: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %15, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


*** Scheduling [6]: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0


Examining Available:
Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %15, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


*** Scheduling [7]: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64


Examining Available:
Height 7: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %15, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


*** Scheduling [8]: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63


Examining Available:
Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %15, t34

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack24)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack20)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack18)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.25)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


*** Scheduling [9]: SU(23): t36: ch = CopyToReg t0, Register:i64 %15, t34


Examining Available:
Height 10: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack24)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack20)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack18)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.25)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


*** Scheduling [10]: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>


Examining Available:
Height 11: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %2

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack24)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack20)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack18)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.25)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


*** Scheduling [11]: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %2


Examining Available:
Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack24)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack20)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack18)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.25)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


*** Scheduling [12]: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack24)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1


Examining Available:
Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack20)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack18)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.25)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


*** Scheduling [13]: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1


Examining Available:
Height 14: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack20)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack18)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.25)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


*** Scheduling [14]: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %1


Examining Available:
Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack20)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack18)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.25)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


*** Scheduling [15]: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack20)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1


Examining Available:
Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack18)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.25)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


*** Scheduling [16]: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack18)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.25)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


*** Scheduling [17]: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.25)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 18: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %13

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [18]: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %13


Examining Available:
Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [19]: SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82


Examining Available:
Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [20]: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


Examining Available:
Height 21: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


*** Scheduling [21]: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


Examining Available:
Height 22: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


*** Scheduling [22]: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


Examining Available:
Height 23: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


*** Scheduling [23]: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


Examining Available:
Height 24: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [24]: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

SU(24): t11: ch = CopyToReg t0, Register:i64 %14, t82

SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %13

SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.25)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack18)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack20)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %1

SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack22)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack24)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %2

SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

SU(23): t36: ch = CopyToReg t0, Register:i64 %15, t34

SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

SU(22): t48: ch = CopyToReg t0, Register:i64 %16, t46

SU(2): t69: i32 = TEST64rr t31, t31

SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge94 0x7fee59053bd0>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph93.preheader 0x7fee59053ad0>, t71


Total amount of phi nodes to update: 0
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %16
Creating constant: t3: i8 = Constant<0>
Creating new node: t5: i64,ch = CopyFromReg t0, Register:i64 %15
Creating constant: t7: i64 = TargetConstant<0>
Creating new node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Creating new node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Creating new node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Creating new node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Initial selection DAG: %bb.5 'main:.lr.ph93.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t3: i8 = Constant<0>
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %16
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %15
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Combining: t13: Untyped = RegisterMask

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Combining: t11: i64 = Register $rsi

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Combining: t9: i64 = Register $rdi

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t7: i64 = TargetConstant<0>

Combining: t6: i64 = ExternalSymbol'__bzero'

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %15

Combining: t4: i64 = Register %15

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %16

Combining: t1: i64 = Register %16

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.5 'main:.lr.ph93.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %16
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %15
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


Legalizing node: t13: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t13: Untyped = RegisterMask

Legalizing node: t11: i64 = Register $rsi
Ignoring node results
Legally typed node: t11: i64 = Register $rsi

Legalizing node: t9: i64 = Register $rdi
Ignoring node results
Legally typed node: t9: i64 = Register $rdi

Legalizing node: t7: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t7: i64 = TargetConstant<0>

Legalizing node: t6: i64 = ExternalSymbol'__bzero'
Analyzing result type: i64
Legal result type
Legally typed node: t6: i64 = ExternalSymbol'__bzero'

Legalizing node: t4: i64 = Register %15
Ignoring node results
Legally typed node: t4: i64 = Register %15

Legalizing node: t1: i64 = Register %16
Ignoring node results
Legally typed node: t1: i64 = Register %16

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %16
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %16

Legalizing node: t5: i64,ch = CopyFromReg t0, Register:i64 %15
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t5: i64,ch = CopyFromReg t0, Register:i64 %15

Legalizing node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %16
Legal operand
Legally typed node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Analyzing operand: t5: i64,ch = CopyFromReg t0, Register:i64 %15
Legal operand
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Legally typed node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Analyzing operand: t6: i64 = ExternalSymbol'__bzero'
Legal operand
Analyzing operand: t13: Untyped = RegisterMask
Legal operand
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Legally typed node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Legally typed node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.5 'main:.lr.ph93.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %16
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %15
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %15
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %16
Legal node: nothing to do

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Legalizing: t6: i64 = ExternalSymbol'__bzero'
Trying custom legalization
Creating new node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Successfully custom legalized node
 ... replacing: t6: i64 = ExternalSymbol'__bzero'
     with:      t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t4: i64 = Register %15

Legalizing: t1: i64 = Register %16

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do
Legalized selection DAG: %bb.5 'main:.lr.ph93.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %16
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %15
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Combining: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do

Combining: t16: i64 = TargetExternalSymbol'__bzero'

Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Combining: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %15
Legal node: nothing to do

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %15

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %16
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %16

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Combining: t13: Untyped = RegisterMask

Legalizing: t11: i64 = Register $rsi

Combining: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Combining: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Combining: t7: i64 = TargetConstant<0>

Legalizing: t4: i64 = Register %15

Combining: t4: i64 = Register %15

Legalizing: t1: i64 = Register %16

Combining: t1: i64 = Register %16

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.5 'main:.lr.ph93.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %16
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %15
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


===== Instruction selection begins: %bb.5 '.lr.ph93.preheader'

ISEL: Starting selection on root node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

ISEL: Starting selection on root node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

ISEL: Starting selection on root node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132022
  Match failed at index 132025
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t18: i32 = TargetConstant<0>
  Morphed node: t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i64,ch = CopyFromReg t0, Register:i64 %15

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %16

ISEL: Starting selection on root node: t16: i64 = TargetExternalSymbol'__bzero'

ISEL: Starting selection on root node: t13: Untyped = RegisterMask

ISEL: Starting selection on root node: t11: i64 = Register $rsi

ISEL: Starting selection on root node: t9: i64 = Register $rdi

ISEL: Starting selection on root node: t7: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t4: i64 = Register %15

ISEL: Starting selection on root node: t1: i64 = Register %16

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.5 'main:.lr.ph93.preheader'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
    t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t2: i64,ch = CopyFromReg t0, Register:i64 %16
  t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %15
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
  t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1


********** List Scheduling %bb.5 '.lr.ph93.preheader' **********
SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1

  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Data Latency=1
    SU(1): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %15

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %16

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1

Examining Available:
Height 0: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


*** Scheduling [0]: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Examining Available:
Height 1: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %15

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %16

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [1]: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'


Examining Available:
Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %15

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %16

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [2]: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %15


Examining Available:
Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %16

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [3]: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %16


Examining Available:
Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [4]: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %16

SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %15

SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<1>
Creating constant: t2: i64 = Constant<1>
Creating constant: t3: i64 = Constant<40>
Creating constant: t4: i64 = Constant<15>
Creating constant: t5: i64 = Constant<55>
Creating constant: t6: i64 = Constant<-16>
Creating constant: t7: i64 = Constant<48>
Creating constant: t8: i64 = Constant<0>
Creating new node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Creating new node: t11: ch = CopyToReg t0, Register:i64 %17, t9
Creating new node: t13: i64,ch = CopyFromReg t0, Register:i64 %16
Creating new node: t14: i64 = undef
Creating new node: t15: ch = store<(store (s64) into %ir.28)> t9:1, t13, t9, undef:i64
Creating constant: t16: i64 = Constant<8>
Creating new node: t17: i64 = add nuw t9, Constant:i64<8>
Creating new node: t18: ch = store<(store (s64) into %ir..repack27)> t15, t13, t17, undef:i64
Creating constant: t19: i64 = Constant<16>
Creating new node: t20: i64 = add nuw t9, Constant:i64<16>
Creating new node: t21: ch = store<(store (s64) into %ir..repack29)> t18, Constant:i64<0>, t20, undef:i64
Creating constant: t22: i64 = Constant<24>
Creating new node: t23: i64 = add nuw t9, Constant:i64<24>
Creating new node: t25: i64,ch = CopyFromReg t0, Register:i64 %2
Creating new node: t26: ch = store<(store (s64) into %ir..repack31)> t21, t25, t23, undef:i64
Creating constant: t27: i64 = Constant<32>
Creating new node: t28: i64 = add nuw t9, Constant:i64<32>
Creating new node: t29: ch = store<(store (s64) into %ir..repack33)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t31: i64,ch = CopyFromReg t0, Register:i64 %3
Creating constant: t32: i64 = Constant<3>
Creating constant: t33: i8 = Constant<3>
Creating new node: t34: i64 = shl t31, Constant:i8<3>
Creating new node: t36: ch = CopyToReg t0, Register:i64 %18, t34
Creating constant: t38: i64 = TargetConstant<0>
Creating new node: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Creating new node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Creating new node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Creating new node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Creating new node: t48: ch = CopyToReg t0, Register:i64 %19, t46
Creating new node: t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
Creating constant: t51: i1 = Constant<-1>
Creating new node: t52: i1 = xor t50, Constant:i1<-1>
Creating new node: t53: ch = TokenFactor t11, t36, t48, t46:1
Creating new node: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>
Creating new node: t57: ch = br t55, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>
Initial selection DAG: %bb.6 'main:._crit_edge94'
SelectionDAG has 58 nodes:
  t0: ch,glue = EntryToken
  t1: i32 = Constant<1>
  t3: i64 = Constant<40>
  t4: i64 = Constant<15>
  t5: i64 = Constant<55>
  t6: i64 = Constant<-16>
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %16
  t31: i64,ch = CopyFromReg t0, Register:i64 %3
  t32: i64 = Constant<3>
  t34: i64 = shl t31, Constant:i8<3>
              t15: ch = store<(store (s64) into %ir.28)> t9:1, t13, t9, undef:i64
              t17: i64 = add nuw t9, Constant:i64<8>
            t18: ch = store<(store (s64) into %ir..repack27)> t15, t13, t17, undef:i64
            t20: i64 = add nuw t9, Constant:i64<16>
          t21: ch = store<(store (s64) into %ir..repack29)> t18, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %2
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack31)> t21, t25, t23, undef:i64
        t28: i64 = add nuw t9, Constant:i64<32>
      t29: ch = store<(store (s64) into %ir..repack33)> t26, Constant:i64<1>, t28, undef:i64
    t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %17, t9
        t36: ch = CopyToReg t0, Register:i64 %18, t34
        t48: ch = CopyToReg t0, Register:i64 %19, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
      t52: i1 = xor t50, Constant:i1<-1>
    t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>
  t57: ch = br t55, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>



Combining: t57: ch = br t55, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>

Combining: t56: ch = BasicBlock<.lr.ph96.preheader 0x7fee59053cd0>

Combining: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>
Creating new node: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>
 ... into: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>

Combining: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>

Combining: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
 ... into: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>

Combining: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t61: ch = setlt

Combining: t54: ch = BasicBlock<._crit_edge97 0x7fee59053dd0>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %19, t46

Combining: t47: i64 = Register %19

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %18, t34

Combining: t35: i64 = Register %18

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %3

Combining: t30: i64 = Register %3

Combining: t29: ch = store<(store (s64) into %ir..repack33)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t63: ch = store<(store (s64) into %ir..repack33)> t9:1, Constant:i64<1>, t28, undef:i64
Creating new node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Replacing.1 t29: ch = store<(store (s64) into %ir..repack33)> t26, Constant:i64<1>, t28, undef:i64

With: t64: ch = TokenFactor t15, t18, t21, t26, t63
 and 0 other values

Combining: t63: ch = store<(store (s64) into %ir..repack33)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack31)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %2

Combining: t24: i64 = Register %2

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack29)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack27)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.28)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %16

Combining: t12: i64 = Register %16

Combining: t11: ch = CopyToReg t0, Register:i64 %17, t9

Combining: t10: i64 = Register %17

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.6 'main:._crit_edge94'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %16
  t31: i64,ch = CopyFromReg t0, Register:i64 %3
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.28)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack27)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack29)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %2
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack31)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack33)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %17, t9
        t36: ch = CopyToReg t0, Register:i64 %18, t34
        t48: ch = CopyToReg t0, Register:i64 %19, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>
  t57: ch = br t60, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>


Legalizing node: t61: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t61: ch = setlt

Legalizing node: t56: ch = BasicBlock<.lr.ph96.preheader 0x7fee59053cd0>
Analyzing result type: ch
Legal result type
Legally typed node: t56: ch = BasicBlock<.lr.ph96.preheader 0x7fee59053cd0>

Legalizing node: t54: ch = BasicBlock<._crit_edge97 0x7fee59053dd0>
Analyzing result type: ch
Legal result type
Legally typed node: t54: ch = BasicBlock<._crit_edge97 0x7fee59053dd0>

Legalizing node: t47: i64 = Register %19
Ignoring node results
Legally typed node: t47: i64 = Register %19

Legalizing node: t45: i64 = Register $rax
Ignoring node results
Legally typed node: t45: i64 = Register $rax

Legalizing node: t42: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t42: Untyped = RegisterMask

Legalizing node: t40: i64 = Register $rdi
Ignoring node results
Legally typed node: t40: i64 = Register $rdi

Legalizing node: t38: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t38: i64 = TargetConstant<0>

Legalizing node: t37: i64 = GlobalAddress<ptr @malloc> 0
Analyzing result type: i64
Legal result type
Legally typed node: t37: i64 = GlobalAddress<ptr @malloc> 0

Legalizing node: t35: i64 = Register %18
Ignoring node results
Legally typed node: t35: i64 = Register %18

Legalizing node: t33: i8 = Constant<3>
Analyzing result type: i8
Legal result type
Legally typed node: t33: i8 = Constant<3>

Legalizing node: t30: i64 = Register %3
Ignoring node results
Legally typed node: t30: i64 = Register %3

Legalizing node: t27: i64 = Constant<32>
Analyzing result type: i64
Legal result type
Legally typed node: t27: i64 = Constant<32>

Legalizing node: t24: i64 = Register %2
Ignoring node results
Legally typed node: t24: i64 = Register %2

Legalizing node: t22: i64 = Constant<24>
Analyzing result type: i64
Legal result type
Legally typed node: t22: i64 = Constant<24>

Legalizing node: t19: i64 = Constant<16>
Analyzing result type: i64
Legal result type
Legally typed node: t19: i64 = Constant<16>

Legalizing node: t16: i64 = Constant<8>
Analyzing result type: i64
Legal result type
Legally typed node: t16: i64 = Constant<8>

Legalizing node: t14: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t14: i64 = undef

Legalizing node: t12: i64 = Register %16
Ignoring node results
Legally typed node: t12: i64 = Register %16

Legalizing node: t10: i64 = Register %17
Ignoring node results
Legally typed node: t10: i64 = Register %17

Legalizing node: t8: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t8: i64 = Constant<0>

Legalizing node: t7: i64 = Constant<48>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<48>

Legalizing node: t2: i64 = Constant<1>
Analyzing result type: i64
Legal result type
Legally typed node: t2: i64 = Constant<1>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t7: i64 = Constant<48>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Legally typed node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Legalizing node: t11: ch = CopyToReg t0, Register:i64 %17, t9
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Legally typed node: t11: ch = CopyToReg t0, Register:i64 %17, t9

Legalizing node: t17: i64 = add nuw t9, Constant:i64<8>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t16: i64 = Constant<8>
Legal operand
Legally typed node: t17: i64 = add nuw t9, Constant:i64<8>

Legalizing node: t20: i64 = add nuw t9, Constant:i64<16>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t19: i64 = Constant<16>
Legal operand
Legally typed node: t20: i64 = add nuw t9, Constant:i64<16>

Legalizing node: t21: ch = store<(store (s64) into %ir..repack29)> t9:1, Constant:i64<0>, t20, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Analyzing operand: t20: i64 = add nuw t9, Constant:i64<16>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t21: ch = store<(store (s64) into %ir..repack29)> t9:1, Constant:i64<0>, t20, undef:i64

Legalizing node: t23: i64 = add nuw t9, Constant:i64<24>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t22: i64 = Constant<24>
Legal operand
Legally typed node: t23: i64 = add nuw t9, Constant:i64<24>

Legalizing node: t28: i64 = add nuw t9, Constant:i64<32>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t27: i64 = Constant<32>
Legal operand
Legally typed node: t28: i64 = add nuw t9, Constant:i64<32>

Legalizing node: t63: ch = store<(store (s64) into %ir..repack33)> t9:1, Constant:i64<1>, t28, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t28: i64 = add nuw t9, Constant:i64<32>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t63: ch = store<(store (s64) into %ir..repack33)> t9:1, Constant:i64<1>, t28, undef:i64

Legalizing node: t13: i64,ch = CopyFromReg t0, Register:i64 %16
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t13: i64,ch = CopyFromReg t0, Register:i64 %16

Legalizing node: t15: ch = store<(store (s64) into %ir.28)> t9:1, t13, t9, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %16
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t15: ch = store<(store (s64) into %ir.28)> t9:1, t13, t9, undef:i64

Legalizing node: t18: ch = store<(store (s64) into %ir..repack27)> t9:1, t13, t17, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %16
Legal operand
Analyzing operand: t17: i64 = add nuw t9, Constant:i64<8>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t18: ch = store<(store (s64) into %ir..repack27)> t9:1, t13, t17, undef:i64

Legalizing node: t25: i64,ch = CopyFromReg t0, Register:i64 %2
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t25: i64,ch = CopyFromReg t0, Register:i64 %2

Legalizing node: t26: ch = store<(store (s64) into %ir..repack31)> t9:1, t25, t23, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t25: i64,ch = CopyFromReg t0, Register:i64 %2
Legal operand
Analyzing operand: t23: i64 = add nuw t9, Constant:i64<24>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t26: ch = store<(store (s64) into %ir..repack31)> t9:1, t25, t23, undef:i64

Legalizing node: t64: ch = TokenFactor t15, t18, t21, t26, t63
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = store<(store (s64) into %ir.28)> t9:1, t13, t9, undef:i64
Legal operand
Analyzing operand: t18: ch = store<(store (s64) into %ir..repack27)> t9:1, t13, t17, undef:i64
Legal operand
Analyzing operand: t21: ch = store<(store (s64) into %ir..repack29)> t9:1, Constant:i64<0>, t20, undef:i64
Legal operand
Analyzing operand: t26: ch = store<(store (s64) into %ir..repack31)> t9:1, t25, t23, undef:i64
Legal operand
Analyzing operand: t63: ch = store<(store (s64) into %ir..repack33)> t9:1, Constant:i64<1>, t28, undef:i64
Legal operand
Legally typed node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal operand
Legally typed node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t31: i64,ch = CopyFromReg t0, Register:i64 %3
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t31: i64,ch = CopyFromReg t0, Register:i64 %3

Legalizing node: t34: i64 = shl t31, Constant:i8<3>
Analyzing result type: i64
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %3
Legal operand
Analyzing operand: t33: i8 = Constant<3>
Legal operand
Legally typed node: t34: i64 = shl t31, Constant:i8<3>

Legalizing node: t36: ch = CopyToReg t0, Register:i64 %18, t34
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t36: ch = CopyToReg t0, Register:i64 %18, t34

Legalizing node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Analyzing operand: t37: i64 = GlobalAddress<ptr @malloc> 0
Legal operand
Analyzing operand: t42: Untyped = RegisterMask
Legal operand
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Legally typed node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Legally typed node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Legally typed node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing node: t48: ch = CopyToReg t0, Register:i64 %19, t46
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t48: ch = CopyToReg t0, Register:i64 %19, t46

Legalizing node: t53: ch = TokenFactor t11, t36, t48, t46:1
Analyzing result type: ch
Legal result type
Analyzing operand: t11: ch = CopyToReg t0, Register:i64 %17, t9
Legal operand
Analyzing operand: t36: ch = CopyToReg t0, Register:i64 %18, t34
Legal operand
Analyzing operand: t48: ch = CopyToReg t0, Register:i64 %19, t46
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i1
Promote integer result: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Creating new node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legalizing node: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>

Creating new node: t66: i8 = zero_extend t62
Legalizing node: t66: i8 = zero_extend t62
Analyzing result type: i8
Legal result type
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t66: i8 = zero_extend t62

Creating constant: t67: i8 = Constant<1>
Creating new node: t68: i8 = and t65, Constant:i8<1>
Replacing: t66: i8 = zero_extend t62
     with: t68: i8 = and t65, Constant:i8<1>
Legalizing node: t67: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t67: i8 = Constant<1>

Legalizing node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %3
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t61: ch = setlt
Legal operand
Legally typed node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Legalizing node: t68: i8 = and t65, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legal operand
Analyzing operand: t67: i8 = Constant<1>
Legal operand
Legally typed node: t68: i8 = and t65, Constant:i8<1>

Legalizing node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t68: i8 = and t65, Constant:i8<1>
Legal operand
Analyzing operand: t54: ch = BasicBlock<._crit_edge97 0x7fee59053dd0>
Legal operand
Legally typed node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>

Legalizing node: t57: ch = br t60, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>
Analyzing result type: ch
Legal result type
Analyzing operand: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>
Legal operand
Analyzing operand: t56: ch = BasicBlock<.lr.ph96.preheader 0x7fee59053cd0>
Legal operand
Legally typed node: t57: ch = br t60, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>

Legalizing node: t65535: ch = handlenode t57
Analyzing result type: ch
Legal result type
Analyzing operand: t57: ch = br t60, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>
Legal operand
Legally typed node: t65535: ch = handlenode t57

Type-legalized selection DAG: %bb.6 'main:._crit_edge94'
SelectionDAG has 53 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %16
  t31: i64,ch = CopyFromReg t0, Register:i64 %3
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.28)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack27)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack29)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %2
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack31)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack33)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %17, t9
        t36: ch = CopyToReg t0, Register:i64 %18, t34
        t48: ch = CopyToReg t0, Register:i64 %19, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
      t68: i8 = and t65, Constant:i8<1>
    t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>
  t57: ch = br t60, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>



Combining: t68: i8 = and t65, Constant:i8<1>

Replacing.2 t68: i8 = and t65, Constant:i8<1>

With: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch


Combining: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t63: ch = store<(store (s64) into %ir..repack33)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t61: ch = setlt

Combining: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>

Combining: t56: ch = BasicBlock<.lr.ph96.preheader 0x7fee59053cd0>

Combining: t54: ch = BasicBlock<._crit_edge97 0x7fee59053dd0>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %19, t46

Combining: t47: i64 = Register %19

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %18, t34

Combining: t35: i64 = Register %18

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %3

Combining: t30: i64 = Register %3

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack31)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %2

Combining: t24: i64 = Register %2

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack29)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack27)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.28)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %16

Combining: t12: i64 = Register %16

Combining: t11: ch = CopyToReg t0, Register:i64 %17, t9

Combining: t10: i64 = Register %17

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized type-legalized selection DAG: %bb.6 'main:._crit_edge94'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %16
  t31: i64,ch = CopyFromReg t0, Register:i64 %3
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.28)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack27)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack29)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %2
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack31)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack33)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %17, t9
        t36: ch = CopyToReg t0, Register:i64 %18, t34
        t48: ch = CopyToReg t0, Register:i64 %19, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>
  t57: ch = br t60, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>



Legalizing: t57: ch = br t60, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>
Legal node: nothing to do

Legalizing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>
Trying custom legalization
Creating new node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Creating constant: t70: i8 = TargetConstant<14>
Creating new node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>, TargetConstant:i8<14>, t69
Successfully custom legalized node
 ... replacing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>
     with:      t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>, TargetConstant:i8<14>, t69

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Legalizing: t48: ch = CopyToReg t0, Register:i64 %19, t46
Legal node: nothing to do

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Legalizing: t36: ch = CopyToReg t0, Register:i64 %18, t34
Legal node: nothing to do

Legalizing: t18: ch = store<(store (s64) into %ir..repack27)> t9:1, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t21: ch = store<(store (s64) into %ir..repack29)> t9:1, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t26: ch = store<(store (s64) into %ir..repack31)> t9:1, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t63: ch = store<(store (s64) into %ir..repack33)> t9:1, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Legalizing: t15: ch = store<(store (s64) into %ir.28)> t9:1, t13, t9, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t11: ch = CopyToReg t0, Register:i64 %17, t9
Legal node: nothing to do

Legalizing: t17: i64 = add nuw t9, Constant:i64<8>
Legal node: nothing to do

Legalizing: t20: i64 = add nuw t9, Constant:i64<16>
Legal node: nothing to do

Legalizing: t23: i64 = add nuw t9, Constant:i64<24>
Legal node: nothing to do

Legalizing: t28: i64 = add nuw t9, Constant:i64<32>
Legal node: nothing to do

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %3
Legal node: nothing to do

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %2
Legal node: nothing to do

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %16
Legal node: nothing to do

Legalizing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Trying custom legalization
Creating new node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Creating new node: t75: i64 = sub t74, Constant:i64<48>
Creating new node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Creating new node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t78: i64,ch = merge_values t75, t77
Successfully custom legalized node
 ... replacing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
     with:      t78: i64,ch = merge_values t75, t77
      and:      t78: i64,ch = merge_values t75, t77

Legalizing: t56: ch = BasicBlock<.lr.ph96.preheader 0x7fee59053cd0>
Legal node: nothing to do

Legalizing: t54: ch = BasicBlock<._crit_edge97 0x7fee59053dd0>
Legal node: nothing to do

Legalizing: t47: i64 = Register %19

Legalizing: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Legalizing: t37: i64 = GlobalAddress<ptr @malloc> 0
Trying custom legalization
Creating new node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Successfully custom legalized node
 ... replacing: t37: i64 = GlobalAddress<ptr @malloc> 0
     with:      t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t35: i64 = Register %18

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Legalizing: t30: i64 = Register %3

Legalizing: t27: i64 = Constant<32>
Legal node: nothing to do

Legalizing: t24: i64 = Register %2

Legalizing: t22: i64 = Constant<24>
Legal node: nothing to do

Legalizing: t19: i64 = Constant<16>
Legal node: nothing to do

Legalizing: t16: i64 = Constant<8>
Legal node: nothing to do

Legalizing: t14: i64 = undef
Legal node: nothing to do

Legalizing: t12: i64 = Register %16

Legalizing: t10: i64 = Register %17

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t7: i64 = Constant<48>
Legal node: nothing to do

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t78: i64,ch = merge_values t75, t77
Trying to expand node
Successfully expanded node
 ... replacing: t78: i64,ch = merge_values t75, t77
     with:      t75: i64 = sub t74, Constant:i64<48>
      and:      t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Legalizing: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Legalizing: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do
Legalized selection DAG: %bb.6 'main:._crit_edge94'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %16
  t31: i64,ch = CopyFromReg t0, Register:i64 %3
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.28)> t77, t13, t75, undef:i64
          t17: i64 = add nuw t75, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack27)> t77, t13, t17, undef:i64
          t20: i64 = add nuw t75, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack29)> t77, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %2
          t23: i64 = add nuw t75, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack31)> t77, t25, t23, undef:i64
          t28: i64 = add nuw t75, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack33)> t77, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
  t75: i64 = sub t74, Constant:i64<48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
        t11: ch = CopyToReg t0, Register:i64 %17, t75
        t36: ch = CopyToReg t0, Register:i64 %18, t34
        t48: ch = CopyToReg t0, Register:i64 %19, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>



Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Combining: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Combining: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Combining: t75: i64 = sub t74, Constant:i64<48>
Creating constant: t81: i64 = Constant<-48>
Creating new node: t82: i64 = add t74, Constant:i64<-48>
 ... into: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t81: i64 = Constant<-48>
Legal node: nothing to do

Combining: t81: i64 = Constant<-48>

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Combining: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

Legalizing: t73: i64 = Register $rsp

Combining: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Combining: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>, TargetConstant:i8<14>, t69

Legalizing: t70: i8 = TargetConstant<14>

Combining: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do

Combining: t69: i32 = X86ISD::CMP t31, Constant:i64<0>

Legalizing: t57: ch = br t71, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>
Legal node: nothing to do

Combining: t57: ch = br t71, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing: t48: ch = CopyToReg t0, Register:i64 %19, t46
Legal node: nothing to do

Combining: t48: ch = CopyToReg t0, Register:i64 %19, t46

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Combining: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing: t36: ch = CopyToReg t0, Register:i64 %18, t34
Legal node: nothing to do

Combining: t36: ch = CopyToReg t0, Register:i64 %18, t34

Legalizing: t18: ch = store<(store (s64) into %ir..repack27)> t77, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack27)> t77, t13, t17, undef:i64

Legalizing: t21: ch = store<(store (s64) into %ir..repack29)> t77, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack29)> t77, Constant:i64<0>, t20, undef:i64

Legalizing: t26: ch = store<(store (s64) into %ir..repack31)> t77, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack31)> t77, t25, t23, undef:i64

Legalizing: t63: ch = store<(store (s64) into %ir..repack33)> t77, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack33)> t77, Constant:i64<1>, t28, undef:i64

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Combining: t34: i64 = shl t31, Constant:i8<3>

Legalizing: t15: ch = store<(store (s64) into %ir.28)> t77, t13, t82, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t15: ch = store<(store (s64) into %ir.28)> t77, t13, t82, undef:i64

Legalizing: t11: ch = CopyToReg t0, Register:i64 %17, t82
Legal node: nothing to do

Combining: t11: ch = CopyToReg t0, Register:i64 %17, t82

Legalizing: t17: i64 = add nuw t82, Constant:i64<8>
Legal node: nothing to do

Combining: t17: i64 = add nuw t82, Constant:i64<8>
Creating constant: t83: i64 = Constant<-40>
Creating new node: t84: i64 = add t74, Constant:i64<-40>
 ... into: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t18: ch = store<(store (s64) into %ir..repack27)> t77, t13, t84, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack27)> t77, t13, t84, undef:i64

Legalizing: t84: i64 = add t74, Constant:i64<-40>
Legal node: nothing to do

Combining: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t83: i64 = Constant<-40>
Legal node: nothing to do

Combining: t83: i64 = Constant<-40>

Legalizing: t20: i64 = add nuw t82, Constant:i64<16>
Legal node: nothing to do

Combining: t20: i64 = add nuw t82, Constant:i64<16>
Creating constant: t85: i64 = Constant<-32>
Creating new node: t86: i64 = add t74, Constant:i64<-32>
 ... into: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t21: ch = store<(store (s64) into %ir..repack29)> t77, Constant:i64<0>, t86, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack29)> t77, Constant:i64<0>, t86, undef:i64

Legalizing: t86: i64 = add t74, Constant:i64<-32>
Legal node: nothing to do

Combining: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t85: i64 = Constant<-32>
Legal node: nothing to do

Combining: t85: i64 = Constant<-32>

Legalizing: t23: i64 = add nuw t82, Constant:i64<24>
Legal node: nothing to do

Combining: t23: i64 = add nuw t82, Constant:i64<24>
Creating constant: t87: i64 = Constant<-24>
Creating new node: t88: i64 = add t74, Constant:i64<-24>
 ... into: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t26: ch = store<(store (s64) into %ir..repack31)> t77, t25, t88, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack31)> t77, t25, t88, undef:i64

Legalizing: t88: i64 = add t74, Constant:i64<-24>
Legal node: nothing to do

Combining: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t87: i64 = Constant<-24>
Legal node: nothing to do

Combining: t87: i64 = Constant<-24>

Legalizing: t28: i64 = add nuw t82, Constant:i64<32>
Legal node: nothing to do

Combining: t28: i64 = add nuw t82, Constant:i64<32>
Creating constant: t89: i64 = Constant<-16>
Creating new node: t90: i64 = add t74, Constant:i64<-16>
 ... into: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t63: ch = store<(store (s64) into %ir..repack33)> t77, Constant:i64<1>, t90, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack33)> t77, Constant:i64<1>, t90, undef:i64

Legalizing: t90: i64 = add t74, Constant:i64<-16>
Legal node: nothing to do

Combining: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t89: i64 = Constant<-16>
Legal node: nothing to do

Combining: t89: i64 = Constant<-16>

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %3
Legal node: nothing to do

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %3

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %2
Legal node: nothing to do

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %2

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %16
Legal node: nothing to do

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %16

Legalizing: t56: ch = BasicBlock<.lr.ph96.preheader 0x7fee59053cd0>
Legal node: nothing to do

Combining: t56: ch = BasicBlock<.lr.ph96.preheader 0x7fee59053cd0>

Legalizing: t54: ch = BasicBlock<._crit_edge97 0x7fee59053dd0>
Legal node: nothing to do

Combining: t54: ch = BasicBlock<._crit_edge97 0x7fee59053dd0>

Legalizing: t47: i64 = Register %19

Combining: t47: i64 = Register %19

Legalizing: t45: i64 = Register $rax

Combining: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Combining: t42: Untyped = RegisterMask

Legalizing: t40: i64 = Register $rdi

Combining: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Combining: t38: i64 = TargetConstant<0>

Legalizing: t35: i64 = Register %18

Combining: t35: i64 = Register %18

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Combining: t33: i8 = Constant<3>

Legalizing: t30: i64 = Register %3

Combining: t30: i64 = Register %3

Legalizing: t24: i64 = Register %2

Combining: t24: i64 = Register %2

Legalizing: t14: i64 = undef
Legal node: nothing to do

Combining: t14: i64 = undef

Legalizing: t12: i64 = Register %16

Combining: t12: i64 = Register %16

Legalizing: t10: i64 = Register %17

Combining: t10: i64 = Register %17

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Combining: t8: i64 = Constant<0>

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Combining: t2: i64 = Constant<1>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.6 'main:._crit_edge94'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %16
  t31: i64,ch = CopyFromReg t0, Register:i64 %3
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.28)> t77, t13, t82, undef:i64
          t84: i64 = add t74, Constant:i64<-40>
        t18: ch = store<(store (s64) into %ir..repack27)> t77, t13, t84, undef:i64
          t86: i64 = add t74, Constant:i64<-32>
        t21: ch = store<(store (s64) into %ir..repack29)> t77, Constant:i64<0>, t86, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %2
          t88: i64 = add t74, Constant:i64<-24>
        t26: ch = store<(store (s64) into %ir..repack31)> t77, t25, t88, undef:i64
          t90: i64 = add t74, Constant:i64<-16>
        t63: ch = store<(store (s64) into %ir..repack33)> t77, Constant:i64<1>, t90, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
  t82: i64 = add t74, Constant:i64<-48>
        t11: ch = CopyToReg t0, Register:i64 %17, t82
        t36: ch = CopyToReg t0, Register:i64 %18, t34
        t48: ch = CopyToReg t0, Register:i64 %19, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>


===== Instruction selection begins: %bb.6 '._crit_edge94'

ISEL: Starting selection on root node: t57: ch = br t71, BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>
ISEL: Starting pattern match
  Initial Opcode index to 134414
  Morphed node: t57: ch = JMP_1 BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>, t71
ISEL: Match complete!

ISEL: Starting selection on root node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge97 0x7fee59053dd0>, TargetConstant:i8<14>, t69
ISEL: Starting pattern match
  Initial Opcode index to 131614
Creating new node: t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  Morphed node: t71: ch = JCC_1 BasicBlock:ch<._crit_edge97 0x7fee59053dd0>, TargetConstant:i8<14>, t92, t92:1
ISEL: Match complete!

ISEL: Starting selection on root node: t53: ch = TokenFactor t11, t36, t48, t46:1

ISEL: Starting selection on root node: t48: ch = CopyToReg t0, Register:i64 %19, t46

ISEL: Starting selection on root node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

ISEL: Starting selection on root node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
ISEL: Match complete!

ISEL: Starting selection on root node: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
ISEL: Match complete!

ISEL: Starting selection on root node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

ISEL: Starting selection on root node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t93: i32 = TargetConstant<0>
  Morphed node: t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
ISEL: Match complete!

ISEL: Starting selection on root node: t64: ch = TokenFactor t15, t18, t21, t26, t63

ISEL: Starting selection on root node: t15: ch = store<(store (s64) into %ir.28)> t77, t13, t82, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t94: i8 = TargetConstant<1>
Creating constant: t96: i32 = TargetConstant<-48>
  Morphed node: t15: ch = MOV64mr<Mem:(store (s64) into %ir.28)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch = store<(store (s64) into %ir..repack27)> t77, t13, t84, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t98: i32 = TargetConstant<-40>
  Morphed node: t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack27)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = store<(store (s64) into %ir..repack29)> t77, Constant:i64<0>, t86, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Skipped scope entry (due to false predicate) at index 16132, continuing at 16162
  Skipped scope entry (due to false predicate) at index 16163, continuing at 16193
  Match failed at index 16203
  Continuing at 16224
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t99: i32 = TargetConstant<-32>
  Morphed node: t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack29)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t26: ch = store<(store (s64) into %ir..repack31)> t77, t25, t88, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t100: i32 = TargetConstant<-24>
  Morphed node: t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t63: ch = store<(store (s64) into %ir..repack33)> t77, Constant:i64<1>, t90, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t101: i32 = TargetConstant<-16>
Creating constant: t102: i64 = TargetConstant<1>
  Morphed node: t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack33)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
ISEL: Match complete!

ISEL: Starting selection on root node: t11: ch = CopyToReg t0, Register:i64 %17, t82

ISEL: Starting selection on root node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

ISEL: Starting selection on root node: t82: i64 = add t74, Constant:i64<-48>
ISEL: Starting pattern match
  Initial Opcode index to 102161
  Match failed at index 102165
  Continuing at 102268
  Match failed at index 102270
  Continuing at 102377
  TypeSwitch[i64] from 102379 to 102420
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 102420
  Continuing at 102435
  Match failed at index 102438
  Continuing at 102459
  Match failed at index 102461
  Continuing at 102483
  Skipped scope entry (due to false predicate) at index 102488, continuing at 102540
  Skipped scope entry (due to false predicate) at index 102541, continuing at 102593
  Skipped scope entry (due to false predicate) at index 102594, continuing at 102644
  Skipped scope entry (due to false predicate) at index 102645, continuing at 102669
  Match failed at index 102683
  Continuing at 102696
  Match failed at index 102700
  Continuing at 102713
Creating constant: t104: i64 = TargetConstant<-48>
  Morphed node: t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
ISEL: Match complete!

ISEL: Starting selection on root node: t36: ch = CopyToReg t0, Register:i64 %18, t34

ISEL: Starting selection on root node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

ISEL: Starting selection on root node: t34: i64 = shl t31, Constant:i8<3>
ISEL: Starting pattern match
  Initial Opcode index to 44725
  Match failed at index 44729
  Continuing at 44944
  TypeSwitch[i64] from 44946 to 44987
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 44987
  Continuing at 45002
  Match failed at index 45009
  Continuing at 45152
  Match failed at index 45153
  Continuing at 45203
  TypeSwitch[i64] from 45215 to 45257
Creating constant: t105: i8 = TargetConstant<3>
  Morphed node: t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 25710
  Match failed at index 25714
  Continuing at 26614
  Skipped scope entry (due to false predicate) at index 26619, continuing at 26650
  Skipped scope entry (due to false predicate) at index 26651, continuing at 26682
  Skipped scope entry (due to false predicate) at index 26683, continuing at 26714
  Match failed at index 26718
  Continuing at 26746
  Continuing at 26747
  Match failed at index 26750
  Continuing at 27134
  Skipped scope entry (due to false predicate) at index 27139, continuing at 27203
  Skipped scope entry (due to false predicate) at index 27204, continuing at 27304
  Skipped scope entry (due to false predicate) at index 27305, continuing at 27405
  Morphed node: t69: i32 = TEST64rr t31, t31
ISEL: Match complete!

ISEL: Starting selection on root node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132007
  Match failed at index 132010
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t31: i64,ch = CopyFromReg t0, Register:i64 %3

ISEL: Starting selection on root node: t25: i64,ch = CopyFromReg t0, Register:i64 %2

ISEL: Starting selection on root node: t13: i64,ch = CopyFromReg t0, Register:i64 %16

ISEL: Starting selection on root node: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

ISEL: Starting selection on root node: t73: i64 = Register $rsp

ISEL: Starting selection on root node: t70: i8 = TargetConstant<14>

ISEL: Starting selection on root node: t56: ch = BasicBlock<.lr.ph96.preheader 0x7fee59053cd0>

ISEL: Starting selection on root node: t54: ch = BasicBlock<._crit_edge97 0x7fee59053dd0>

ISEL: Starting selection on root node: t47: i64 = Register %19

ISEL: Starting selection on root node: t45: i64 = Register $rax

ISEL: Starting selection on root node: t42: Untyped = RegisterMask

ISEL: Starting selection on root node: t40: i64 = Register $rdi

ISEL: Starting selection on root node: t38: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t35: i64 = Register %18

ISEL: Starting selection on root node: t30: i64 = Register %3

ISEL: Starting selection on root node: t24: i64 = Register %2

ISEL: Starting selection on root node: t12: i64 = Register %16

ISEL: Starting selection on root node: t10: i64 = Register %17

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.6 'main:._crit_edge94'
SelectionDAG has 59 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %16
  t31: i64,ch = CopyFromReg t0, Register:i64 %3
  t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
    t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
  t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp
  t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
        t15: ch = MOV64mr<Mem:(store (s64) into %ir.28)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1
        t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack27)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1
        t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack29)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1
          t25: i64,ch = CopyFromReg t0, Register:i64 %2
        t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1
        t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack33)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
  t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34
    t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
  t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
  t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2
      t11: ch = CopyToReg t0, Register:i64 %17, t82
      t36: ch = CopyToReg t0, Register:i64 %18, t34
      t48: ch = CopyToReg t0, Register:i64 %19, t46
    t53: ch = TokenFactor t11, t36, t48, t46:1
    t69: i32 = TEST64rr t31, t31
  t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  t103: i32 = Register $noreg
    t71: ch = JCC_1 BasicBlock:ch<._crit_edge97 0x7fee59053dd0>, TargetConstant:i8<14>, t92, t92:1
  t57: ch = JMP_1 BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>, t71


********** List Scheduling %bb.6 '._crit_edge94' **********
SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>, t71

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge97 0x7fee59053dd0>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(4): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t69: i32 = TEST64rr t31, t31

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %3

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(6): Data Latency=1
SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(24): Ord  Latency=1 Barrier
    SU(23): Ord  Latency=1 Barrier
    SU(22): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(21): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(22): Data Latency=1
SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(5): Data Latency=1
    SU(23): Data Latency=1
SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(8): Ord  Latency=0 Barrier
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(20): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(9): Ord  Latency=1 Barrier
  Successors:
    SU(7): Ord  Latency=0 Barrier
SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack33)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

  # preds left       : 1
  # succs left       : 5
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(11): Ord  Latency=1 Barrier
  Successors:
    SU(9): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(20): Ord  Latency=1 Barrier
SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 7
  Predecessors:
    SU(13): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
  Successors:
    SU(10): Ord  Latency=1 Barrier
SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(13): Data Latency=1
  Successors:
    SU(11): Data Latency=1
    SU(24): Data Latency=1
SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

  # preds left       : 1
  # succs left       : 7
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 9
  Predecessors:
    SU(14): Ord  Latency=1 Barrier
  Successors:
    SU(9): Data Latency=1
    SU(11): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
    SU(15): Data Latency=1
    SU(17): Data Latency=1
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(13): Ord  Latency=1 Barrier
SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(16): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %2

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(15): Data Latency=1
SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack29)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack27)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %16

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.28)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(22): t48: ch = CopyToReg t0, Register:i64 %19, t46

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(23): t36: ch = CopyToReg t0, Register:i64 %18, t34

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>, t71


*** Scheduling [0]: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>, t71


Examining Available:
Height 1: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge97 0x7fee59053dd0>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


*** Scheduling [1]: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge97 0x7fee59053dd0>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


Examining Available:
Height 1: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

Height 2: SU(2): t69: i32 = TEST64rr t31, t31


*** Scheduling [2]: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1


Examining Available:
Height 2: SU(2): t69: i32 = TEST64rr t31, t31

Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %19, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %18, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


*** Scheduling [3]: SU(2): t69: i32 = TEST64rr t31, t31


Examining Available:
Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %19, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %18, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


*** Scheduling [4]: SU(22): t48: ch = CopyToReg t0, Register:i64 %19, t46


Examining Available:
Height 5: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %18, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


*** Scheduling [5]: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1


Examining Available:
Height 6: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %18, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


*** Scheduling [6]: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0


Examining Available:
Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %18, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


*** Scheduling [7]: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64


Examining Available:
Height 7: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %18, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


*** Scheduling [8]: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63


Examining Available:
Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %18, t34

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack33)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack29)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack27)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.28)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


*** Scheduling [9]: SU(23): t36: ch = CopyToReg t0, Register:i64 %18, t34


Examining Available:
Height 10: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack33)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack29)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack27)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.28)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


*** Scheduling [10]: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>


Examining Available:
Height 11: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %3

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack33)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack29)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack27)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.28)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


*** Scheduling [11]: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %3


Examining Available:
Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack33)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack29)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack27)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.28)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


*** Scheduling [12]: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack33)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1


Examining Available:
Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack29)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack27)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.28)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


*** Scheduling [13]: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1


Examining Available:
Height 14: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %2

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack29)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack27)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.28)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


*** Scheduling [14]: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %2


Examining Available:
Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack29)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack27)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.28)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


*** Scheduling [15]: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack29)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1


Examining Available:
Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack27)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.28)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


*** Scheduling [16]: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack27)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.28)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


*** Scheduling [17]: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.28)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 18: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %16

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [18]: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %16


Examining Available:
Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [19]: SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82


Examining Available:
Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [20]: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


Examining Available:
Height 21: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


*** Scheduling [21]: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


Examining Available:
Height 22: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


*** Scheduling [22]: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


Examining Available:
Height 23: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


*** Scheduling [23]: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


Examining Available:
Height 24: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [24]: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

SU(24): t11: ch = CopyToReg t0, Register:i64 %17, t82

SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %16

SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.28)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack27)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack29)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %2

SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack33)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %3

SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

SU(23): t36: ch = CopyToReg t0, Register:i64 %18, t34

SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

SU(22): t48: ch = CopyToReg t0, Register:i64 %19, t46

SU(2): t69: i32 = TEST64rr t31, t31

SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge97 0x7fee59053dd0>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph96.preheader 0x7fee59053cd0>, t71


Total amount of phi nodes to update: 0
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %19
Creating constant: t3: i8 = Constant<0>
Creating new node: t5: i64,ch = CopyFromReg t0, Register:i64 %18
Creating constant: t7: i64 = TargetConstant<0>
Creating new node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Creating new node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Creating new node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Creating new node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Initial selection DAG: %bb.7 'main:.lr.ph96.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t3: i8 = Constant<0>
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %19
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %18
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Combining: t13: Untyped = RegisterMask

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Combining: t11: i64 = Register $rsi

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Combining: t9: i64 = Register $rdi

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t7: i64 = TargetConstant<0>

Combining: t6: i64 = ExternalSymbol'__bzero'

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %18

Combining: t4: i64 = Register %18

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %19

Combining: t1: i64 = Register %19

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.7 'main:.lr.ph96.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %19
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %18
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


Legalizing node: t13: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t13: Untyped = RegisterMask

Legalizing node: t11: i64 = Register $rsi
Ignoring node results
Legally typed node: t11: i64 = Register $rsi

Legalizing node: t9: i64 = Register $rdi
Ignoring node results
Legally typed node: t9: i64 = Register $rdi

Legalizing node: t7: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t7: i64 = TargetConstant<0>

Legalizing node: t6: i64 = ExternalSymbol'__bzero'
Analyzing result type: i64
Legal result type
Legally typed node: t6: i64 = ExternalSymbol'__bzero'

Legalizing node: t4: i64 = Register %18
Ignoring node results
Legally typed node: t4: i64 = Register %18

Legalizing node: t1: i64 = Register %19
Ignoring node results
Legally typed node: t1: i64 = Register %19

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %19
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %19

Legalizing node: t5: i64,ch = CopyFromReg t0, Register:i64 %18
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t5: i64,ch = CopyFromReg t0, Register:i64 %18

Legalizing node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %19
Legal operand
Legally typed node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Analyzing operand: t5: i64,ch = CopyFromReg t0, Register:i64 %18
Legal operand
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Legally typed node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Analyzing operand: t6: i64 = ExternalSymbol'__bzero'
Legal operand
Analyzing operand: t13: Untyped = RegisterMask
Legal operand
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Legally typed node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Legally typed node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.7 'main:.lr.ph96.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %19
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %18
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %18
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %19
Legal node: nothing to do

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Legalizing: t6: i64 = ExternalSymbol'__bzero'
Trying custom legalization
Creating new node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Successfully custom legalized node
 ... replacing: t6: i64 = ExternalSymbol'__bzero'
     with:      t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t4: i64 = Register %18

Legalizing: t1: i64 = Register %19

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do
Legalized selection DAG: %bb.7 'main:.lr.ph96.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %19
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %18
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Combining: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do

Combining: t16: i64 = TargetExternalSymbol'__bzero'

Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Combining: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %18
Legal node: nothing to do

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %18

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %19
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %19

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Combining: t13: Untyped = RegisterMask

Legalizing: t11: i64 = Register $rsi

Combining: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Combining: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Combining: t7: i64 = TargetConstant<0>

Legalizing: t4: i64 = Register %18

Combining: t4: i64 = Register %18

Legalizing: t1: i64 = Register %19

Combining: t1: i64 = Register %19

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.7 'main:.lr.ph96.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %19
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %18
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


===== Instruction selection begins: %bb.7 '.lr.ph96.preheader'

ISEL: Starting selection on root node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

ISEL: Starting selection on root node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

ISEL: Starting selection on root node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132022
  Match failed at index 132025
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t18: i32 = TargetConstant<0>
  Morphed node: t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i64,ch = CopyFromReg t0, Register:i64 %18

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %19

ISEL: Starting selection on root node: t16: i64 = TargetExternalSymbol'__bzero'

ISEL: Starting selection on root node: t13: Untyped = RegisterMask

ISEL: Starting selection on root node: t11: i64 = Register $rsi

ISEL: Starting selection on root node: t9: i64 = Register $rdi

ISEL: Starting selection on root node: t7: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t4: i64 = Register %18

ISEL: Starting selection on root node: t1: i64 = Register %19

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.7 'main:.lr.ph96.preheader'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
    t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t2: i64,ch = CopyFromReg t0, Register:i64 %19
  t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %18
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
  t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1


********** List Scheduling %bb.7 '.lr.ph96.preheader' **********
SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1

  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Data Latency=1
    SU(1): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %18

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %19

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1

Examining Available:
Height 0: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


*** Scheduling [0]: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Examining Available:
Height 1: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %18

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %19

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [1]: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'


Examining Available:
Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %18

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %19

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [2]: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %18


Examining Available:
Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %19

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [3]: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %19


Examining Available:
Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [4]: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %19

SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %18

SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<1>
Creating constant: t2: i64 = Constant<1>
Creating constant: t3: i64 = Constant<40>
Creating constant: t4: i64 = Constant<15>
Creating constant: t5: i64 = Constant<55>
Creating constant: t6: i64 = Constant<-16>
Creating constant: t7: i64 = Constant<48>
Creating constant: t8: i64 = Constant<0>
Creating new node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Creating new node: t11: ch = CopyToReg t0, Register:i64 %20, t9
Creating new node: t13: i64,ch = CopyFromReg t0, Register:i64 %19
Creating new node: t14: i64 = undef
Creating new node: t15: ch = store<(store (s64) into %ir.31)> t9:1, t13, t9, undef:i64
Creating constant: t16: i64 = Constant<8>
Creating new node: t17: i64 = add nuw t9, Constant:i64<8>
Creating new node: t18: ch = store<(store (s64) into %ir..repack36)> t15, t13, t17, undef:i64
Creating constant: t19: i64 = Constant<16>
Creating new node: t20: i64 = add nuw t9, Constant:i64<16>
Creating new node: t21: ch = store<(store (s64) into %ir..repack38)> t18, Constant:i64<0>, t20, undef:i64
Creating constant: t22: i64 = Constant<24>
Creating new node: t23: i64 = add nuw t9, Constant:i64<24>
Creating new node: t25: i64,ch = CopyFromReg t0, Register:i64 %3
Creating new node: t26: ch = store<(store (s64) into %ir..repack40)> t21, t25, t23, undef:i64
Creating constant: t27: i64 = Constant<32>
Creating new node: t28: i64 = add nuw t9, Constant:i64<32>
Creating new node: t29: ch = store<(store (s64) into %ir..repack42)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t31: i64,ch = CopyFromReg t0, Register:i64 %4
Creating constant: t32: i64 = Constant<3>
Creating constant: t33: i8 = Constant<3>
Creating new node: t34: i64 = shl t31, Constant:i8<3>
Creating new node: t36: ch = CopyToReg t0, Register:i64 %21, t34
Creating constant: t38: i64 = TargetConstant<0>
Creating new node: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Creating new node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Creating new node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Creating new node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Creating new node: t48: ch = CopyToReg t0, Register:i64 %22, t46
Creating new node: t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
Creating constant: t51: i1 = Constant<-1>
Creating new node: t52: i1 = xor t50, Constant:i1<-1>
Creating new node: t53: ch = TokenFactor t11, t36, t48, t46:1
Creating new node: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge100 0x7fee5905b600>
Creating new node: t57: ch = br t55, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>
Initial selection DAG: %bb.8 'main:._crit_edge97'
SelectionDAG has 58 nodes:
  t0: ch,glue = EntryToken
  t1: i32 = Constant<1>
  t3: i64 = Constant<40>
  t4: i64 = Constant<15>
  t5: i64 = Constant<55>
  t6: i64 = Constant<-16>
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %19
  t31: i64,ch = CopyFromReg t0, Register:i64 %4
  t32: i64 = Constant<3>
  t34: i64 = shl t31, Constant:i8<3>
              t15: ch = store<(store (s64) into %ir.31)> t9:1, t13, t9, undef:i64
              t17: i64 = add nuw t9, Constant:i64<8>
            t18: ch = store<(store (s64) into %ir..repack36)> t15, t13, t17, undef:i64
            t20: i64 = add nuw t9, Constant:i64<16>
          t21: ch = store<(store (s64) into %ir..repack38)> t18, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %3
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack40)> t21, t25, t23, undef:i64
        t28: i64 = add nuw t9, Constant:i64<32>
      t29: ch = store<(store (s64) into %ir..repack42)> t26, Constant:i64<1>, t28, undef:i64
    t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %20, t9
        t36: ch = CopyToReg t0, Register:i64 %21, t34
        t48: ch = CopyToReg t0, Register:i64 %22, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
      t52: i1 = xor t50, Constant:i1<-1>
    t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge100 0x7fee5905b600>
  t57: ch = br t55, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>



Combining: t57: ch = br t55, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>

Combining: t56: ch = BasicBlock<.lr.ph99.preheader 0x7fee59053ed0>

Combining: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge100 0x7fee5905b600>
Creating new node: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge100 0x7fee5905b600>
 ... into: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge100 0x7fee5905b600>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>

Combining: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge100 0x7fee5905b600>

Combining: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
 ... into: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge100 0x7fee5905b600>

Combining: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t61: ch = setlt

Combining: t54: ch = BasicBlock<._crit_edge100 0x7fee5905b600>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %22, t46

Combining: t47: i64 = Register %22

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %21, t34

Combining: t35: i64 = Register %21

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %4

Combining: t30: i64 = Register %4

Combining: t29: ch = store<(store (s64) into %ir..repack42)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t63: ch = store<(store (s64) into %ir..repack42)> t9:1, Constant:i64<1>, t28, undef:i64
Creating new node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Replacing.1 t29: ch = store<(store (s64) into %ir..repack42)> t26, Constant:i64<1>, t28, undef:i64

With: t64: ch = TokenFactor t15, t18, t21, t26, t63
 and 0 other values

Combining: t63: ch = store<(store (s64) into %ir..repack42)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack40)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %3

Combining: t24: i64 = Register %3

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack38)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack36)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.31)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %19

Combining: t12: i64 = Register %19

Combining: t11: ch = CopyToReg t0, Register:i64 %20, t9

Combining: t10: i64 = Register %20

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.8 'main:._crit_edge97'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %19
  t31: i64,ch = CopyFromReg t0, Register:i64 %4
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.31)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack36)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack38)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %3
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack40)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack42)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %20, t9
        t36: ch = CopyToReg t0, Register:i64 %21, t34
        t48: ch = CopyToReg t0, Register:i64 %22, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge100 0x7fee5905b600>
  t57: ch = br t60, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>


Legalizing node: t61: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t61: ch = setlt

Legalizing node: t56: ch = BasicBlock<.lr.ph99.preheader 0x7fee59053ed0>
Analyzing result type: ch
Legal result type
Legally typed node: t56: ch = BasicBlock<.lr.ph99.preheader 0x7fee59053ed0>

Legalizing node: t54: ch = BasicBlock<._crit_edge100 0x7fee5905b600>
Analyzing result type: ch
Legal result type
Legally typed node: t54: ch = BasicBlock<._crit_edge100 0x7fee5905b600>

Legalizing node: t47: i64 = Register %22
Ignoring node results
Legally typed node: t47: i64 = Register %22

Legalizing node: t45: i64 = Register $rax
Ignoring node results
Legally typed node: t45: i64 = Register $rax

Legalizing node: t42: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t42: Untyped = RegisterMask

Legalizing node: t40: i64 = Register $rdi
Ignoring node results
Legally typed node: t40: i64 = Register $rdi

Legalizing node: t38: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t38: i64 = TargetConstant<0>

Legalizing node: t37: i64 = GlobalAddress<ptr @malloc> 0
Analyzing result type: i64
Legal result type
Legally typed node: t37: i64 = GlobalAddress<ptr @malloc> 0

Legalizing node: t35: i64 = Register %21
Ignoring node results
Legally typed node: t35: i64 = Register %21

Legalizing node: t33: i8 = Constant<3>
Analyzing result type: i8
Legal result type
Legally typed node: t33: i8 = Constant<3>

Legalizing node: t30: i64 = Register %4
Ignoring node results
Legally typed node: t30: i64 = Register %4

Legalizing node: t27: i64 = Constant<32>
Analyzing result type: i64
Legal result type
Legally typed node: t27: i64 = Constant<32>

Legalizing node: t24: i64 = Register %3
Ignoring node results
Legally typed node: t24: i64 = Register %3

Legalizing node: t22: i64 = Constant<24>
Analyzing result type: i64
Legal result type
Legally typed node: t22: i64 = Constant<24>

Legalizing node: t19: i64 = Constant<16>
Analyzing result type: i64
Legal result type
Legally typed node: t19: i64 = Constant<16>

Legalizing node: t16: i64 = Constant<8>
Analyzing result type: i64
Legal result type
Legally typed node: t16: i64 = Constant<8>

Legalizing node: t14: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t14: i64 = undef

Legalizing node: t12: i64 = Register %19
Ignoring node results
Legally typed node: t12: i64 = Register %19

Legalizing node: t10: i64 = Register %20
Ignoring node results
Legally typed node: t10: i64 = Register %20

Legalizing node: t8: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t8: i64 = Constant<0>

Legalizing node: t7: i64 = Constant<48>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<48>

Legalizing node: t2: i64 = Constant<1>
Analyzing result type: i64
Legal result type
Legally typed node: t2: i64 = Constant<1>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t7: i64 = Constant<48>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Legally typed node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Legalizing node: t11: ch = CopyToReg t0, Register:i64 %20, t9
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Legally typed node: t11: ch = CopyToReg t0, Register:i64 %20, t9

Legalizing node: t17: i64 = add nuw t9, Constant:i64<8>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t16: i64 = Constant<8>
Legal operand
Legally typed node: t17: i64 = add nuw t9, Constant:i64<8>

Legalizing node: t20: i64 = add nuw t9, Constant:i64<16>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t19: i64 = Constant<16>
Legal operand
Legally typed node: t20: i64 = add nuw t9, Constant:i64<16>

Legalizing node: t21: ch = store<(store (s64) into %ir..repack38)> t9:1, Constant:i64<0>, t20, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Analyzing operand: t20: i64 = add nuw t9, Constant:i64<16>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t21: ch = store<(store (s64) into %ir..repack38)> t9:1, Constant:i64<0>, t20, undef:i64

Legalizing node: t23: i64 = add nuw t9, Constant:i64<24>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t22: i64 = Constant<24>
Legal operand
Legally typed node: t23: i64 = add nuw t9, Constant:i64<24>

Legalizing node: t28: i64 = add nuw t9, Constant:i64<32>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t27: i64 = Constant<32>
Legal operand
Legally typed node: t28: i64 = add nuw t9, Constant:i64<32>

Legalizing node: t63: ch = store<(store (s64) into %ir..repack42)> t9:1, Constant:i64<1>, t28, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t28: i64 = add nuw t9, Constant:i64<32>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t63: ch = store<(store (s64) into %ir..repack42)> t9:1, Constant:i64<1>, t28, undef:i64

Legalizing node: t13: i64,ch = CopyFromReg t0, Register:i64 %19
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t13: i64,ch = CopyFromReg t0, Register:i64 %19

Legalizing node: t15: ch = store<(store (s64) into %ir.31)> t9:1, t13, t9, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %19
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t15: ch = store<(store (s64) into %ir.31)> t9:1, t13, t9, undef:i64

Legalizing node: t18: ch = store<(store (s64) into %ir..repack36)> t9:1, t13, t17, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %19
Legal operand
Analyzing operand: t17: i64 = add nuw t9, Constant:i64<8>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t18: ch = store<(store (s64) into %ir..repack36)> t9:1, t13, t17, undef:i64

Legalizing node: t25: i64,ch = CopyFromReg t0, Register:i64 %3
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t25: i64,ch = CopyFromReg t0, Register:i64 %3

Legalizing node: t26: ch = store<(store (s64) into %ir..repack40)> t9:1, t25, t23, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t25: i64,ch = CopyFromReg t0, Register:i64 %3
Legal operand
Analyzing operand: t23: i64 = add nuw t9, Constant:i64<24>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t26: ch = store<(store (s64) into %ir..repack40)> t9:1, t25, t23, undef:i64

Legalizing node: t64: ch = TokenFactor t15, t18, t21, t26, t63
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = store<(store (s64) into %ir.31)> t9:1, t13, t9, undef:i64
Legal operand
Analyzing operand: t18: ch = store<(store (s64) into %ir..repack36)> t9:1, t13, t17, undef:i64
Legal operand
Analyzing operand: t21: ch = store<(store (s64) into %ir..repack38)> t9:1, Constant:i64<0>, t20, undef:i64
Legal operand
Analyzing operand: t26: ch = store<(store (s64) into %ir..repack40)> t9:1, t25, t23, undef:i64
Legal operand
Analyzing operand: t63: ch = store<(store (s64) into %ir..repack42)> t9:1, Constant:i64<1>, t28, undef:i64
Legal operand
Legally typed node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal operand
Legally typed node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t31: i64,ch = CopyFromReg t0, Register:i64 %4
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t31: i64,ch = CopyFromReg t0, Register:i64 %4

Legalizing node: t34: i64 = shl t31, Constant:i8<3>
Analyzing result type: i64
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %4
Legal operand
Analyzing operand: t33: i8 = Constant<3>
Legal operand
Legally typed node: t34: i64 = shl t31, Constant:i8<3>

Legalizing node: t36: ch = CopyToReg t0, Register:i64 %21, t34
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t36: ch = CopyToReg t0, Register:i64 %21, t34

Legalizing node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Analyzing operand: t37: i64 = GlobalAddress<ptr @malloc> 0
Legal operand
Analyzing operand: t42: Untyped = RegisterMask
Legal operand
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Legally typed node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Legally typed node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Legally typed node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing node: t48: ch = CopyToReg t0, Register:i64 %22, t46
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t48: ch = CopyToReg t0, Register:i64 %22, t46

Legalizing node: t53: ch = TokenFactor t11, t36, t48, t46:1
Analyzing result type: ch
Legal result type
Analyzing operand: t11: ch = CopyToReg t0, Register:i64 %20, t9
Legal operand
Analyzing operand: t36: ch = CopyToReg t0, Register:i64 %21, t34
Legal operand
Analyzing operand: t48: ch = CopyToReg t0, Register:i64 %22, t46
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i1
Promote integer result: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Creating new node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legalizing node: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge100 0x7fee5905b600>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge100 0x7fee5905b600>

Creating new node: t66: i8 = zero_extend t62
Legalizing node: t66: i8 = zero_extend t62
Analyzing result type: i8
Legal result type
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t66: i8 = zero_extend t62

Creating constant: t67: i8 = Constant<1>
Creating new node: t68: i8 = and t65, Constant:i8<1>
Replacing: t66: i8 = zero_extend t62
     with: t68: i8 = and t65, Constant:i8<1>
Legalizing node: t67: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t67: i8 = Constant<1>

Legalizing node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %4
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t61: ch = setlt
Legal operand
Legally typed node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Legalizing node: t68: i8 = and t65, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legal operand
Analyzing operand: t67: i8 = Constant<1>
Legal operand
Legally typed node: t68: i8 = and t65, Constant:i8<1>

Legalizing node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge100 0x7fee5905b600>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t68: i8 = and t65, Constant:i8<1>
Legal operand
Analyzing operand: t54: ch = BasicBlock<._crit_edge100 0x7fee5905b600>
Legal operand
Legally typed node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge100 0x7fee5905b600>

Legalizing node: t57: ch = br t60, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>
Analyzing result type: ch
Legal result type
Analyzing operand: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge100 0x7fee5905b600>
Legal operand
Analyzing operand: t56: ch = BasicBlock<.lr.ph99.preheader 0x7fee59053ed0>
Legal operand
Legally typed node: t57: ch = br t60, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>

Legalizing node: t65535: ch = handlenode t57
Analyzing result type: ch
Legal result type
Analyzing operand: t57: ch = br t60, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>
Legal operand
Legally typed node: t65535: ch = handlenode t57

Type-legalized selection DAG: %bb.8 'main:._crit_edge97'
SelectionDAG has 53 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %19
  t31: i64,ch = CopyFromReg t0, Register:i64 %4
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.31)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack36)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack38)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %3
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack40)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack42)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %20, t9
        t36: ch = CopyToReg t0, Register:i64 %21, t34
        t48: ch = CopyToReg t0, Register:i64 %22, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
      t68: i8 = and t65, Constant:i8<1>
    t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge100 0x7fee5905b600>
  t57: ch = br t60, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>



Combining: t68: i8 = and t65, Constant:i8<1>

Replacing.2 t68: i8 = and t65, Constant:i8<1>

With: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch


Combining: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t63: ch = store<(store (s64) into %ir..repack42)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t61: ch = setlt

Combining: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge100 0x7fee5905b600>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>

Combining: t56: ch = BasicBlock<.lr.ph99.preheader 0x7fee59053ed0>

Combining: t54: ch = BasicBlock<._crit_edge100 0x7fee5905b600>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %22, t46

Combining: t47: i64 = Register %22

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %21, t34

Combining: t35: i64 = Register %21

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %4

Combining: t30: i64 = Register %4

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack40)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %3

Combining: t24: i64 = Register %3

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack38)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack36)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.31)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %19

Combining: t12: i64 = Register %19

Combining: t11: ch = CopyToReg t0, Register:i64 %20, t9

Combining: t10: i64 = Register %20

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized type-legalized selection DAG: %bb.8 'main:._crit_edge97'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %19
  t31: i64,ch = CopyFromReg t0, Register:i64 %4
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.31)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack36)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack38)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %3
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack40)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack42)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %20, t9
        t36: ch = CopyToReg t0, Register:i64 %21, t34
        t48: ch = CopyToReg t0, Register:i64 %22, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge100 0x7fee5905b600>
  t57: ch = br t60, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>



Legalizing: t57: ch = br t60, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>
Legal node: nothing to do

Legalizing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge100 0x7fee5905b600>
Trying custom legalization
Creating new node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Creating constant: t70: i8 = TargetConstant<14>
Creating new node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge100 0x7fee5905b600>, TargetConstant:i8<14>, t69
Successfully custom legalized node
 ... replacing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge100 0x7fee5905b600>
     with:      t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge100 0x7fee5905b600>, TargetConstant:i8<14>, t69

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Legalizing: t48: ch = CopyToReg t0, Register:i64 %22, t46
Legal node: nothing to do

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Legalizing: t36: ch = CopyToReg t0, Register:i64 %21, t34
Legal node: nothing to do

Legalizing: t18: ch = store<(store (s64) into %ir..repack36)> t9:1, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t21: ch = store<(store (s64) into %ir..repack38)> t9:1, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t26: ch = store<(store (s64) into %ir..repack40)> t9:1, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t63: ch = store<(store (s64) into %ir..repack42)> t9:1, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Legalizing: t15: ch = store<(store (s64) into %ir.31)> t9:1, t13, t9, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t11: ch = CopyToReg t0, Register:i64 %20, t9
Legal node: nothing to do

Legalizing: t17: i64 = add nuw t9, Constant:i64<8>
Legal node: nothing to do

Legalizing: t20: i64 = add nuw t9, Constant:i64<16>
Legal node: nothing to do

Legalizing: t23: i64 = add nuw t9, Constant:i64<24>
Legal node: nothing to do

Legalizing: t28: i64 = add nuw t9, Constant:i64<32>
Legal node: nothing to do

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %4
Legal node: nothing to do

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %3
Legal node: nothing to do

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %19
Legal node: nothing to do

Legalizing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Trying custom legalization
Creating new node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Creating new node: t75: i64 = sub t74, Constant:i64<48>
Creating new node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Creating new node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t78: i64,ch = merge_values t75, t77
Successfully custom legalized node
 ... replacing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
     with:      t78: i64,ch = merge_values t75, t77
      and:      t78: i64,ch = merge_values t75, t77

Legalizing: t56: ch = BasicBlock<.lr.ph99.preheader 0x7fee59053ed0>
Legal node: nothing to do

Legalizing: t54: ch = BasicBlock<._crit_edge100 0x7fee5905b600>
Legal node: nothing to do

Legalizing: t47: i64 = Register %22

Legalizing: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Legalizing: t37: i64 = GlobalAddress<ptr @malloc> 0
Trying custom legalization
Creating new node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Successfully custom legalized node
 ... replacing: t37: i64 = GlobalAddress<ptr @malloc> 0
     with:      t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t35: i64 = Register %21

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Legalizing: t30: i64 = Register %4

Legalizing: t27: i64 = Constant<32>
Legal node: nothing to do

Legalizing: t24: i64 = Register %3

Legalizing: t22: i64 = Constant<24>
Legal node: nothing to do

Legalizing: t19: i64 = Constant<16>
Legal node: nothing to do

Legalizing: t16: i64 = Constant<8>
Legal node: nothing to do

Legalizing: t14: i64 = undef
Legal node: nothing to do

Legalizing: t12: i64 = Register %19

Legalizing: t10: i64 = Register %20

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t7: i64 = Constant<48>
Legal node: nothing to do

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t78: i64,ch = merge_values t75, t77
Trying to expand node
Successfully expanded node
 ... replacing: t78: i64,ch = merge_values t75, t77
     with:      t75: i64 = sub t74, Constant:i64<48>
      and:      t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Legalizing: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge100 0x7fee5905b600>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Legalizing: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do
Legalized selection DAG: %bb.8 'main:._crit_edge97'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %19
  t31: i64,ch = CopyFromReg t0, Register:i64 %4
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.31)> t77, t13, t75, undef:i64
          t17: i64 = add nuw t75, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack36)> t77, t13, t17, undef:i64
          t20: i64 = add nuw t75, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack38)> t77, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %3
          t23: i64 = add nuw t75, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack40)> t77, t25, t23, undef:i64
          t28: i64 = add nuw t75, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack42)> t77, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
  t75: i64 = sub t74, Constant:i64<48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
        t11: ch = CopyToReg t0, Register:i64 %20, t75
        t36: ch = CopyToReg t0, Register:i64 %21, t34
        t48: ch = CopyToReg t0, Register:i64 %22, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge100 0x7fee5905b600>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>



Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Combining: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Combining: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Combining: t75: i64 = sub t74, Constant:i64<48>
Creating constant: t81: i64 = Constant<-48>
Creating new node: t82: i64 = add t74, Constant:i64<-48>
 ... into: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t81: i64 = Constant<-48>
Legal node: nothing to do

Combining: t81: i64 = Constant<-48>

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Combining: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

Legalizing: t73: i64 = Register $rsp

Combining: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge100 0x7fee5905b600>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Combining: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge100 0x7fee5905b600>, TargetConstant:i8<14>, t69

Legalizing: t70: i8 = TargetConstant<14>

Combining: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do

Combining: t69: i32 = X86ISD::CMP t31, Constant:i64<0>

Legalizing: t57: ch = br t71, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>
Legal node: nothing to do

Combining: t57: ch = br t71, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing: t48: ch = CopyToReg t0, Register:i64 %22, t46
Legal node: nothing to do

Combining: t48: ch = CopyToReg t0, Register:i64 %22, t46

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Combining: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing: t36: ch = CopyToReg t0, Register:i64 %21, t34
Legal node: nothing to do

Combining: t36: ch = CopyToReg t0, Register:i64 %21, t34

Legalizing: t18: ch = store<(store (s64) into %ir..repack36)> t77, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack36)> t77, t13, t17, undef:i64

Legalizing: t21: ch = store<(store (s64) into %ir..repack38)> t77, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack38)> t77, Constant:i64<0>, t20, undef:i64

Legalizing: t26: ch = store<(store (s64) into %ir..repack40)> t77, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack40)> t77, t25, t23, undef:i64

Legalizing: t63: ch = store<(store (s64) into %ir..repack42)> t77, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack42)> t77, Constant:i64<1>, t28, undef:i64

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Combining: t34: i64 = shl t31, Constant:i8<3>

Legalizing: t15: ch = store<(store (s64) into %ir.31)> t77, t13, t82, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t15: ch = store<(store (s64) into %ir.31)> t77, t13, t82, undef:i64

Legalizing: t11: ch = CopyToReg t0, Register:i64 %20, t82
Legal node: nothing to do

Combining: t11: ch = CopyToReg t0, Register:i64 %20, t82

Legalizing: t17: i64 = add nuw t82, Constant:i64<8>
Legal node: nothing to do

Combining: t17: i64 = add nuw t82, Constant:i64<8>
Creating constant: t83: i64 = Constant<-40>
Creating new node: t84: i64 = add t74, Constant:i64<-40>
 ... into: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t18: ch = store<(store (s64) into %ir..repack36)> t77, t13, t84, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack36)> t77, t13, t84, undef:i64

Legalizing: t84: i64 = add t74, Constant:i64<-40>
Legal node: nothing to do

Combining: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t83: i64 = Constant<-40>
Legal node: nothing to do

Combining: t83: i64 = Constant<-40>

Legalizing: t20: i64 = add nuw t82, Constant:i64<16>
Legal node: nothing to do

Combining: t20: i64 = add nuw t82, Constant:i64<16>
Creating constant: t85: i64 = Constant<-32>
Creating new node: t86: i64 = add t74, Constant:i64<-32>
 ... into: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t21: ch = store<(store (s64) into %ir..repack38)> t77, Constant:i64<0>, t86, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack38)> t77, Constant:i64<0>, t86, undef:i64

Legalizing: t86: i64 = add t74, Constant:i64<-32>
Legal node: nothing to do

Combining: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t85: i64 = Constant<-32>
Legal node: nothing to do

Combining: t85: i64 = Constant<-32>

Legalizing: t23: i64 = add nuw t82, Constant:i64<24>
Legal node: nothing to do

Combining: t23: i64 = add nuw t82, Constant:i64<24>
Creating constant: t87: i64 = Constant<-24>
Creating new node: t88: i64 = add t74, Constant:i64<-24>
 ... into: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t26: ch = store<(store (s64) into %ir..repack40)> t77, t25, t88, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack40)> t77, t25, t88, undef:i64

Legalizing: t88: i64 = add t74, Constant:i64<-24>
Legal node: nothing to do

Combining: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t87: i64 = Constant<-24>
Legal node: nothing to do

Combining: t87: i64 = Constant<-24>

Legalizing: t28: i64 = add nuw t82, Constant:i64<32>
Legal node: nothing to do

Combining: t28: i64 = add nuw t82, Constant:i64<32>
Creating constant: t89: i64 = Constant<-16>
Creating new node: t90: i64 = add t74, Constant:i64<-16>
 ... into: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t63: ch = store<(store (s64) into %ir..repack42)> t77, Constant:i64<1>, t90, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack42)> t77, Constant:i64<1>, t90, undef:i64

Legalizing: t90: i64 = add t74, Constant:i64<-16>
Legal node: nothing to do

Combining: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t89: i64 = Constant<-16>
Legal node: nothing to do

Combining: t89: i64 = Constant<-16>

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %4
Legal node: nothing to do

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %4

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %3
Legal node: nothing to do

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %3

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %19
Legal node: nothing to do

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %19

Legalizing: t56: ch = BasicBlock<.lr.ph99.preheader 0x7fee59053ed0>
Legal node: nothing to do

Combining: t56: ch = BasicBlock<.lr.ph99.preheader 0x7fee59053ed0>

Legalizing: t54: ch = BasicBlock<._crit_edge100 0x7fee5905b600>
Legal node: nothing to do

Combining: t54: ch = BasicBlock<._crit_edge100 0x7fee5905b600>

Legalizing: t47: i64 = Register %22

Combining: t47: i64 = Register %22

Legalizing: t45: i64 = Register $rax

Combining: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Combining: t42: Untyped = RegisterMask

Legalizing: t40: i64 = Register $rdi

Combining: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Combining: t38: i64 = TargetConstant<0>

Legalizing: t35: i64 = Register %21

Combining: t35: i64 = Register %21

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Combining: t33: i8 = Constant<3>

Legalizing: t30: i64 = Register %4

Combining: t30: i64 = Register %4

Legalizing: t24: i64 = Register %3

Combining: t24: i64 = Register %3

Legalizing: t14: i64 = undef
Legal node: nothing to do

Combining: t14: i64 = undef

Legalizing: t12: i64 = Register %19

Combining: t12: i64 = Register %19

Legalizing: t10: i64 = Register %20

Combining: t10: i64 = Register %20

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Combining: t8: i64 = Constant<0>

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Combining: t2: i64 = Constant<1>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.8 'main:._crit_edge97'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %19
  t31: i64,ch = CopyFromReg t0, Register:i64 %4
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.31)> t77, t13, t82, undef:i64
          t84: i64 = add t74, Constant:i64<-40>
        t18: ch = store<(store (s64) into %ir..repack36)> t77, t13, t84, undef:i64
          t86: i64 = add t74, Constant:i64<-32>
        t21: ch = store<(store (s64) into %ir..repack38)> t77, Constant:i64<0>, t86, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %3
          t88: i64 = add t74, Constant:i64<-24>
        t26: ch = store<(store (s64) into %ir..repack40)> t77, t25, t88, undef:i64
          t90: i64 = add t74, Constant:i64<-16>
        t63: ch = store<(store (s64) into %ir..repack42)> t77, Constant:i64<1>, t90, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
  t82: i64 = add t74, Constant:i64<-48>
        t11: ch = CopyToReg t0, Register:i64 %20, t82
        t36: ch = CopyToReg t0, Register:i64 %21, t34
        t48: ch = CopyToReg t0, Register:i64 %22, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge100 0x7fee5905b600>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>


===== Instruction selection begins: %bb.8 '._crit_edge97'

ISEL: Starting selection on root node: t57: ch = br t71, BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>
ISEL: Starting pattern match
  Initial Opcode index to 134414
  Morphed node: t57: ch = JMP_1 BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>, t71
ISEL: Match complete!

ISEL: Starting selection on root node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge100 0x7fee5905b600>, TargetConstant:i8<14>, t69
ISEL: Starting pattern match
  Initial Opcode index to 131614
Creating new node: t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  Morphed node: t71: ch = JCC_1 BasicBlock:ch<._crit_edge100 0x7fee5905b600>, TargetConstant:i8<14>, t92, t92:1
ISEL: Match complete!

ISEL: Starting selection on root node: t53: ch = TokenFactor t11, t36, t48, t46:1

ISEL: Starting selection on root node: t48: ch = CopyToReg t0, Register:i64 %22, t46

ISEL: Starting selection on root node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

ISEL: Starting selection on root node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
ISEL: Match complete!

ISEL: Starting selection on root node: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
ISEL: Match complete!

ISEL: Starting selection on root node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

ISEL: Starting selection on root node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t93: i32 = TargetConstant<0>
  Morphed node: t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
ISEL: Match complete!

ISEL: Starting selection on root node: t64: ch = TokenFactor t15, t18, t21, t26, t63

ISEL: Starting selection on root node: t15: ch = store<(store (s64) into %ir.31)> t77, t13, t82, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t94: i8 = TargetConstant<1>
Creating constant: t96: i32 = TargetConstant<-48>
  Morphed node: t15: ch = MOV64mr<Mem:(store (s64) into %ir.31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch = store<(store (s64) into %ir..repack36)> t77, t13, t84, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t98: i32 = TargetConstant<-40>
  Morphed node: t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack36)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = store<(store (s64) into %ir..repack38)> t77, Constant:i64<0>, t86, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Skipped scope entry (due to false predicate) at index 16132, continuing at 16162
  Skipped scope entry (due to false predicate) at index 16163, continuing at 16193
  Match failed at index 16203
  Continuing at 16224
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t99: i32 = TargetConstant<-32>
  Morphed node: t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack38)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t26: ch = store<(store (s64) into %ir..repack40)> t77, t25, t88, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t100: i32 = TargetConstant<-24>
  Morphed node: t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t63: ch = store<(store (s64) into %ir..repack42)> t77, Constant:i64<1>, t90, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t101: i32 = TargetConstant<-16>
Creating constant: t102: i64 = TargetConstant<1>
  Morphed node: t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack42)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
ISEL: Match complete!

ISEL: Starting selection on root node: t11: ch = CopyToReg t0, Register:i64 %20, t82

ISEL: Starting selection on root node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

ISEL: Starting selection on root node: t82: i64 = add t74, Constant:i64<-48>
ISEL: Starting pattern match
  Initial Opcode index to 102161
  Match failed at index 102165
  Continuing at 102268
  Match failed at index 102270
  Continuing at 102377
  TypeSwitch[i64] from 102379 to 102420
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 102420
  Continuing at 102435
  Match failed at index 102438
  Continuing at 102459
  Match failed at index 102461
  Continuing at 102483
  Skipped scope entry (due to false predicate) at index 102488, continuing at 102540
  Skipped scope entry (due to false predicate) at index 102541, continuing at 102593
  Skipped scope entry (due to false predicate) at index 102594, continuing at 102644
  Skipped scope entry (due to false predicate) at index 102645, continuing at 102669
  Match failed at index 102683
  Continuing at 102696
  Match failed at index 102700
  Continuing at 102713
Creating constant: t104: i64 = TargetConstant<-48>
  Morphed node: t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
ISEL: Match complete!

ISEL: Starting selection on root node: t36: ch = CopyToReg t0, Register:i64 %21, t34

ISEL: Starting selection on root node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

ISEL: Starting selection on root node: t34: i64 = shl t31, Constant:i8<3>
ISEL: Starting pattern match
  Initial Opcode index to 44725
  Match failed at index 44729
  Continuing at 44944
  TypeSwitch[i64] from 44946 to 44987
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 44987
  Continuing at 45002
  Match failed at index 45009
  Continuing at 45152
  Match failed at index 45153
  Continuing at 45203
  TypeSwitch[i64] from 45215 to 45257
Creating constant: t105: i8 = TargetConstant<3>
  Morphed node: t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 25710
  Match failed at index 25714
  Continuing at 26614
  Skipped scope entry (due to false predicate) at index 26619, continuing at 26650
  Skipped scope entry (due to false predicate) at index 26651, continuing at 26682
  Skipped scope entry (due to false predicate) at index 26683, continuing at 26714
  Match failed at index 26718
  Continuing at 26746
  Continuing at 26747
  Match failed at index 26750
  Continuing at 27134
  Skipped scope entry (due to false predicate) at index 27139, continuing at 27203
  Skipped scope entry (due to false predicate) at index 27204, continuing at 27304
  Skipped scope entry (due to false predicate) at index 27305, continuing at 27405
  Morphed node: t69: i32 = TEST64rr t31, t31
ISEL: Match complete!

ISEL: Starting selection on root node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132007
  Match failed at index 132010
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t31: i64,ch = CopyFromReg t0, Register:i64 %4

ISEL: Starting selection on root node: t25: i64,ch = CopyFromReg t0, Register:i64 %3

ISEL: Starting selection on root node: t13: i64,ch = CopyFromReg t0, Register:i64 %19

ISEL: Starting selection on root node: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

ISEL: Starting selection on root node: t73: i64 = Register $rsp

ISEL: Starting selection on root node: t70: i8 = TargetConstant<14>

ISEL: Starting selection on root node: t56: ch = BasicBlock<.lr.ph99.preheader 0x7fee59053ed0>

ISEL: Starting selection on root node: t54: ch = BasicBlock<._crit_edge100 0x7fee5905b600>

ISEL: Starting selection on root node: t47: i64 = Register %22

ISEL: Starting selection on root node: t45: i64 = Register $rax

ISEL: Starting selection on root node: t42: Untyped = RegisterMask

ISEL: Starting selection on root node: t40: i64 = Register $rdi

ISEL: Starting selection on root node: t38: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t35: i64 = Register %21

ISEL: Starting selection on root node: t30: i64 = Register %4

ISEL: Starting selection on root node: t24: i64 = Register %3

ISEL: Starting selection on root node: t12: i64 = Register %19

ISEL: Starting selection on root node: t10: i64 = Register %20

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.8 'main:._crit_edge97'
SelectionDAG has 59 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %19
  t31: i64,ch = CopyFromReg t0, Register:i64 %4
  t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
    t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
  t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp
  t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
        t15: ch = MOV64mr<Mem:(store (s64) into %ir.31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1
        t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack36)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1
        t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack38)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1
          t25: i64,ch = CopyFromReg t0, Register:i64 %3
        t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1
        t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack42)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
  t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34
    t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
  t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
  t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2
      t11: ch = CopyToReg t0, Register:i64 %20, t82
      t36: ch = CopyToReg t0, Register:i64 %21, t34
      t48: ch = CopyToReg t0, Register:i64 %22, t46
    t53: ch = TokenFactor t11, t36, t48, t46:1
    t69: i32 = TEST64rr t31, t31
  t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  t103: i32 = Register $noreg
    t71: ch = JCC_1 BasicBlock:ch<._crit_edge100 0x7fee5905b600>, TargetConstant:i8<14>, t92, t92:1
  t57: ch = JMP_1 BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>, t71


********** List Scheduling %bb.8 '._crit_edge97' **********
SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>, t71

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge100 0x7fee5905b600>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(4): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t69: i32 = TEST64rr t31, t31

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %4

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(6): Data Latency=1
SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(24): Ord  Latency=1 Barrier
    SU(23): Ord  Latency=1 Barrier
    SU(22): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(21): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(22): Data Latency=1
SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(5): Data Latency=1
    SU(23): Data Latency=1
SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(8): Ord  Latency=0 Barrier
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(20): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(9): Ord  Latency=1 Barrier
  Successors:
    SU(7): Ord  Latency=0 Barrier
SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack42)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

  # preds left       : 1
  # succs left       : 5
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(11): Ord  Latency=1 Barrier
  Successors:
    SU(9): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(20): Ord  Latency=1 Barrier
SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 7
  Predecessors:
    SU(13): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
  Successors:
    SU(10): Ord  Latency=1 Barrier
SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(13): Data Latency=1
  Successors:
    SU(11): Data Latency=1
    SU(24): Data Latency=1
SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

  # preds left       : 1
  # succs left       : 7
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 9
  Predecessors:
    SU(14): Ord  Latency=1 Barrier
  Successors:
    SU(9): Data Latency=1
    SU(11): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
    SU(15): Data Latency=1
    SU(17): Data Latency=1
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(13): Ord  Latency=1 Barrier
SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(16): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %3

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(15): Data Latency=1
SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack38)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack36)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %19

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(22): t48: ch = CopyToReg t0, Register:i64 %22, t46

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(23): t36: ch = CopyToReg t0, Register:i64 %21, t34

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>, t71


*** Scheduling [0]: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>, t71


Examining Available:
Height 1: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge100 0x7fee5905b600>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


*** Scheduling [1]: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge100 0x7fee5905b600>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


Examining Available:
Height 1: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

Height 2: SU(2): t69: i32 = TEST64rr t31, t31


*** Scheduling [2]: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1


Examining Available:
Height 2: SU(2): t69: i32 = TEST64rr t31, t31

Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %22, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %21, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


*** Scheduling [3]: SU(2): t69: i32 = TEST64rr t31, t31


Examining Available:
Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %22, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %21, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


*** Scheduling [4]: SU(22): t48: ch = CopyToReg t0, Register:i64 %22, t46


Examining Available:
Height 5: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %21, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


*** Scheduling [5]: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1


Examining Available:
Height 6: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %21, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


*** Scheduling [6]: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0


Examining Available:
Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %21, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


*** Scheduling [7]: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64


Examining Available:
Height 7: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %21, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


*** Scheduling [8]: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63


Examining Available:
Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %21, t34

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack42)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack38)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack36)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


*** Scheduling [9]: SU(23): t36: ch = CopyToReg t0, Register:i64 %21, t34


Examining Available:
Height 10: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack42)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack38)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack36)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


*** Scheduling [10]: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>


Examining Available:
Height 11: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %4

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack42)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack38)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack36)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


*** Scheduling [11]: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %4


Examining Available:
Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack42)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack38)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack36)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


*** Scheduling [12]: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack42)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1


Examining Available:
Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack38)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack36)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


*** Scheduling [13]: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1


Examining Available:
Height 14: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %3

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack38)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack36)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


*** Scheduling [14]: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %3


Examining Available:
Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack38)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack36)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


*** Scheduling [15]: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack38)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1


Examining Available:
Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack36)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


*** Scheduling [16]: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack36)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


*** Scheduling [17]: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 18: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %19

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [18]: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %19


Examining Available:
Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [19]: SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82


Examining Available:
Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [20]: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


Examining Available:
Height 21: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


*** Scheduling [21]: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


Examining Available:
Height 22: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


*** Scheduling [22]: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


Examining Available:
Height 23: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


*** Scheduling [23]: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


Examining Available:
Height 24: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [24]: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

SU(24): t11: ch = CopyToReg t0, Register:i64 %20, t82

SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %19

SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.31)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack36)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack38)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %3

SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack42)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %4

SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

SU(23): t36: ch = CopyToReg t0, Register:i64 %21, t34

SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

SU(22): t48: ch = CopyToReg t0, Register:i64 %22, t46

SU(2): t69: i32 = TEST64rr t31, t31

SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge100 0x7fee5905b600>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph99.preheader 0x7fee59053ed0>, t71


Total amount of phi nodes to update: 0
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %22
Creating constant: t3: i8 = Constant<0>
Creating new node: t5: i64,ch = CopyFromReg t0, Register:i64 %21
Creating constant: t7: i64 = TargetConstant<0>
Creating new node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Creating new node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Creating new node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Creating new node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Initial selection DAG: %bb.9 'main:.lr.ph99.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t3: i8 = Constant<0>
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %22
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %21
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Combining: t13: Untyped = RegisterMask

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Combining: t11: i64 = Register $rsi

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Combining: t9: i64 = Register $rdi

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t7: i64 = TargetConstant<0>

Combining: t6: i64 = ExternalSymbol'__bzero'

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %21

Combining: t4: i64 = Register %21

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %22

Combining: t1: i64 = Register %22

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.9 'main:.lr.ph99.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %22
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %21
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


Legalizing node: t13: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t13: Untyped = RegisterMask

Legalizing node: t11: i64 = Register $rsi
Ignoring node results
Legally typed node: t11: i64 = Register $rsi

Legalizing node: t9: i64 = Register $rdi
Ignoring node results
Legally typed node: t9: i64 = Register $rdi

Legalizing node: t7: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t7: i64 = TargetConstant<0>

Legalizing node: t6: i64 = ExternalSymbol'__bzero'
Analyzing result type: i64
Legal result type
Legally typed node: t6: i64 = ExternalSymbol'__bzero'

Legalizing node: t4: i64 = Register %21
Ignoring node results
Legally typed node: t4: i64 = Register %21

Legalizing node: t1: i64 = Register %22
Ignoring node results
Legally typed node: t1: i64 = Register %22

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %22
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %22

Legalizing node: t5: i64,ch = CopyFromReg t0, Register:i64 %21
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t5: i64,ch = CopyFromReg t0, Register:i64 %21

Legalizing node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %22
Legal operand
Legally typed node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Analyzing operand: t5: i64,ch = CopyFromReg t0, Register:i64 %21
Legal operand
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Legally typed node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Analyzing operand: t6: i64 = ExternalSymbol'__bzero'
Legal operand
Analyzing operand: t13: Untyped = RegisterMask
Legal operand
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Legally typed node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Legally typed node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.9 'main:.lr.ph99.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %22
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %21
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %21
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %22
Legal node: nothing to do

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Legalizing: t6: i64 = ExternalSymbol'__bzero'
Trying custom legalization
Creating new node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Successfully custom legalized node
 ... replacing: t6: i64 = ExternalSymbol'__bzero'
     with:      t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t4: i64 = Register %21

Legalizing: t1: i64 = Register %22

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do
Legalized selection DAG: %bb.9 'main:.lr.ph99.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %22
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %21
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Combining: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do

Combining: t16: i64 = TargetExternalSymbol'__bzero'

Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Combining: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %21
Legal node: nothing to do

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %21

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %22
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %22

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Combining: t13: Untyped = RegisterMask

Legalizing: t11: i64 = Register $rsi

Combining: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Combining: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Combining: t7: i64 = TargetConstant<0>

Legalizing: t4: i64 = Register %21

Combining: t4: i64 = Register %21

Legalizing: t1: i64 = Register %22

Combining: t1: i64 = Register %22

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.9 'main:.lr.ph99.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %22
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %21
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


===== Instruction selection begins: %bb.9 '.lr.ph99.preheader'

ISEL: Starting selection on root node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

ISEL: Starting selection on root node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

ISEL: Starting selection on root node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132022
  Match failed at index 132025
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t18: i32 = TargetConstant<0>
  Morphed node: t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i64,ch = CopyFromReg t0, Register:i64 %21

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %22

ISEL: Starting selection on root node: t16: i64 = TargetExternalSymbol'__bzero'

ISEL: Starting selection on root node: t13: Untyped = RegisterMask

ISEL: Starting selection on root node: t11: i64 = Register $rsi

ISEL: Starting selection on root node: t9: i64 = Register $rdi

ISEL: Starting selection on root node: t7: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t4: i64 = Register %21

ISEL: Starting selection on root node: t1: i64 = Register %22

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.9 'main:.lr.ph99.preheader'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
    t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t2: i64,ch = CopyFromReg t0, Register:i64 %22
  t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %21
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
  t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1


********** List Scheduling %bb.9 '.lr.ph99.preheader' **********
SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1

  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Data Latency=1
    SU(1): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %21

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %22

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1

Examining Available:
Height 0: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


*** Scheduling [0]: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Examining Available:
Height 1: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %21

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %22

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [1]: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'


Examining Available:
Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %21

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %22

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [2]: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %21


Examining Available:
Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %22

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [3]: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %22


Examining Available:
Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [4]: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %22

SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %21

SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<1>
Creating constant: t2: i64 = Constant<1>
Creating constant: t3: i64 = Constant<40>
Creating constant: t4: i64 = Constant<15>
Creating constant: t5: i64 = Constant<55>
Creating constant: t6: i64 = Constant<-16>
Creating constant: t7: i64 = Constant<48>
Creating constant: t8: i64 = Constant<0>
Creating new node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Creating new node: t11: ch = CopyToReg t0, Register:i64 %23, t9
Creating new node: t13: i64,ch = CopyFromReg t0, Register:i64 %22
Creating new node: t14: i64 = undef
Creating new node: t15: ch = store<(store (s64) into %ir.34)> t9:1, t13, t9, undef:i64
Creating constant: t16: i64 = Constant<8>
Creating new node: t17: i64 = add nuw t9, Constant:i64<8>
Creating new node: t18: ch = store<(store (s64) into %ir..repack45)> t15, t13, t17, undef:i64
Creating constant: t19: i64 = Constant<16>
Creating new node: t20: i64 = add nuw t9, Constant:i64<16>
Creating new node: t21: ch = store<(store (s64) into %ir..repack47)> t18, Constant:i64<0>, t20, undef:i64
Creating constant: t22: i64 = Constant<24>
Creating new node: t23: i64 = add nuw t9, Constant:i64<24>
Creating new node: t25: i64,ch = CopyFromReg t0, Register:i64 %4
Creating new node: t26: ch = store<(store (s64) into %ir..repack49)> t21, t25, t23, undef:i64
Creating constant: t27: i64 = Constant<32>
Creating new node: t28: i64 = add nuw t9, Constant:i64<32>
Creating new node: t29: ch = store<(store (s64) into %ir..repack51)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t31: i64,ch = CopyFromReg t0, Register:i64 %5
Creating constant: t32: i64 = Constant<3>
Creating constant: t33: i8 = Constant<3>
Creating new node: t34: i64 = shl t31, Constant:i8<3>
Creating new node: t36: ch = CopyToReg t0, Register:i64 %24, t34
Creating constant: t38: i64 = TargetConstant<0>
Creating new node: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Creating new node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Creating new node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Creating new node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Creating new node: t48: ch = CopyToReg t0, Register:i64 %25, t46
Creating new node: t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
Creating constant: t51: i1 = Constant<-1>
Creating new node: t52: i1 = xor t50, Constant:i1<-1>
Creating new node: t53: ch = TokenFactor t11, t36, t48, t46:1
Creating new node: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge103 0x7fee5905b800>
Creating new node: t57: ch = br t55, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>
Initial selection DAG: %bb.10 'main:._crit_edge100'
SelectionDAG has 58 nodes:
  t0: ch,glue = EntryToken
  t1: i32 = Constant<1>
  t3: i64 = Constant<40>
  t4: i64 = Constant<15>
  t5: i64 = Constant<55>
  t6: i64 = Constant<-16>
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %22
  t31: i64,ch = CopyFromReg t0, Register:i64 %5
  t32: i64 = Constant<3>
  t34: i64 = shl t31, Constant:i8<3>
              t15: ch = store<(store (s64) into %ir.34)> t9:1, t13, t9, undef:i64
              t17: i64 = add nuw t9, Constant:i64<8>
            t18: ch = store<(store (s64) into %ir..repack45)> t15, t13, t17, undef:i64
            t20: i64 = add nuw t9, Constant:i64<16>
          t21: ch = store<(store (s64) into %ir..repack47)> t18, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %4
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack49)> t21, t25, t23, undef:i64
        t28: i64 = add nuw t9, Constant:i64<32>
      t29: ch = store<(store (s64) into %ir..repack51)> t26, Constant:i64<1>, t28, undef:i64
    t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %23, t9
        t36: ch = CopyToReg t0, Register:i64 %24, t34
        t48: ch = CopyToReg t0, Register:i64 %25, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
      t52: i1 = xor t50, Constant:i1<-1>
    t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge103 0x7fee5905b800>
  t57: ch = br t55, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>



Combining: t57: ch = br t55, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>

Combining: t56: ch = BasicBlock<.lr.ph102.preheader 0x7fee5905b700>

Combining: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge103 0x7fee5905b800>
Creating new node: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge103 0x7fee5905b800>
 ... into: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge103 0x7fee5905b800>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>

Combining: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge103 0x7fee5905b800>

Combining: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
 ... into: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge103 0x7fee5905b800>

Combining: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t61: ch = setlt

Combining: t54: ch = BasicBlock<._crit_edge103 0x7fee5905b800>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %25, t46

Combining: t47: i64 = Register %25

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %24, t34

Combining: t35: i64 = Register %24

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %5

Combining: t30: i64 = Register %5

Combining: t29: ch = store<(store (s64) into %ir..repack51)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t63: ch = store<(store (s64) into %ir..repack51)> t9:1, Constant:i64<1>, t28, undef:i64
Creating new node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Replacing.1 t29: ch = store<(store (s64) into %ir..repack51)> t26, Constant:i64<1>, t28, undef:i64

With: t64: ch = TokenFactor t15, t18, t21, t26, t63
 and 0 other values

Combining: t63: ch = store<(store (s64) into %ir..repack51)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack49)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %4

Combining: t24: i64 = Register %4

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack47)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack45)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.34)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %22

Combining: t12: i64 = Register %22

Combining: t11: ch = CopyToReg t0, Register:i64 %23, t9

Combining: t10: i64 = Register %23

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.10 'main:._crit_edge100'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %22
  t31: i64,ch = CopyFromReg t0, Register:i64 %5
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.34)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack45)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack47)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %4
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack49)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack51)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %23, t9
        t36: ch = CopyToReg t0, Register:i64 %24, t34
        t48: ch = CopyToReg t0, Register:i64 %25, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge103 0x7fee5905b800>
  t57: ch = br t60, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>


Legalizing node: t61: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t61: ch = setlt

Legalizing node: t56: ch = BasicBlock<.lr.ph102.preheader 0x7fee5905b700>
Analyzing result type: ch
Legal result type
Legally typed node: t56: ch = BasicBlock<.lr.ph102.preheader 0x7fee5905b700>

Legalizing node: t54: ch = BasicBlock<._crit_edge103 0x7fee5905b800>
Analyzing result type: ch
Legal result type
Legally typed node: t54: ch = BasicBlock<._crit_edge103 0x7fee5905b800>

Legalizing node: t47: i64 = Register %25
Ignoring node results
Legally typed node: t47: i64 = Register %25

Legalizing node: t45: i64 = Register $rax
Ignoring node results
Legally typed node: t45: i64 = Register $rax

Legalizing node: t42: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t42: Untyped = RegisterMask

Legalizing node: t40: i64 = Register $rdi
Ignoring node results
Legally typed node: t40: i64 = Register $rdi

Legalizing node: t38: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t38: i64 = TargetConstant<0>

Legalizing node: t37: i64 = GlobalAddress<ptr @malloc> 0
Analyzing result type: i64
Legal result type
Legally typed node: t37: i64 = GlobalAddress<ptr @malloc> 0

Legalizing node: t35: i64 = Register %24
Ignoring node results
Legally typed node: t35: i64 = Register %24

Legalizing node: t33: i8 = Constant<3>
Analyzing result type: i8
Legal result type
Legally typed node: t33: i8 = Constant<3>

Legalizing node: t30: i64 = Register %5
Ignoring node results
Legally typed node: t30: i64 = Register %5

Legalizing node: t27: i64 = Constant<32>
Analyzing result type: i64
Legal result type
Legally typed node: t27: i64 = Constant<32>

Legalizing node: t24: i64 = Register %4
Ignoring node results
Legally typed node: t24: i64 = Register %4

Legalizing node: t22: i64 = Constant<24>
Analyzing result type: i64
Legal result type
Legally typed node: t22: i64 = Constant<24>

Legalizing node: t19: i64 = Constant<16>
Analyzing result type: i64
Legal result type
Legally typed node: t19: i64 = Constant<16>

Legalizing node: t16: i64 = Constant<8>
Analyzing result type: i64
Legal result type
Legally typed node: t16: i64 = Constant<8>

Legalizing node: t14: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t14: i64 = undef

Legalizing node: t12: i64 = Register %22
Ignoring node results
Legally typed node: t12: i64 = Register %22

Legalizing node: t10: i64 = Register %23
Ignoring node results
Legally typed node: t10: i64 = Register %23

Legalizing node: t8: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t8: i64 = Constant<0>

Legalizing node: t7: i64 = Constant<48>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<48>

Legalizing node: t2: i64 = Constant<1>
Analyzing result type: i64
Legal result type
Legally typed node: t2: i64 = Constant<1>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t7: i64 = Constant<48>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Legally typed node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Legalizing node: t11: ch = CopyToReg t0, Register:i64 %23, t9
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Legally typed node: t11: ch = CopyToReg t0, Register:i64 %23, t9

Legalizing node: t17: i64 = add nuw t9, Constant:i64<8>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t16: i64 = Constant<8>
Legal operand
Legally typed node: t17: i64 = add nuw t9, Constant:i64<8>

Legalizing node: t20: i64 = add nuw t9, Constant:i64<16>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t19: i64 = Constant<16>
Legal operand
Legally typed node: t20: i64 = add nuw t9, Constant:i64<16>

Legalizing node: t21: ch = store<(store (s64) into %ir..repack47)> t9:1, Constant:i64<0>, t20, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Analyzing operand: t20: i64 = add nuw t9, Constant:i64<16>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t21: ch = store<(store (s64) into %ir..repack47)> t9:1, Constant:i64<0>, t20, undef:i64

Legalizing node: t23: i64 = add nuw t9, Constant:i64<24>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t22: i64 = Constant<24>
Legal operand
Legally typed node: t23: i64 = add nuw t9, Constant:i64<24>

Legalizing node: t28: i64 = add nuw t9, Constant:i64<32>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t27: i64 = Constant<32>
Legal operand
Legally typed node: t28: i64 = add nuw t9, Constant:i64<32>

Legalizing node: t63: ch = store<(store (s64) into %ir..repack51)> t9:1, Constant:i64<1>, t28, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t28: i64 = add nuw t9, Constant:i64<32>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t63: ch = store<(store (s64) into %ir..repack51)> t9:1, Constant:i64<1>, t28, undef:i64

Legalizing node: t13: i64,ch = CopyFromReg t0, Register:i64 %22
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t13: i64,ch = CopyFromReg t0, Register:i64 %22

Legalizing node: t15: ch = store<(store (s64) into %ir.34)> t9:1, t13, t9, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %22
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t15: ch = store<(store (s64) into %ir.34)> t9:1, t13, t9, undef:i64

Legalizing node: t18: ch = store<(store (s64) into %ir..repack45)> t9:1, t13, t17, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %22
Legal operand
Analyzing operand: t17: i64 = add nuw t9, Constant:i64<8>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t18: ch = store<(store (s64) into %ir..repack45)> t9:1, t13, t17, undef:i64

Legalizing node: t25: i64,ch = CopyFromReg t0, Register:i64 %4
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t25: i64,ch = CopyFromReg t0, Register:i64 %4

Legalizing node: t26: ch = store<(store (s64) into %ir..repack49)> t9:1, t25, t23, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t25: i64,ch = CopyFromReg t0, Register:i64 %4
Legal operand
Analyzing operand: t23: i64 = add nuw t9, Constant:i64<24>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t26: ch = store<(store (s64) into %ir..repack49)> t9:1, t25, t23, undef:i64

Legalizing node: t64: ch = TokenFactor t15, t18, t21, t26, t63
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = store<(store (s64) into %ir.34)> t9:1, t13, t9, undef:i64
Legal operand
Analyzing operand: t18: ch = store<(store (s64) into %ir..repack45)> t9:1, t13, t17, undef:i64
Legal operand
Analyzing operand: t21: ch = store<(store (s64) into %ir..repack47)> t9:1, Constant:i64<0>, t20, undef:i64
Legal operand
Analyzing operand: t26: ch = store<(store (s64) into %ir..repack49)> t9:1, t25, t23, undef:i64
Legal operand
Analyzing operand: t63: ch = store<(store (s64) into %ir..repack51)> t9:1, Constant:i64<1>, t28, undef:i64
Legal operand
Legally typed node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal operand
Legally typed node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t31: i64,ch = CopyFromReg t0, Register:i64 %5
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t31: i64,ch = CopyFromReg t0, Register:i64 %5

Legalizing node: t34: i64 = shl t31, Constant:i8<3>
Analyzing result type: i64
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %5
Legal operand
Analyzing operand: t33: i8 = Constant<3>
Legal operand
Legally typed node: t34: i64 = shl t31, Constant:i8<3>

Legalizing node: t36: ch = CopyToReg t0, Register:i64 %24, t34
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t36: ch = CopyToReg t0, Register:i64 %24, t34

Legalizing node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Analyzing operand: t37: i64 = GlobalAddress<ptr @malloc> 0
Legal operand
Analyzing operand: t42: Untyped = RegisterMask
Legal operand
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Legally typed node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Legally typed node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Legally typed node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing node: t48: ch = CopyToReg t0, Register:i64 %25, t46
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t48: ch = CopyToReg t0, Register:i64 %25, t46

Legalizing node: t53: ch = TokenFactor t11, t36, t48, t46:1
Analyzing result type: ch
Legal result type
Analyzing operand: t11: ch = CopyToReg t0, Register:i64 %23, t9
Legal operand
Analyzing operand: t36: ch = CopyToReg t0, Register:i64 %24, t34
Legal operand
Analyzing operand: t48: ch = CopyToReg t0, Register:i64 %25, t46
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i1
Promote integer result: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Creating new node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legalizing node: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge103 0x7fee5905b800>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge103 0x7fee5905b800>

Creating new node: t66: i8 = zero_extend t62
Legalizing node: t66: i8 = zero_extend t62
Analyzing result type: i8
Legal result type
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t66: i8 = zero_extend t62

Creating constant: t67: i8 = Constant<1>
Creating new node: t68: i8 = and t65, Constant:i8<1>
Replacing: t66: i8 = zero_extend t62
     with: t68: i8 = and t65, Constant:i8<1>
Legalizing node: t67: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t67: i8 = Constant<1>

Legalizing node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %5
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t61: ch = setlt
Legal operand
Legally typed node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Legalizing node: t68: i8 = and t65, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legal operand
Analyzing operand: t67: i8 = Constant<1>
Legal operand
Legally typed node: t68: i8 = and t65, Constant:i8<1>

Legalizing node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge103 0x7fee5905b800>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t68: i8 = and t65, Constant:i8<1>
Legal operand
Analyzing operand: t54: ch = BasicBlock<._crit_edge103 0x7fee5905b800>
Legal operand
Legally typed node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge103 0x7fee5905b800>

Legalizing node: t57: ch = br t60, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>
Analyzing result type: ch
Legal result type
Analyzing operand: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge103 0x7fee5905b800>
Legal operand
Analyzing operand: t56: ch = BasicBlock<.lr.ph102.preheader 0x7fee5905b700>
Legal operand
Legally typed node: t57: ch = br t60, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>

Legalizing node: t65535: ch = handlenode t57
Analyzing result type: ch
Legal result type
Analyzing operand: t57: ch = br t60, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>
Legal operand
Legally typed node: t65535: ch = handlenode t57

Type-legalized selection DAG: %bb.10 'main:._crit_edge100'
SelectionDAG has 53 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %22
  t31: i64,ch = CopyFromReg t0, Register:i64 %5
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.34)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack45)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack47)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %4
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack49)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack51)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %23, t9
        t36: ch = CopyToReg t0, Register:i64 %24, t34
        t48: ch = CopyToReg t0, Register:i64 %25, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
      t68: i8 = and t65, Constant:i8<1>
    t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge103 0x7fee5905b800>
  t57: ch = br t60, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>



Combining: t68: i8 = and t65, Constant:i8<1>

Replacing.2 t68: i8 = and t65, Constant:i8<1>

With: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch


Combining: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t63: ch = store<(store (s64) into %ir..repack51)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t61: ch = setlt

Combining: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge103 0x7fee5905b800>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>

Combining: t56: ch = BasicBlock<.lr.ph102.preheader 0x7fee5905b700>

Combining: t54: ch = BasicBlock<._crit_edge103 0x7fee5905b800>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %25, t46

Combining: t47: i64 = Register %25

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %24, t34

Combining: t35: i64 = Register %24

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %5

Combining: t30: i64 = Register %5

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack49)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %4

Combining: t24: i64 = Register %4

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack47)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack45)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.34)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %22

Combining: t12: i64 = Register %22

Combining: t11: ch = CopyToReg t0, Register:i64 %23, t9

Combining: t10: i64 = Register %23

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized type-legalized selection DAG: %bb.10 'main:._crit_edge100'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %22
  t31: i64,ch = CopyFromReg t0, Register:i64 %5
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.34)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack45)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack47)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %4
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack49)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack51)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %23, t9
        t36: ch = CopyToReg t0, Register:i64 %24, t34
        t48: ch = CopyToReg t0, Register:i64 %25, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge103 0x7fee5905b800>
  t57: ch = br t60, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>



Legalizing: t57: ch = br t60, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>
Legal node: nothing to do

Legalizing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge103 0x7fee5905b800>
Trying custom legalization
Creating new node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Creating constant: t70: i8 = TargetConstant<14>
Creating new node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge103 0x7fee5905b800>, TargetConstant:i8<14>, t69
Successfully custom legalized node
 ... replacing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge103 0x7fee5905b800>
     with:      t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge103 0x7fee5905b800>, TargetConstant:i8<14>, t69

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Legalizing: t48: ch = CopyToReg t0, Register:i64 %25, t46
Legal node: nothing to do

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Legalizing: t36: ch = CopyToReg t0, Register:i64 %24, t34
Legal node: nothing to do

Legalizing: t18: ch = store<(store (s64) into %ir..repack45)> t9:1, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t21: ch = store<(store (s64) into %ir..repack47)> t9:1, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t26: ch = store<(store (s64) into %ir..repack49)> t9:1, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t63: ch = store<(store (s64) into %ir..repack51)> t9:1, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Legalizing: t15: ch = store<(store (s64) into %ir.34)> t9:1, t13, t9, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t11: ch = CopyToReg t0, Register:i64 %23, t9
Legal node: nothing to do

Legalizing: t17: i64 = add nuw t9, Constant:i64<8>
Legal node: nothing to do

Legalizing: t20: i64 = add nuw t9, Constant:i64<16>
Legal node: nothing to do

Legalizing: t23: i64 = add nuw t9, Constant:i64<24>
Legal node: nothing to do

Legalizing: t28: i64 = add nuw t9, Constant:i64<32>
Legal node: nothing to do

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %5
Legal node: nothing to do

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %4
Legal node: nothing to do

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %22
Legal node: nothing to do

Legalizing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Trying custom legalization
Creating new node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Creating new node: t75: i64 = sub t74, Constant:i64<48>
Creating new node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Creating new node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t78: i64,ch = merge_values t75, t77
Successfully custom legalized node
 ... replacing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
     with:      t78: i64,ch = merge_values t75, t77
      and:      t78: i64,ch = merge_values t75, t77

Legalizing: t56: ch = BasicBlock<.lr.ph102.preheader 0x7fee5905b700>
Legal node: nothing to do

Legalizing: t54: ch = BasicBlock<._crit_edge103 0x7fee5905b800>
Legal node: nothing to do

Legalizing: t47: i64 = Register %25

Legalizing: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Legalizing: t37: i64 = GlobalAddress<ptr @malloc> 0
Trying custom legalization
Creating new node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Successfully custom legalized node
 ... replacing: t37: i64 = GlobalAddress<ptr @malloc> 0
     with:      t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t35: i64 = Register %24

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Legalizing: t30: i64 = Register %5

Legalizing: t27: i64 = Constant<32>
Legal node: nothing to do

Legalizing: t24: i64 = Register %4

Legalizing: t22: i64 = Constant<24>
Legal node: nothing to do

Legalizing: t19: i64 = Constant<16>
Legal node: nothing to do

Legalizing: t16: i64 = Constant<8>
Legal node: nothing to do

Legalizing: t14: i64 = undef
Legal node: nothing to do

Legalizing: t12: i64 = Register %22

Legalizing: t10: i64 = Register %23

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t7: i64 = Constant<48>
Legal node: nothing to do

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t78: i64,ch = merge_values t75, t77
Trying to expand node
Successfully expanded node
 ... replacing: t78: i64,ch = merge_values t75, t77
     with:      t75: i64 = sub t74, Constant:i64<48>
      and:      t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Legalizing: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge103 0x7fee5905b800>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Legalizing: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do
Legalized selection DAG: %bb.10 'main:._crit_edge100'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %22
  t31: i64,ch = CopyFromReg t0, Register:i64 %5
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.34)> t77, t13, t75, undef:i64
          t17: i64 = add nuw t75, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack45)> t77, t13, t17, undef:i64
          t20: i64 = add nuw t75, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack47)> t77, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %4
          t23: i64 = add nuw t75, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack49)> t77, t25, t23, undef:i64
          t28: i64 = add nuw t75, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack51)> t77, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
  t75: i64 = sub t74, Constant:i64<48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
        t11: ch = CopyToReg t0, Register:i64 %23, t75
        t36: ch = CopyToReg t0, Register:i64 %24, t34
        t48: ch = CopyToReg t0, Register:i64 %25, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge103 0x7fee5905b800>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>



Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Combining: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Combining: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Combining: t75: i64 = sub t74, Constant:i64<48>
Creating constant: t81: i64 = Constant<-48>
Creating new node: t82: i64 = add t74, Constant:i64<-48>
 ... into: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t81: i64 = Constant<-48>
Legal node: nothing to do

Combining: t81: i64 = Constant<-48>

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Combining: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

Legalizing: t73: i64 = Register $rsp

Combining: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge103 0x7fee5905b800>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Combining: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge103 0x7fee5905b800>, TargetConstant:i8<14>, t69

Legalizing: t70: i8 = TargetConstant<14>

Combining: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do

Combining: t69: i32 = X86ISD::CMP t31, Constant:i64<0>

Legalizing: t57: ch = br t71, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>
Legal node: nothing to do

Combining: t57: ch = br t71, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing: t48: ch = CopyToReg t0, Register:i64 %25, t46
Legal node: nothing to do

Combining: t48: ch = CopyToReg t0, Register:i64 %25, t46

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Combining: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing: t36: ch = CopyToReg t0, Register:i64 %24, t34
Legal node: nothing to do

Combining: t36: ch = CopyToReg t0, Register:i64 %24, t34

Legalizing: t18: ch = store<(store (s64) into %ir..repack45)> t77, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack45)> t77, t13, t17, undef:i64

Legalizing: t21: ch = store<(store (s64) into %ir..repack47)> t77, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack47)> t77, Constant:i64<0>, t20, undef:i64

Legalizing: t26: ch = store<(store (s64) into %ir..repack49)> t77, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack49)> t77, t25, t23, undef:i64

Legalizing: t63: ch = store<(store (s64) into %ir..repack51)> t77, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack51)> t77, Constant:i64<1>, t28, undef:i64

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Combining: t34: i64 = shl t31, Constant:i8<3>

Legalizing: t15: ch = store<(store (s64) into %ir.34)> t77, t13, t82, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t15: ch = store<(store (s64) into %ir.34)> t77, t13, t82, undef:i64

Legalizing: t11: ch = CopyToReg t0, Register:i64 %23, t82
Legal node: nothing to do

Combining: t11: ch = CopyToReg t0, Register:i64 %23, t82

Legalizing: t17: i64 = add nuw t82, Constant:i64<8>
Legal node: nothing to do

Combining: t17: i64 = add nuw t82, Constant:i64<8>
Creating constant: t83: i64 = Constant<-40>
Creating new node: t84: i64 = add t74, Constant:i64<-40>
 ... into: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t18: ch = store<(store (s64) into %ir..repack45)> t77, t13, t84, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack45)> t77, t13, t84, undef:i64

Legalizing: t84: i64 = add t74, Constant:i64<-40>
Legal node: nothing to do

Combining: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t83: i64 = Constant<-40>
Legal node: nothing to do

Combining: t83: i64 = Constant<-40>

Legalizing: t20: i64 = add nuw t82, Constant:i64<16>
Legal node: nothing to do

Combining: t20: i64 = add nuw t82, Constant:i64<16>
Creating constant: t85: i64 = Constant<-32>
Creating new node: t86: i64 = add t74, Constant:i64<-32>
 ... into: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t21: ch = store<(store (s64) into %ir..repack47)> t77, Constant:i64<0>, t86, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack47)> t77, Constant:i64<0>, t86, undef:i64

Legalizing: t86: i64 = add t74, Constant:i64<-32>
Legal node: nothing to do

Combining: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t85: i64 = Constant<-32>
Legal node: nothing to do

Combining: t85: i64 = Constant<-32>

Legalizing: t23: i64 = add nuw t82, Constant:i64<24>
Legal node: nothing to do

Combining: t23: i64 = add nuw t82, Constant:i64<24>
Creating constant: t87: i64 = Constant<-24>
Creating new node: t88: i64 = add t74, Constant:i64<-24>
 ... into: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t26: ch = store<(store (s64) into %ir..repack49)> t77, t25, t88, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack49)> t77, t25, t88, undef:i64

Legalizing: t88: i64 = add t74, Constant:i64<-24>
Legal node: nothing to do

Combining: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t87: i64 = Constant<-24>
Legal node: nothing to do

Combining: t87: i64 = Constant<-24>

Legalizing: t28: i64 = add nuw t82, Constant:i64<32>
Legal node: nothing to do

Combining: t28: i64 = add nuw t82, Constant:i64<32>
Creating constant: t89: i64 = Constant<-16>
Creating new node: t90: i64 = add t74, Constant:i64<-16>
 ... into: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t63: ch = store<(store (s64) into %ir..repack51)> t77, Constant:i64<1>, t90, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack51)> t77, Constant:i64<1>, t90, undef:i64

Legalizing: t90: i64 = add t74, Constant:i64<-16>
Legal node: nothing to do

Combining: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t89: i64 = Constant<-16>
Legal node: nothing to do

Combining: t89: i64 = Constant<-16>

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %5
Legal node: nothing to do

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %5

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %4
Legal node: nothing to do

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %4

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %22
Legal node: nothing to do

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %22

Legalizing: t56: ch = BasicBlock<.lr.ph102.preheader 0x7fee5905b700>
Legal node: nothing to do

Combining: t56: ch = BasicBlock<.lr.ph102.preheader 0x7fee5905b700>

Legalizing: t54: ch = BasicBlock<._crit_edge103 0x7fee5905b800>
Legal node: nothing to do

Combining: t54: ch = BasicBlock<._crit_edge103 0x7fee5905b800>

Legalizing: t47: i64 = Register %25

Combining: t47: i64 = Register %25

Legalizing: t45: i64 = Register $rax

Combining: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Combining: t42: Untyped = RegisterMask

Legalizing: t40: i64 = Register $rdi

Combining: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Combining: t38: i64 = TargetConstant<0>

Legalizing: t35: i64 = Register %24

Combining: t35: i64 = Register %24

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Combining: t33: i8 = Constant<3>

Legalizing: t30: i64 = Register %5

Combining: t30: i64 = Register %5

Legalizing: t24: i64 = Register %4

Combining: t24: i64 = Register %4

Legalizing: t14: i64 = undef
Legal node: nothing to do

Combining: t14: i64 = undef

Legalizing: t12: i64 = Register %22

Combining: t12: i64 = Register %22

Legalizing: t10: i64 = Register %23

Combining: t10: i64 = Register %23

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Combining: t8: i64 = Constant<0>

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Combining: t2: i64 = Constant<1>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.10 'main:._crit_edge100'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %22
  t31: i64,ch = CopyFromReg t0, Register:i64 %5
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.34)> t77, t13, t82, undef:i64
          t84: i64 = add t74, Constant:i64<-40>
        t18: ch = store<(store (s64) into %ir..repack45)> t77, t13, t84, undef:i64
          t86: i64 = add t74, Constant:i64<-32>
        t21: ch = store<(store (s64) into %ir..repack47)> t77, Constant:i64<0>, t86, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %4
          t88: i64 = add t74, Constant:i64<-24>
        t26: ch = store<(store (s64) into %ir..repack49)> t77, t25, t88, undef:i64
          t90: i64 = add t74, Constant:i64<-16>
        t63: ch = store<(store (s64) into %ir..repack51)> t77, Constant:i64<1>, t90, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
  t82: i64 = add t74, Constant:i64<-48>
        t11: ch = CopyToReg t0, Register:i64 %23, t82
        t36: ch = CopyToReg t0, Register:i64 %24, t34
        t48: ch = CopyToReg t0, Register:i64 %25, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge103 0x7fee5905b800>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>


===== Instruction selection begins: %bb.10 '._crit_edge100'

ISEL: Starting selection on root node: t57: ch = br t71, BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>
ISEL: Starting pattern match
  Initial Opcode index to 134414
  Morphed node: t57: ch = JMP_1 BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>, t71
ISEL: Match complete!

ISEL: Starting selection on root node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge103 0x7fee5905b800>, TargetConstant:i8<14>, t69
ISEL: Starting pattern match
  Initial Opcode index to 131614
Creating new node: t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  Morphed node: t71: ch = JCC_1 BasicBlock:ch<._crit_edge103 0x7fee5905b800>, TargetConstant:i8<14>, t92, t92:1
ISEL: Match complete!

ISEL: Starting selection on root node: t53: ch = TokenFactor t11, t36, t48, t46:1

ISEL: Starting selection on root node: t48: ch = CopyToReg t0, Register:i64 %25, t46

ISEL: Starting selection on root node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

ISEL: Starting selection on root node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
ISEL: Match complete!

ISEL: Starting selection on root node: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
ISEL: Match complete!

ISEL: Starting selection on root node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

ISEL: Starting selection on root node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t93: i32 = TargetConstant<0>
  Morphed node: t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
ISEL: Match complete!

ISEL: Starting selection on root node: t64: ch = TokenFactor t15, t18, t21, t26, t63

ISEL: Starting selection on root node: t15: ch = store<(store (s64) into %ir.34)> t77, t13, t82, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t94: i8 = TargetConstant<1>
Creating constant: t96: i32 = TargetConstant<-48>
  Morphed node: t15: ch = MOV64mr<Mem:(store (s64) into %ir.34)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch = store<(store (s64) into %ir..repack45)> t77, t13, t84, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t98: i32 = TargetConstant<-40>
  Morphed node: t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack45)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = store<(store (s64) into %ir..repack47)> t77, Constant:i64<0>, t86, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Skipped scope entry (due to false predicate) at index 16132, continuing at 16162
  Skipped scope entry (due to false predicate) at index 16163, continuing at 16193
  Match failed at index 16203
  Continuing at 16224
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t99: i32 = TargetConstant<-32>
  Morphed node: t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack47)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t26: ch = store<(store (s64) into %ir..repack49)> t77, t25, t88, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t100: i32 = TargetConstant<-24>
  Morphed node: t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack49)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t63: ch = store<(store (s64) into %ir..repack51)> t77, Constant:i64<1>, t90, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t101: i32 = TargetConstant<-16>
Creating constant: t102: i64 = TargetConstant<1>
  Morphed node: t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack51)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
ISEL: Match complete!

ISEL: Starting selection on root node: t11: ch = CopyToReg t0, Register:i64 %23, t82

ISEL: Starting selection on root node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

ISEL: Starting selection on root node: t82: i64 = add t74, Constant:i64<-48>
ISEL: Starting pattern match
  Initial Opcode index to 102161
  Match failed at index 102165
  Continuing at 102268
  Match failed at index 102270
  Continuing at 102377
  TypeSwitch[i64] from 102379 to 102420
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 102420
  Continuing at 102435
  Match failed at index 102438
  Continuing at 102459
  Match failed at index 102461
  Continuing at 102483
  Skipped scope entry (due to false predicate) at index 102488, continuing at 102540
  Skipped scope entry (due to false predicate) at index 102541, continuing at 102593
  Skipped scope entry (due to false predicate) at index 102594, continuing at 102644
  Skipped scope entry (due to false predicate) at index 102645, continuing at 102669
  Match failed at index 102683
  Continuing at 102696
  Match failed at index 102700
  Continuing at 102713
Creating constant: t104: i64 = TargetConstant<-48>
  Morphed node: t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
ISEL: Match complete!

ISEL: Starting selection on root node: t36: ch = CopyToReg t0, Register:i64 %24, t34

ISEL: Starting selection on root node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

ISEL: Starting selection on root node: t34: i64 = shl t31, Constant:i8<3>
ISEL: Starting pattern match
  Initial Opcode index to 44725
  Match failed at index 44729
  Continuing at 44944
  TypeSwitch[i64] from 44946 to 44987
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 44987
  Continuing at 45002
  Match failed at index 45009
  Continuing at 45152
  Match failed at index 45153
  Continuing at 45203
  TypeSwitch[i64] from 45215 to 45257
Creating constant: t105: i8 = TargetConstant<3>
  Morphed node: t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 25710
  Match failed at index 25714
  Continuing at 26614
  Skipped scope entry (due to false predicate) at index 26619, continuing at 26650
  Skipped scope entry (due to false predicate) at index 26651, continuing at 26682
  Skipped scope entry (due to false predicate) at index 26683, continuing at 26714
  Match failed at index 26718
  Continuing at 26746
  Continuing at 26747
  Match failed at index 26750
  Continuing at 27134
  Skipped scope entry (due to false predicate) at index 27139, continuing at 27203
  Skipped scope entry (due to false predicate) at index 27204, continuing at 27304
  Skipped scope entry (due to false predicate) at index 27305, continuing at 27405
  Morphed node: t69: i32 = TEST64rr t31, t31
ISEL: Match complete!

ISEL: Starting selection on root node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132007
  Match failed at index 132010
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t31: i64,ch = CopyFromReg t0, Register:i64 %5

ISEL: Starting selection on root node: t25: i64,ch = CopyFromReg t0, Register:i64 %4

ISEL: Starting selection on root node: t13: i64,ch = CopyFromReg t0, Register:i64 %22

ISEL: Starting selection on root node: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

ISEL: Starting selection on root node: t73: i64 = Register $rsp

ISEL: Starting selection on root node: t70: i8 = TargetConstant<14>

ISEL: Starting selection on root node: t56: ch = BasicBlock<.lr.ph102.preheader 0x7fee5905b700>

ISEL: Starting selection on root node: t54: ch = BasicBlock<._crit_edge103 0x7fee5905b800>

ISEL: Starting selection on root node: t47: i64 = Register %25

ISEL: Starting selection on root node: t45: i64 = Register $rax

ISEL: Starting selection on root node: t42: Untyped = RegisterMask

ISEL: Starting selection on root node: t40: i64 = Register $rdi

ISEL: Starting selection on root node: t38: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t35: i64 = Register %24

ISEL: Starting selection on root node: t30: i64 = Register %5

ISEL: Starting selection on root node: t24: i64 = Register %4

ISEL: Starting selection on root node: t12: i64 = Register %22

ISEL: Starting selection on root node: t10: i64 = Register %23

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.10 'main:._crit_edge100'
SelectionDAG has 59 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %22
  t31: i64,ch = CopyFromReg t0, Register:i64 %5
  t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
    t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
  t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp
  t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
        t15: ch = MOV64mr<Mem:(store (s64) into %ir.34)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1
        t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack45)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1
        t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack47)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1
          t25: i64,ch = CopyFromReg t0, Register:i64 %4
        t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack49)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1
        t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack51)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
  t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34
    t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
  t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
  t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2
      t11: ch = CopyToReg t0, Register:i64 %23, t82
      t36: ch = CopyToReg t0, Register:i64 %24, t34
      t48: ch = CopyToReg t0, Register:i64 %25, t46
    t53: ch = TokenFactor t11, t36, t48, t46:1
    t69: i32 = TEST64rr t31, t31
  t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  t103: i32 = Register $noreg
    t71: ch = JCC_1 BasicBlock:ch<._crit_edge103 0x7fee5905b800>, TargetConstant:i8<14>, t92, t92:1
  t57: ch = JMP_1 BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>, t71


********** List Scheduling %bb.10 '._crit_edge100' **********
SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>, t71

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge103 0x7fee5905b800>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(4): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t69: i32 = TEST64rr t31, t31

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %5

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(6): Data Latency=1
SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(24): Ord  Latency=1 Barrier
    SU(23): Ord  Latency=1 Barrier
    SU(22): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(21): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(22): Data Latency=1
SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(5): Data Latency=1
    SU(23): Data Latency=1
SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(8): Ord  Latency=0 Barrier
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(20): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(9): Ord  Latency=1 Barrier
  Successors:
    SU(7): Ord  Latency=0 Barrier
SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack51)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

  # preds left       : 1
  # succs left       : 5
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(11): Ord  Latency=1 Barrier
  Successors:
    SU(9): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(20): Ord  Latency=1 Barrier
SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 7
  Predecessors:
    SU(13): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
  Successors:
    SU(10): Ord  Latency=1 Barrier
SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(13): Data Latency=1
  Successors:
    SU(11): Data Latency=1
    SU(24): Data Latency=1
SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

  # preds left       : 1
  # succs left       : 7
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 9
  Predecessors:
    SU(14): Ord  Latency=1 Barrier
  Successors:
    SU(9): Data Latency=1
    SU(11): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
    SU(15): Data Latency=1
    SU(17): Data Latency=1
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(13): Ord  Latency=1 Barrier
SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack49)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(16): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %4

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(15): Data Latency=1
SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack47)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack45)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %22

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.34)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(22): t48: ch = CopyToReg t0, Register:i64 %25, t46

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(23): t36: ch = CopyToReg t0, Register:i64 %24, t34

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>, t71


*** Scheduling [0]: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>, t71


Examining Available:
Height 1: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge103 0x7fee5905b800>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


*** Scheduling [1]: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge103 0x7fee5905b800>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


Examining Available:
Height 1: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

Height 2: SU(2): t69: i32 = TEST64rr t31, t31


*** Scheduling [2]: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1


Examining Available:
Height 2: SU(2): t69: i32 = TEST64rr t31, t31

Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %25, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %24, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


*** Scheduling [3]: SU(2): t69: i32 = TEST64rr t31, t31


Examining Available:
Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %25, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %24, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


*** Scheduling [4]: SU(22): t48: ch = CopyToReg t0, Register:i64 %25, t46


Examining Available:
Height 5: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %24, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


*** Scheduling [5]: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1


Examining Available:
Height 6: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %24, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


*** Scheduling [6]: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0


Examining Available:
Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %24, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


*** Scheduling [7]: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64


Examining Available:
Height 7: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %24, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


*** Scheduling [8]: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63


Examining Available:
Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %24, t34

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack51)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack49)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack47)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack45)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.34)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


*** Scheduling [9]: SU(23): t36: ch = CopyToReg t0, Register:i64 %24, t34


Examining Available:
Height 10: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack51)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack49)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack47)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack45)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.34)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


*** Scheduling [10]: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>


Examining Available:
Height 11: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %5

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack51)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack49)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack47)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack45)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.34)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


*** Scheduling [11]: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %5


Examining Available:
Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack51)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack49)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack47)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack45)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.34)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


*** Scheduling [12]: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack51)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1


Examining Available:
Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack49)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack47)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack45)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.34)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


*** Scheduling [13]: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack49)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1


Examining Available:
Height 14: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %4

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack47)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack45)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.34)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


*** Scheduling [14]: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %4


Examining Available:
Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack47)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack45)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.34)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


*** Scheduling [15]: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack47)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1


Examining Available:
Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack45)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.34)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


*** Scheduling [16]: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack45)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.34)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


*** Scheduling [17]: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.34)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 18: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %22

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [18]: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %22


Examining Available:
Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [19]: SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82


Examining Available:
Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [20]: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


Examining Available:
Height 21: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


*** Scheduling [21]: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


Examining Available:
Height 22: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


*** Scheduling [22]: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


Examining Available:
Height 23: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


*** Scheduling [23]: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


Examining Available:
Height 24: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [24]: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

SU(24): t11: ch = CopyToReg t0, Register:i64 %23, t82

SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %22

SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.34)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack45)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack47)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %4

SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack49)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack51)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %5

SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

SU(23): t36: ch = CopyToReg t0, Register:i64 %24, t34

SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

SU(22): t48: ch = CopyToReg t0, Register:i64 %25, t46

SU(2): t69: i32 = TEST64rr t31, t31

SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge103 0x7fee5905b800>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph102.preheader 0x7fee5905b700>, t71


Total amount of phi nodes to update: 0
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %25
Creating constant: t3: i8 = Constant<0>
Creating new node: t5: i64,ch = CopyFromReg t0, Register:i64 %24
Creating constant: t7: i64 = TargetConstant<0>
Creating new node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Creating new node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Creating new node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Creating new node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Initial selection DAG: %bb.11 'main:.lr.ph102.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t3: i8 = Constant<0>
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %25
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %24
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Combining: t13: Untyped = RegisterMask

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Combining: t11: i64 = Register $rsi

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Combining: t9: i64 = Register $rdi

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t7: i64 = TargetConstant<0>

Combining: t6: i64 = ExternalSymbol'__bzero'

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %24

Combining: t4: i64 = Register %24

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %25

Combining: t1: i64 = Register %25

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.11 'main:.lr.ph102.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %25
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %24
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


Legalizing node: t13: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t13: Untyped = RegisterMask

Legalizing node: t11: i64 = Register $rsi
Ignoring node results
Legally typed node: t11: i64 = Register $rsi

Legalizing node: t9: i64 = Register $rdi
Ignoring node results
Legally typed node: t9: i64 = Register $rdi

Legalizing node: t7: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t7: i64 = TargetConstant<0>

Legalizing node: t6: i64 = ExternalSymbol'__bzero'
Analyzing result type: i64
Legal result type
Legally typed node: t6: i64 = ExternalSymbol'__bzero'

Legalizing node: t4: i64 = Register %24
Ignoring node results
Legally typed node: t4: i64 = Register %24

Legalizing node: t1: i64 = Register %25
Ignoring node results
Legally typed node: t1: i64 = Register %25

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %25
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %25

Legalizing node: t5: i64,ch = CopyFromReg t0, Register:i64 %24
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t5: i64,ch = CopyFromReg t0, Register:i64 %24

Legalizing node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %25
Legal operand
Legally typed node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Analyzing operand: t5: i64,ch = CopyFromReg t0, Register:i64 %24
Legal operand
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Legally typed node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Analyzing operand: t6: i64 = ExternalSymbol'__bzero'
Legal operand
Analyzing operand: t13: Untyped = RegisterMask
Legal operand
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Legally typed node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Legally typed node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.11 'main:.lr.ph102.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %25
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %24
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %24
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %25
Legal node: nothing to do

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Legalizing: t6: i64 = ExternalSymbol'__bzero'
Trying custom legalization
Creating new node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Successfully custom legalized node
 ... replacing: t6: i64 = ExternalSymbol'__bzero'
     with:      t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t4: i64 = Register %24

Legalizing: t1: i64 = Register %25

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do
Legalized selection DAG: %bb.11 'main:.lr.ph102.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %25
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %24
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Combining: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do

Combining: t16: i64 = TargetExternalSymbol'__bzero'

Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Combining: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %24
Legal node: nothing to do

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %24

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %25
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %25

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Combining: t13: Untyped = RegisterMask

Legalizing: t11: i64 = Register $rsi

Combining: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Combining: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Combining: t7: i64 = TargetConstant<0>

Legalizing: t4: i64 = Register %24

Combining: t4: i64 = Register %24

Legalizing: t1: i64 = Register %25

Combining: t1: i64 = Register %25

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.11 'main:.lr.ph102.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %25
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %24
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


===== Instruction selection begins: %bb.11 '.lr.ph102.preheader'

ISEL: Starting selection on root node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

ISEL: Starting selection on root node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

ISEL: Starting selection on root node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132022
  Match failed at index 132025
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t18: i32 = TargetConstant<0>
  Morphed node: t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i64,ch = CopyFromReg t0, Register:i64 %24

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %25

ISEL: Starting selection on root node: t16: i64 = TargetExternalSymbol'__bzero'

ISEL: Starting selection on root node: t13: Untyped = RegisterMask

ISEL: Starting selection on root node: t11: i64 = Register $rsi

ISEL: Starting selection on root node: t9: i64 = Register $rdi

ISEL: Starting selection on root node: t7: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t4: i64 = Register %24

ISEL: Starting selection on root node: t1: i64 = Register %25

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.11 'main:.lr.ph102.preheader'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
    t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t2: i64,ch = CopyFromReg t0, Register:i64 %25
  t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %24
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
  t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1


********** List Scheduling %bb.11 '.lr.ph102.preheader' **********
SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1

  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Data Latency=1
    SU(1): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %24

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %25

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1

Examining Available:
Height 0: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


*** Scheduling [0]: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Examining Available:
Height 1: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %24

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %25

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [1]: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'


Examining Available:
Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %24

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %25

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [2]: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %24


Examining Available:
Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %25

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [3]: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %25


Examining Available:
Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [4]: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %25

SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %24

SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<1>
Creating constant: t2: i64 = Constant<1>
Creating constant: t3: i64 = Constant<40>
Creating constant: t4: i64 = Constant<15>
Creating constant: t5: i64 = Constant<55>
Creating constant: t6: i64 = Constant<-16>
Creating constant: t7: i64 = Constant<48>
Creating constant: t8: i64 = Constant<0>
Creating new node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Creating new node: t11: ch = CopyToReg t0, Register:i64 %26, t9
Creating new node: t13: i64,ch = CopyFromReg t0, Register:i64 %25
Creating new node: t14: i64 = undef
Creating new node: t15: ch = store<(store (s64) into %ir.37)> t9:1, t13, t9, undef:i64
Creating constant: t16: i64 = Constant<8>
Creating new node: t17: i64 = add nuw t9, Constant:i64<8>
Creating new node: t18: ch = store<(store (s64) into %ir..repack54)> t15, t13, t17, undef:i64
Creating constant: t19: i64 = Constant<16>
Creating new node: t20: i64 = add nuw t9, Constant:i64<16>
Creating new node: t21: ch = store<(store (s64) into %ir..repack56)> t18, Constant:i64<0>, t20, undef:i64
Creating constant: t22: i64 = Constant<24>
Creating new node: t23: i64 = add nuw t9, Constant:i64<24>
Creating new node: t25: i64,ch = CopyFromReg t0, Register:i64 %5
Creating new node: t26: ch = store<(store (s64) into %ir..repack58)> t21, t25, t23, undef:i64
Creating constant: t27: i64 = Constant<32>
Creating new node: t28: i64 = add nuw t9, Constant:i64<32>
Creating new node: t29: ch = store<(store (s64) into %ir..repack60)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t31: i64,ch = CopyFromReg t0, Register:i64 %6
Creating constant: t32: i64 = Constant<3>
Creating constant: t33: i8 = Constant<3>
Creating new node: t34: i64 = shl t31, Constant:i8<3>
Creating new node: t36: ch = CopyToReg t0, Register:i64 %27, t34
Creating constant: t38: i64 = TargetConstant<0>
Creating new node: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Creating new node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Creating new node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Creating new node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Creating new node: t48: ch = CopyToReg t0, Register:i64 %28, t46
Creating new node: t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
Creating constant: t51: i1 = Constant<-1>
Creating new node: t52: i1 = xor t50, Constant:i1<-1>
Creating new node: t53: ch = TokenFactor t11, t36, t48, t46:1
Creating new node: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>
Creating new node: t57: ch = br t55, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>
Initial selection DAG: %bb.12 'main:._crit_edge103'
SelectionDAG has 58 nodes:
  t0: ch,glue = EntryToken
  t1: i32 = Constant<1>
  t3: i64 = Constant<40>
  t4: i64 = Constant<15>
  t5: i64 = Constant<55>
  t6: i64 = Constant<-16>
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %25
  t31: i64,ch = CopyFromReg t0, Register:i64 %6
  t32: i64 = Constant<3>
  t34: i64 = shl t31, Constant:i8<3>
              t15: ch = store<(store (s64) into %ir.37)> t9:1, t13, t9, undef:i64
              t17: i64 = add nuw t9, Constant:i64<8>
            t18: ch = store<(store (s64) into %ir..repack54)> t15, t13, t17, undef:i64
            t20: i64 = add nuw t9, Constant:i64<16>
          t21: ch = store<(store (s64) into %ir..repack56)> t18, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %5
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack58)> t21, t25, t23, undef:i64
        t28: i64 = add nuw t9, Constant:i64<32>
      t29: ch = store<(store (s64) into %ir..repack60)> t26, Constant:i64<1>, t28, undef:i64
    t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %26, t9
        t36: ch = CopyToReg t0, Register:i64 %27, t34
        t48: ch = CopyToReg t0, Register:i64 %28, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
      t52: i1 = xor t50, Constant:i1<-1>
    t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>
  t57: ch = br t55, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>



Combining: t57: ch = br t55, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>

Combining: t56: ch = BasicBlock<.lr.ph105.preheader 0x7fee5905b900>

Combining: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>
Creating new node: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>
 ... into: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>

Combining: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>

Combining: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
 ... into: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>

Combining: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t61: ch = setlt

Combining: t54: ch = BasicBlock<._crit_edge106 0x7fee5905ba00>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %28, t46

Combining: t47: i64 = Register %28

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %27, t34

Combining: t35: i64 = Register %27

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %6

Combining: t30: i64 = Register %6

Combining: t29: ch = store<(store (s64) into %ir..repack60)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t63: ch = store<(store (s64) into %ir..repack60)> t9:1, Constant:i64<1>, t28, undef:i64
Creating new node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Replacing.1 t29: ch = store<(store (s64) into %ir..repack60)> t26, Constant:i64<1>, t28, undef:i64

With: t64: ch = TokenFactor t15, t18, t21, t26, t63
 and 0 other values

Combining: t63: ch = store<(store (s64) into %ir..repack60)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack58)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %5

Combining: t24: i64 = Register %5

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack56)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack54)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.37)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %25

Combining: t12: i64 = Register %25

Combining: t11: ch = CopyToReg t0, Register:i64 %26, t9

Combining: t10: i64 = Register %26

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.12 'main:._crit_edge103'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %25
  t31: i64,ch = CopyFromReg t0, Register:i64 %6
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.37)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack54)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack56)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %5
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack58)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack60)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %26, t9
        t36: ch = CopyToReg t0, Register:i64 %27, t34
        t48: ch = CopyToReg t0, Register:i64 %28, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>
  t57: ch = br t60, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>


Legalizing node: t61: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t61: ch = setlt

Legalizing node: t56: ch = BasicBlock<.lr.ph105.preheader 0x7fee5905b900>
Analyzing result type: ch
Legal result type
Legally typed node: t56: ch = BasicBlock<.lr.ph105.preheader 0x7fee5905b900>

Legalizing node: t54: ch = BasicBlock<._crit_edge106 0x7fee5905ba00>
Analyzing result type: ch
Legal result type
Legally typed node: t54: ch = BasicBlock<._crit_edge106 0x7fee5905ba00>

Legalizing node: t47: i64 = Register %28
Ignoring node results
Legally typed node: t47: i64 = Register %28

Legalizing node: t45: i64 = Register $rax
Ignoring node results
Legally typed node: t45: i64 = Register $rax

Legalizing node: t42: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t42: Untyped = RegisterMask

Legalizing node: t40: i64 = Register $rdi
Ignoring node results
Legally typed node: t40: i64 = Register $rdi

Legalizing node: t38: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t38: i64 = TargetConstant<0>

Legalizing node: t37: i64 = GlobalAddress<ptr @malloc> 0
Analyzing result type: i64
Legal result type
Legally typed node: t37: i64 = GlobalAddress<ptr @malloc> 0

Legalizing node: t35: i64 = Register %27
Ignoring node results
Legally typed node: t35: i64 = Register %27

Legalizing node: t33: i8 = Constant<3>
Analyzing result type: i8
Legal result type
Legally typed node: t33: i8 = Constant<3>

Legalizing node: t30: i64 = Register %6
Ignoring node results
Legally typed node: t30: i64 = Register %6

Legalizing node: t27: i64 = Constant<32>
Analyzing result type: i64
Legal result type
Legally typed node: t27: i64 = Constant<32>

Legalizing node: t24: i64 = Register %5
Ignoring node results
Legally typed node: t24: i64 = Register %5

Legalizing node: t22: i64 = Constant<24>
Analyzing result type: i64
Legal result type
Legally typed node: t22: i64 = Constant<24>

Legalizing node: t19: i64 = Constant<16>
Analyzing result type: i64
Legal result type
Legally typed node: t19: i64 = Constant<16>

Legalizing node: t16: i64 = Constant<8>
Analyzing result type: i64
Legal result type
Legally typed node: t16: i64 = Constant<8>

Legalizing node: t14: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t14: i64 = undef

Legalizing node: t12: i64 = Register %25
Ignoring node results
Legally typed node: t12: i64 = Register %25

Legalizing node: t10: i64 = Register %26
Ignoring node results
Legally typed node: t10: i64 = Register %26

Legalizing node: t8: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t8: i64 = Constant<0>

Legalizing node: t7: i64 = Constant<48>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<48>

Legalizing node: t2: i64 = Constant<1>
Analyzing result type: i64
Legal result type
Legally typed node: t2: i64 = Constant<1>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t7: i64 = Constant<48>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Legally typed node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Legalizing node: t11: ch = CopyToReg t0, Register:i64 %26, t9
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Legally typed node: t11: ch = CopyToReg t0, Register:i64 %26, t9

Legalizing node: t17: i64 = add nuw t9, Constant:i64<8>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t16: i64 = Constant<8>
Legal operand
Legally typed node: t17: i64 = add nuw t9, Constant:i64<8>

Legalizing node: t20: i64 = add nuw t9, Constant:i64<16>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t19: i64 = Constant<16>
Legal operand
Legally typed node: t20: i64 = add nuw t9, Constant:i64<16>

Legalizing node: t21: ch = store<(store (s64) into %ir..repack56)> t9:1, Constant:i64<0>, t20, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Analyzing operand: t20: i64 = add nuw t9, Constant:i64<16>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t21: ch = store<(store (s64) into %ir..repack56)> t9:1, Constant:i64<0>, t20, undef:i64

Legalizing node: t23: i64 = add nuw t9, Constant:i64<24>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t22: i64 = Constant<24>
Legal operand
Legally typed node: t23: i64 = add nuw t9, Constant:i64<24>

Legalizing node: t28: i64 = add nuw t9, Constant:i64<32>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t27: i64 = Constant<32>
Legal operand
Legally typed node: t28: i64 = add nuw t9, Constant:i64<32>

Legalizing node: t63: ch = store<(store (s64) into %ir..repack60)> t9:1, Constant:i64<1>, t28, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t28: i64 = add nuw t9, Constant:i64<32>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t63: ch = store<(store (s64) into %ir..repack60)> t9:1, Constant:i64<1>, t28, undef:i64

Legalizing node: t13: i64,ch = CopyFromReg t0, Register:i64 %25
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t13: i64,ch = CopyFromReg t0, Register:i64 %25

Legalizing node: t15: ch = store<(store (s64) into %ir.37)> t9:1, t13, t9, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %25
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t15: ch = store<(store (s64) into %ir.37)> t9:1, t13, t9, undef:i64

Legalizing node: t18: ch = store<(store (s64) into %ir..repack54)> t9:1, t13, t17, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %25
Legal operand
Analyzing operand: t17: i64 = add nuw t9, Constant:i64<8>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t18: ch = store<(store (s64) into %ir..repack54)> t9:1, t13, t17, undef:i64

Legalizing node: t25: i64,ch = CopyFromReg t0, Register:i64 %5
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t25: i64,ch = CopyFromReg t0, Register:i64 %5

Legalizing node: t26: ch = store<(store (s64) into %ir..repack58)> t9:1, t25, t23, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t25: i64,ch = CopyFromReg t0, Register:i64 %5
Legal operand
Analyzing operand: t23: i64 = add nuw t9, Constant:i64<24>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t26: ch = store<(store (s64) into %ir..repack58)> t9:1, t25, t23, undef:i64

Legalizing node: t64: ch = TokenFactor t15, t18, t21, t26, t63
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = store<(store (s64) into %ir.37)> t9:1, t13, t9, undef:i64
Legal operand
Analyzing operand: t18: ch = store<(store (s64) into %ir..repack54)> t9:1, t13, t17, undef:i64
Legal operand
Analyzing operand: t21: ch = store<(store (s64) into %ir..repack56)> t9:1, Constant:i64<0>, t20, undef:i64
Legal operand
Analyzing operand: t26: ch = store<(store (s64) into %ir..repack58)> t9:1, t25, t23, undef:i64
Legal operand
Analyzing operand: t63: ch = store<(store (s64) into %ir..repack60)> t9:1, Constant:i64<1>, t28, undef:i64
Legal operand
Legally typed node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal operand
Legally typed node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t31: i64,ch = CopyFromReg t0, Register:i64 %6
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t31: i64,ch = CopyFromReg t0, Register:i64 %6

Legalizing node: t34: i64 = shl t31, Constant:i8<3>
Analyzing result type: i64
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %6
Legal operand
Analyzing operand: t33: i8 = Constant<3>
Legal operand
Legally typed node: t34: i64 = shl t31, Constant:i8<3>

Legalizing node: t36: ch = CopyToReg t0, Register:i64 %27, t34
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t36: ch = CopyToReg t0, Register:i64 %27, t34

Legalizing node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Analyzing operand: t37: i64 = GlobalAddress<ptr @malloc> 0
Legal operand
Analyzing operand: t42: Untyped = RegisterMask
Legal operand
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Legally typed node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Legally typed node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Legally typed node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing node: t48: ch = CopyToReg t0, Register:i64 %28, t46
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t48: ch = CopyToReg t0, Register:i64 %28, t46

Legalizing node: t53: ch = TokenFactor t11, t36, t48, t46:1
Analyzing result type: ch
Legal result type
Analyzing operand: t11: ch = CopyToReg t0, Register:i64 %26, t9
Legal operand
Analyzing operand: t36: ch = CopyToReg t0, Register:i64 %27, t34
Legal operand
Analyzing operand: t48: ch = CopyToReg t0, Register:i64 %28, t46
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i1
Promote integer result: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Creating new node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legalizing node: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>

Creating new node: t66: i8 = zero_extend t62
Legalizing node: t66: i8 = zero_extend t62
Analyzing result type: i8
Legal result type
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t66: i8 = zero_extend t62

Creating constant: t67: i8 = Constant<1>
Creating new node: t68: i8 = and t65, Constant:i8<1>
Replacing: t66: i8 = zero_extend t62
     with: t68: i8 = and t65, Constant:i8<1>
Legalizing node: t67: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t67: i8 = Constant<1>

Legalizing node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %6
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t61: ch = setlt
Legal operand
Legally typed node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Legalizing node: t68: i8 = and t65, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legal operand
Analyzing operand: t67: i8 = Constant<1>
Legal operand
Legally typed node: t68: i8 = and t65, Constant:i8<1>

Legalizing node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t68: i8 = and t65, Constant:i8<1>
Legal operand
Analyzing operand: t54: ch = BasicBlock<._crit_edge106 0x7fee5905ba00>
Legal operand
Legally typed node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>

Legalizing node: t57: ch = br t60, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>
Analyzing result type: ch
Legal result type
Analyzing operand: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>
Legal operand
Analyzing operand: t56: ch = BasicBlock<.lr.ph105.preheader 0x7fee5905b900>
Legal operand
Legally typed node: t57: ch = br t60, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>

Legalizing node: t65535: ch = handlenode t57
Analyzing result type: ch
Legal result type
Analyzing operand: t57: ch = br t60, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>
Legal operand
Legally typed node: t65535: ch = handlenode t57

Type-legalized selection DAG: %bb.12 'main:._crit_edge103'
SelectionDAG has 53 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %25
  t31: i64,ch = CopyFromReg t0, Register:i64 %6
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.37)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack54)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack56)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %5
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack58)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack60)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %26, t9
        t36: ch = CopyToReg t0, Register:i64 %27, t34
        t48: ch = CopyToReg t0, Register:i64 %28, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
      t68: i8 = and t65, Constant:i8<1>
    t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>
  t57: ch = br t60, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>



Combining: t68: i8 = and t65, Constant:i8<1>

Replacing.2 t68: i8 = and t65, Constant:i8<1>

With: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch


Combining: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t63: ch = store<(store (s64) into %ir..repack60)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t61: ch = setlt

Combining: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>

Combining: t56: ch = BasicBlock<.lr.ph105.preheader 0x7fee5905b900>

Combining: t54: ch = BasicBlock<._crit_edge106 0x7fee5905ba00>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %28, t46

Combining: t47: i64 = Register %28

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %27, t34

Combining: t35: i64 = Register %27

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %6

Combining: t30: i64 = Register %6

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack58)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %5

Combining: t24: i64 = Register %5

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack56)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack54)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.37)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %25

Combining: t12: i64 = Register %25

Combining: t11: ch = CopyToReg t0, Register:i64 %26, t9

Combining: t10: i64 = Register %26

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized type-legalized selection DAG: %bb.12 'main:._crit_edge103'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %25
  t31: i64,ch = CopyFromReg t0, Register:i64 %6
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.37)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack54)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack56)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %5
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack58)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack60)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %26, t9
        t36: ch = CopyToReg t0, Register:i64 %27, t34
        t48: ch = CopyToReg t0, Register:i64 %28, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>
  t57: ch = br t60, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>



Legalizing: t57: ch = br t60, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>
Legal node: nothing to do

Legalizing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>
Trying custom legalization
Creating new node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Creating constant: t70: i8 = TargetConstant<14>
Creating new node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>, TargetConstant:i8<14>, t69
Successfully custom legalized node
 ... replacing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>
     with:      t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>, TargetConstant:i8<14>, t69

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Legalizing: t48: ch = CopyToReg t0, Register:i64 %28, t46
Legal node: nothing to do

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Legalizing: t36: ch = CopyToReg t0, Register:i64 %27, t34
Legal node: nothing to do

Legalizing: t18: ch = store<(store (s64) into %ir..repack54)> t9:1, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t21: ch = store<(store (s64) into %ir..repack56)> t9:1, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t26: ch = store<(store (s64) into %ir..repack58)> t9:1, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t63: ch = store<(store (s64) into %ir..repack60)> t9:1, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Legalizing: t15: ch = store<(store (s64) into %ir.37)> t9:1, t13, t9, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t11: ch = CopyToReg t0, Register:i64 %26, t9
Legal node: nothing to do

Legalizing: t17: i64 = add nuw t9, Constant:i64<8>
Legal node: nothing to do

Legalizing: t20: i64 = add nuw t9, Constant:i64<16>
Legal node: nothing to do

Legalizing: t23: i64 = add nuw t9, Constant:i64<24>
Legal node: nothing to do

Legalizing: t28: i64 = add nuw t9, Constant:i64<32>
Legal node: nothing to do

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %6
Legal node: nothing to do

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %5
Legal node: nothing to do

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %25
Legal node: nothing to do

Legalizing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Trying custom legalization
Creating new node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Creating new node: t75: i64 = sub t74, Constant:i64<48>
Creating new node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Creating new node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t78: i64,ch = merge_values t75, t77
Successfully custom legalized node
 ... replacing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
     with:      t78: i64,ch = merge_values t75, t77
      and:      t78: i64,ch = merge_values t75, t77

Legalizing: t56: ch = BasicBlock<.lr.ph105.preheader 0x7fee5905b900>
Legal node: nothing to do

Legalizing: t54: ch = BasicBlock<._crit_edge106 0x7fee5905ba00>
Legal node: nothing to do

Legalizing: t47: i64 = Register %28

Legalizing: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Legalizing: t37: i64 = GlobalAddress<ptr @malloc> 0
Trying custom legalization
Creating new node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Successfully custom legalized node
 ... replacing: t37: i64 = GlobalAddress<ptr @malloc> 0
     with:      t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t35: i64 = Register %27

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Legalizing: t30: i64 = Register %6

Legalizing: t27: i64 = Constant<32>
Legal node: nothing to do

Legalizing: t24: i64 = Register %5

Legalizing: t22: i64 = Constant<24>
Legal node: nothing to do

Legalizing: t19: i64 = Constant<16>
Legal node: nothing to do

Legalizing: t16: i64 = Constant<8>
Legal node: nothing to do

Legalizing: t14: i64 = undef
Legal node: nothing to do

Legalizing: t12: i64 = Register %25

Legalizing: t10: i64 = Register %26

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t7: i64 = Constant<48>
Legal node: nothing to do

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t78: i64,ch = merge_values t75, t77
Trying to expand node
Successfully expanded node
 ... replacing: t78: i64,ch = merge_values t75, t77
     with:      t75: i64 = sub t74, Constant:i64<48>
      and:      t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Legalizing: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Legalizing: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do
Legalized selection DAG: %bb.12 'main:._crit_edge103'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %25
  t31: i64,ch = CopyFromReg t0, Register:i64 %6
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.37)> t77, t13, t75, undef:i64
          t17: i64 = add nuw t75, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack54)> t77, t13, t17, undef:i64
          t20: i64 = add nuw t75, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack56)> t77, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %5
          t23: i64 = add nuw t75, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack58)> t77, t25, t23, undef:i64
          t28: i64 = add nuw t75, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack60)> t77, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
  t75: i64 = sub t74, Constant:i64<48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
        t11: ch = CopyToReg t0, Register:i64 %26, t75
        t36: ch = CopyToReg t0, Register:i64 %27, t34
        t48: ch = CopyToReg t0, Register:i64 %28, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>



Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Combining: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Combining: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Combining: t75: i64 = sub t74, Constant:i64<48>
Creating constant: t81: i64 = Constant<-48>
Creating new node: t82: i64 = add t74, Constant:i64<-48>
 ... into: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t81: i64 = Constant<-48>
Legal node: nothing to do

Combining: t81: i64 = Constant<-48>

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Combining: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

Legalizing: t73: i64 = Register $rsp

Combining: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Combining: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>, TargetConstant:i8<14>, t69

Legalizing: t70: i8 = TargetConstant<14>

Combining: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do

Combining: t69: i32 = X86ISD::CMP t31, Constant:i64<0>

Legalizing: t57: ch = br t71, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>
Legal node: nothing to do

Combining: t57: ch = br t71, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing: t48: ch = CopyToReg t0, Register:i64 %28, t46
Legal node: nothing to do

Combining: t48: ch = CopyToReg t0, Register:i64 %28, t46

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Combining: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing: t36: ch = CopyToReg t0, Register:i64 %27, t34
Legal node: nothing to do

Combining: t36: ch = CopyToReg t0, Register:i64 %27, t34

Legalizing: t18: ch = store<(store (s64) into %ir..repack54)> t77, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack54)> t77, t13, t17, undef:i64

Legalizing: t21: ch = store<(store (s64) into %ir..repack56)> t77, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack56)> t77, Constant:i64<0>, t20, undef:i64

Legalizing: t26: ch = store<(store (s64) into %ir..repack58)> t77, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack58)> t77, t25, t23, undef:i64

Legalizing: t63: ch = store<(store (s64) into %ir..repack60)> t77, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack60)> t77, Constant:i64<1>, t28, undef:i64

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Combining: t34: i64 = shl t31, Constant:i8<3>

Legalizing: t15: ch = store<(store (s64) into %ir.37)> t77, t13, t82, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t15: ch = store<(store (s64) into %ir.37)> t77, t13, t82, undef:i64

Legalizing: t11: ch = CopyToReg t0, Register:i64 %26, t82
Legal node: nothing to do

Combining: t11: ch = CopyToReg t0, Register:i64 %26, t82

Legalizing: t17: i64 = add nuw t82, Constant:i64<8>
Legal node: nothing to do

Combining: t17: i64 = add nuw t82, Constant:i64<8>
Creating constant: t83: i64 = Constant<-40>
Creating new node: t84: i64 = add t74, Constant:i64<-40>
 ... into: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t18: ch = store<(store (s64) into %ir..repack54)> t77, t13, t84, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack54)> t77, t13, t84, undef:i64

Legalizing: t84: i64 = add t74, Constant:i64<-40>
Legal node: nothing to do

Combining: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t83: i64 = Constant<-40>
Legal node: nothing to do

Combining: t83: i64 = Constant<-40>

Legalizing: t20: i64 = add nuw t82, Constant:i64<16>
Legal node: nothing to do

Combining: t20: i64 = add nuw t82, Constant:i64<16>
Creating constant: t85: i64 = Constant<-32>
Creating new node: t86: i64 = add t74, Constant:i64<-32>
 ... into: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t21: ch = store<(store (s64) into %ir..repack56)> t77, Constant:i64<0>, t86, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack56)> t77, Constant:i64<0>, t86, undef:i64

Legalizing: t86: i64 = add t74, Constant:i64<-32>
Legal node: nothing to do

Combining: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t85: i64 = Constant<-32>
Legal node: nothing to do

Combining: t85: i64 = Constant<-32>

Legalizing: t23: i64 = add nuw t82, Constant:i64<24>
Legal node: nothing to do

Combining: t23: i64 = add nuw t82, Constant:i64<24>
Creating constant: t87: i64 = Constant<-24>
Creating new node: t88: i64 = add t74, Constant:i64<-24>
 ... into: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t26: ch = store<(store (s64) into %ir..repack58)> t77, t25, t88, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack58)> t77, t25, t88, undef:i64

Legalizing: t88: i64 = add t74, Constant:i64<-24>
Legal node: nothing to do

Combining: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t87: i64 = Constant<-24>
Legal node: nothing to do

Combining: t87: i64 = Constant<-24>

Legalizing: t28: i64 = add nuw t82, Constant:i64<32>
Legal node: nothing to do

Combining: t28: i64 = add nuw t82, Constant:i64<32>
Creating constant: t89: i64 = Constant<-16>
Creating new node: t90: i64 = add t74, Constant:i64<-16>
 ... into: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t63: ch = store<(store (s64) into %ir..repack60)> t77, Constant:i64<1>, t90, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack60)> t77, Constant:i64<1>, t90, undef:i64

Legalizing: t90: i64 = add t74, Constant:i64<-16>
Legal node: nothing to do

Combining: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t89: i64 = Constant<-16>
Legal node: nothing to do

Combining: t89: i64 = Constant<-16>

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %6
Legal node: nothing to do

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %6

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %5
Legal node: nothing to do

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %5

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %25
Legal node: nothing to do

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %25

Legalizing: t56: ch = BasicBlock<.lr.ph105.preheader 0x7fee5905b900>
Legal node: nothing to do

Combining: t56: ch = BasicBlock<.lr.ph105.preheader 0x7fee5905b900>

Legalizing: t54: ch = BasicBlock<._crit_edge106 0x7fee5905ba00>
Legal node: nothing to do

Combining: t54: ch = BasicBlock<._crit_edge106 0x7fee5905ba00>

Legalizing: t47: i64 = Register %28

Combining: t47: i64 = Register %28

Legalizing: t45: i64 = Register $rax

Combining: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Combining: t42: Untyped = RegisterMask

Legalizing: t40: i64 = Register $rdi

Combining: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Combining: t38: i64 = TargetConstant<0>

Legalizing: t35: i64 = Register %27

Combining: t35: i64 = Register %27

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Combining: t33: i8 = Constant<3>

Legalizing: t30: i64 = Register %6

Combining: t30: i64 = Register %6

Legalizing: t24: i64 = Register %5

Combining: t24: i64 = Register %5

Legalizing: t14: i64 = undef
Legal node: nothing to do

Combining: t14: i64 = undef

Legalizing: t12: i64 = Register %25

Combining: t12: i64 = Register %25

Legalizing: t10: i64 = Register %26

Combining: t10: i64 = Register %26

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Combining: t8: i64 = Constant<0>

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Combining: t2: i64 = Constant<1>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.12 'main:._crit_edge103'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %25
  t31: i64,ch = CopyFromReg t0, Register:i64 %6
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.37)> t77, t13, t82, undef:i64
          t84: i64 = add t74, Constant:i64<-40>
        t18: ch = store<(store (s64) into %ir..repack54)> t77, t13, t84, undef:i64
          t86: i64 = add t74, Constant:i64<-32>
        t21: ch = store<(store (s64) into %ir..repack56)> t77, Constant:i64<0>, t86, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %5
          t88: i64 = add t74, Constant:i64<-24>
        t26: ch = store<(store (s64) into %ir..repack58)> t77, t25, t88, undef:i64
          t90: i64 = add t74, Constant:i64<-16>
        t63: ch = store<(store (s64) into %ir..repack60)> t77, Constant:i64<1>, t90, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
  t82: i64 = add t74, Constant:i64<-48>
        t11: ch = CopyToReg t0, Register:i64 %26, t82
        t36: ch = CopyToReg t0, Register:i64 %27, t34
        t48: ch = CopyToReg t0, Register:i64 %28, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>


===== Instruction selection begins: %bb.12 '._crit_edge103'

ISEL: Starting selection on root node: t57: ch = br t71, BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>
ISEL: Starting pattern match
  Initial Opcode index to 134414
  Morphed node: t57: ch = JMP_1 BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>, t71
ISEL: Match complete!

ISEL: Starting selection on root node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge106 0x7fee5905ba00>, TargetConstant:i8<14>, t69
ISEL: Starting pattern match
  Initial Opcode index to 131614
Creating new node: t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  Morphed node: t71: ch = JCC_1 BasicBlock:ch<._crit_edge106 0x7fee5905ba00>, TargetConstant:i8<14>, t92, t92:1
ISEL: Match complete!

ISEL: Starting selection on root node: t53: ch = TokenFactor t11, t36, t48, t46:1

ISEL: Starting selection on root node: t48: ch = CopyToReg t0, Register:i64 %28, t46

ISEL: Starting selection on root node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

ISEL: Starting selection on root node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
ISEL: Match complete!

ISEL: Starting selection on root node: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
ISEL: Match complete!

ISEL: Starting selection on root node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

ISEL: Starting selection on root node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t93: i32 = TargetConstant<0>
  Morphed node: t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
ISEL: Match complete!

ISEL: Starting selection on root node: t64: ch = TokenFactor t15, t18, t21, t26, t63

ISEL: Starting selection on root node: t15: ch = store<(store (s64) into %ir.37)> t77, t13, t82, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t94: i8 = TargetConstant<1>
Creating constant: t96: i32 = TargetConstant<-48>
  Morphed node: t15: ch = MOV64mr<Mem:(store (s64) into %ir.37)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch = store<(store (s64) into %ir..repack54)> t77, t13, t84, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t98: i32 = TargetConstant<-40>
  Morphed node: t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack54)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = store<(store (s64) into %ir..repack56)> t77, Constant:i64<0>, t86, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Skipped scope entry (due to false predicate) at index 16132, continuing at 16162
  Skipped scope entry (due to false predicate) at index 16163, continuing at 16193
  Match failed at index 16203
  Continuing at 16224
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t99: i32 = TargetConstant<-32>
  Morphed node: t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack56)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t26: ch = store<(store (s64) into %ir..repack58)> t77, t25, t88, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t100: i32 = TargetConstant<-24>
  Morphed node: t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack58)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t63: ch = store<(store (s64) into %ir..repack60)> t77, Constant:i64<1>, t90, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t101: i32 = TargetConstant<-16>
Creating constant: t102: i64 = TargetConstant<1>
  Morphed node: t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack60)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
ISEL: Match complete!

ISEL: Starting selection on root node: t11: ch = CopyToReg t0, Register:i64 %26, t82

ISEL: Starting selection on root node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

ISEL: Starting selection on root node: t82: i64 = add t74, Constant:i64<-48>
ISEL: Starting pattern match
  Initial Opcode index to 102161
  Match failed at index 102165
  Continuing at 102268
  Match failed at index 102270
  Continuing at 102377
  TypeSwitch[i64] from 102379 to 102420
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 102420
  Continuing at 102435
  Match failed at index 102438
  Continuing at 102459
  Match failed at index 102461
  Continuing at 102483
  Skipped scope entry (due to false predicate) at index 102488, continuing at 102540
  Skipped scope entry (due to false predicate) at index 102541, continuing at 102593
  Skipped scope entry (due to false predicate) at index 102594, continuing at 102644
  Skipped scope entry (due to false predicate) at index 102645, continuing at 102669
  Match failed at index 102683
  Continuing at 102696
  Match failed at index 102700
  Continuing at 102713
Creating constant: t104: i64 = TargetConstant<-48>
  Morphed node: t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
ISEL: Match complete!

ISEL: Starting selection on root node: t36: ch = CopyToReg t0, Register:i64 %27, t34

ISEL: Starting selection on root node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

ISEL: Starting selection on root node: t34: i64 = shl t31, Constant:i8<3>
ISEL: Starting pattern match
  Initial Opcode index to 44725
  Match failed at index 44729
  Continuing at 44944
  TypeSwitch[i64] from 44946 to 44987
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 44987
  Continuing at 45002
  Match failed at index 45009
  Continuing at 45152
  Match failed at index 45153
  Continuing at 45203
  TypeSwitch[i64] from 45215 to 45257
Creating constant: t105: i8 = TargetConstant<3>
  Morphed node: t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 25710
  Match failed at index 25714
  Continuing at 26614
  Skipped scope entry (due to false predicate) at index 26619, continuing at 26650
  Skipped scope entry (due to false predicate) at index 26651, continuing at 26682
  Skipped scope entry (due to false predicate) at index 26683, continuing at 26714
  Match failed at index 26718
  Continuing at 26746
  Continuing at 26747
  Match failed at index 26750
  Continuing at 27134
  Skipped scope entry (due to false predicate) at index 27139, continuing at 27203
  Skipped scope entry (due to false predicate) at index 27204, continuing at 27304
  Skipped scope entry (due to false predicate) at index 27305, continuing at 27405
  Morphed node: t69: i32 = TEST64rr t31, t31
ISEL: Match complete!

ISEL: Starting selection on root node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132007
  Match failed at index 132010
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t31: i64,ch = CopyFromReg t0, Register:i64 %6

ISEL: Starting selection on root node: t25: i64,ch = CopyFromReg t0, Register:i64 %5

ISEL: Starting selection on root node: t13: i64,ch = CopyFromReg t0, Register:i64 %25

ISEL: Starting selection on root node: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

ISEL: Starting selection on root node: t73: i64 = Register $rsp

ISEL: Starting selection on root node: t70: i8 = TargetConstant<14>

ISEL: Starting selection on root node: t56: ch = BasicBlock<.lr.ph105.preheader 0x7fee5905b900>

ISEL: Starting selection on root node: t54: ch = BasicBlock<._crit_edge106 0x7fee5905ba00>

ISEL: Starting selection on root node: t47: i64 = Register %28

ISEL: Starting selection on root node: t45: i64 = Register $rax

ISEL: Starting selection on root node: t42: Untyped = RegisterMask

ISEL: Starting selection on root node: t40: i64 = Register $rdi

ISEL: Starting selection on root node: t38: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t35: i64 = Register %27

ISEL: Starting selection on root node: t30: i64 = Register %6

ISEL: Starting selection on root node: t24: i64 = Register %5

ISEL: Starting selection on root node: t12: i64 = Register %25

ISEL: Starting selection on root node: t10: i64 = Register %26

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.12 'main:._crit_edge103'
SelectionDAG has 59 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %25
  t31: i64,ch = CopyFromReg t0, Register:i64 %6
  t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
    t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
  t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp
  t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
        t15: ch = MOV64mr<Mem:(store (s64) into %ir.37)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1
        t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack54)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1
        t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack56)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1
          t25: i64,ch = CopyFromReg t0, Register:i64 %5
        t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack58)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1
        t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack60)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
  t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34
    t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
  t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
  t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2
      t11: ch = CopyToReg t0, Register:i64 %26, t82
      t36: ch = CopyToReg t0, Register:i64 %27, t34
      t48: ch = CopyToReg t0, Register:i64 %28, t46
    t53: ch = TokenFactor t11, t36, t48, t46:1
    t69: i32 = TEST64rr t31, t31
  t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  t103: i32 = Register $noreg
    t71: ch = JCC_1 BasicBlock:ch<._crit_edge106 0x7fee5905ba00>, TargetConstant:i8<14>, t92, t92:1
  t57: ch = JMP_1 BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>, t71


********** List Scheduling %bb.12 '._crit_edge103' **********
SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>, t71

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge106 0x7fee5905ba00>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(4): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t69: i32 = TEST64rr t31, t31

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %6

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(6): Data Latency=1
SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(24): Ord  Latency=1 Barrier
    SU(23): Ord  Latency=1 Barrier
    SU(22): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(21): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(22): Data Latency=1
SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(5): Data Latency=1
    SU(23): Data Latency=1
SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(8): Ord  Latency=0 Barrier
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(20): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(9): Ord  Latency=1 Barrier
  Successors:
    SU(7): Ord  Latency=0 Barrier
SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack60)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

  # preds left       : 1
  # succs left       : 5
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(11): Ord  Latency=1 Barrier
  Successors:
    SU(9): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(20): Ord  Latency=1 Barrier
SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 7
  Predecessors:
    SU(13): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
  Successors:
    SU(10): Ord  Latency=1 Barrier
SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(13): Data Latency=1
  Successors:
    SU(11): Data Latency=1
    SU(24): Data Latency=1
SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

  # preds left       : 1
  # succs left       : 7
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 9
  Predecessors:
    SU(14): Ord  Latency=1 Barrier
  Successors:
    SU(9): Data Latency=1
    SU(11): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
    SU(15): Data Latency=1
    SU(17): Data Latency=1
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(13): Ord  Latency=1 Barrier
SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack58)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(16): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %5

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(15): Data Latency=1
SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack56)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack54)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %25

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.37)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(22): t48: ch = CopyToReg t0, Register:i64 %28, t46

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(23): t36: ch = CopyToReg t0, Register:i64 %27, t34

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>, t71


*** Scheduling [0]: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>, t71


Examining Available:
Height 1: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge106 0x7fee5905ba00>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


*** Scheduling [1]: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge106 0x7fee5905ba00>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


Examining Available:
Height 1: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

Height 2: SU(2): t69: i32 = TEST64rr t31, t31


*** Scheduling [2]: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1


Examining Available:
Height 2: SU(2): t69: i32 = TEST64rr t31, t31

Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %28, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %27, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


*** Scheduling [3]: SU(2): t69: i32 = TEST64rr t31, t31


Examining Available:
Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %28, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %27, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


*** Scheduling [4]: SU(22): t48: ch = CopyToReg t0, Register:i64 %28, t46


Examining Available:
Height 5: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %27, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


*** Scheduling [5]: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1


Examining Available:
Height 6: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %27, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


*** Scheduling [6]: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0


Examining Available:
Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %27, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


*** Scheduling [7]: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64


Examining Available:
Height 7: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %27, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


*** Scheduling [8]: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63


Examining Available:
Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %27, t34

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack60)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack58)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack56)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack54)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.37)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


*** Scheduling [9]: SU(23): t36: ch = CopyToReg t0, Register:i64 %27, t34


Examining Available:
Height 10: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack60)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack58)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack56)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack54)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.37)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


*** Scheduling [10]: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>


Examining Available:
Height 11: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %6

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack60)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack58)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack56)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack54)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.37)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


*** Scheduling [11]: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %6


Examining Available:
Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack60)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack58)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack56)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack54)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.37)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


*** Scheduling [12]: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack60)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1


Examining Available:
Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack58)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack56)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack54)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.37)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


*** Scheduling [13]: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack58)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1


Examining Available:
Height 14: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %5

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack56)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack54)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.37)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


*** Scheduling [14]: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %5


Examining Available:
Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack56)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack54)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.37)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


*** Scheduling [15]: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack56)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1


Examining Available:
Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack54)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.37)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


*** Scheduling [16]: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack54)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.37)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


*** Scheduling [17]: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.37)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 18: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %25

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [18]: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %25


Examining Available:
Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [19]: SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82


Examining Available:
Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [20]: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


Examining Available:
Height 21: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


*** Scheduling [21]: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


Examining Available:
Height 22: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


*** Scheduling [22]: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


Examining Available:
Height 23: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


*** Scheduling [23]: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


Examining Available:
Height 24: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [24]: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

SU(24): t11: ch = CopyToReg t0, Register:i64 %26, t82

SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %25

SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.37)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack54)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack56)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %5

SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack58)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack60)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %6

SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

SU(23): t36: ch = CopyToReg t0, Register:i64 %27, t34

SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

SU(22): t48: ch = CopyToReg t0, Register:i64 %28, t46

SU(2): t69: i32 = TEST64rr t31, t31

SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge106 0x7fee5905ba00>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph105.preheader 0x7fee5905b900>, t71


Total amount of phi nodes to update: 0
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %28
Creating constant: t3: i8 = Constant<0>
Creating new node: t5: i64,ch = CopyFromReg t0, Register:i64 %27
Creating constant: t7: i64 = TargetConstant<0>
Creating new node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Creating new node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Creating new node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Creating new node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Initial selection DAG: %bb.13 'main:.lr.ph105.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t3: i8 = Constant<0>
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %28
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %27
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Combining: t13: Untyped = RegisterMask

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Combining: t11: i64 = Register $rsi

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Combining: t9: i64 = Register $rdi

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t7: i64 = TargetConstant<0>

Combining: t6: i64 = ExternalSymbol'__bzero'

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %27

Combining: t4: i64 = Register %27

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %28

Combining: t1: i64 = Register %28

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.13 'main:.lr.ph105.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %28
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %27
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


Legalizing node: t13: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t13: Untyped = RegisterMask

Legalizing node: t11: i64 = Register $rsi
Ignoring node results
Legally typed node: t11: i64 = Register $rsi

Legalizing node: t9: i64 = Register $rdi
Ignoring node results
Legally typed node: t9: i64 = Register $rdi

Legalizing node: t7: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t7: i64 = TargetConstant<0>

Legalizing node: t6: i64 = ExternalSymbol'__bzero'
Analyzing result type: i64
Legal result type
Legally typed node: t6: i64 = ExternalSymbol'__bzero'

Legalizing node: t4: i64 = Register %27
Ignoring node results
Legally typed node: t4: i64 = Register %27

Legalizing node: t1: i64 = Register %28
Ignoring node results
Legally typed node: t1: i64 = Register %28

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %28
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %28

Legalizing node: t5: i64,ch = CopyFromReg t0, Register:i64 %27
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t5: i64,ch = CopyFromReg t0, Register:i64 %27

Legalizing node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %28
Legal operand
Legally typed node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Analyzing operand: t5: i64,ch = CopyFromReg t0, Register:i64 %27
Legal operand
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Legally typed node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Analyzing operand: t6: i64 = ExternalSymbol'__bzero'
Legal operand
Analyzing operand: t13: Untyped = RegisterMask
Legal operand
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Legally typed node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Legally typed node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.13 'main:.lr.ph105.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %28
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %27
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %27
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %28
Legal node: nothing to do

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Legalizing: t6: i64 = ExternalSymbol'__bzero'
Trying custom legalization
Creating new node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Successfully custom legalized node
 ... replacing: t6: i64 = ExternalSymbol'__bzero'
     with:      t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t4: i64 = Register %27

Legalizing: t1: i64 = Register %28

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do
Legalized selection DAG: %bb.13 'main:.lr.ph105.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %28
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %27
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Combining: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do

Combining: t16: i64 = TargetExternalSymbol'__bzero'

Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Combining: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %27
Legal node: nothing to do

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %27

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %28
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %28

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Combining: t13: Untyped = RegisterMask

Legalizing: t11: i64 = Register $rsi

Combining: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Combining: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Combining: t7: i64 = TargetConstant<0>

Legalizing: t4: i64 = Register %27

Combining: t4: i64 = Register %27

Legalizing: t1: i64 = Register %28

Combining: t1: i64 = Register %28

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.13 'main:.lr.ph105.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %28
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %27
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


===== Instruction selection begins: %bb.13 '.lr.ph105.preheader'

ISEL: Starting selection on root node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

ISEL: Starting selection on root node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

ISEL: Starting selection on root node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132022
  Match failed at index 132025
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t18: i32 = TargetConstant<0>
  Morphed node: t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i64,ch = CopyFromReg t0, Register:i64 %27

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %28

ISEL: Starting selection on root node: t16: i64 = TargetExternalSymbol'__bzero'

ISEL: Starting selection on root node: t13: Untyped = RegisterMask

ISEL: Starting selection on root node: t11: i64 = Register $rsi

ISEL: Starting selection on root node: t9: i64 = Register $rdi

ISEL: Starting selection on root node: t7: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t4: i64 = Register %27

ISEL: Starting selection on root node: t1: i64 = Register %28

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.13 'main:.lr.ph105.preheader'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
    t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t2: i64,ch = CopyFromReg t0, Register:i64 %28
  t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %27
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
  t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1


********** List Scheduling %bb.13 '.lr.ph105.preheader' **********
SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1

  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Data Latency=1
    SU(1): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %27

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %28

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1

Examining Available:
Height 0: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


*** Scheduling [0]: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Examining Available:
Height 1: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %27

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %28

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [1]: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'


Examining Available:
Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %27

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %28

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [2]: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %27


Examining Available:
Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %28

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [3]: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %28


Examining Available:
Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [4]: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %28

SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %27

SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<1>
Creating constant: t2: i64 = Constant<1>
Creating constant: t3: i64 = Constant<40>
Creating constant: t4: i64 = Constant<15>
Creating constant: t5: i64 = Constant<55>
Creating constant: t6: i64 = Constant<-16>
Creating constant: t7: i64 = Constant<48>
Creating constant: t8: i64 = Constant<0>
Creating new node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Creating new node: t11: ch = CopyToReg t0, Register:i64 %29, t9
Creating new node: t13: i64,ch = CopyFromReg t0, Register:i64 %28
Creating new node: t14: i64 = undef
Creating new node: t15: ch = store<(store (s64) into %ir.40)> t9:1, t13, t9, undef:i64
Creating constant: t16: i64 = Constant<8>
Creating new node: t17: i64 = add nuw t9, Constant:i64<8>
Creating new node: t18: ch = store<(store (s64) into %ir..repack63)> t15, t13, t17, undef:i64
Creating constant: t19: i64 = Constant<16>
Creating new node: t20: i64 = add nuw t9, Constant:i64<16>
Creating new node: t21: ch = store<(store (s64) into %ir..repack65)> t18, Constant:i64<0>, t20, undef:i64
Creating constant: t22: i64 = Constant<24>
Creating new node: t23: i64 = add nuw t9, Constant:i64<24>
Creating new node: t25: i64,ch = CopyFromReg t0, Register:i64 %6
Creating new node: t26: ch = store<(store (s64) into %ir..repack67)> t21, t25, t23, undef:i64
Creating constant: t27: i64 = Constant<32>
Creating new node: t28: i64 = add nuw t9, Constant:i64<32>
Creating new node: t29: ch = store<(store (s64) into %ir..repack69)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t31: i64,ch = CopyFromReg t0, Register:i64 %7
Creating constant: t32: i64 = Constant<3>
Creating constant: t33: i8 = Constant<3>
Creating new node: t34: i64 = shl t31, Constant:i8<3>
Creating new node: t36: ch = CopyToReg t0, Register:i64 %30, t34
Creating constant: t38: i64 = TargetConstant<0>
Creating new node: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Creating new node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Creating new node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Creating new node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Creating new node: t48: ch = CopyToReg t0, Register:i64 %31, t46
Creating new node: t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
Creating constant: t51: i1 = Constant<-1>
Creating new node: t52: i1 = xor t50, Constant:i1<-1>
Creating new node: t53: ch = TokenFactor t11, t36, t48, t46:1
Creating new node: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>
Creating new node: t57: ch = br t55, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>
Initial selection DAG: %bb.14 'main:._crit_edge106'
SelectionDAG has 58 nodes:
  t0: ch,glue = EntryToken
  t1: i32 = Constant<1>
  t3: i64 = Constant<40>
  t4: i64 = Constant<15>
  t5: i64 = Constant<55>
  t6: i64 = Constant<-16>
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %28
  t31: i64,ch = CopyFromReg t0, Register:i64 %7
  t32: i64 = Constant<3>
  t34: i64 = shl t31, Constant:i8<3>
              t15: ch = store<(store (s64) into %ir.40)> t9:1, t13, t9, undef:i64
              t17: i64 = add nuw t9, Constant:i64<8>
            t18: ch = store<(store (s64) into %ir..repack63)> t15, t13, t17, undef:i64
            t20: i64 = add nuw t9, Constant:i64<16>
          t21: ch = store<(store (s64) into %ir..repack65)> t18, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %6
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack67)> t21, t25, t23, undef:i64
        t28: i64 = add nuw t9, Constant:i64<32>
      t29: ch = store<(store (s64) into %ir..repack69)> t26, Constant:i64<1>, t28, undef:i64
    t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %29, t9
        t36: ch = CopyToReg t0, Register:i64 %30, t34
        t48: ch = CopyToReg t0, Register:i64 %31, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
      t52: i1 = xor t50, Constant:i1<-1>
    t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>
  t57: ch = br t55, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>



Combining: t57: ch = br t55, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>

Combining: t56: ch = BasicBlock<.lr.ph108.preheader 0x7fee5905bb00>

Combining: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>
Creating new node: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>
 ... into: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>

Combining: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>

Combining: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
 ... into: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>

Combining: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t61: ch = setlt

Combining: t54: ch = BasicBlock<._crit_edge109 0x7fee5905bc00>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %31, t46

Combining: t47: i64 = Register %31

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %30, t34

Combining: t35: i64 = Register %30

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %7

Combining: t30: i64 = Register %7

Combining: t29: ch = store<(store (s64) into %ir..repack69)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t63: ch = store<(store (s64) into %ir..repack69)> t9:1, Constant:i64<1>, t28, undef:i64
Creating new node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Replacing.1 t29: ch = store<(store (s64) into %ir..repack69)> t26, Constant:i64<1>, t28, undef:i64

With: t64: ch = TokenFactor t15, t18, t21, t26, t63
 and 0 other values

Combining: t63: ch = store<(store (s64) into %ir..repack69)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack67)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %6

Combining: t24: i64 = Register %6

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack65)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack63)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.40)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %28

Combining: t12: i64 = Register %28

Combining: t11: ch = CopyToReg t0, Register:i64 %29, t9

Combining: t10: i64 = Register %29

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.14 'main:._crit_edge106'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %28
  t31: i64,ch = CopyFromReg t0, Register:i64 %7
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.40)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack63)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack65)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %6
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack67)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack69)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %29, t9
        t36: ch = CopyToReg t0, Register:i64 %30, t34
        t48: ch = CopyToReg t0, Register:i64 %31, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>
  t57: ch = br t60, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>


Legalizing node: t61: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t61: ch = setlt

Legalizing node: t56: ch = BasicBlock<.lr.ph108.preheader 0x7fee5905bb00>
Analyzing result type: ch
Legal result type
Legally typed node: t56: ch = BasicBlock<.lr.ph108.preheader 0x7fee5905bb00>

Legalizing node: t54: ch = BasicBlock<._crit_edge109 0x7fee5905bc00>
Analyzing result type: ch
Legal result type
Legally typed node: t54: ch = BasicBlock<._crit_edge109 0x7fee5905bc00>

Legalizing node: t47: i64 = Register %31
Ignoring node results
Legally typed node: t47: i64 = Register %31

Legalizing node: t45: i64 = Register $rax
Ignoring node results
Legally typed node: t45: i64 = Register $rax

Legalizing node: t42: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t42: Untyped = RegisterMask

Legalizing node: t40: i64 = Register $rdi
Ignoring node results
Legally typed node: t40: i64 = Register $rdi

Legalizing node: t38: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t38: i64 = TargetConstant<0>

Legalizing node: t37: i64 = GlobalAddress<ptr @malloc> 0
Analyzing result type: i64
Legal result type
Legally typed node: t37: i64 = GlobalAddress<ptr @malloc> 0

Legalizing node: t35: i64 = Register %30
Ignoring node results
Legally typed node: t35: i64 = Register %30

Legalizing node: t33: i8 = Constant<3>
Analyzing result type: i8
Legal result type
Legally typed node: t33: i8 = Constant<3>

Legalizing node: t30: i64 = Register %7
Ignoring node results
Legally typed node: t30: i64 = Register %7

Legalizing node: t27: i64 = Constant<32>
Analyzing result type: i64
Legal result type
Legally typed node: t27: i64 = Constant<32>

Legalizing node: t24: i64 = Register %6
Ignoring node results
Legally typed node: t24: i64 = Register %6

Legalizing node: t22: i64 = Constant<24>
Analyzing result type: i64
Legal result type
Legally typed node: t22: i64 = Constant<24>

Legalizing node: t19: i64 = Constant<16>
Analyzing result type: i64
Legal result type
Legally typed node: t19: i64 = Constant<16>

Legalizing node: t16: i64 = Constant<8>
Analyzing result type: i64
Legal result type
Legally typed node: t16: i64 = Constant<8>

Legalizing node: t14: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t14: i64 = undef

Legalizing node: t12: i64 = Register %28
Ignoring node results
Legally typed node: t12: i64 = Register %28

Legalizing node: t10: i64 = Register %29
Ignoring node results
Legally typed node: t10: i64 = Register %29

Legalizing node: t8: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t8: i64 = Constant<0>

Legalizing node: t7: i64 = Constant<48>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<48>

Legalizing node: t2: i64 = Constant<1>
Analyzing result type: i64
Legal result type
Legally typed node: t2: i64 = Constant<1>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t7: i64 = Constant<48>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Legally typed node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Legalizing node: t11: ch = CopyToReg t0, Register:i64 %29, t9
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Legally typed node: t11: ch = CopyToReg t0, Register:i64 %29, t9

Legalizing node: t17: i64 = add nuw t9, Constant:i64<8>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t16: i64 = Constant<8>
Legal operand
Legally typed node: t17: i64 = add nuw t9, Constant:i64<8>

Legalizing node: t20: i64 = add nuw t9, Constant:i64<16>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t19: i64 = Constant<16>
Legal operand
Legally typed node: t20: i64 = add nuw t9, Constant:i64<16>

Legalizing node: t21: ch = store<(store (s64) into %ir..repack65)> t9:1, Constant:i64<0>, t20, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Analyzing operand: t20: i64 = add nuw t9, Constant:i64<16>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t21: ch = store<(store (s64) into %ir..repack65)> t9:1, Constant:i64<0>, t20, undef:i64

Legalizing node: t23: i64 = add nuw t9, Constant:i64<24>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t22: i64 = Constant<24>
Legal operand
Legally typed node: t23: i64 = add nuw t9, Constant:i64<24>

Legalizing node: t28: i64 = add nuw t9, Constant:i64<32>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t27: i64 = Constant<32>
Legal operand
Legally typed node: t28: i64 = add nuw t9, Constant:i64<32>

Legalizing node: t63: ch = store<(store (s64) into %ir..repack69)> t9:1, Constant:i64<1>, t28, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t28: i64 = add nuw t9, Constant:i64<32>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t63: ch = store<(store (s64) into %ir..repack69)> t9:1, Constant:i64<1>, t28, undef:i64

Legalizing node: t13: i64,ch = CopyFromReg t0, Register:i64 %28
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t13: i64,ch = CopyFromReg t0, Register:i64 %28

Legalizing node: t15: ch = store<(store (s64) into %ir.40)> t9:1, t13, t9, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %28
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t15: ch = store<(store (s64) into %ir.40)> t9:1, t13, t9, undef:i64

Legalizing node: t18: ch = store<(store (s64) into %ir..repack63)> t9:1, t13, t17, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %28
Legal operand
Analyzing operand: t17: i64 = add nuw t9, Constant:i64<8>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t18: ch = store<(store (s64) into %ir..repack63)> t9:1, t13, t17, undef:i64

Legalizing node: t25: i64,ch = CopyFromReg t0, Register:i64 %6
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t25: i64,ch = CopyFromReg t0, Register:i64 %6

Legalizing node: t26: ch = store<(store (s64) into %ir..repack67)> t9:1, t25, t23, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t25: i64,ch = CopyFromReg t0, Register:i64 %6
Legal operand
Analyzing operand: t23: i64 = add nuw t9, Constant:i64<24>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t26: ch = store<(store (s64) into %ir..repack67)> t9:1, t25, t23, undef:i64

Legalizing node: t64: ch = TokenFactor t15, t18, t21, t26, t63
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = store<(store (s64) into %ir.40)> t9:1, t13, t9, undef:i64
Legal operand
Analyzing operand: t18: ch = store<(store (s64) into %ir..repack63)> t9:1, t13, t17, undef:i64
Legal operand
Analyzing operand: t21: ch = store<(store (s64) into %ir..repack65)> t9:1, Constant:i64<0>, t20, undef:i64
Legal operand
Analyzing operand: t26: ch = store<(store (s64) into %ir..repack67)> t9:1, t25, t23, undef:i64
Legal operand
Analyzing operand: t63: ch = store<(store (s64) into %ir..repack69)> t9:1, Constant:i64<1>, t28, undef:i64
Legal operand
Legally typed node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal operand
Legally typed node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t31: i64,ch = CopyFromReg t0, Register:i64 %7
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t31: i64,ch = CopyFromReg t0, Register:i64 %7

Legalizing node: t34: i64 = shl t31, Constant:i8<3>
Analyzing result type: i64
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %7
Legal operand
Analyzing operand: t33: i8 = Constant<3>
Legal operand
Legally typed node: t34: i64 = shl t31, Constant:i8<3>

Legalizing node: t36: ch = CopyToReg t0, Register:i64 %30, t34
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t36: ch = CopyToReg t0, Register:i64 %30, t34

Legalizing node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Analyzing operand: t37: i64 = GlobalAddress<ptr @malloc> 0
Legal operand
Analyzing operand: t42: Untyped = RegisterMask
Legal operand
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Legally typed node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Legally typed node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Legally typed node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing node: t48: ch = CopyToReg t0, Register:i64 %31, t46
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t48: ch = CopyToReg t0, Register:i64 %31, t46

Legalizing node: t53: ch = TokenFactor t11, t36, t48, t46:1
Analyzing result type: ch
Legal result type
Analyzing operand: t11: ch = CopyToReg t0, Register:i64 %29, t9
Legal operand
Analyzing operand: t36: ch = CopyToReg t0, Register:i64 %30, t34
Legal operand
Analyzing operand: t48: ch = CopyToReg t0, Register:i64 %31, t46
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i1
Promote integer result: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Creating new node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legalizing node: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>

Creating new node: t66: i8 = zero_extend t62
Legalizing node: t66: i8 = zero_extend t62
Analyzing result type: i8
Legal result type
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t66: i8 = zero_extend t62

Creating constant: t67: i8 = Constant<1>
Creating new node: t68: i8 = and t65, Constant:i8<1>
Replacing: t66: i8 = zero_extend t62
     with: t68: i8 = and t65, Constant:i8<1>
Legalizing node: t67: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t67: i8 = Constant<1>

Legalizing node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %7
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t61: ch = setlt
Legal operand
Legally typed node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Legalizing node: t68: i8 = and t65, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legal operand
Analyzing operand: t67: i8 = Constant<1>
Legal operand
Legally typed node: t68: i8 = and t65, Constant:i8<1>

Legalizing node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t68: i8 = and t65, Constant:i8<1>
Legal operand
Analyzing operand: t54: ch = BasicBlock<._crit_edge109 0x7fee5905bc00>
Legal operand
Legally typed node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>

Legalizing node: t57: ch = br t60, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>
Analyzing result type: ch
Legal result type
Analyzing operand: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>
Legal operand
Analyzing operand: t56: ch = BasicBlock<.lr.ph108.preheader 0x7fee5905bb00>
Legal operand
Legally typed node: t57: ch = br t60, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>

Legalizing node: t65535: ch = handlenode t57
Analyzing result type: ch
Legal result type
Analyzing operand: t57: ch = br t60, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>
Legal operand
Legally typed node: t65535: ch = handlenode t57

Type-legalized selection DAG: %bb.14 'main:._crit_edge106'
SelectionDAG has 53 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %28
  t31: i64,ch = CopyFromReg t0, Register:i64 %7
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.40)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack63)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack65)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %6
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack67)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack69)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %29, t9
        t36: ch = CopyToReg t0, Register:i64 %30, t34
        t48: ch = CopyToReg t0, Register:i64 %31, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
      t68: i8 = and t65, Constant:i8<1>
    t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>
  t57: ch = br t60, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>



Combining: t68: i8 = and t65, Constant:i8<1>

Replacing.2 t68: i8 = and t65, Constant:i8<1>

With: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch


Combining: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t63: ch = store<(store (s64) into %ir..repack69)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t61: ch = setlt

Combining: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>

Combining: t56: ch = BasicBlock<.lr.ph108.preheader 0x7fee5905bb00>

Combining: t54: ch = BasicBlock<._crit_edge109 0x7fee5905bc00>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %31, t46

Combining: t47: i64 = Register %31

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %30, t34

Combining: t35: i64 = Register %30

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %7

Combining: t30: i64 = Register %7

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack67)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %6

Combining: t24: i64 = Register %6

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack65)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack63)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.40)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %28

Combining: t12: i64 = Register %28

Combining: t11: ch = CopyToReg t0, Register:i64 %29, t9

Combining: t10: i64 = Register %29

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized type-legalized selection DAG: %bb.14 'main:._crit_edge106'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %28
  t31: i64,ch = CopyFromReg t0, Register:i64 %7
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.40)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack63)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack65)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %6
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack67)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack69)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %29, t9
        t36: ch = CopyToReg t0, Register:i64 %30, t34
        t48: ch = CopyToReg t0, Register:i64 %31, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>
  t57: ch = br t60, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>



Legalizing: t57: ch = br t60, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>
Legal node: nothing to do

Legalizing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>
Trying custom legalization
Creating new node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Creating constant: t70: i8 = TargetConstant<14>
Creating new node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>, TargetConstant:i8<14>, t69
Successfully custom legalized node
 ... replacing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>
     with:      t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>, TargetConstant:i8<14>, t69

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Legalizing: t48: ch = CopyToReg t0, Register:i64 %31, t46
Legal node: nothing to do

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Legalizing: t36: ch = CopyToReg t0, Register:i64 %30, t34
Legal node: nothing to do

Legalizing: t18: ch = store<(store (s64) into %ir..repack63)> t9:1, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t21: ch = store<(store (s64) into %ir..repack65)> t9:1, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t26: ch = store<(store (s64) into %ir..repack67)> t9:1, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t63: ch = store<(store (s64) into %ir..repack69)> t9:1, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Legalizing: t15: ch = store<(store (s64) into %ir.40)> t9:1, t13, t9, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t11: ch = CopyToReg t0, Register:i64 %29, t9
Legal node: nothing to do

Legalizing: t17: i64 = add nuw t9, Constant:i64<8>
Legal node: nothing to do

Legalizing: t20: i64 = add nuw t9, Constant:i64<16>
Legal node: nothing to do

Legalizing: t23: i64 = add nuw t9, Constant:i64<24>
Legal node: nothing to do

Legalizing: t28: i64 = add nuw t9, Constant:i64<32>
Legal node: nothing to do

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %7
Legal node: nothing to do

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %6
Legal node: nothing to do

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %28
Legal node: nothing to do

Legalizing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Trying custom legalization
Creating new node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Creating new node: t75: i64 = sub t74, Constant:i64<48>
Creating new node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Creating new node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t78: i64,ch = merge_values t75, t77
Successfully custom legalized node
 ... replacing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
     with:      t78: i64,ch = merge_values t75, t77
      and:      t78: i64,ch = merge_values t75, t77

Legalizing: t56: ch = BasicBlock<.lr.ph108.preheader 0x7fee5905bb00>
Legal node: nothing to do

Legalizing: t54: ch = BasicBlock<._crit_edge109 0x7fee5905bc00>
Legal node: nothing to do

Legalizing: t47: i64 = Register %31

Legalizing: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Legalizing: t37: i64 = GlobalAddress<ptr @malloc> 0
Trying custom legalization
Creating new node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Successfully custom legalized node
 ... replacing: t37: i64 = GlobalAddress<ptr @malloc> 0
     with:      t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t35: i64 = Register %30

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Legalizing: t30: i64 = Register %7

Legalizing: t27: i64 = Constant<32>
Legal node: nothing to do

Legalizing: t24: i64 = Register %6

Legalizing: t22: i64 = Constant<24>
Legal node: nothing to do

Legalizing: t19: i64 = Constant<16>
Legal node: nothing to do

Legalizing: t16: i64 = Constant<8>
Legal node: nothing to do

Legalizing: t14: i64 = undef
Legal node: nothing to do

Legalizing: t12: i64 = Register %28

Legalizing: t10: i64 = Register %29

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t7: i64 = Constant<48>
Legal node: nothing to do

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t78: i64,ch = merge_values t75, t77
Trying to expand node
Successfully expanded node
 ... replacing: t78: i64,ch = merge_values t75, t77
     with:      t75: i64 = sub t74, Constant:i64<48>
      and:      t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Legalizing: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Legalizing: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do
Legalized selection DAG: %bb.14 'main:._crit_edge106'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %28
  t31: i64,ch = CopyFromReg t0, Register:i64 %7
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.40)> t77, t13, t75, undef:i64
          t17: i64 = add nuw t75, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack63)> t77, t13, t17, undef:i64
          t20: i64 = add nuw t75, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack65)> t77, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %6
          t23: i64 = add nuw t75, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack67)> t77, t25, t23, undef:i64
          t28: i64 = add nuw t75, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack69)> t77, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
  t75: i64 = sub t74, Constant:i64<48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
        t11: ch = CopyToReg t0, Register:i64 %29, t75
        t36: ch = CopyToReg t0, Register:i64 %30, t34
        t48: ch = CopyToReg t0, Register:i64 %31, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>



Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Combining: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Combining: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Combining: t75: i64 = sub t74, Constant:i64<48>
Creating constant: t81: i64 = Constant<-48>
Creating new node: t82: i64 = add t74, Constant:i64<-48>
 ... into: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t81: i64 = Constant<-48>
Legal node: nothing to do

Combining: t81: i64 = Constant<-48>

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Combining: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

Legalizing: t73: i64 = Register $rsp

Combining: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Combining: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>, TargetConstant:i8<14>, t69

Legalizing: t70: i8 = TargetConstant<14>

Combining: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do

Combining: t69: i32 = X86ISD::CMP t31, Constant:i64<0>

Legalizing: t57: ch = br t71, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>
Legal node: nothing to do

Combining: t57: ch = br t71, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing: t48: ch = CopyToReg t0, Register:i64 %31, t46
Legal node: nothing to do

Combining: t48: ch = CopyToReg t0, Register:i64 %31, t46

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Combining: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing: t36: ch = CopyToReg t0, Register:i64 %30, t34
Legal node: nothing to do

Combining: t36: ch = CopyToReg t0, Register:i64 %30, t34

Legalizing: t18: ch = store<(store (s64) into %ir..repack63)> t77, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack63)> t77, t13, t17, undef:i64

Legalizing: t21: ch = store<(store (s64) into %ir..repack65)> t77, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack65)> t77, Constant:i64<0>, t20, undef:i64

Legalizing: t26: ch = store<(store (s64) into %ir..repack67)> t77, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack67)> t77, t25, t23, undef:i64

Legalizing: t63: ch = store<(store (s64) into %ir..repack69)> t77, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack69)> t77, Constant:i64<1>, t28, undef:i64

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Combining: t34: i64 = shl t31, Constant:i8<3>

Legalizing: t15: ch = store<(store (s64) into %ir.40)> t77, t13, t82, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t15: ch = store<(store (s64) into %ir.40)> t77, t13, t82, undef:i64

Legalizing: t11: ch = CopyToReg t0, Register:i64 %29, t82
Legal node: nothing to do

Combining: t11: ch = CopyToReg t0, Register:i64 %29, t82

Legalizing: t17: i64 = add nuw t82, Constant:i64<8>
Legal node: nothing to do

Combining: t17: i64 = add nuw t82, Constant:i64<8>
Creating constant: t83: i64 = Constant<-40>
Creating new node: t84: i64 = add t74, Constant:i64<-40>
 ... into: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t18: ch = store<(store (s64) into %ir..repack63)> t77, t13, t84, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack63)> t77, t13, t84, undef:i64

Legalizing: t84: i64 = add t74, Constant:i64<-40>
Legal node: nothing to do

Combining: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t83: i64 = Constant<-40>
Legal node: nothing to do

Combining: t83: i64 = Constant<-40>

Legalizing: t20: i64 = add nuw t82, Constant:i64<16>
Legal node: nothing to do

Combining: t20: i64 = add nuw t82, Constant:i64<16>
Creating constant: t85: i64 = Constant<-32>
Creating new node: t86: i64 = add t74, Constant:i64<-32>
 ... into: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t21: ch = store<(store (s64) into %ir..repack65)> t77, Constant:i64<0>, t86, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack65)> t77, Constant:i64<0>, t86, undef:i64

Legalizing: t86: i64 = add t74, Constant:i64<-32>
Legal node: nothing to do

Combining: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t85: i64 = Constant<-32>
Legal node: nothing to do

Combining: t85: i64 = Constant<-32>

Legalizing: t23: i64 = add nuw t82, Constant:i64<24>
Legal node: nothing to do

Combining: t23: i64 = add nuw t82, Constant:i64<24>
Creating constant: t87: i64 = Constant<-24>
Creating new node: t88: i64 = add t74, Constant:i64<-24>
 ... into: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t26: ch = store<(store (s64) into %ir..repack67)> t77, t25, t88, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack67)> t77, t25, t88, undef:i64

Legalizing: t88: i64 = add t74, Constant:i64<-24>
Legal node: nothing to do

Combining: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t87: i64 = Constant<-24>
Legal node: nothing to do

Combining: t87: i64 = Constant<-24>

Legalizing: t28: i64 = add nuw t82, Constant:i64<32>
Legal node: nothing to do

Combining: t28: i64 = add nuw t82, Constant:i64<32>
Creating constant: t89: i64 = Constant<-16>
Creating new node: t90: i64 = add t74, Constant:i64<-16>
 ... into: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t63: ch = store<(store (s64) into %ir..repack69)> t77, Constant:i64<1>, t90, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack69)> t77, Constant:i64<1>, t90, undef:i64

Legalizing: t90: i64 = add t74, Constant:i64<-16>
Legal node: nothing to do

Combining: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t89: i64 = Constant<-16>
Legal node: nothing to do

Combining: t89: i64 = Constant<-16>

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %7
Legal node: nothing to do

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %7

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %6
Legal node: nothing to do

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %6

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %28
Legal node: nothing to do

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %28

Legalizing: t56: ch = BasicBlock<.lr.ph108.preheader 0x7fee5905bb00>
Legal node: nothing to do

Combining: t56: ch = BasicBlock<.lr.ph108.preheader 0x7fee5905bb00>

Legalizing: t54: ch = BasicBlock<._crit_edge109 0x7fee5905bc00>
Legal node: nothing to do

Combining: t54: ch = BasicBlock<._crit_edge109 0x7fee5905bc00>

Legalizing: t47: i64 = Register %31

Combining: t47: i64 = Register %31

Legalizing: t45: i64 = Register $rax

Combining: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Combining: t42: Untyped = RegisterMask

Legalizing: t40: i64 = Register $rdi

Combining: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Combining: t38: i64 = TargetConstant<0>

Legalizing: t35: i64 = Register %30

Combining: t35: i64 = Register %30

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Combining: t33: i8 = Constant<3>

Legalizing: t30: i64 = Register %7

Combining: t30: i64 = Register %7

Legalizing: t24: i64 = Register %6

Combining: t24: i64 = Register %6

Legalizing: t14: i64 = undef
Legal node: nothing to do

Combining: t14: i64 = undef

Legalizing: t12: i64 = Register %28

Combining: t12: i64 = Register %28

Legalizing: t10: i64 = Register %29

Combining: t10: i64 = Register %29

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Combining: t8: i64 = Constant<0>

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Combining: t2: i64 = Constant<1>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.14 'main:._crit_edge106'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %28
  t31: i64,ch = CopyFromReg t0, Register:i64 %7
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.40)> t77, t13, t82, undef:i64
          t84: i64 = add t74, Constant:i64<-40>
        t18: ch = store<(store (s64) into %ir..repack63)> t77, t13, t84, undef:i64
          t86: i64 = add t74, Constant:i64<-32>
        t21: ch = store<(store (s64) into %ir..repack65)> t77, Constant:i64<0>, t86, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %6
          t88: i64 = add t74, Constant:i64<-24>
        t26: ch = store<(store (s64) into %ir..repack67)> t77, t25, t88, undef:i64
          t90: i64 = add t74, Constant:i64<-16>
        t63: ch = store<(store (s64) into %ir..repack69)> t77, Constant:i64<1>, t90, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
  t82: i64 = add t74, Constant:i64<-48>
        t11: ch = CopyToReg t0, Register:i64 %29, t82
        t36: ch = CopyToReg t0, Register:i64 %30, t34
        t48: ch = CopyToReg t0, Register:i64 %31, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>


===== Instruction selection begins: %bb.14 '._crit_edge106'

ISEL: Starting selection on root node: t57: ch = br t71, BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>
ISEL: Starting pattern match
  Initial Opcode index to 134414
  Morphed node: t57: ch = JMP_1 BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>, t71
ISEL: Match complete!

ISEL: Starting selection on root node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge109 0x7fee5905bc00>, TargetConstant:i8<14>, t69
ISEL: Starting pattern match
  Initial Opcode index to 131614
Creating new node: t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  Morphed node: t71: ch = JCC_1 BasicBlock:ch<._crit_edge109 0x7fee5905bc00>, TargetConstant:i8<14>, t92, t92:1
ISEL: Match complete!

ISEL: Starting selection on root node: t53: ch = TokenFactor t11, t36, t48, t46:1

ISEL: Starting selection on root node: t48: ch = CopyToReg t0, Register:i64 %31, t46

ISEL: Starting selection on root node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

ISEL: Starting selection on root node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
ISEL: Match complete!

ISEL: Starting selection on root node: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
ISEL: Match complete!

ISEL: Starting selection on root node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

ISEL: Starting selection on root node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t93: i32 = TargetConstant<0>
  Morphed node: t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
ISEL: Match complete!

ISEL: Starting selection on root node: t64: ch = TokenFactor t15, t18, t21, t26, t63

ISEL: Starting selection on root node: t15: ch = store<(store (s64) into %ir.40)> t77, t13, t82, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t94: i8 = TargetConstant<1>
Creating constant: t96: i32 = TargetConstant<-48>
  Morphed node: t15: ch = MOV64mr<Mem:(store (s64) into %ir.40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch = store<(store (s64) into %ir..repack63)> t77, t13, t84, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t98: i32 = TargetConstant<-40>
  Morphed node: t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack63)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = store<(store (s64) into %ir..repack65)> t77, Constant:i64<0>, t86, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Skipped scope entry (due to false predicate) at index 16132, continuing at 16162
  Skipped scope entry (due to false predicate) at index 16163, continuing at 16193
  Match failed at index 16203
  Continuing at 16224
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t99: i32 = TargetConstant<-32>
  Morphed node: t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack65)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t26: ch = store<(store (s64) into %ir..repack67)> t77, t25, t88, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t100: i32 = TargetConstant<-24>
  Morphed node: t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack67)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t63: ch = store<(store (s64) into %ir..repack69)> t77, Constant:i64<1>, t90, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t101: i32 = TargetConstant<-16>
Creating constant: t102: i64 = TargetConstant<1>
  Morphed node: t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack69)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
ISEL: Match complete!

ISEL: Starting selection on root node: t11: ch = CopyToReg t0, Register:i64 %29, t82

ISEL: Starting selection on root node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

ISEL: Starting selection on root node: t82: i64 = add t74, Constant:i64<-48>
ISEL: Starting pattern match
  Initial Opcode index to 102161
  Match failed at index 102165
  Continuing at 102268
  Match failed at index 102270
  Continuing at 102377
  TypeSwitch[i64] from 102379 to 102420
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 102420
  Continuing at 102435
  Match failed at index 102438
  Continuing at 102459
  Match failed at index 102461
  Continuing at 102483
  Skipped scope entry (due to false predicate) at index 102488, continuing at 102540
  Skipped scope entry (due to false predicate) at index 102541, continuing at 102593
  Skipped scope entry (due to false predicate) at index 102594, continuing at 102644
  Skipped scope entry (due to false predicate) at index 102645, continuing at 102669
  Match failed at index 102683
  Continuing at 102696
  Match failed at index 102700
  Continuing at 102713
Creating constant: t104: i64 = TargetConstant<-48>
  Morphed node: t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
ISEL: Match complete!

ISEL: Starting selection on root node: t36: ch = CopyToReg t0, Register:i64 %30, t34

ISEL: Starting selection on root node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

ISEL: Starting selection on root node: t34: i64 = shl t31, Constant:i8<3>
ISEL: Starting pattern match
  Initial Opcode index to 44725
  Match failed at index 44729
  Continuing at 44944
  TypeSwitch[i64] from 44946 to 44987
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 44987
  Continuing at 45002
  Match failed at index 45009
  Continuing at 45152
  Match failed at index 45153
  Continuing at 45203
  TypeSwitch[i64] from 45215 to 45257
Creating constant: t105: i8 = TargetConstant<3>
  Morphed node: t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 25710
  Match failed at index 25714
  Continuing at 26614
  Skipped scope entry (due to false predicate) at index 26619, continuing at 26650
  Skipped scope entry (due to false predicate) at index 26651, continuing at 26682
  Skipped scope entry (due to false predicate) at index 26683, continuing at 26714
  Match failed at index 26718
  Continuing at 26746
  Continuing at 26747
  Match failed at index 26750
  Continuing at 27134
  Skipped scope entry (due to false predicate) at index 27139, continuing at 27203
  Skipped scope entry (due to false predicate) at index 27204, continuing at 27304
  Skipped scope entry (due to false predicate) at index 27305, continuing at 27405
  Morphed node: t69: i32 = TEST64rr t31, t31
ISEL: Match complete!

ISEL: Starting selection on root node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132007
  Match failed at index 132010
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t31: i64,ch = CopyFromReg t0, Register:i64 %7

ISEL: Starting selection on root node: t25: i64,ch = CopyFromReg t0, Register:i64 %6

ISEL: Starting selection on root node: t13: i64,ch = CopyFromReg t0, Register:i64 %28

ISEL: Starting selection on root node: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

ISEL: Starting selection on root node: t73: i64 = Register $rsp

ISEL: Starting selection on root node: t70: i8 = TargetConstant<14>

ISEL: Starting selection on root node: t56: ch = BasicBlock<.lr.ph108.preheader 0x7fee5905bb00>

ISEL: Starting selection on root node: t54: ch = BasicBlock<._crit_edge109 0x7fee5905bc00>

ISEL: Starting selection on root node: t47: i64 = Register %31

ISEL: Starting selection on root node: t45: i64 = Register $rax

ISEL: Starting selection on root node: t42: Untyped = RegisterMask

ISEL: Starting selection on root node: t40: i64 = Register $rdi

ISEL: Starting selection on root node: t38: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t35: i64 = Register %30

ISEL: Starting selection on root node: t30: i64 = Register %7

ISEL: Starting selection on root node: t24: i64 = Register %6

ISEL: Starting selection on root node: t12: i64 = Register %28

ISEL: Starting selection on root node: t10: i64 = Register %29

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.14 'main:._crit_edge106'
SelectionDAG has 59 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %28
  t31: i64,ch = CopyFromReg t0, Register:i64 %7
  t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
    t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
  t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp
  t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
        t15: ch = MOV64mr<Mem:(store (s64) into %ir.40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1
        t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack63)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1
        t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack65)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1
          t25: i64,ch = CopyFromReg t0, Register:i64 %6
        t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack67)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1
        t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack69)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
  t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34
    t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
  t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
  t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2
      t11: ch = CopyToReg t0, Register:i64 %29, t82
      t36: ch = CopyToReg t0, Register:i64 %30, t34
      t48: ch = CopyToReg t0, Register:i64 %31, t46
    t53: ch = TokenFactor t11, t36, t48, t46:1
    t69: i32 = TEST64rr t31, t31
  t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  t103: i32 = Register $noreg
    t71: ch = JCC_1 BasicBlock:ch<._crit_edge109 0x7fee5905bc00>, TargetConstant:i8<14>, t92, t92:1
  t57: ch = JMP_1 BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>, t71


********** List Scheduling %bb.14 '._crit_edge106' **********
SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>, t71

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge109 0x7fee5905bc00>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(4): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t69: i32 = TEST64rr t31, t31

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %7

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(6): Data Latency=1
SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(24): Ord  Latency=1 Barrier
    SU(23): Ord  Latency=1 Barrier
    SU(22): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(21): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(22): Data Latency=1
SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(5): Data Latency=1
    SU(23): Data Latency=1
SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(8): Ord  Latency=0 Barrier
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(20): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(9): Ord  Latency=1 Barrier
  Successors:
    SU(7): Ord  Latency=0 Barrier
SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack69)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

  # preds left       : 1
  # succs left       : 5
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(11): Ord  Latency=1 Barrier
  Successors:
    SU(9): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(20): Ord  Latency=1 Barrier
SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 7
  Predecessors:
    SU(13): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
  Successors:
    SU(10): Ord  Latency=1 Barrier
SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(13): Data Latency=1
  Successors:
    SU(11): Data Latency=1
    SU(24): Data Latency=1
SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

  # preds left       : 1
  # succs left       : 7
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 9
  Predecessors:
    SU(14): Ord  Latency=1 Barrier
  Successors:
    SU(9): Data Latency=1
    SU(11): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
    SU(15): Data Latency=1
    SU(17): Data Latency=1
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(13): Ord  Latency=1 Barrier
SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack67)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(16): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %6

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(15): Data Latency=1
SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack65)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack63)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %28

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(22): t48: ch = CopyToReg t0, Register:i64 %31, t46

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(23): t36: ch = CopyToReg t0, Register:i64 %30, t34

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>, t71


*** Scheduling [0]: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>, t71


Examining Available:
Height 1: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge109 0x7fee5905bc00>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


*** Scheduling [1]: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge109 0x7fee5905bc00>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


Examining Available:
Height 1: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

Height 2: SU(2): t69: i32 = TEST64rr t31, t31


*** Scheduling [2]: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1


Examining Available:
Height 2: SU(2): t69: i32 = TEST64rr t31, t31

Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %31, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %30, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


*** Scheduling [3]: SU(2): t69: i32 = TEST64rr t31, t31


Examining Available:
Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %31, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %30, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


*** Scheduling [4]: SU(22): t48: ch = CopyToReg t0, Register:i64 %31, t46


Examining Available:
Height 5: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %30, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


*** Scheduling [5]: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1


Examining Available:
Height 6: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %30, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


*** Scheduling [6]: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0


Examining Available:
Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %30, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


*** Scheduling [7]: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64


Examining Available:
Height 7: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %30, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


*** Scheduling [8]: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63


Examining Available:
Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %30, t34

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack69)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack67)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack65)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack63)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


*** Scheduling [9]: SU(23): t36: ch = CopyToReg t0, Register:i64 %30, t34


Examining Available:
Height 10: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack69)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack67)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack65)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack63)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


*** Scheduling [10]: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>


Examining Available:
Height 11: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %7

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack69)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack67)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack65)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack63)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


*** Scheduling [11]: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %7


Examining Available:
Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack69)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack67)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack65)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack63)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


*** Scheduling [12]: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack69)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1


Examining Available:
Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack67)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack65)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack63)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


*** Scheduling [13]: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack67)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1


Examining Available:
Height 14: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %6

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack65)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack63)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


*** Scheduling [14]: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %6


Examining Available:
Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack65)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack63)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


*** Scheduling [15]: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack65)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1


Examining Available:
Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack63)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


*** Scheduling [16]: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack63)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


*** Scheduling [17]: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 18: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %28

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [18]: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %28


Examining Available:
Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [19]: SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82


Examining Available:
Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [20]: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


Examining Available:
Height 21: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


*** Scheduling [21]: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


Examining Available:
Height 22: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


*** Scheduling [22]: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


Examining Available:
Height 23: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


*** Scheduling [23]: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


Examining Available:
Height 24: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [24]: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

SU(24): t11: ch = CopyToReg t0, Register:i64 %29, t82

SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %28

SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.40)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack63)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack65)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %6

SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack67)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack69)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %7

SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

SU(23): t36: ch = CopyToReg t0, Register:i64 %30, t34

SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

SU(22): t48: ch = CopyToReg t0, Register:i64 %31, t46

SU(2): t69: i32 = TEST64rr t31, t31

SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge109 0x7fee5905bc00>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph108.preheader 0x7fee5905bb00>, t71


Total amount of phi nodes to update: 0
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %31
Creating constant: t3: i8 = Constant<0>
Creating new node: t5: i64,ch = CopyFromReg t0, Register:i64 %30
Creating constant: t7: i64 = TargetConstant<0>
Creating new node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Creating new node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Creating new node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Creating new node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Initial selection DAG: %bb.15 'main:.lr.ph108.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t3: i8 = Constant<0>
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %31
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %30
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Combining: t13: Untyped = RegisterMask

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Combining: t11: i64 = Register $rsi

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Combining: t9: i64 = Register $rdi

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t7: i64 = TargetConstant<0>

Combining: t6: i64 = ExternalSymbol'__bzero'

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %30

Combining: t4: i64 = Register %30

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %31

Combining: t1: i64 = Register %31

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.15 'main:.lr.ph108.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %31
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %30
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


Legalizing node: t13: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t13: Untyped = RegisterMask

Legalizing node: t11: i64 = Register $rsi
Ignoring node results
Legally typed node: t11: i64 = Register $rsi

Legalizing node: t9: i64 = Register $rdi
Ignoring node results
Legally typed node: t9: i64 = Register $rdi

Legalizing node: t7: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t7: i64 = TargetConstant<0>

Legalizing node: t6: i64 = ExternalSymbol'__bzero'
Analyzing result type: i64
Legal result type
Legally typed node: t6: i64 = ExternalSymbol'__bzero'

Legalizing node: t4: i64 = Register %30
Ignoring node results
Legally typed node: t4: i64 = Register %30

Legalizing node: t1: i64 = Register %31
Ignoring node results
Legally typed node: t1: i64 = Register %31

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %31
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %31

Legalizing node: t5: i64,ch = CopyFromReg t0, Register:i64 %30
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t5: i64,ch = CopyFromReg t0, Register:i64 %30

Legalizing node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %31
Legal operand
Legally typed node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Analyzing operand: t5: i64,ch = CopyFromReg t0, Register:i64 %30
Legal operand
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Legally typed node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Analyzing operand: t6: i64 = ExternalSymbol'__bzero'
Legal operand
Analyzing operand: t13: Untyped = RegisterMask
Legal operand
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Legally typed node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Legally typed node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.15 'main:.lr.ph108.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %31
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %30
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %30
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %31
Legal node: nothing to do

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Legalizing: t6: i64 = ExternalSymbol'__bzero'
Trying custom legalization
Creating new node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Successfully custom legalized node
 ... replacing: t6: i64 = ExternalSymbol'__bzero'
     with:      t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t4: i64 = Register %30

Legalizing: t1: i64 = Register %31

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do
Legalized selection DAG: %bb.15 'main:.lr.ph108.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %31
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %30
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Combining: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do

Combining: t16: i64 = TargetExternalSymbol'__bzero'

Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Combining: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %30
Legal node: nothing to do

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %30

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %31
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %31

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Combining: t13: Untyped = RegisterMask

Legalizing: t11: i64 = Register $rsi

Combining: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Combining: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Combining: t7: i64 = TargetConstant<0>

Legalizing: t4: i64 = Register %30

Combining: t4: i64 = Register %30

Legalizing: t1: i64 = Register %31

Combining: t1: i64 = Register %31

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.15 'main:.lr.ph108.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %31
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %30
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


===== Instruction selection begins: %bb.15 '.lr.ph108.preheader'

ISEL: Starting selection on root node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

ISEL: Starting selection on root node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

ISEL: Starting selection on root node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132022
  Match failed at index 132025
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t18: i32 = TargetConstant<0>
  Morphed node: t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i64,ch = CopyFromReg t0, Register:i64 %30

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %31

ISEL: Starting selection on root node: t16: i64 = TargetExternalSymbol'__bzero'

ISEL: Starting selection on root node: t13: Untyped = RegisterMask

ISEL: Starting selection on root node: t11: i64 = Register $rsi

ISEL: Starting selection on root node: t9: i64 = Register $rdi

ISEL: Starting selection on root node: t7: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t4: i64 = Register %30

ISEL: Starting selection on root node: t1: i64 = Register %31

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.15 'main:.lr.ph108.preheader'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
    t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t2: i64,ch = CopyFromReg t0, Register:i64 %31
  t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %30
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
  t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1


********** List Scheduling %bb.15 '.lr.ph108.preheader' **********
SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1

  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Data Latency=1
    SU(1): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %30

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %31

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1

Examining Available:
Height 0: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


*** Scheduling [0]: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Examining Available:
Height 1: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %30

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %31

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [1]: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'


Examining Available:
Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %30

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %31

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [2]: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %30


Examining Available:
Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %31

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [3]: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %31


Examining Available:
Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [4]: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %31

SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %30

SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<1>
Creating constant: t2: i64 = Constant<1>
Creating constant: t3: i64 = Constant<40>
Creating constant: t4: i64 = Constant<15>
Creating constant: t5: i64 = Constant<55>
Creating constant: t6: i64 = Constant<-16>
Creating constant: t7: i64 = Constant<48>
Creating constant: t8: i64 = Constant<0>
Creating new node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Creating new node: t11: ch = CopyToReg t0, Register:i64 %32, t9
Creating new node: t13: i64,ch = CopyFromReg t0, Register:i64 %31
Creating new node: t14: i64 = undef
Creating new node: t15: ch = store<(store (s64) into %ir.43)> t9:1, t13, t9, undef:i64
Creating constant: t16: i64 = Constant<8>
Creating new node: t17: i64 = add nuw t9, Constant:i64<8>
Creating new node: t18: ch = store<(store (s64) into %ir..repack72)> t15, t13, t17, undef:i64
Creating constant: t19: i64 = Constant<16>
Creating new node: t20: i64 = add nuw t9, Constant:i64<16>
Creating new node: t21: ch = store<(store (s64) into %ir..repack74)> t18, Constant:i64<0>, t20, undef:i64
Creating constant: t22: i64 = Constant<24>
Creating new node: t23: i64 = add nuw t9, Constant:i64<24>
Creating new node: t25: i64,ch = CopyFromReg t0, Register:i64 %7
Creating new node: t26: ch = store<(store (s64) into %ir..repack76)> t21, t25, t23, undef:i64
Creating constant: t27: i64 = Constant<32>
Creating new node: t28: i64 = add nuw t9, Constant:i64<32>
Creating new node: t29: ch = store<(store (s64) into %ir..repack78)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t31: i64,ch = CopyFromReg t0, Register:i64 %8
Creating constant: t32: i64 = Constant<3>
Creating constant: t33: i8 = Constant<3>
Creating new node: t34: i64 = shl t31, Constant:i8<3>
Creating new node: t36: ch = CopyToReg t0, Register:i64 %33, t34
Creating constant: t38: i64 = TargetConstant<0>
Creating new node: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Creating new node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Creating new node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Creating new node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Creating new node: t48: ch = CopyToReg t0, Register:i64 %34, t46
Creating new node: t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
Creating constant: t51: i1 = Constant<-1>
Creating new node: t52: i1 = xor t50, Constant:i1<-1>
Creating new node: t53: ch = TokenFactor t11, t36, t48, t46:1
Creating new node: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge112 0x7fee5905be00>
Creating new node: t57: ch = br t55, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>
Initial selection DAG: %bb.16 'main:._crit_edge109'
SelectionDAG has 58 nodes:
  t0: ch,glue = EntryToken
  t1: i32 = Constant<1>
  t3: i64 = Constant<40>
  t4: i64 = Constant<15>
  t5: i64 = Constant<55>
  t6: i64 = Constant<-16>
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %31
  t31: i64,ch = CopyFromReg t0, Register:i64 %8
  t32: i64 = Constant<3>
  t34: i64 = shl t31, Constant:i8<3>
              t15: ch = store<(store (s64) into %ir.43)> t9:1, t13, t9, undef:i64
              t17: i64 = add nuw t9, Constant:i64<8>
            t18: ch = store<(store (s64) into %ir..repack72)> t15, t13, t17, undef:i64
            t20: i64 = add nuw t9, Constant:i64<16>
          t21: ch = store<(store (s64) into %ir..repack74)> t18, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %7
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack76)> t21, t25, t23, undef:i64
        t28: i64 = add nuw t9, Constant:i64<32>
      t29: ch = store<(store (s64) into %ir..repack78)> t26, Constant:i64<1>, t28, undef:i64
    t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %32, t9
        t36: ch = CopyToReg t0, Register:i64 %33, t34
        t48: ch = CopyToReg t0, Register:i64 %34, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t50: i1 = setcc t31, Constant:i64<0>, setgt:ch
      t52: i1 = xor t50, Constant:i1<-1>
    t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge112 0x7fee5905be00>
  t57: ch = br t55, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>



Combining: t57: ch = br t55, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>

Combining: t56: ch = BasicBlock<.lr.ph111.preheader 0x7fee5905bd00>

Combining: t55: ch = brcond t53, t52, BasicBlock:ch<._crit_edge112 0x7fee5905be00>
Creating new node: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge112 0x7fee5905be00>
 ... into: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge112 0x7fee5905be00>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>

Combining: t60: ch = brcond t53, t59, BasicBlock:ch<._crit_edge112 0x7fee5905be00>

Combining: t59: i1 = setcc t31, Constant:i64<0>, setle:ch
Creating new node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
 ... into: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge112 0x7fee5905be00>

Combining: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t61: ch = setlt

Combining: t54: ch = BasicBlock<._crit_edge112 0x7fee5905be00>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %34, t46

Combining: t47: i64 = Register %34

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t29, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %33, t34

Combining: t35: i64 = Register %33

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %8

Combining: t30: i64 = Register %8

Combining: t29: ch = store<(store (s64) into %ir..repack78)> t26, Constant:i64<1>, t28, undef:i64
Creating new node: t63: ch = store<(store (s64) into %ir..repack78)> t9:1, Constant:i64<1>, t28, undef:i64
Creating new node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Replacing.1 t29: ch = store<(store (s64) into %ir..repack78)> t26, Constant:i64<1>, t28, undef:i64

With: t64: ch = TokenFactor t15, t18, t21, t26, t63
 and 0 other values

Combining: t63: ch = store<(store (s64) into %ir..repack78)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack76)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %7

Combining: t24: i64 = Register %7

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack74)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack72)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.43)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %31

Combining: t12: i64 = Register %31

Combining: t11: ch = CopyToReg t0, Register:i64 %32, t9

Combining: t10: i64 = Register %32

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.16 'main:._crit_edge109'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %31
  t31: i64,ch = CopyFromReg t0, Register:i64 %8
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.43)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack72)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack74)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %7
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack76)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack78)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %32, t9
        t36: ch = CopyToReg t0, Register:i64 %33, t34
        t48: ch = CopyToReg t0, Register:i64 %34, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge112 0x7fee5905be00>
  t57: ch = br t60, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>


Legalizing node: t61: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t61: ch = setlt

Legalizing node: t56: ch = BasicBlock<.lr.ph111.preheader 0x7fee5905bd00>
Analyzing result type: ch
Legal result type
Legally typed node: t56: ch = BasicBlock<.lr.ph111.preheader 0x7fee5905bd00>

Legalizing node: t54: ch = BasicBlock<._crit_edge112 0x7fee5905be00>
Analyzing result type: ch
Legal result type
Legally typed node: t54: ch = BasicBlock<._crit_edge112 0x7fee5905be00>

Legalizing node: t47: i64 = Register %34
Ignoring node results
Legally typed node: t47: i64 = Register %34

Legalizing node: t45: i64 = Register $rax
Ignoring node results
Legally typed node: t45: i64 = Register $rax

Legalizing node: t42: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t42: Untyped = RegisterMask

Legalizing node: t40: i64 = Register $rdi
Ignoring node results
Legally typed node: t40: i64 = Register $rdi

Legalizing node: t38: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t38: i64 = TargetConstant<0>

Legalizing node: t37: i64 = GlobalAddress<ptr @malloc> 0
Analyzing result type: i64
Legal result type
Legally typed node: t37: i64 = GlobalAddress<ptr @malloc> 0

Legalizing node: t35: i64 = Register %33
Ignoring node results
Legally typed node: t35: i64 = Register %33

Legalizing node: t33: i8 = Constant<3>
Analyzing result type: i8
Legal result type
Legally typed node: t33: i8 = Constant<3>

Legalizing node: t30: i64 = Register %8
Ignoring node results
Legally typed node: t30: i64 = Register %8

Legalizing node: t27: i64 = Constant<32>
Analyzing result type: i64
Legal result type
Legally typed node: t27: i64 = Constant<32>

Legalizing node: t24: i64 = Register %7
Ignoring node results
Legally typed node: t24: i64 = Register %7

Legalizing node: t22: i64 = Constant<24>
Analyzing result type: i64
Legal result type
Legally typed node: t22: i64 = Constant<24>

Legalizing node: t19: i64 = Constant<16>
Analyzing result type: i64
Legal result type
Legally typed node: t19: i64 = Constant<16>

Legalizing node: t16: i64 = Constant<8>
Analyzing result type: i64
Legal result type
Legally typed node: t16: i64 = Constant<8>

Legalizing node: t14: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t14: i64 = undef

Legalizing node: t12: i64 = Register %31
Ignoring node results
Legally typed node: t12: i64 = Register %31

Legalizing node: t10: i64 = Register %32
Ignoring node results
Legally typed node: t10: i64 = Register %32

Legalizing node: t8: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t8: i64 = Constant<0>

Legalizing node: t7: i64 = Constant<48>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<48>

Legalizing node: t2: i64 = Constant<1>
Analyzing result type: i64
Legal result type
Legally typed node: t2: i64 = Constant<1>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t7: i64 = Constant<48>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Legally typed node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Legalizing node: t11: ch = CopyToReg t0, Register:i64 %32, t9
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Legally typed node: t11: ch = CopyToReg t0, Register:i64 %32, t9

Legalizing node: t17: i64 = add nuw t9, Constant:i64<8>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t16: i64 = Constant<8>
Legal operand
Legally typed node: t17: i64 = add nuw t9, Constant:i64<8>

Legalizing node: t20: i64 = add nuw t9, Constant:i64<16>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t19: i64 = Constant<16>
Legal operand
Legally typed node: t20: i64 = add nuw t9, Constant:i64<16>

Legalizing node: t21: ch = store<(store (s64) into %ir..repack74)> t9:1, Constant:i64<0>, t20, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Analyzing operand: t20: i64 = add nuw t9, Constant:i64<16>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t21: ch = store<(store (s64) into %ir..repack74)> t9:1, Constant:i64<0>, t20, undef:i64

Legalizing node: t23: i64 = add nuw t9, Constant:i64<24>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t22: i64 = Constant<24>
Legal operand
Legally typed node: t23: i64 = add nuw t9, Constant:i64<24>

Legalizing node: t28: i64 = add nuw t9, Constant:i64<32>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t27: i64 = Constant<32>
Legal operand
Legally typed node: t28: i64 = add nuw t9, Constant:i64<32>

Legalizing node: t63: ch = store<(store (s64) into %ir..repack78)> t9:1, Constant:i64<1>, t28, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t28: i64 = add nuw t9, Constant:i64<32>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t63: ch = store<(store (s64) into %ir..repack78)> t9:1, Constant:i64<1>, t28, undef:i64

Legalizing node: t13: i64,ch = CopyFromReg t0, Register:i64 %31
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t13: i64,ch = CopyFromReg t0, Register:i64 %31

Legalizing node: t15: ch = store<(store (s64) into %ir.43)> t9:1, t13, t9, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %31
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t15: ch = store<(store (s64) into %ir.43)> t9:1, t13, t9, undef:i64

Legalizing node: t18: ch = store<(store (s64) into %ir..repack72)> t9:1, t13, t17, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t13: i64,ch = CopyFromReg t0, Register:i64 %31
Legal operand
Analyzing operand: t17: i64 = add nuw t9, Constant:i64<8>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t18: ch = store<(store (s64) into %ir..repack72)> t9:1, t13, t17, undef:i64

Legalizing node: t25: i64,ch = CopyFromReg t0, Register:i64 %7
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t25: i64,ch = CopyFromReg t0, Register:i64 %7

Legalizing node: t26: ch = store<(store (s64) into %ir..repack76)> t9:1, t25, t23, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t25: i64,ch = CopyFromReg t0, Register:i64 %7
Legal operand
Analyzing operand: t23: i64 = add nuw t9, Constant:i64<24>
Legal operand
Analyzing operand: t14: i64 = undef
Legal operand
Legally typed node: t26: ch = store<(store (s64) into %ir..repack76)> t9:1, t25, t23, undef:i64

Legalizing node: t64: ch = TokenFactor t15, t18, t21, t26, t63
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = store<(store (s64) into %ir.43)> t9:1, t13, t9, undef:i64
Legal operand
Analyzing operand: t18: ch = store<(store (s64) into %ir..repack72)> t9:1, t13, t17, undef:i64
Legal operand
Analyzing operand: t21: ch = store<(store (s64) into %ir..repack74)> t9:1, Constant:i64<0>, t20, undef:i64
Legal operand
Analyzing operand: t26: ch = store<(store (s64) into %ir..repack76)> t9:1, t25, t23, undef:i64
Legal operand
Analyzing operand: t63: ch = store<(store (s64) into %ir..repack78)> t9:1, Constant:i64<1>, t28, undef:i64
Legal operand
Legally typed node: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal operand
Legally typed node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t31: i64,ch = CopyFromReg t0, Register:i64 %8
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t31: i64,ch = CopyFromReg t0, Register:i64 %8

Legalizing node: t34: i64 = shl t31, Constant:i8<3>
Analyzing result type: i64
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %8
Legal operand
Analyzing operand: t33: i8 = Constant<3>
Legal operand
Legally typed node: t34: i64 = shl t31, Constant:i8<3>

Legalizing node: t36: ch = CopyToReg t0, Register:i64 %33, t34
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t36: ch = CopyToReg t0, Register:i64 %33, t34

Legalizing node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t34: i64 = shl t31, Constant:i8<3>
Legal operand
Legally typed node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Analyzing operand: t37: i64 = GlobalAddress<ptr @malloc> 0
Legal operand
Analyzing operand: t42: Untyped = RegisterMask
Legal operand
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal operand
Legally typed node: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Analyzing operand: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal operand
Legally typed node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Analyzing operand: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
Legal operand
Legally typed node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing node: t48: ch = CopyToReg t0, Register:i64 %34, t46
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t48: ch = CopyToReg t0, Register:i64 %34, t46

Legalizing node: t53: ch = TokenFactor t11, t36, t48, t46:1
Analyzing result type: ch
Legal result type
Analyzing operand: t11: ch = CopyToReg t0, Register:i64 %32, t9
Legal operand
Analyzing operand: t36: ch = CopyToReg t0, Register:i64 %33, t34
Legal operand
Analyzing operand: t48: ch = CopyToReg t0, Register:i64 %34, t46
Legal operand
Analyzing operand: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal operand
Legally typed node: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing node: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i1
Promote integer result: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch

Creating new node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legalizing node: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge112 0x7fee5905be00>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t60: ch = brcond t53, t62, BasicBlock:ch<._crit_edge112 0x7fee5905be00>

Creating new node: t66: i8 = zero_extend t62
Legalizing node: t66: i8 = zero_extend t62
Analyzing result type: i8
Legal result type
Analyzing operand: t62: i1 = setcc t31, Constant:i64<1>, setlt:ch
Promote integer operand: t66: i8 = zero_extend t62

Creating constant: t67: i8 = Constant<1>
Creating new node: t68: i8 = and t65, Constant:i8<1>
Replacing: t66: i8 = zero_extend t62
     with: t68: i8 = and t65, Constant:i8<1>
Legalizing node: t67: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t67: i8 = Constant<1>

Legalizing node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t31: i64,ch = CopyFromReg t0, Register:i64 %8
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t61: ch = setlt
Legal operand
Legally typed node: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Legalizing node: t68: i8 = and t65, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
Legal operand
Analyzing operand: t67: i8 = Constant<1>
Legal operand
Legally typed node: t68: i8 = and t65, Constant:i8<1>

Legalizing node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge112 0x7fee5905be00>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal operand
Analyzing operand: t68: i8 = and t65, Constant:i8<1>
Legal operand
Analyzing operand: t54: ch = BasicBlock<._crit_edge112 0x7fee5905be00>
Legal operand
Legally typed node: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge112 0x7fee5905be00>

Legalizing node: t57: ch = br t60, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>
Analyzing result type: ch
Legal result type
Analyzing operand: t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge112 0x7fee5905be00>
Legal operand
Analyzing operand: t56: ch = BasicBlock<.lr.ph111.preheader 0x7fee5905bd00>
Legal operand
Legally typed node: t57: ch = br t60, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>

Legalizing node: t65535: ch = handlenode t57
Analyzing result type: ch
Legal result type
Analyzing operand: t57: ch = br t60, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>
Legal operand
Legally typed node: t65535: ch = handlenode t57

Type-legalized selection DAG: %bb.16 'main:._crit_edge109'
SelectionDAG has 53 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %31
  t31: i64,ch = CopyFromReg t0, Register:i64 %8
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.43)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack72)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack74)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %7
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack76)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack78)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %32, t9
        t36: ch = CopyToReg t0, Register:i64 %33, t34
        t48: ch = CopyToReg t0, Register:i64 %34, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
        t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
      t68: i8 = and t65, Constant:i8<1>
    t60: ch = brcond t53, t68, BasicBlock:ch<._crit_edge112 0x7fee5905be00>
  t57: ch = br t60, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>



Combining: t68: i8 = and t65, Constant:i8<1>

Replacing.2 t68: i8 = and t65, Constant:i8<1>

With: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch


Combining: t65: i8 = setcc t31, Constant:i64<1>, setlt:ch

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Combining: t63: ch = store<(store (s64) into %ir..repack78)> t9:1, Constant:i64<1>, t28, undef:i64

Combining: t61: ch = setlt

Combining: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge112 0x7fee5905be00>

Combining: t57: ch = br t60, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>

Combining: t56: ch = BasicBlock<.lr.ph111.preheader 0x7fee5905bd00>

Combining: t54: ch = BasicBlock<._crit_edge112 0x7fee5905be00>

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Combining: t48: ch = CopyToReg t0, Register:i64 %34, t46

Combining: t47: i64 = Register %34

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Combining: t45: i64 = Register $rax

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Combining: t42: Untyped = RegisterMask

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Combining: t40: i64 = Register $rdi

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t38: i64 = TargetConstant<0>

Combining: t37: i64 = GlobalAddress<ptr @malloc> 0

Combining: t36: ch = CopyToReg t0, Register:i64 %33, t34

Combining: t35: i64 = Register %33

Combining: t34: i64 = shl t31, Constant:i8<3>

Combining: t33: i8 = Constant<3>

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %8

Combining: t30: i64 = Register %8

Combining: t28: i64 = add nuw t9, Constant:i64<32>

Combining: t27: i64 = Constant<32>

Combining: t26: ch = store<(store (s64) into %ir..repack76)> t9:1, t25, t23, undef:i64

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %7

Combining: t24: i64 = Register %7

Combining: t23: i64 = add nuw t9, Constant:i64<24>

Combining: t22: i64 = Constant<24>

Combining: t21: ch = store<(store (s64) into %ir..repack74)> t9:1, Constant:i64<0>, t20, undef:i64

Combining: t20: i64 = add nuw t9, Constant:i64<16>

Combining: t19: i64 = Constant<16>

Combining: t18: ch = store<(store (s64) into %ir..repack72)> t9:1, t13, t17, undef:i64

Combining: t17: i64 = add nuw t9, Constant:i64<8>

Combining: t16: i64 = Constant<8>

Combining: t15: ch = store<(store (s64) into %ir.43)> t9:1, t13, t9, undef:i64

Combining: t14: i64 = undef

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %31

Combining: t12: i64 = Register %31

Combining: t11: ch = CopyToReg t0, Register:i64 %32, t9

Combining: t10: i64 = Register %32

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t2: i64 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized type-legalized selection DAG: %bb.16 'main:._crit_edge109'
SelectionDAG has 51 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t13: i64,ch = CopyFromReg t0, Register:i64 %31
  t31: i64,ch = CopyFromReg t0, Register:i64 %8
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.43)> t9:1, t13, t9, undef:i64
          t17: i64 = add nuw t9, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack72)> t9:1, t13, t17, undef:i64
          t20: i64 = add nuw t9, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack74)> t9:1, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %7
          t23: i64 = add nuw t9, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack76)> t9:1, t25, t23, undef:i64
          t28: i64 = add nuw t9, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack78)> t9:1, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
  t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
        t11: ch = CopyToReg t0, Register:i64 %32, t9
        t36: ch = CopyToReg t0, Register:i64 %33, t34
        t48: ch = CopyToReg t0, Register:i64 %34, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t65: i8 = setcc t31, Constant:i64<1>, setlt:ch
    t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge112 0x7fee5905be00>
  t57: ch = br t60, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>



Legalizing: t57: ch = br t60, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>
Legal node: nothing to do

Legalizing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge112 0x7fee5905be00>
Trying custom legalization
Creating new node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Creating constant: t70: i8 = TargetConstant<14>
Creating new node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge112 0x7fee5905be00>, TargetConstant:i8<14>, t69
Successfully custom legalized node
 ... replacing: t60: ch = brcond t53, t65, BasicBlock:ch<._crit_edge112 0x7fee5905be00>
     with:      t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge112 0x7fee5905be00>, TargetConstant:i8<14>, t69

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Legalizing: t48: ch = CopyToReg t0, Register:i64 %34, t46
Legal node: nothing to do

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, GlobalAddress:i64<ptr @malloc> 0, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Legalizing: t36: ch = CopyToReg t0, Register:i64 %33, t34
Legal node: nothing to do

Legalizing: t18: ch = store<(store (s64) into %ir..repack72)> t9:1, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t21: ch = store<(store (s64) into %ir..repack74)> t9:1, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t26: ch = store<(store (s64) into %ir..repack76)> t9:1, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t63: ch = store<(store (s64) into %ir..repack78)> t9:1, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Legalizing: t15: ch = store<(store (s64) into %ir.43)> t9:1, t13, t9, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t11: ch = CopyToReg t0, Register:i64 %32, t9
Legal node: nothing to do

Legalizing: t17: i64 = add nuw t9, Constant:i64<8>
Legal node: nothing to do

Legalizing: t20: i64 = add nuw t9, Constant:i64<16>
Legal node: nothing to do

Legalizing: t23: i64 = add nuw t9, Constant:i64<24>
Legal node: nothing to do

Legalizing: t28: i64 = add nuw t9, Constant:i64<32>
Legal node: nothing to do

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %8
Legal node: nothing to do

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %7
Legal node: nothing to do

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %31
Legal node: nothing to do

Legalizing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Trying custom legalization
Creating new node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Creating new node: t75: i64 = sub t74, Constant:i64<48>
Creating new node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Creating new node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t78: i64,ch = merge_values t75, t77
Successfully custom legalized node
 ... replacing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
     with:      t78: i64,ch = merge_values t75, t77
      and:      t78: i64,ch = merge_values t75, t77

Legalizing: t56: ch = BasicBlock<.lr.ph111.preheader 0x7fee5905bd00>
Legal node: nothing to do

Legalizing: t54: ch = BasicBlock<._crit_edge112 0x7fee5905be00>
Legal node: nothing to do

Legalizing: t47: i64 = Register %34

Legalizing: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Legalizing: t37: i64 = GlobalAddress<ptr @malloc> 0
Trying custom legalization
Creating new node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Successfully custom legalized node
 ... replacing: t37: i64 = GlobalAddress<ptr @malloc> 0
     with:      t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t35: i64 = Register %33

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Legalizing: t30: i64 = Register %8

Legalizing: t27: i64 = Constant<32>
Legal node: nothing to do

Legalizing: t24: i64 = Register %7

Legalizing: t22: i64 = Constant<24>
Legal node: nothing to do

Legalizing: t19: i64 = Constant<16>
Legal node: nothing to do

Legalizing: t16: i64 = Constant<8>
Legal node: nothing to do

Legalizing: t14: i64 = undef
Legal node: nothing to do

Legalizing: t12: i64 = Register %31

Legalizing: t10: i64 = Register %32

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t7: i64 = Constant<48>
Legal node: nothing to do

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Legalizing: t78: i64,ch = merge_values t75, t77
Trying to expand node
Successfully expanded node
 ... replacing: t78: i64,ch = merge_values t75, t77
     with:      t75: i64 = sub t74, Constant:i64<48>
      and:      t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Legalizing: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge112 0x7fee5905be00>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Legalizing: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do
Legalized selection DAG: %bb.16 'main:._crit_edge109'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %31
  t31: i64,ch = CopyFromReg t0, Register:i64 %8
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.43)> t77, t13, t75, undef:i64
          t17: i64 = add nuw t75, Constant:i64<8>
        t18: ch = store<(store (s64) into %ir..repack72)> t77, t13, t17, undef:i64
          t20: i64 = add nuw t75, Constant:i64<16>
        t21: ch = store<(store (s64) into %ir..repack74)> t77, Constant:i64<0>, t20, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %7
          t23: i64 = add nuw t75, Constant:i64<24>
        t26: ch = store<(store (s64) into %ir..repack76)> t77, t25, t23, undef:i64
          t28: i64 = add nuw t75, Constant:i64<32>
        t63: ch = store<(store (s64) into %ir..repack78)> t77, Constant:i64<1>, t28, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
  t75: i64 = sub t74, Constant:i64<48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
        t11: ch = CopyToReg t0, Register:i64 %32, t75
        t36: ch = CopyToReg t0, Register:i64 %33, t34
        t48: ch = CopyToReg t0, Register:i64 %34, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge112 0x7fee5905be00>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>



Legalizing: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
Legal node: nothing to do

Combining: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0

Legalizing: t79: i64 = TargetGlobalAddress<ptr @malloc> 0
Legal node: nothing to do

Combining: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

Legalizing: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t75

Legalizing: t75: i64 = sub t74, Constant:i64<48>
Legal node: nothing to do

Combining: t75: i64 = sub t74, Constant:i64<48>
Creating constant: t81: i64 = Constant<-48>
Creating new node: t82: i64 = add t74, Constant:i64<-48>
 ... into: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
Legal node: nothing to do

Combining: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t81: i64 = Constant<-48>
Legal node: nothing to do

Combining: t81: i64 = Constant<-48>

Legalizing: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
Legal node: nothing to do

Combining: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

Legalizing: t73: i64 = Register $rsp

Combining: t73: i64 = Register $rsp

Legalizing: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge112 0x7fee5905be00>, TargetConstant:i8<14>, t69
Legal node: nothing to do

Combining: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge112 0x7fee5905be00>, TargetConstant:i8<14>, t69

Legalizing: t70: i8 = TargetConstant<14>

Combining: t70: i8 = TargetConstant<14>

Legalizing: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
Legal node: nothing to do

Combining: t69: i32 = X86ISD::CMP t31, Constant:i64<0>

Legalizing: t57: ch = br t71, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>
Legal node: nothing to do

Combining: t57: ch = br t71, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>

Legalizing: t53: ch = TokenFactor t11, t36, t48, t46:1
Legal node: nothing to do

Combining: t53: ch = TokenFactor t11, t36, t48, t46:1

Legalizing: t48: ch = CopyToReg t0, Register:i64 %34, t46
Legal node: nothing to do

Combining: t48: ch = CopyToReg t0, Register:i64 %34, t46

Legalizing: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
Legal node: nothing to do

Combining: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

Legalizing: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Combining: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1

Legalizing: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
Legal node: nothing to do

Combining: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
Legal node: nothing to do

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

Legalizing: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t64: ch = TokenFactor t15, t18, t21, t26, t63
Legal node: nothing to do

Combining: t64: ch = TokenFactor t15, t18, t21, t26, t63

Legalizing: t36: ch = CopyToReg t0, Register:i64 %33, t34
Legal node: nothing to do

Combining: t36: ch = CopyToReg t0, Register:i64 %33, t34

Legalizing: t18: ch = store<(store (s64) into %ir..repack72)> t77, t13, t17, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack72)> t77, t13, t17, undef:i64

Legalizing: t21: ch = store<(store (s64) into %ir..repack74)> t77, Constant:i64<0>, t20, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack74)> t77, Constant:i64<0>, t20, undef:i64

Legalizing: t26: ch = store<(store (s64) into %ir..repack76)> t77, t25, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack76)> t77, t25, t23, undef:i64

Legalizing: t63: ch = store<(store (s64) into %ir..repack78)> t77, Constant:i64<1>, t28, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack78)> t77, Constant:i64<1>, t28, undef:i64

Legalizing: t34: i64 = shl t31, Constant:i8<3>
Legal node: nothing to do

Combining: t34: i64 = shl t31, Constant:i8<3>

Legalizing: t15: ch = store<(store (s64) into %ir.43)> t77, t13, t82, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t15: ch = store<(store (s64) into %ir.43)> t77, t13, t82, undef:i64

Legalizing: t11: ch = CopyToReg t0, Register:i64 %32, t82
Legal node: nothing to do

Combining: t11: ch = CopyToReg t0, Register:i64 %32, t82

Legalizing: t17: i64 = add nuw t82, Constant:i64<8>
Legal node: nothing to do

Combining: t17: i64 = add nuw t82, Constant:i64<8>
Creating constant: t83: i64 = Constant<-40>
Creating new node: t84: i64 = add t74, Constant:i64<-40>
 ... into: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t18: ch = store<(store (s64) into %ir..repack72)> t77, t13, t84, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir..repack72)> t77, t13, t84, undef:i64

Legalizing: t84: i64 = add t74, Constant:i64<-40>
Legal node: nothing to do

Combining: t84: i64 = add t74, Constant:i64<-40>

Legalizing: t83: i64 = Constant<-40>
Legal node: nothing to do

Combining: t83: i64 = Constant<-40>

Legalizing: t20: i64 = add nuw t82, Constant:i64<16>
Legal node: nothing to do

Combining: t20: i64 = add nuw t82, Constant:i64<16>
Creating constant: t85: i64 = Constant<-32>
Creating new node: t86: i64 = add t74, Constant:i64<-32>
 ... into: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t21: ch = store<(store (s64) into %ir..repack74)> t77, Constant:i64<0>, t86, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir..repack74)> t77, Constant:i64<0>, t86, undef:i64

Legalizing: t86: i64 = add t74, Constant:i64<-32>
Legal node: nothing to do

Combining: t86: i64 = add t74, Constant:i64<-32>

Legalizing: t85: i64 = Constant<-32>
Legal node: nothing to do

Combining: t85: i64 = Constant<-32>

Legalizing: t23: i64 = add nuw t82, Constant:i64<24>
Legal node: nothing to do

Combining: t23: i64 = add nuw t82, Constant:i64<24>
Creating constant: t87: i64 = Constant<-24>
Creating new node: t88: i64 = add t74, Constant:i64<-24>
 ... into: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t26: ch = store<(store (s64) into %ir..repack76)> t77, t25, t88, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir..repack76)> t77, t25, t88, undef:i64

Legalizing: t88: i64 = add t74, Constant:i64<-24>
Legal node: nothing to do

Combining: t88: i64 = add t74, Constant:i64<-24>

Legalizing: t87: i64 = Constant<-24>
Legal node: nothing to do

Combining: t87: i64 = Constant<-24>

Legalizing: t28: i64 = add nuw t82, Constant:i64<32>
Legal node: nothing to do

Combining: t28: i64 = add nuw t82, Constant:i64<32>
Creating constant: t89: i64 = Constant<-16>
Creating new node: t90: i64 = add t74, Constant:i64<-16>
 ... into: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t82: i64 = add t74, Constant:i64<-48>
Legal node: nothing to do

Combining: t82: i64 = add t74, Constant:i64<-48>

Legalizing: t63: ch = store<(store (s64) into %ir..repack78)> t77, Constant:i64<1>, t90, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t63: ch = store<(store (s64) into %ir..repack78)> t77, Constant:i64<1>, t90, undef:i64

Legalizing: t90: i64 = add t74, Constant:i64<-16>
Legal node: nothing to do

Combining: t90: i64 = add t74, Constant:i64<-16>

Legalizing: t89: i64 = Constant<-16>
Legal node: nothing to do

Combining: t89: i64 = Constant<-16>

Legalizing: t31: i64,ch = CopyFromReg t0, Register:i64 %8
Legal node: nothing to do

Combining: t31: i64,ch = CopyFromReg t0, Register:i64 %8

Legalizing: t25: i64,ch = CopyFromReg t0, Register:i64 %7
Legal node: nothing to do

Combining: t25: i64,ch = CopyFromReg t0, Register:i64 %7

Legalizing: t13: i64,ch = CopyFromReg t0, Register:i64 %31
Legal node: nothing to do

Combining: t13: i64,ch = CopyFromReg t0, Register:i64 %31

Legalizing: t56: ch = BasicBlock<.lr.ph111.preheader 0x7fee5905bd00>
Legal node: nothing to do

Combining: t56: ch = BasicBlock<.lr.ph111.preheader 0x7fee5905bd00>

Legalizing: t54: ch = BasicBlock<._crit_edge112 0x7fee5905be00>
Legal node: nothing to do

Combining: t54: ch = BasicBlock<._crit_edge112 0x7fee5905be00>

Legalizing: t47: i64 = Register %34

Combining: t47: i64 = Register %34

Legalizing: t45: i64 = Register $rax

Combining: t45: i64 = Register $rax

Legalizing: t42: Untyped = RegisterMask
Legal node: nothing to do

Combining: t42: Untyped = RegisterMask

Legalizing: t40: i64 = Register $rdi

Combining: t40: i64 = Register $rdi

Legalizing: t38: i64 = TargetConstant<0>

Combining: t38: i64 = TargetConstant<0>

Legalizing: t35: i64 = Register %33

Combining: t35: i64 = Register %33

Legalizing: t33: i8 = Constant<3>
Legal node: nothing to do

Combining: t33: i8 = Constant<3>

Legalizing: t30: i64 = Register %8

Combining: t30: i64 = Register %8

Legalizing: t24: i64 = Register %7

Combining: t24: i64 = Register %7

Legalizing: t14: i64 = undef
Legal node: nothing to do

Combining: t14: i64 = undef

Legalizing: t12: i64 = Register %31

Combining: t12: i64 = Register %31

Legalizing: t10: i64 = Register %32

Combining: t10: i64 = Register %32

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Combining: t8: i64 = Constant<0>

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Combining: t2: i64 = Constant<1>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.16 'main:._crit_edge109'
SelectionDAG has 57 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %31
  t31: i64,ch = CopyFromReg t0, Register:i64 %8
  t34: i64 = shl t31, Constant:i8<3>
        t15: ch = store<(store (s64) into %ir.43)> t77, t13, t82, undef:i64
          t84: i64 = add t74, Constant:i64<-40>
        t18: ch = store<(store (s64) into %ir..repack72)> t77, t13, t84, undef:i64
          t86: i64 = add t74, Constant:i64<-32>
        t21: ch = store<(store (s64) into %ir..repack74)> t77, Constant:i64<0>, t86, undef:i64
          t25: i64,ch = CopyFromReg t0, Register:i64 %7
          t88: i64 = add t74, Constant:i64<-24>
        t26: ch = store<(store (s64) into %ir..repack76)> t77, t25, t88, undef:i64
          t90: i64 = add t74, Constant:i64<-16>
        t63: ch = store<(store (s64) into %ir..repack78)> t77, Constant:i64<1>, t90, undef:i64
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
  t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34
    t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
  t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
  t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1
    t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
  t82: i64 = add t74, Constant:i64<-48>
        t11: ch = CopyToReg t0, Register:i64 %32, t82
        t36: ch = CopyToReg t0, Register:i64 %33, t34
        t48: ch = CopyToReg t0, Register:i64 %34, t46
      t53: ch = TokenFactor t11, t36, t48, t46:1
      t69: i32 = X86ISD::CMP t31, Constant:i64<0>
    t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge112 0x7fee5905be00>, TargetConstant:i8<14>, t69
  t57: ch = br t71, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>


===== Instruction selection begins: %bb.16 '._crit_edge109'

ISEL: Starting selection on root node: t57: ch = br t71, BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>
ISEL: Starting pattern match
  Initial Opcode index to 134414
  Morphed node: t57: ch = JMP_1 BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>, t71
ISEL: Match complete!

ISEL: Starting selection on root node: t71: ch = X86ISD::BRCOND t53, BasicBlock:ch<._crit_edge112 0x7fee5905be00>, TargetConstant:i8<14>, t69
ISEL: Starting pattern match
  Initial Opcode index to 131614
Creating new node: t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  Morphed node: t71: ch = JCC_1 BasicBlock:ch<._crit_edge112 0x7fee5905be00>, TargetConstant:i8<14>, t92, t92:1
ISEL: Match complete!

ISEL: Starting selection on root node: t53: ch = TokenFactor t11, t36, t48, t46:1

ISEL: Starting selection on root node: t48: ch = CopyToReg t0, Register:i64 %34, t46

ISEL: Starting selection on root node: t46: i64,ch,glue = CopyFromReg t44, Register:i64 $rax, t44:1

ISEL: Starting selection on root node: t44: ch,glue = callseq_end t43, TargetConstant:i64<0>, TargetConstant:i64<0>, t43:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
ISEL: Match complete!

ISEL: Starting selection on root node: t43: ch,glue = X86ISD::CALL t41, t80, Register:i64 $rdi, RegisterMask:Untyped, t41:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
ISEL: Match complete!

ISEL: Starting selection on root node: t41: ch,glue = CopyToReg t39, Register:i64 $rdi, t34

ISEL: Starting selection on root node: t39: ch,glue = callseq_start t64, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t93: i32 = TargetConstant<0>
  Morphed node: t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
ISEL: Match complete!

ISEL: Starting selection on root node: t64: ch = TokenFactor t15, t18, t21, t26, t63

ISEL: Starting selection on root node: t15: ch = store<(store (s64) into %ir.43)> t77, t13, t82, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t94: i8 = TargetConstant<1>
Creating constant: t96: i32 = TargetConstant<-48>
  Morphed node: t15: ch = MOV64mr<Mem:(store (s64) into %ir.43)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch = store<(store (s64) into %ir..repack72)> t77, t13, t84, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t98: i32 = TargetConstant<-40>
  Morphed node: t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack72)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = store<(store (s64) into %ir..repack74)> t77, Constant:i64<0>, t86, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Skipped scope entry (due to false predicate) at index 16132, continuing at 16162
  Skipped scope entry (due to false predicate) at index 16163, continuing at 16193
  Match failed at index 16203
  Continuing at 16224
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t99: i32 = TargetConstant<-32>
  Morphed node: t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack74)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t26: ch = store<(store (s64) into %ir..repack76)> t77, t25, t88, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t100: i32 = TargetConstant<-24>
  Morphed node: t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack76)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t63: ch = store<(store (s64) into %ir..repack78)> t77, Constant:i64<1>, t90, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t101: i32 = TargetConstant<-16>
Creating constant: t102: i64 = TargetConstant<1>
  Morphed node: t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack78)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t77: ch,glue = callseq_end t76, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
ISEL: Match complete!

ISEL: Starting selection on root node: t11: ch = CopyToReg t0, Register:i64 %32, t82

ISEL: Starting selection on root node: t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

ISEL: Starting selection on root node: t82: i64 = add t74, Constant:i64<-48>
ISEL: Starting pattern match
  Initial Opcode index to 102161
  Match failed at index 102165
  Continuing at 102268
  Match failed at index 102270
  Continuing at 102377
  TypeSwitch[i64] from 102379 to 102420
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t74: i64,ch = CopyFromReg t72, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 102420
  Continuing at 102435
  Match failed at index 102438
  Continuing at 102459
  Match failed at index 102461
  Continuing at 102483
  Skipped scope entry (due to false predicate) at index 102488, continuing at 102540
  Skipped scope entry (due to false predicate) at index 102541, continuing at 102593
  Skipped scope entry (due to false predicate) at index 102594, continuing at 102644
  Skipped scope entry (due to false predicate) at index 102645, continuing at 102669
  Match failed at index 102683
  Continuing at 102696
  Match failed at index 102700
  Continuing at 102713
Creating constant: t104: i64 = TargetConstant<-48>
  Morphed node: t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
ISEL: Match complete!

ISEL: Starting selection on root node: t36: ch = CopyToReg t0, Register:i64 %33, t34

ISEL: Starting selection on root node: t74: i64,ch = CopyFromReg t72, Register:i64 $rsp

ISEL: Starting selection on root node: t34: i64 = shl t31, Constant:i8<3>
ISEL: Starting pattern match
  Initial Opcode index to 44725
  Match failed at index 44729
  Continuing at 44944
  TypeSwitch[i64] from 44946 to 44987
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 44987
  Continuing at 45002
  Match failed at index 45009
  Continuing at 45152
  Match failed at index 45153
  Continuing at 45203
  TypeSwitch[i64] from 45215 to 45257
Creating constant: t105: i8 = TargetConstant<3>
  Morphed node: t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t69: i32 = X86ISD::CMP t31, Constant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 25710
  Match failed at index 25714
  Continuing at 26614
  Skipped scope entry (due to false predicate) at index 26619, continuing at 26650
  Skipped scope entry (due to false predicate) at index 26651, continuing at 26682
  Skipped scope entry (due to false predicate) at index 26683, continuing at 26714
  Match failed at index 26718
  Continuing at 26746
  Continuing at 26747
  Match failed at index 26750
  Continuing at 27134
  Skipped scope entry (due to false predicate) at index 27139, continuing at 27203
  Skipped scope entry (due to false predicate) at index 27204, continuing at 27304
  Skipped scope entry (due to false predicate) at index 27305, continuing at 27405
  Morphed node: t69: i32 = TEST64rr t31, t31
ISEL: Match complete!

ISEL: Starting selection on root node: t80: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132007
  Match failed at index 132010
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t72: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t31: i64,ch = CopyFromReg t0, Register:i64 %8

ISEL: Starting selection on root node: t25: i64,ch = CopyFromReg t0, Register:i64 %7

ISEL: Starting selection on root node: t13: i64,ch = CopyFromReg t0, Register:i64 %31

ISEL: Starting selection on root node: t79: i64 = TargetGlobalAddress<ptr @malloc> 0

ISEL: Starting selection on root node: t73: i64 = Register $rsp

ISEL: Starting selection on root node: t70: i8 = TargetConstant<14>

ISEL: Starting selection on root node: t56: ch = BasicBlock<.lr.ph111.preheader 0x7fee5905bd00>

ISEL: Starting selection on root node: t54: ch = BasicBlock<._crit_edge112 0x7fee5905be00>

ISEL: Starting selection on root node: t47: i64 = Register %34

ISEL: Starting selection on root node: t45: i64 = Register $rax

ISEL: Starting selection on root node: t42: Untyped = RegisterMask

ISEL: Starting selection on root node: t40: i64 = Register $rdi

ISEL: Starting selection on root node: t38: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t35: i64 = Register %33

ISEL: Starting selection on root node: t30: i64 = Register %8

ISEL: Starting selection on root node: t24: i64 = Register %7

ISEL: Starting selection on root node: t12: i64 = Register %31

ISEL: Starting selection on root node: t10: i64 = Register %32

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.16 'main:._crit_edge109'
SelectionDAG has 59 nodes:
  t0: ch,glue = EntryToken
  t13: i64,ch = CopyFromReg t0, Register:i64 %31
  t31: i64,ch = CopyFromReg t0, Register:i64 %8
  t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>
    t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
  t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp
  t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>
    t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82
  t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76
        t15: ch = MOV64mr<Mem:(store (s64) into %ir.43)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1
        t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack72)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1
        t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack74)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1
          t25: i64,ch = CopyFromReg t0, Register:i64 %7
        t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack76)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1
        t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack78)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1
      t64: ch = TokenFactor t15, t18, t21, t26, t63
    t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64
  t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34
    t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0
  t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1
  t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1
  t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2
      t11: ch = CopyToReg t0, Register:i64 %32, t82
      t36: ch = CopyToReg t0, Register:i64 %33, t34
      t48: ch = CopyToReg t0, Register:i64 %34, t46
    t53: ch = TokenFactor t11, t36, t48, t46:1
    t69: i32 = TEST64rr t31, t31
  t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69
  t103: i32 = Register $noreg
    t71: ch = JCC_1 BasicBlock:ch<._crit_edge112 0x7fee5905be00>, TargetConstant:i8<14>, t92, t92:1
  t57: ch = JMP_1 BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>, t71


********** List Scheduling %bb.16 '._crit_edge109' **********
SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>, t71

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge112 0x7fee5905be00>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(4): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t69: i32 = TEST64rr t31, t31

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %8

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=1
    SU(6): Data Latency=1
SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(24): Ord  Latency=1 Barrier
    SU(23): Ord  Latency=1 Barrier
    SU(22): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(21): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(22): Data Latency=1
SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(5): Data Latency=1
    SU(23): Data Latency=1
SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(8): Ord  Latency=0 Barrier
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(20): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(9): Ord  Latency=1 Barrier
  Successors:
    SU(7): Ord  Latency=0 Barrier
SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack78)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

  # preds left       : 1
  # succs left       : 5
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(11): Ord  Latency=1 Barrier
  Successors:
    SU(9): Ord  Latency=1 Barrier
    SU(15): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(20): Ord  Latency=1 Barrier
SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 7
  Predecessors:
    SU(13): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
  Successors:
    SU(10): Ord  Latency=1 Barrier
SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(13): Data Latency=1
  Successors:
    SU(11): Data Latency=1
    SU(24): Data Latency=1
SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

  # preds left       : 1
  # succs left       : 7
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 9
  Predecessors:
    SU(14): Ord  Latency=1 Barrier
  Successors:
    SU(9): Data Latency=1
    SU(11): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
    SU(15): Data Latency=1
    SU(17): Data Latency=1
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(13): Ord  Latency=1 Barrier
SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack76)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(16): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %7

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(15): Data Latency=1
SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack74)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack72)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %31

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(18): Data Latency=1
    SU(20): Data Latency=1
SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.43)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(13): Data Latency=1
    SU(19): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(22): t48: ch = CopyToReg t0, Register:i64 %34, t46

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(23): t36: ch = CopyToReg t0, Register:i64 %33, t34

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>, t71


*** Scheduling [0]: SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>, t71


Examining Available:
Height 1: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge112 0x7fee5905be00>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


*** Scheduling [1]: SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge112 0x7fee5905be00>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69


Examining Available:
Height 1: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

Height 2: SU(2): t69: i32 = TEST64rr t31, t31


*** Scheduling [2]: SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1


Examining Available:
Height 2: SU(2): t69: i32 = TEST64rr t31, t31

Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %34, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %33, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


*** Scheduling [3]: SU(2): t69: i32 = TEST64rr t31, t31


Examining Available:
Height 3: SU(22): t48: ch = CopyToReg t0, Register:i64 %34, t46

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %33, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


*** Scheduling [4]: SU(22): t48: ch = CopyToReg t0, Register:i64 %34, t46


Examining Available:
Height 5: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %33, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


*** Scheduling [5]: SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1


Examining Available:
Height 6: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %33, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


*** Scheduling [6]: SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0


Examining Available:
Height 6: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %33, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


*** Scheduling [7]: SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64


Examining Available:
Height 7: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %33, t34

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


*** Scheduling [8]: SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63


Examining Available:
Height 3: SU(23): t36: ch = CopyToReg t0, Register:i64 %33, t34

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack78)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack76)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack74)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack72)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.43)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


*** Scheduling [9]: SU(23): t36: ch = CopyToReg t0, Register:i64 %33, t34


Examining Available:
Height 10: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack78)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack76)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack74)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack72)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.43)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


*** Scheduling [10]: SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>


Examining Available:
Height 11: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %8

Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack78)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack76)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack74)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack72)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.43)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


*** Scheduling [11]: SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %8


Examining Available:
Height 9: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack78)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack76)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack74)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack72)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.43)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


*** Scheduling [12]: SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack78)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1


Examining Available:
Height 9: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack76)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack74)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack72)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.43)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


*** Scheduling [13]: SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack76)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1


Examining Available:
Height 14: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %7

Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack74)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack72)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.43)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


*** Scheduling [14]: SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %7


Examining Available:
Height 9: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack74)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack72)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.43)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


*** Scheduling [15]: SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack74)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1


Examining Available:
Height 9: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack72)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.43)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


*** Scheduling [16]: SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack72)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 9: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.43)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


*** Scheduling [17]: SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.43)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1


Examining Available:
Height 18: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %31

Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [18]: SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %31


Examining Available:
Height 3: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82

Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [19]: SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82


Examining Available:
Height 18: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


*** Scheduling [20]: SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76


Examining Available:
Height 21: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


*** Scheduling [21]: SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82


Examining Available:
Height 22: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


*** Scheduling [22]: SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>


Examining Available:
Height 23: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


*** Scheduling [23]: SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp


Examining Available:
Height 24: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [24]: SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(14): t72: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(13): t74: i64,ch = CopyFromReg t72:1, Register:i64 $rsp

SU(12): t82: i64,i32 = ADD64ri8 t74, TargetConstant:i64<-48>

SU(11): t76: ch = CopyToReg t74:1, Register:i64 $rsp, t82

SU(10): t77: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t76

SU(24): t11: ch = CopyToReg t0, Register:i64 %32, t82

SU(19): t13: i64,ch = CopyFromReg t0, Register:i64 %31

SU(20): t15: ch = MOV64mr<Mem:(store (s64) into %ir.43)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t13, t77:1

SU(18): t18: ch = MOV64mr<Mem:(store (s64) into %ir..repack72)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t13, t77:1

SU(17): t21: ch = MOV64mi32<Mem:(store (s64) into %ir..repack74)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t77:1

SU(16): t25: i64,ch = CopyFromReg t0, Register:i64 %7

SU(15): t26: ch = MOV64mr<Mem:(store (s64) into %ir..repack76)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t25, t77:1

SU(9): t63: ch = MOV64mi32<Mem:(store (s64) into %ir..repack78)> t74, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t77:1

SU(3): t31: i64,ch = CopyFromReg t0, Register:i64 %8

SU(6): t34: i64,i32 = SHL64ri t31, TargetConstant:i8<3>

SU(23): t36: ch = CopyToReg t0, Register:i64 %33, t34

SU(8): t64: ch = TokenFactor t15, t18, t21, t26, t63

SU(7): t39: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t64

SU(21): t80: i64 = MOV64ri TargetGlobalAddress:i64<ptr @malloc> 0

SU(5): t46: i64,ch,glue = CopyFromReg t44:1, Register:i64 $rax, t44:2

    t41: ch,glue = CopyToReg t39:1, Register:i64 $rdi, t34

    t43: ch,glue = CALL64r t80, Register:i64 $rdi, RegisterMask:Untyped, t41, t41:1

    t44: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t43, t43:1

SU(22): t48: ch = CopyToReg t0, Register:i64 %34, t46

SU(2): t69: i32 = TEST64rr t31, t31

SU(4): t53: ch = TokenFactor t11, t36, t48, t46:1

SU(1): t71: ch = JCC_1 BasicBlock:ch<._crit_edge112 0x7fee5905be00>, TargetConstant:i8<14>, t92, t92:1

    t92: ch,glue = CopyToReg t53, Register:i32 $eflags, t69

SU(0): t57: ch = JMP_1 BasicBlock:ch<.lr.ph111.preheader 0x7fee5905bd00>, t71


Total amount of phi nodes to update: 0
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %34
Creating constant: t3: i8 = Constant<0>
Creating new node: t5: i64,ch = CopyFromReg t0, Register:i64 %33
Creating constant: t7: i64 = TargetConstant<0>
Creating new node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Creating new node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Creating new node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Creating new node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Initial selection DAG: %bb.17 'main:.lr.ph111.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
  t3: i8 = Constant<0>
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %34
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %33
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Combining: t13: Untyped = RegisterMask

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Combining: t11: i64 = Register $rsi

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Combining: t9: i64 = Register $rdi

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t7: i64 = TargetConstant<0>

Combining: t6: i64 = ExternalSymbol'__bzero'

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %33

Combining: t4: i64 = Register %33

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %34

Combining: t1: i64 = Register %34

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.17 'main:.lr.ph111.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %34
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %33
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


Legalizing node: t13: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t13: Untyped = RegisterMask

Legalizing node: t11: i64 = Register $rsi
Ignoring node results
Legally typed node: t11: i64 = Register $rsi

Legalizing node: t9: i64 = Register $rdi
Ignoring node results
Legally typed node: t9: i64 = Register $rdi

Legalizing node: t7: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t7: i64 = TargetConstant<0>

Legalizing node: t6: i64 = ExternalSymbol'__bzero'
Analyzing result type: i64
Legal result type
Legally typed node: t6: i64 = ExternalSymbol'__bzero'

Legalizing node: t4: i64 = Register %33
Ignoring node results
Legally typed node: t4: i64 = Register %33

Legalizing node: t1: i64 = Register %34
Ignoring node results
Legally typed node: t1: i64 = Register %34

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %34
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %34

Legalizing node: t5: i64,ch = CopyFromReg t0, Register:i64 %33
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t5: i64,ch = CopyFromReg t0, Register:i64 %33

Legalizing node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %34
Legal operand
Legally typed node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Analyzing operand: t5: i64,ch = CopyFromReg t0, Register:i64 %33
Legal operand
Analyzing operand: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal operand
Legally typed node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Analyzing operand: t6: i64 = ExternalSymbol'__bzero'
Legal operand
Analyzing operand: t13: Untyped = RegisterMask
Legal operand
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal operand
Legally typed node: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Analyzing operand: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal operand
Legally typed node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.17 'main:.lr.ph111.preheader'
SelectionDAG has 15 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %34
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %33
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
  t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, ExternalSymbol:i64'__bzero', Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %33
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %34
Legal node: nothing to do

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Legalizing: t6: i64 = ExternalSymbol'__bzero'
Trying custom legalization
Creating new node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Successfully custom legalized node
 ... replacing: t6: i64 = ExternalSymbol'__bzero'
     with:      t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t4: i64 = Register %33

Legalizing: t1: i64 = Register %34

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do
Legalized selection DAG: %bb.17 'main:.lr.ph111.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %34
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %33
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1



Legalizing: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
Legal node: nothing to do

Combining: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'

Legalizing: t16: i64 = TargetExternalSymbol'__bzero'
Legal node: nothing to do

Combining: t16: i64 = TargetExternalSymbol'__bzero'

Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Combining: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1

Legalizing: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
Legal node: nothing to do

Combining: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

Legalizing: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
Legal node: nothing to do

Combining: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

Legalizing: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i64,ch = CopyFromReg t0, Register:i64 %33
Legal node: nothing to do

Combining: t5: i64,ch = CopyFromReg t0, Register:i64 %33

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %34
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %34

Legalizing: t13: Untyped = RegisterMask
Legal node: nothing to do

Combining: t13: Untyped = RegisterMask

Legalizing: t11: i64 = Register $rsi

Combining: t11: i64 = Register $rsi

Legalizing: t9: i64 = Register $rdi

Combining: t9: i64 = Register $rdi

Legalizing: t7: i64 = TargetConstant<0>

Combining: t7: i64 = TargetConstant<0>

Legalizing: t4: i64 = Register %33

Combining: t4: i64 = Register %33

Legalizing: t1: i64 = Register %34

Combining: t1: i64 = Register %34

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.17 'main:.lr.ph111.preheader'
SelectionDAG has 16 nodes:
  t0: ch,glue = EntryToken
    t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t2: i64,ch = CopyFromReg t0, Register:i64 %34
  t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %33
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1


===== Instruction selection begins: %bb.17 '.lr.ph111.preheader'

ISEL: Starting selection on root node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch,glue = X86ISD::CALL t12, t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

ISEL: Starting selection on root node: t10: ch,glue = CopyToReg t8, Register:i64 $rdi, t2

ISEL: Starting selection on root node: t17: i64 = X86ISD::Wrapper TargetExternalSymbol:i64'__bzero'
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132022
  Match failed at index 132025
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
Creating constant: t18: i32 = TargetConstant<0>
  Morphed node: t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i64,ch = CopyFromReg t0, Register:i64 %33

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %34

ISEL: Starting selection on root node: t16: i64 = TargetExternalSymbol'__bzero'

ISEL: Starting selection on root node: t13: Untyped = RegisterMask

ISEL: Starting selection on root node: t11: i64 = Register $rsi

ISEL: Starting selection on root node: t9: i64 = Register $rdi

ISEL: Starting selection on root node: t7: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t4: i64 = Register %33

ISEL: Starting selection on root node: t1: i64 = Register %34

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.17 'main:.lr.ph111.preheader'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
    t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t2: i64,ch = CopyFromReg t0, Register:i64 %34
  t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2
    t5: i64,ch = CopyFromReg t0, Register:i64 %33
  t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1
    t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'
  t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1
  t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1


********** List Scheduling %bb.17 '.lr.ph111.preheader' **********
SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1

  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Data Latency=1
    SU(1): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %33

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %34

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1

Examining Available:
Height 0: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


*** Scheduling [0]: SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Examining Available:
Height 1: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %33

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %34

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [1]: SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'


Examining Available:
Height 1: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %33

Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %34

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [2]: SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %33


Examining Available:
Height 1: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %34

Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [3]: SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %34


Examining Available:
Height 1: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [4]: SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(3): t8: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(2): t2: i64,ch = CopyFromReg t0, Register:i64 %34

SU(1): t5: i64,ch = CopyFromReg t0, Register:i64 %33

SU(4): t17: i64 = MOV64ri TargetExternalSymbol:i64'__bzero'

SU(0): t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

    t10: ch,glue = CopyToReg t8:1, Register:i64 $rdi, t2

    t12: ch,glue = CopyToReg t10, Register:i64 $rsi, t5, t10:1

    t14: ch,glue = CALL64r t17, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t12, t12:1


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = Constant<1>
Creating constant: t2: i64 = Constant<1>
Creating constant: t3: i64 = Constant<40>
Creating constant: t4: i64 = Constant<15>
Creating constant: t5: i64 = Constant<55>
Creating constant: t6: i64 = Constant<-16>
Creating constant: t7: i64 = Constant<48>
Creating constant: t8: i64 = Constant<0>
Creating new node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Creating new node: t11: i64,ch = CopyFromReg t0, Register:i64 %34
Creating new node: t12: i64 = undef
Creating new node: t13: ch = store<(store (s64) into %ir.46)> t9:1, t11, t9, undef:i64
Creating constant: t14: i64 = Constant<8>
Creating new node: t15: i64 = add nuw t9, Constant:i64<8>
Creating new node: t16: ch = store<(store (s64) into %ir..repack81)> t13, t11, t15, undef:i64
Creating constant: t17: i64 = Constant<16>
Creating new node: t18: i64 = add nuw t9, Constant:i64<16>
Creating new node: t19: ch = store<(store (s64) into %ir..repack83)> t16, Constant:i64<0>, t18, undef:i64
Creating constant: t20: i64 = Constant<24>
Creating new node: t21: i64 = add nuw t9, Constant:i64<24>
Creating new node: t23: i64,ch = CopyFromReg t0, Register:i64 %8
Creating new node: t24: ch = store<(store (s64) into %ir..repack85)> t19, t23, t21, undef:i64
Creating constant: t25: i64 = Constant<32>
Creating new node: t26: i64 = add nuw t9, Constant:i64<32>
Creating new node: t27: ch = store<(store (s64) into %ir..repack87)> t24, Constant:i64<1>, t26, undef:i64
Creating constant: t29: i64 = Constant<3>
Creating constant: t30: i64 = Constant<-1>
Creating new node: t32: i64,ch = CopyFromReg t0, Register:i64 %11
Creating new node: t34: i64,ch = CopyFromReg t0, Register:i64 %14
Creating new node: t36: i64,ch = CopyFromReg t0, Register:i64 %17
Creating new node: t38: i64,ch = CopyFromReg t0, Register:i64 %20
Creating new node: t40: i64,ch = CopyFromReg t0, Register:i64 %23
Creating new node: t42: i64,ch = CopyFromReg t0, Register:i64 %26
Creating new node: t44: i64,ch = CopyFromReg t0, Register:i64 %29
Creating new node: t46: i64,ch = CopyFromReg t0, Register:i64 %32
Creating constant: t47: i64 = TargetConstant<144>
Creating constant: t48: i64 = TargetConstant<0>
Creating new node: t49: ch,glue = callseq_start t27, TargetConstant:i64<144>, TargetConstant:i64<0>
Creating new node: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Creating new node: t52: ch = store<(store (s64) into stack)> t49, t32, t51, undef:i64
Creating new node: t53: i64 = add t51, Constant:i64<8>
Creating new node: t54: ch = store<(store (s64) into stack + 8)> t49, Constant:i64<1>, t53, undef:i64
Creating new node: t55: i64 = add t51, Constant:i64<16>
Creating new node: t56: ch = store<(store (s64) into stack + 16)> t49, t34, t55, undef:i64
Creating new node: t57: i64 = add t51, Constant:i64<24>
Creating new node: t58: ch = store<(store (s64) into stack + 24)> t49, Constant:i64<1>, t57, undef:i64
Creating new node: t59: i64 = add t51, Constant:i64<32>
Creating new node: t60: ch = store<(store (s64) into stack + 32)> t49, t36, t59, undef:i64
Creating new node: t61: i64 = add t51, Constant:i64<40>
Creating new node: t62: ch = store<(store (s64) into stack + 40)> t49, Constant:i64<1>, t61, undef:i64
Creating new node: t63: i64 = add t51, Constant:i64<48>
Creating new node: t64: ch = store<(store (s64) into stack + 48)> t49, t38, t63, undef:i64
Creating constant: t65: i64 = Constant<56>
Creating new node: t66: i64 = add t51, Constant:i64<56>
Creating new node: t67: ch = store<(store (s64) into stack + 56)> t49, Constant:i64<1>, t66, undef:i64
Creating constant: t68: i64 = Constant<64>
Creating new node: t69: i64 = add t51, Constant:i64<64>
Creating new node: t70: ch = store<(store (s64) into stack + 64)> t49, t40, t69, undef:i64
Creating constant: t71: i64 = Constant<72>
Creating new node: t72: i64 = add t51, Constant:i64<72>
Creating new node: t73: ch = store<(store (s64) into stack + 72)> t49, Constant:i64<1>, t72, undef:i64
Creating constant: t74: i64 = Constant<80>
Creating new node: t75: i64 = add t51, Constant:i64<80>
Creating new node: t76: ch = store<(store (s64) into stack + 80)> t49, t42, t75, undef:i64
Creating constant: t77: i64 = Constant<88>
Creating new node: t78: i64 = add t51, Constant:i64<88>
Creating new node: t79: ch = store<(store (s64) into stack + 88)> t49, Constant:i64<1>, t78, undef:i64
Creating constant: t80: i64 = Constant<96>
Creating new node: t81: i64 = add t51, Constant:i64<96>
Creating new node: t82: ch = store<(store (s64) into stack + 96)> t49, t44, t81, undef:i64
Creating constant: t83: i64 = Constant<104>
Creating new node: t84: i64 = add t51, Constant:i64<104>
Creating new node: t85: ch = store<(store (s64) into stack + 104)> t49, Constant:i64<1>, t84, undef:i64
Creating constant: t86: i64 = Constant<112>
Creating new node: t87: i64 = add t51, Constant:i64<112>
Creating new node: t88: ch = store<(store (s64) into stack + 112)> t49, t46, t87, undef:i64
Creating constant: t89: i64 = Constant<120>
Creating new node: t90: i64 = add t51, Constant:i64<120>
Creating new node: t91: ch = store<(store (s64) into stack + 120)> t49, Constant:i64<1>, t90, undef:i64
Creating constant: t92: i64 = Constant<128>
Creating new node: t93: i64 = add t51, Constant:i64<128>
Creating new node: t94: ch = store<(store (s64) into stack + 128)> t49, t9, t93, undef:i64
Creating constant: t95: i64 = Constant<136>
Creating new node: t96: i64 = add t51, Constant:i64<136>
Creating new node: t97: ch = store<(store (s32) into stack + 136)> t49, Constant:i32<1>, t96, undef:i64
Creating new node: t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97
Creating new node: t100: ch,glue = CopyToReg t98, Register:i32 $edi, Constant:i32<1>
Creating new node: t102: ch,glue = CopyToReg t100, Register:i64 $rsi, Constant:i64<0>, t100:1
Creating new node: t104: ch,glue = CopyToReg t102, Register:i64 $rdx, Constant:i64<3>, t102:1
Creating new node: t106: ch,glue = CopyToReg t104, Register:i64 $rcx, Constant:i64<0>, t104:1
Creating new node: t108: ch,glue = CopyToReg t106, Register:i64 $r8, Constant:i64<-1>, t106:1
Creating new node: t110: ch,glue = CopyToReg t108, Register:i64 $r9, Constant:i64<1>, t108:1
Creating new node: t112: ch,glue = X86ISD::CALL t110, GlobalAddress:i64<ptr @read_input_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110:1
Creating new node: t113: ch,glue = callseq_end t112, TargetConstant:i64<144>, TargetConstant:i64<0>, t112:1
Creating new node: t115: ch,glue = callseq_start t113, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t117: ch,glue = CopyToReg t115, Register:i64 $rdi, Constant:i64<1>
Creating new node: t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1
Creating new node: t119: ch,glue = X86ISD::CALL t118, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118:1
Creating new node: t120: ch,glue = callseq_end t119, TargetConstant:i64<0>, TargetConstant:i64<0>, t119:1
Creating new node: t121: ch,glue = callseq_start t120, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t122: ch,glue = CopyToReg t121, Register:i64 $rdi, Constant:i64<1>
Creating new node: t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1
Creating new node: t124: ch,glue = X86ISD::CALL t123, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123:1
Creating new node: t125: ch,glue = callseq_end t124, TargetConstant:i64<0>, TargetConstant:i64<0>, t124:1
Creating new node: t126: ch,glue = callseq_start t125, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t127: ch,glue = CopyToReg t126, Register:i64 $rdi, Constant:i64<1>
Creating new node: t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1
Creating new node: t129: ch,glue = X86ISD::CALL t128, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128:1
Creating new node: t130: ch,glue = callseq_end t129, TargetConstant:i64<0>, TargetConstant:i64<0>, t129:1
Creating new node: t131: ch,glue = callseq_start t130, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t132: ch,glue = CopyToReg t131, Register:i64 $rdi, Constant:i64<1>
Creating new node: t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1
Creating new node: t134: ch,glue = X86ISD::CALL t133, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133:1
Creating new node: t135: ch,glue = callseq_end t134, TargetConstant:i64<0>, TargetConstant:i64<0>, t134:1
Creating new node: t136: ch,glue = callseq_start t135, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t137: ch,glue = CopyToReg t136, Register:i64 $rdi, Constant:i64<1>
Creating new node: t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1
Creating new node: t139: ch,glue = X86ISD::CALL t138, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138:1
Creating new node: t140: ch,glue = callseq_end t139, TargetConstant:i64<0>, TargetConstant:i64<0>, t139:1
Creating new node: t141: ch,glue = callseq_start t140, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t142: ch,glue = CopyToReg t141, Register:i64 $rdi, Constant:i64<1>
Creating new node: t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1
Creating new node: t144: ch,glue = X86ISD::CALL t143, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143:1
Creating new node: t145: ch,glue = callseq_end t144, TargetConstant:i64<0>, TargetConstant:i64<0>, t144:1
Creating new node: t146: ch,glue = callseq_start t145, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t147: ch,glue = CopyToReg t146, Register:i64 $rdi, Constant:i64<1>
Creating new node: t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1
Creating new node: t149: ch,glue = X86ISD::CALL t148, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148:1
Creating new node: t150: ch,glue = callseq_end t149, TargetConstant:i64<0>, TargetConstant:i64<0>, t149:1
Creating new node: t151: ch,glue = callseq_start t150, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t152: ch,glue = CopyToReg t151, Register:i64 $rdi, Constant:i64<1>
Creating new node: t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1
Creating new node: t154: ch,glue = X86ISD::CALL t153, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153:1
Creating new node: t155: ch,glue = callseq_end t154, TargetConstant:i64<0>, TargetConstant:i64<0>, t154:1
Creating new node: t157: ch,glue = callseq_start t155, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t158: ch,glue = CopyToReg t157, Register:i64 $rdi, Constant:i64<1>
Creating new node: t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t9, t158:1
Creating new node: t160: ch,glue = X86ISD::CALL t159, GlobalAddress:i64<ptr @comet_print_memref_f64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159:1
Creating new node: t161: ch,glue = callseq_end t160, TargetConstant:i64<0>, TargetConstant:i64<0>, t160:1
Creating constant: t162: i32 = TargetConstant<0>
Creating new node: t163: ch = X86ISD::RET_FLAG t161, TargetConstant:i32<0>
Initial selection DAG: %bb.18 'main:._crit_edge112'
SelectionDAG has 164 nodes:
  t0: ch,glue = EntryToken
  t4: i64 = Constant<15>
  t5: i64 = Constant<55>
  t6: i64 = Constant<-16>
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t11: i64,ch = CopyFromReg t0, Register:i64 %34
  t32: i64,ch = CopyFromReg t0, Register:i64 %11
  t34: i64,ch = CopyFromReg t0, Register:i64 %14
  t36: i64,ch = CopyFromReg t0, Register:i64 %17
  t38: i64,ch = CopyFromReg t0, Register:i64 %20
  t40: i64,ch = CopyFromReg t0, Register:i64 %23
  t42: i64,ch = CopyFromReg t0, Register:i64 %26
  t44: i64,ch = CopyFromReg t0, Register:i64 %29
  t46: i64,ch = CopyFromReg t0, Register:i64 %32
            t13: ch = store<(store (s64) into %ir.46)> t9:1, t11, t9, undef:i64
            t15: i64 = add nuw t9, Constant:i64<8>
          t16: ch = store<(store (s64) into %ir..repack81)> t13, t11, t15, undef:i64
          t18: i64 = add nuw t9, Constant:i64<16>
        t19: ch = store<(store (s64) into %ir..repack83)> t16, Constant:i64<0>, t18, undef:i64
        t23: i64,ch = CopyFromReg t0, Register:i64 %8
        t21: i64 = add nuw t9, Constant:i64<24>
      t24: ch = store<(store (s64) into %ir..repack85)> t19, t23, t21, undef:i64
      t26: i64 = add nuw t9, Constant:i64<32>
    t27: ch = store<(store (s64) into %ir..repack87)> t24, Constant:i64<1>, t26, undef:i64
  t49: ch,glue = callseq_start t27, TargetConstant:i64<144>, TargetConstant:i64<0>
  t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
      t52: ch = store<(store (s64) into stack)> t49, t32, t51, undef:i64
        t53: i64 = add t51, Constant:i64<8>
      t54: ch = store<(store (s64) into stack + 8)> t49, Constant:i64<1>, t53, undef:i64
        t55: i64 = add t51, Constant:i64<16>
      t56: ch = store<(store (s64) into stack + 16)> t49, t34, t55, undef:i64
        t57: i64 = add t51, Constant:i64<24>
      t58: ch = store<(store (s64) into stack + 24)> t49, Constant:i64<1>, t57, undef:i64
        t59: i64 = add t51, Constant:i64<32>
      t60: ch = store<(store (s64) into stack + 32)> t49, t36, t59, undef:i64
        t61: i64 = add t51, Constant:i64<40>
      t62: ch = store<(store (s64) into stack + 40)> t49, Constant:i64<1>, t61, undef:i64
        t63: i64 = add t51, Constant:i64<48>
      t64: ch = store<(store (s64) into stack + 48)> t49, t38, t63, undef:i64
        t66: i64 = add t51, Constant:i64<56>
      t67: ch = store<(store (s64) into stack + 56)> t49, Constant:i64<1>, t66, undef:i64
        t69: i64 = add t51, Constant:i64<64>
      t70: ch = store<(store (s64) into stack + 64)> t49, t40, t69, undef:i64
        t72: i64 = add t51, Constant:i64<72>
      t73: ch = store<(store (s64) into stack + 72)> t49, Constant:i64<1>, t72, undef:i64
        t75: i64 = add t51, Constant:i64<80>
      t76: ch = store<(store (s64) into stack + 80)> t49, t42, t75, undef:i64
        t78: i64 = add t51, Constant:i64<88>
      t79: ch = store<(store (s64) into stack + 88)> t49, Constant:i64<1>, t78, undef:i64
        t81: i64 = add t51, Constant:i64<96>
      t82: ch = store<(store (s64) into stack + 96)> t49, t44, t81, undef:i64
        t84: i64 = add t51, Constant:i64<104>
      t85: ch = store<(store (s64) into stack + 104)> t49, Constant:i64<1>, t84, undef:i64
        t87: i64 = add t51, Constant:i64<112>
      t88: ch = store<(store (s64) into stack + 112)> t49, t46, t87, undef:i64
        t90: i64 = add t51, Constant:i64<120>
      t91: ch = store<(store (s64) into stack + 120)> t49, Constant:i64<1>, t90, undef:i64
        t93: i64 = add t51, Constant:i64<128>
      t94: ch = store<(store (s64) into stack + 128)> t49, t9, t93, undef:i64
        t96: i64 = add t51, Constant:i64<136>
      t97: ch = store<(store (s32) into stack + 136)> t49, Constant:i32<1>, t96, undef:i64
    t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97
  t100: ch,glue = CopyToReg t98, Register:i32 $edi, Constant:i32<1>
  t102: ch,glue = CopyToReg t100, Register:i64 $rsi, Constant:i64<0>, t100:1
  t104: ch,glue = CopyToReg t102, Register:i64 $rdx, Constant:i64<3>, t102:1
  t106: ch,glue = CopyToReg t104, Register:i64 $rcx, Constant:i64<0>, t104:1
  t108: ch,glue = CopyToReg t106, Register:i64 $r8, Constant:i64<-1>, t106:1
  t110: ch,glue = CopyToReg t108, Register:i64 $r9, Constant:i64<1>, t108:1
  t112: ch,glue = X86ISD::CALL t110, GlobalAddress:i64<ptr @read_input_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110:1
      t113: ch,glue = callseq_end t112, TargetConstant:i64<144>, TargetConstant:i64<0>, t112:1
    t115: ch,glue = callseq_start t113, TargetConstant:i64<0>, TargetConstant:i64<0>
  t117: ch,glue = CopyToReg t115, Register:i64 $rdi, Constant:i64<1>
  t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1
  t119: ch,glue = X86ISD::CALL t118, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118:1
      t120: ch,glue = callseq_end t119, TargetConstant:i64<0>, TargetConstant:i64<0>, t119:1
    t121: ch,glue = callseq_start t120, TargetConstant:i64<0>, TargetConstant:i64<0>
  t122: ch,glue = CopyToReg t121, Register:i64 $rdi, Constant:i64<1>
  t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1
  t124: ch,glue = X86ISD::CALL t123, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123:1
      t125: ch,glue = callseq_end t124, TargetConstant:i64<0>, TargetConstant:i64<0>, t124:1
    t126: ch,glue = callseq_start t125, TargetConstant:i64<0>, TargetConstant:i64<0>
  t127: ch,glue = CopyToReg t126, Register:i64 $rdi, Constant:i64<1>
  t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1
  t129: ch,glue = X86ISD::CALL t128, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128:1
      t130: ch,glue = callseq_end t129, TargetConstant:i64<0>, TargetConstant:i64<0>, t129:1
    t131: ch,glue = callseq_start t130, TargetConstant:i64<0>, TargetConstant:i64<0>
  t132: ch,glue = CopyToReg t131, Register:i64 $rdi, Constant:i64<1>
  t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1
  t134: ch,glue = X86ISD::CALL t133, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133:1
      t135: ch,glue = callseq_end t134, TargetConstant:i64<0>, TargetConstant:i64<0>, t134:1
    t136: ch,glue = callseq_start t135, TargetConstant:i64<0>, TargetConstant:i64<0>
  t137: ch,glue = CopyToReg t136, Register:i64 $rdi, Constant:i64<1>
  t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1
  t139: ch,glue = X86ISD::CALL t138, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138:1
      t140: ch,glue = callseq_end t139, TargetConstant:i64<0>, TargetConstant:i64<0>, t139:1
    t141: ch,glue = callseq_start t140, TargetConstant:i64<0>, TargetConstant:i64<0>
  t142: ch,glue = CopyToReg t141, Register:i64 $rdi, Constant:i64<1>
  t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1
  t144: ch,glue = X86ISD::CALL t143, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143:1
      t145: ch,glue = callseq_end t144, TargetConstant:i64<0>, TargetConstant:i64<0>, t144:1
    t146: ch,glue = callseq_start t145, TargetConstant:i64<0>, TargetConstant:i64<0>
  t147: ch,glue = CopyToReg t146, Register:i64 $rdi, Constant:i64<1>
  t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1
  t149: ch,glue = X86ISD::CALL t148, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148:1
      t150: ch,glue = callseq_end t149, TargetConstant:i64<0>, TargetConstant:i64<0>, t149:1
    t151: ch,glue = callseq_start t150, TargetConstant:i64<0>, TargetConstant:i64<0>
  t152: ch,glue = CopyToReg t151, Register:i64 $rdi, Constant:i64<1>
  t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1
  t154: ch,glue = X86ISD::CALL t153, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153:1
      t155: ch,glue = callseq_end t154, TargetConstant:i64<0>, TargetConstant:i64<0>, t154:1
    t157: ch,glue = callseq_start t155, TargetConstant:i64<0>, TargetConstant:i64<0>
  t158: ch,glue = CopyToReg t157, Register:i64 $rdi, Constant:i64<1>
  t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t9, t158:1
  t160: ch,glue = X86ISD::CALL t159, GlobalAddress:i64<ptr @comet_print_memref_f64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159:1
    t161: ch,glue = callseq_end t160, TargetConstant:i64<0>, TargetConstant:i64<0>, t160:1
  t163: ch = X86ISD::RET_FLAG t161, TargetConstant:i32<0>



Combining: t163: ch = X86ISD::RET_FLAG t161, TargetConstant:i32<0>

Combining: t162: i32 = TargetConstant<0>

Combining: t161: ch,glue = callseq_end t160, TargetConstant:i64<0>, TargetConstant:i64<0>, t160:1

Combining: t160: ch,glue = X86ISD::CALL t159, GlobalAddress:i64<ptr @comet_print_memref_f64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159:1

Combining: t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t9, t158:1

Combining: t158: ch,glue = CopyToReg t157, Register:i64 $rdi, Constant:i64<1>

Combining: t157: ch,glue = callseq_start t155, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t156: i64 = GlobalAddress<ptr @comet_print_memref_f64> 0

Combining: t155: ch,glue = callseq_end t154, TargetConstant:i64<0>, TargetConstant:i64<0>, t154:1

Combining: t154: ch,glue = X86ISD::CALL t153, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153:1

Combining: t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1

Combining: t152: ch,glue = CopyToReg t151, Register:i64 $rdi, Constant:i64<1>

Combining: t151: ch,glue = callseq_start t150, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t150: ch,glue = callseq_end t149, TargetConstant:i64<0>, TargetConstant:i64<0>, t149:1

Combining: t149: ch,glue = X86ISD::CALL t148, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148:1

Combining: t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1

Combining: t147: ch,glue = CopyToReg t146, Register:i64 $rdi, Constant:i64<1>

Combining: t146: ch,glue = callseq_start t145, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t145: ch,glue = callseq_end t144, TargetConstant:i64<0>, TargetConstant:i64<0>, t144:1

Combining: t144: ch,glue = X86ISD::CALL t143, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143:1

Combining: t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1

Combining: t142: ch,glue = CopyToReg t141, Register:i64 $rdi, Constant:i64<1>

Combining: t141: ch,glue = callseq_start t140, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t140: ch,glue = callseq_end t139, TargetConstant:i64<0>, TargetConstant:i64<0>, t139:1

Combining: t139: ch,glue = X86ISD::CALL t138, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138:1

Combining: t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1

Combining: t137: ch,glue = CopyToReg t136, Register:i64 $rdi, Constant:i64<1>

Combining: t136: ch,glue = callseq_start t135, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t135: ch,glue = callseq_end t134, TargetConstant:i64<0>, TargetConstant:i64<0>, t134:1

Combining: t134: ch,glue = X86ISD::CALL t133, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133:1

Combining: t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1

Combining: t132: ch,glue = CopyToReg t131, Register:i64 $rdi, Constant:i64<1>

Combining: t131: ch,glue = callseq_start t130, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t130: ch,glue = callseq_end t129, TargetConstant:i64<0>, TargetConstant:i64<0>, t129:1

Combining: t129: ch,glue = X86ISD::CALL t128, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128:1

Combining: t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1

Combining: t127: ch,glue = CopyToReg t126, Register:i64 $rdi, Constant:i64<1>

Combining: t126: ch,glue = callseq_start t125, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t125: ch,glue = callseq_end t124, TargetConstant:i64<0>, TargetConstant:i64<0>, t124:1

Combining: t124: ch,glue = X86ISD::CALL t123, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123:1

Combining: t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1

Combining: t122: ch,glue = CopyToReg t121, Register:i64 $rdi, Constant:i64<1>

Combining: t121: ch,glue = callseq_start t120, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t120: ch,glue = callseq_end t119, TargetConstant:i64<0>, TargetConstant:i64<0>, t119:1

Combining: t119: ch,glue = X86ISD::CALL t118, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118:1

Combining: t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1

Combining: t117: ch,glue = CopyToReg t115, Register:i64 $rdi, Constant:i64<1>

Combining: t116: i64 = Register $rdi

Combining: t115: ch,glue = callseq_start t113, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t114: i64 = GlobalAddress<ptr @comet_print_memref_i64> 0

Combining: t113: ch,glue = callseq_end t112, TargetConstant:i64<144>, TargetConstant:i64<0>, t112:1

Combining: t112: ch,glue = X86ISD::CALL t110, GlobalAddress:i64<ptr @read_input_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110:1

Combining: t111: Untyped = RegisterMask

Combining: t110: ch,glue = CopyToReg t108, Register:i64 $r9, Constant:i64<1>, t108:1

Combining: t109: i64 = Register $r9

Combining: t108: ch,glue = CopyToReg t106, Register:i64 $r8, Constant:i64<-1>, t106:1

Combining: t107: i64 = Register $r8

Combining: t106: ch,glue = CopyToReg t104, Register:i64 $rcx, Constant:i64<0>, t104:1

Combining: t105: i64 = Register $rcx

Combining: t104: ch,glue = CopyToReg t102, Register:i64 $rdx, Constant:i64<3>, t102:1

Combining: t103: i64 = Register $rdx

Combining: t102: ch,glue = CopyToReg t100, Register:i64 $rsi, Constant:i64<0>, t100:1

Combining: t101: i64 = Register $rsi

Combining: t100: ch,glue = CopyToReg t98, Register:i32 $edi, Constant:i32<1>

Combining: t99: i32 = Register $edi

Combining: t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97

Combining: t97: ch = store<(store (s32) into stack + 136)> t49, Constant:i32<1>, t96, undef:i64

Combining: t96: i64 = add t51, Constant:i64<136>

Combining: t95: i64 = Constant<136>

Combining: t94: ch = store<(store (s64) into stack + 128)> t49, t9, t93, undef:i64

Combining: t93: i64 = add t51, Constant:i64<128>

Combining: t92: i64 = Constant<128>

Combining: t91: ch = store<(store (s64) into stack + 120)> t49, Constant:i64<1>, t90, undef:i64

Combining: t90: i64 = add t51, Constant:i64<120>

Combining: t89: i64 = Constant<120>

Combining: t88: ch = store<(store (s64) into stack + 112)> t49, t46, t87, undef:i64

Combining: t87: i64 = add t51, Constant:i64<112>

Combining: t86: i64 = Constant<112>

Combining: t85: ch = store<(store (s64) into stack + 104)> t49, Constant:i64<1>, t84, undef:i64

Combining: t84: i64 = add t51, Constant:i64<104>

Combining: t83: i64 = Constant<104>

Combining: t82: ch = store<(store (s64) into stack + 96)> t49, t44, t81, undef:i64

Combining: t81: i64 = add t51, Constant:i64<96>

Combining: t80: i64 = Constant<96>

Combining: t79: ch = store<(store (s64) into stack + 88)> t49, Constant:i64<1>, t78, undef:i64

Combining: t78: i64 = add t51, Constant:i64<88>

Combining: t77: i64 = Constant<88>

Combining: t76: ch = store<(store (s64) into stack + 80)> t49, t42, t75, undef:i64

Combining: t75: i64 = add t51, Constant:i64<80>

Combining: t74: i64 = Constant<80>

Combining: t73: ch = store<(store (s64) into stack + 72)> t49, Constant:i64<1>, t72, undef:i64

Combining: t72: i64 = add t51, Constant:i64<72>

Combining: t71: i64 = Constant<72>

Combining: t70: ch = store<(store (s64) into stack + 64)> t49, t40, t69, undef:i64

Combining: t69: i64 = add t51, Constant:i64<64>

Combining: t68: i64 = Constant<64>

Combining: t67: ch = store<(store (s64) into stack + 56)> t49, Constant:i64<1>, t66, undef:i64

Combining: t66: i64 = add t51, Constant:i64<56>

Combining: t65: i64 = Constant<56>

Combining: t64: ch = store<(store (s64) into stack + 48)> t49, t38, t63, undef:i64

Combining: t63: i64 = add t51, Constant:i64<48>

Combining: t62: ch = store<(store (s64) into stack + 40)> t49, Constant:i64<1>, t61, undef:i64

Combining: t61: i64 = add t51, Constant:i64<40>

Combining: t60: ch = store<(store (s64) into stack + 32)> t49, t36, t59, undef:i64

Combining: t59: i64 = add t51, Constant:i64<32>

Combining: t58: ch = store<(store (s64) into stack + 24)> t49, Constant:i64<1>, t57, undef:i64

Combining: t57: i64 = add t51, Constant:i64<24>

Combining: t56: ch = store<(store (s64) into stack + 16)> t49, t34, t55, undef:i64

Combining: t55: i64 = add t51, Constant:i64<16>

Combining: t54: ch = store<(store (s64) into stack + 8)> t49, Constant:i64<1>, t53, undef:i64

Combining: t53: i64 = add t51, Constant:i64<8>

Combining: t52: ch = store<(store (s64) into stack)> t49, t32, t51, undef:i64

Combining: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp

Combining: t50: i64 = Register $rsp

Combining: t49: ch,glue = callseq_start t27, TargetConstant:i64<144>, TargetConstant:i64<0>

Combining: t48: i64 = TargetConstant<0>

Combining: t47: i64 = TargetConstant<144>

Combining: t46: i64,ch = CopyFromReg t0, Register:i64 %32

Combining: t45: i64 = Register %32

Combining: t44: i64,ch = CopyFromReg t0, Register:i64 %29

Combining: t43: i64 = Register %29

Combining: t42: i64,ch = CopyFromReg t0, Register:i64 %26

Combining: t41: i64 = Register %26

Combining: t40: i64,ch = CopyFromReg t0, Register:i64 %23

Combining: t39: i64 = Register %23

Combining: t38: i64,ch = CopyFromReg t0, Register:i64 %20

Combining: t37: i64 = Register %20

Combining: t36: i64,ch = CopyFromReg t0, Register:i64 %17

Combining: t35: i64 = Register %17

Combining: t34: i64,ch = CopyFromReg t0, Register:i64 %14

Combining: t33: i64 = Register %14

Combining: t32: i64,ch = CopyFromReg t0, Register:i64 %11

Combining: t31: i64 = Register %11

Combining: t30: i64 = Constant<-1>

Combining: t29: i64 = Constant<3>

Combining: t28: i64 = GlobalAddress<ptr @read_input_2D_f64> 0

Combining: t27: ch = store<(store (s64) into %ir..repack87)> t24, Constant:i64<1>, t26, undef:i64
Creating new node: t164: ch = store<(store (s64) into %ir..repack87)> t9:1, Constant:i64<1>, t26, undef:i64
Creating new node: t165: ch = TokenFactor t13, t16, t19, t24, t164

Replacing.1 t27: ch = store<(store (s64) into %ir..repack87)> t24, Constant:i64<1>, t26, undef:i64

With: t165: ch = TokenFactor t13, t16, t19, t24, t164
 and 0 other values

Combining: t164: ch = store<(store (s64) into %ir..repack87)> t9:1, Constant:i64<1>, t26, undef:i64

Combining: t165: ch = TokenFactor t13, t16, t19, t24, t164

Combining: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>

Combining: t26: i64 = add nuw t9, Constant:i64<32>

Combining: t25: i64 = Constant<32>

Combining: t24: ch = store<(store (s64) into %ir..repack85)> t9:1, t23, t21, undef:i64

Combining: t23: i64,ch = CopyFromReg t0, Register:i64 %8

Combining: t22: i64 = Register %8

Combining: t21: i64 = add nuw t9, Constant:i64<24>

Combining: t20: i64 = Constant<24>

Combining: t19: ch = store<(store (s64) into %ir..repack83)> t9:1, Constant:i64<0>, t18, undef:i64

Combining: t18: i64 = add nuw t9, Constant:i64<16>

Combining: t17: i64 = Constant<16>

Combining: t16: ch = store<(store (s64) into %ir..repack81)> t9:1, t11, t15, undef:i64

Combining: t15: i64 = add nuw t9, Constant:i64<8>

Combining: t14: i64 = Constant<8>

Combining: t13: ch = store<(store (s64) into %ir.46)> t9:1, t11, t9, undef:i64

Combining: t12: i64 = undef

Combining: t11: i64,ch = CopyFromReg t0, Register:i64 %34

Combining: t10: i64 = Register %34

Combining: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Combining: t8: i64 = Constant<0>

Combining: t7: i64 = Constant<48>

Combining: t3: i64 = Constant<40>

Combining: t2: i64 = Constant<1>

Combining: t1: i32 = Constant<1>

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.18 'main:._crit_edge112'
SelectionDAG has 162 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t11: i64,ch = CopyFromReg t0, Register:i64 %34
  t32: i64,ch = CopyFromReg t0, Register:i64 %11
  t34: i64,ch = CopyFromReg t0, Register:i64 %14
  t36: i64,ch = CopyFromReg t0, Register:i64 %17
  t38: i64,ch = CopyFromReg t0, Register:i64 %20
  t40: i64,ch = CopyFromReg t0, Register:i64 %23
  t42: i64,ch = CopyFromReg t0, Register:i64 %26
  t44: i64,ch = CopyFromReg t0, Register:i64 %29
  t46: i64,ch = CopyFromReg t0, Register:i64 %32
      t13: ch = store<(store (s64) into %ir.46)> t9:1, t11, t9, undef:i64
        t15: i64 = add nuw t9, Constant:i64<8>
      t16: ch = store<(store (s64) into %ir..repack81)> t9:1, t11, t15, undef:i64
        t18: i64 = add nuw t9, Constant:i64<16>
      t19: ch = store<(store (s64) into %ir..repack83)> t9:1, Constant:i64<0>, t18, undef:i64
        t23: i64,ch = CopyFromReg t0, Register:i64 %8
        t21: i64 = add nuw t9, Constant:i64<24>
      t24: ch = store<(store (s64) into %ir..repack85)> t9:1, t23, t21, undef:i64
        t26: i64 = add nuw t9, Constant:i64<32>
      t164: ch = store<(store (s64) into %ir..repack87)> t9:1, Constant:i64<1>, t26, undef:i64
    t165: ch = TokenFactor t13, t16, t19, t24, t164
  t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
  t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
      t52: ch = store<(store (s64) into stack)> t49, t32, t51, undef:i64
        t53: i64 = add t51, Constant:i64<8>
      t54: ch = store<(store (s64) into stack + 8)> t49, Constant:i64<1>, t53, undef:i64
        t55: i64 = add t51, Constant:i64<16>
      t56: ch = store<(store (s64) into stack + 16)> t49, t34, t55, undef:i64
        t57: i64 = add t51, Constant:i64<24>
      t58: ch = store<(store (s64) into stack + 24)> t49, Constant:i64<1>, t57, undef:i64
        t59: i64 = add t51, Constant:i64<32>
      t60: ch = store<(store (s64) into stack + 32)> t49, t36, t59, undef:i64
        t61: i64 = add t51, Constant:i64<40>
      t62: ch = store<(store (s64) into stack + 40)> t49, Constant:i64<1>, t61, undef:i64
        t63: i64 = add t51, Constant:i64<48>
      t64: ch = store<(store (s64) into stack + 48)> t49, t38, t63, undef:i64
        t66: i64 = add t51, Constant:i64<56>
      t67: ch = store<(store (s64) into stack + 56)> t49, Constant:i64<1>, t66, undef:i64
        t69: i64 = add t51, Constant:i64<64>
      t70: ch = store<(store (s64) into stack + 64)> t49, t40, t69, undef:i64
        t72: i64 = add t51, Constant:i64<72>
      t73: ch = store<(store (s64) into stack + 72)> t49, Constant:i64<1>, t72, undef:i64
        t75: i64 = add t51, Constant:i64<80>
      t76: ch = store<(store (s64) into stack + 80)> t49, t42, t75, undef:i64
        t78: i64 = add t51, Constant:i64<88>
      t79: ch = store<(store (s64) into stack + 88)> t49, Constant:i64<1>, t78, undef:i64
        t81: i64 = add t51, Constant:i64<96>
      t82: ch = store<(store (s64) into stack + 96)> t49, t44, t81, undef:i64
        t84: i64 = add t51, Constant:i64<104>
      t85: ch = store<(store (s64) into stack + 104)> t49, Constant:i64<1>, t84, undef:i64
        t87: i64 = add t51, Constant:i64<112>
      t88: ch = store<(store (s64) into stack + 112)> t49, t46, t87, undef:i64
        t90: i64 = add t51, Constant:i64<120>
      t91: ch = store<(store (s64) into stack + 120)> t49, Constant:i64<1>, t90, undef:i64
        t93: i64 = add t51, Constant:i64<128>
      t94: ch = store<(store (s64) into stack + 128)> t49, t9, t93, undef:i64
        t96: i64 = add t51, Constant:i64<136>
      t97: ch = store<(store (s32) into stack + 136)> t49, Constant:i32<1>, t96, undef:i64
    t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97
  t100: ch,glue = CopyToReg t98, Register:i32 $edi, Constant:i32<1>
  t102: ch,glue = CopyToReg t100, Register:i64 $rsi, Constant:i64<0>, t100:1
  t104: ch,glue = CopyToReg t102, Register:i64 $rdx, Constant:i64<3>, t102:1
  t106: ch,glue = CopyToReg t104, Register:i64 $rcx, Constant:i64<0>, t104:1
  t108: ch,glue = CopyToReg t106, Register:i64 $r8, Constant:i64<-1>, t106:1
  t110: ch,glue = CopyToReg t108, Register:i64 $r9, Constant:i64<1>, t108:1
  t112: ch,glue = X86ISD::CALL t110, GlobalAddress:i64<ptr @read_input_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110:1
      t113: ch,glue = callseq_end t112, TargetConstant:i64<144>, TargetConstant:i64<0>, t112:1
    t115: ch,glue = callseq_start t113, TargetConstant:i64<0>, TargetConstant:i64<0>
  t117: ch,glue = CopyToReg t115, Register:i64 $rdi, Constant:i64<1>
  t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1
  t119: ch,glue = X86ISD::CALL t118, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118:1
      t120: ch,glue = callseq_end t119, TargetConstant:i64<0>, TargetConstant:i64<0>, t119:1
    t121: ch,glue = callseq_start t120, TargetConstant:i64<0>, TargetConstant:i64<0>
  t122: ch,glue = CopyToReg t121, Register:i64 $rdi, Constant:i64<1>
  t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1
  t124: ch,glue = X86ISD::CALL t123, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123:1
      t125: ch,glue = callseq_end t124, TargetConstant:i64<0>, TargetConstant:i64<0>, t124:1
    t126: ch,glue = callseq_start t125, TargetConstant:i64<0>, TargetConstant:i64<0>
  t127: ch,glue = CopyToReg t126, Register:i64 $rdi, Constant:i64<1>
  t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1
  t129: ch,glue = X86ISD::CALL t128, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128:1
      t130: ch,glue = callseq_end t129, TargetConstant:i64<0>, TargetConstant:i64<0>, t129:1
    t131: ch,glue = callseq_start t130, TargetConstant:i64<0>, TargetConstant:i64<0>
  t132: ch,glue = CopyToReg t131, Register:i64 $rdi, Constant:i64<1>
  t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1
  t134: ch,glue = X86ISD::CALL t133, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133:1
      t135: ch,glue = callseq_end t134, TargetConstant:i64<0>, TargetConstant:i64<0>, t134:1
    t136: ch,glue = callseq_start t135, TargetConstant:i64<0>, TargetConstant:i64<0>
  t137: ch,glue = CopyToReg t136, Register:i64 $rdi, Constant:i64<1>
  t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1
  t139: ch,glue = X86ISD::CALL t138, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138:1
      t140: ch,glue = callseq_end t139, TargetConstant:i64<0>, TargetConstant:i64<0>, t139:1
    t141: ch,glue = callseq_start t140, TargetConstant:i64<0>, TargetConstant:i64<0>
  t142: ch,glue = CopyToReg t141, Register:i64 $rdi, Constant:i64<1>
  t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1
  t144: ch,glue = X86ISD::CALL t143, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143:1
      t145: ch,glue = callseq_end t144, TargetConstant:i64<0>, TargetConstant:i64<0>, t144:1
    t146: ch,glue = callseq_start t145, TargetConstant:i64<0>, TargetConstant:i64<0>
  t147: ch,glue = CopyToReg t146, Register:i64 $rdi, Constant:i64<1>
  t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1
  t149: ch,glue = X86ISD::CALL t148, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148:1
      t150: ch,glue = callseq_end t149, TargetConstant:i64<0>, TargetConstant:i64<0>, t149:1
    t151: ch,glue = callseq_start t150, TargetConstant:i64<0>, TargetConstant:i64<0>
  t152: ch,glue = CopyToReg t151, Register:i64 $rdi, Constant:i64<1>
  t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1
  t154: ch,glue = X86ISD::CALL t153, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153:1
      t155: ch,glue = callseq_end t154, TargetConstant:i64<0>, TargetConstant:i64<0>, t154:1
    t157: ch,glue = callseq_start t155, TargetConstant:i64<0>, TargetConstant:i64<0>
  t158: ch,glue = CopyToReg t157, Register:i64 $rdi, Constant:i64<1>
  t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t9, t158:1
  t160: ch,glue = X86ISD::CALL t159, GlobalAddress:i64<ptr @comet_print_memref_f64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159:1
    t161: ch,glue = callseq_end t160, TargetConstant:i64<0>, TargetConstant:i64<0>, t160:1
  t163: ch = X86ISD::RET_FLAG t161, TargetConstant:i32<0>


Legalizing node: t162: i32 = TargetConstant<0>
Ignoring node results
Legally typed node: t162: i32 = TargetConstant<0>

Legalizing node: t156: i64 = GlobalAddress<ptr @comet_print_memref_f64> 0
Analyzing result type: i64
Legal result type
Legally typed node: t156: i64 = GlobalAddress<ptr @comet_print_memref_f64> 0

Legalizing node: t116: i64 = Register $rdi
Ignoring node results
Legally typed node: t116: i64 = Register $rdi

Legalizing node: t114: i64 = GlobalAddress<ptr @comet_print_memref_i64> 0
Analyzing result type: i64
Legal result type
Legally typed node: t114: i64 = GlobalAddress<ptr @comet_print_memref_i64> 0

Legalizing node: t111: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t111: Untyped = RegisterMask

Legalizing node: t109: i64 = Register $r9
Ignoring node results
Legally typed node: t109: i64 = Register $r9

Legalizing node: t107: i64 = Register $r8
Ignoring node results
Legally typed node: t107: i64 = Register $r8

Legalizing node: t105: i64 = Register $rcx
Ignoring node results
Legally typed node: t105: i64 = Register $rcx

Legalizing node: t103: i64 = Register $rdx
Ignoring node results
Legally typed node: t103: i64 = Register $rdx

Legalizing node: t101: i64 = Register $rsi
Ignoring node results
Legally typed node: t101: i64 = Register $rsi

Legalizing node: t99: i32 = Register $edi
Ignoring node results
Legally typed node: t99: i32 = Register $edi

Legalizing node: t95: i64 = Constant<136>
Analyzing result type: i64
Legal result type
Legally typed node: t95: i64 = Constant<136>

Legalizing node: t92: i64 = Constant<128>
Analyzing result type: i64
Legal result type
Legally typed node: t92: i64 = Constant<128>

Legalizing node: t89: i64 = Constant<120>
Analyzing result type: i64
Legal result type
Legally typed node: t89: i64 = Constant<120>

Legalizing node: t86: i64 = Constant<112>
Analyzing result type: i64
Legal result type
Legally typed node: t86: i64 = Constant<112>

Legalizing node: t83: i64 = Constant<104>
Analyzing result type: i64
Legal result type
Legally typed node: t83: i64 = Constant<104>

Legalizing node: t80: i64 = Constant<96>
Analyzing result type: i64
Legal result type
Legally typed node: t80: i64 = Constant<96>

Legalizing node: t77: i64 = Constant<88>
Analyzing result type: i64
Legal result type
Legally typed node: t77: i64 = Constant<88>

Legalizing node: t74: i64 = Constant<80>
Analyzing result type: i64
Legal result type
Legally typed node: t74: i64 = Constant<80>

Legalizing node: t71: i64 = Constant<72>
Analyzing result type: i64
Legal result type
Legally typed node: t71: i64 = Constant<72>

Legalizing node: t68: i64 = Constant<64>
Analyzing result type: i64
Legal result type
Legally typed node: t68: i64 = Constant<64>

Legalizing node: t65: i64 = Constant<56>
Analyzing result type: i64
Legal result type
Legally typed node: t65: i64 = Constant<56>

Legalizing node: t50: i64 = Register $rsp
Ignoring node results
Legally typed node: t50: i64 = Register $rsp

Legalizing node: t48: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t48: i64 = TargetConstant<0>

Legalizing node: t47: i64 = TargetConstant<144>
Ignoring node results
Legally typed node: t47: i64 = TargetConstant<144>

Legalizing node: t45: i64 = Register %32
Ignoring node results
Legally typed node: t45: i64 = Register %32

Legalizing node: t43: i64 = Register %29
Ignoring node results
Legally typed node: t43: i64 = Register %29

Legalizing node: t41: i64 = Register %26
Ignoring node results
Legally typed node: t41: i64 = Register %26

Legalizing node: t39: i64 = Register %23
Ignoring node results
Legally typed node: t39: i64 = Register %23

Legalizing node: t37: i64 = Register %20
Ignoring node results
Legally typed node: t37: i64 = Register %20

Legalizing node: t35: i64 = Register %17
Ignoring node results
Legally typed node: t35: i64 = Register %17

Legalizing node: t33: i64 = Register %14
Ignoring node results
Legally typed node: t33: i64 = Register %14

Legalizing node: t31: i64 = Register %11
Ignoring node results
Legally typed node: t31: i64 = Register %11

Legalizing node: t30: i64 = Constant<-1>
Analyzing result type: i64
Legal result type
Legally typed node: t30: i64 = Constant<-1>

Legalizing node: t29: i64 = Constant<3>
Analyzing result type: i64
Legal result type
Legally typed node: t29: i64 = Constant<3>

Legalizing node: t28: i64 = GlobalAddress<ptr @read_input_2D_f64> 0
Analyzing result type: i64
Legal result type
Legally typed node: t28: i64 = GlobalAddress<ptr @read_input_2D_f64> 0

Legalizing node: t25: i64 = Constant<32>
Analyzing result type: i64
Legal result type
Legally typed node: t25: i64 = Constant<32>

Legalizing node: t22: i64 = Register %8
Ignoring node results
Legally typed node: t22: i64 = Register %8

Legalizing node: t20: i64 = Constant<24>
Analyzing result type: i64
Legal result type
Legally typed node: t20: i64 = Constant<24>

Legalizing node: t17: i64 = Constant<16>
Analyzing result type: i64
Legal result type
Legally typed node: t17: i64 = Constant<16>

Legalizing node: t14: i64 = Constant<8>
Analyzing result type: i64
Legal result type
Legally typed node: t14: i64 = Constant<8>

Legalizing node: t12: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t12: i64 = undef

Legalizing node: t10: i64 = Register %34
Ignoring node results
Legally typed node: t10: i64 = Register %34

Legalizing node: t8: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t8: i64 = Constant<0>

Legalizing node: t7: i64 = Constant<48>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<48>

Legalizing node: t3: i64 = Constant<40>
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = Constant<40>

Legalizing node: t2: i64 = Constant<1>
Analyzing result type: i64
Legal result type
Legally typed node: t2: i64 = Constant<1>

Legalizing node: t1: i32 = Constant<1>
Analyzing result type: i32
Legal result type
Legally typed node: t1: i32 = Constant<1>

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t7: i64 = Constant<48>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Legally typed node: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>

Legalizing node: t15: i64 = add nuw t9, Constant:i64<8>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t14: i64 = Constant<8>
Legal operand
Legally typed node: t15: i64 = add nuw t9, Constant:i64<8>

Legalizing node: t18: i64 = add nuw t9, Constant:i64<16>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t17: i64 = Constant<16>
Legal operand
Legally typed node: t18: i64 = add nuw t9, Constant:i64<16>

Legalizing node: t19: ch = store<(store (s64) into %ir..repack83)> t9:1, Constant:i64<0>, t18, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Analyzing operand: t18: i64 = add nuw t9, Constant:i64<16>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t19: ch = store<(store (s64) into %ir..repack83)> t9:1, Constant:i64<0>, t18, undef:i64

Legalizing node: t21: i64 = add nuw t9, Constant:i64<24>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t20: i64 = Constant<24>
Legal operand
Legally typed node: t21: i64 = add nuw t9, Constant:i64<24>

Legalizing node: t26: i64 = add nuw t9, Constant:i64<32>
Analyzing result type: i64
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t25: i64 = Constant<32>
Legal operand
Legally typed node: t26: i64 = add nuw t9, Constant:i64<32>

Legalizing node: t164: ch = store<(store (s64) into %ir..repack87)> t9:1, Constant:i64<1>, t26, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t26: i64 = add nuw t9, Constant:i64<32>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t164: ch = store<(store (s64) into %ir..repack87)> t9:1, Constant:i64<1>, t26, undef:i64

Legalizing node: t11: i64,ch = CopyFromReg t0, Register:i64 %34
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t11: i64,ch = CopyFromReg t0, Register:i64 %34

Legalizing node: t13: ch = store<(store (s64) into %ir.46)> t9:1, t11, t9, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t11: i64,ch = CopyFromReg t0, Register:i64 %34
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t13: ch = store<(store (s64) into %ir.46)> t9:1, t11, t9, undef:i64

Legalizing node: t16: ch = store<(store (s64) into %ir..repack81)> t9:1, t11, t15, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t11: i64,ch = CopyFromReg t0, Register:i64 %34
Legal operand
Analyzing operand: t15: i64 = add nuw t9, Constant:i64<8>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t16: ch = store<(store (s64) into %ir..repack81)> t9:1, t11, t15, undef:i64

Legalizing node: t23: i64,ch = CopyFromReg t0, Register:i64 %8
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t23: i64,ch = CopyFromReg t0, Register:i64 %8

Legalizing node: t24: ch = store<(store (s64) into %ir..repack85)> t9:1, t23, t21, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t23: i64,ch = CopyFromReg t0, Register:i64 %8
Legal operand
Analyzing operand: t21: i64 = add nuw t9, Constant:i64<24>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t24: ch = store<(store (s64) into %ir..repack85)> t9:1, t23, t21, undef:i64

Legalizing node: t165: ch = TokenFactor t13, t16, t19, t24, t164
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = store<(store (s64) into %ir.46)> t9:1, t11, t9, undef:i64
Legal operand
Analyzing operand: t16: ch = store<(store (s64) into %ir..repack81)> t9:1, t11, t15, undef:i64
Legal operand
Analyzing operand: t19: ch = store<(store (s64) into %ir..repack83)> t9:1, Constant:i64<0>, t18, undef:i64
Legal operand
Analyzing operand: t24: ch = store<(store (s64) into %ir..repack85)> t9:1, t23, t21, undef:i64
Legal operand
Analyzing operand: t164: ch = store<(store (s64) into %ir..repack87)> t9:1, Constant:i64<1>, t26, undef:i64
Legal operand
Legally typed node: t165: ch = TokenFactor t13, t16, t19, t24, t164

Legalizing node: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t165: ch = TokenFactor t13, t16, t19, t24, t164
Legal operand
Legally typed node: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>

Legalizing node: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Legally typed node: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp

Legalizing node: t53: i64 = add t51, Constant:i64<8>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t14: i64 = Constant<8>
Legal operand
Legally typed node: t53: i64 = add t51, Constant:i64<8>

Legalizing node: t54: ch = store<(store (s64) into stack + 8)> t49, Constant:i64<1>, t53, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t53: i64 = add t51, Constant:i64<8>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t54: ch = store<(store (s64) into stack + 8)> t49, Constant:i64<1>, t53, undef:i64

Legalizing node: t55: i64 = add t51, Constant:i64<16>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t17: i64 = Constant<16>
Legal operand
Legally typed node: t55: i64 = add t51, Constant:i64<16>

Legalizing node: t57: i64 = add t51, Constant:i64<24>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t20: i64 = Constant<24>
Legal operand
Legally typed node: t57: i64 = add t51, Constant:i64<24>

Legalizing node: t58: ch = store<(store (s64) into stack + 24)> t49, Constant:i64<1>, t57, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t57: i64 = add t51, Constant:i64<24>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t58: ch = store<(store (s64) into stack + 24)> t49, Constant:i64<1>, t57, undef:i64

Legalizing node: t59: i64 = add t51, Constant:i64<32>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t25: i64 = Constant<32>
Legal operand
Legally typed node: t59: i64 = add t51, Constant:i64<32>

Legalizing node: t61: i64 = add t51, Constant:i64<40>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t3: i64 = Constant<40>
Legal operand
Legally typed node: t61: i64 = add t51, Constant:i64<40>

Legalizing node: t62: ch = store<(store (s64) into stack + 40)> t49, Constant:i64<1>, t61, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t61: i64 = add t51, Constant:i64<40>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t62: ch = store<(store (s64) into stack + 40)> t49, Constant:i64<1>, t61, undef:i64

Legalizing node: t63: i64 = add t51, Constant:i64<48>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t7: i64 = Constant<48>
Legal operand
Legally typed node: t63: i64 = add t51, Constant:i64<48>

Legalizing node: t66: i64 = add t51, Constant:i64<56>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t65: i64 = Constant<56>
Legal operand
Legally typed node: t66: i64 = add t51, Constant:i64<56>

Legalizing node: t67: ch = store<(store (s64) into stack + 56)> t49, Constant:i64<1>, t66, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t66: i64 = add t51, Constant:i64<56>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t67: ch = store<(store (s64) into stack + 56)> t49, Constant:i64<1>, t66, undef:i64

Legalizing node: t69: i64 = add t51, Constant:i64<64>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t68: i64 = Constant<64>
Legal operand
Legally typed node: t69: i64 = add t51, Constant:i64<64>

Legalizing node: t72: i64 = add t51, Constant:i64<72>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t71: i64 = Constant<72>
Legal operand
Legally typed node: t72: i64 = add t51, Constant:i64<72>

Legalizing node: t73: ch = store<(store (s64) into stack + 72)> t49, Constant:i64<1>, t72, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t72: i64 = add t51, Constant:i64<72>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t73: ch = store<(store (s64) into stack + 72)> t49, Constant:i64<1>, t72, undef:i64

Legalizing node: t75: i64 = add t51, Constant:i64<80>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t74: i64 = Constant<80>
Legal operand
Legally typed node: t75: i64 = add t51, Constant:i64<80>

Legalizing node: t78: i64 = add t51, Constant:i64<88>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t77: i64 = Constant<88>
Legal operand
Legally typed node: t78: i64 = add t51, Constant:i64<88>

Legalizing node: t79: ch = store<(store (s64) into stack + 88)> t49, Constant:i64<1>, t78, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t78: i64 = add t51, Constant:i64<88>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t79: ch = store<(store (s64) into stack + 88)> t49, Constant:i64<1>, t78, undef:i64

Legalizing node: t81: i64 = add t51, Constant:i64<96>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t80: i64 = Constant<96>
Legal operand
Legally typed node: t81: i64 = add t51, Constant:i64<96>

Legalizing node: t84: i64 = add t51, Constant:i64<104>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t83: i64 = Constant<104>
Legal operand
Legally typed node: t84: i64 = add t51, Constant:i64<104>

Legalizing node: t85: ch = store<(store (s64) into stack + 104)> t49, Constant:i64<1>, t84, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t84: i64 = add t51, Constant:i64<104>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t85: ch = store<(store (s64) into stack + 104)> t49, Constant:i64<1>, t84, undef:i64

Legalizing node: t87: i64 = add t51, Constant:i64<112>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t86: i64 = Constant<112>
Legal operand
Legally typed node: t87: i64 = add t51, Constant:i64<112>

Legalizing node: t90: i64 = add t51, Constant:i64<120>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t89: i64 = Constant<120>
Legal operand
Legally typed node: t90: i64 = add t51, Constant:i64<120>

Legalizing node: t91: ch = store<(store (s64) into stack + 120)> t49, Constant:i64<1>, t90, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t90: i64 = add t51, Constant:i64<120>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t91: ch = store<(store (s64) into stack + 120)> t49, Constant:i64<1>, t90, undef:i64

Legalizing node: t93: i64 = add t51, Constant:i64<128>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t92: i64 = Constant<128>
Legal operand
Legally typed node: t93: i64 = add t51, Constant:i64<128>

Legalizing node: t94: ch = store<(store (s64) into stack + 128)> t49, t9, t93, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t93: i64 = add t51, Constant:i64<128>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t94: ch = store<(store (s64) into stack + 128)> t49, t9, t93, undef:i64

Legalizing node: t96: i64 = add t51, Constant:i64<136>
Analyzing result type: i64
Legal result type
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t95: i64 = Constant<136>
Legal operand
Legally typed node: t96: i64 = add t51, Constant:i64<136>

Legalizing node: t97: ch = store<(store (s32) into stack + 136)> t49, Constant:i32<1>, t96, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t1: i32 = Constant<1>
Legal operand
Analyzing operand: t96: i64 = add t51, Constant:i64<136>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t97: ch = store<(store (s32) into stack + 136)> t49, Constant:i32<1>, t96, undef:i64

Legalizing node: t32: i64,ch = CopyFromReg t0, Register:i64 %11
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t32: i64,ch = CopyFromReg t0, Register:i64 %11

Legalizing node: t52: ch = store<(store (s64) into stack)> t49, t32, t51, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t32: i64,ch = CopyFromReg t0, Register:i64 %11
Legal operand
Analyzing operand: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t52: ch = store<(store (s64) into stack)> t49, t32, t51, undef:i64

Legalizing node: t34: i64,ch = CopyFromReg t0, Register:i64 %14
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t34: i64,ch = CopyFromReg t0, Register:i64 %14

Legalizing node: t56: ch = store<(store (s64) into stack + 16)> t49, t34, t55, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t34: i64,ch = CopyFromReg t0, Register:i64 %14
Legal operand
Analyzing operand: t55: i64 = add t51, Constant:i64<16>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t56: ch = store<(store (s64) into stack + 16)> t49, t34, t55, undef:i64

Legalizing node: t36: i64,ch = CopyFromReg t0, Register:i64 %17
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t36: i64,ch = CopyFromReg t0, Register:i64 %17

Legalizing node: t60: ch = store<(store (s64) into stack + 32)> t49, t36, t59, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t36: i64,ch = CopyFromReg t0, Register:i64 %17
Legal operand
Analyzing operand: t59: i64 = add t51, Constant:i64<32>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t60: ch = store<(store (s64) into stack + 32)> t49, t36, t59, undef:i64

Legalizing node: t38: i64,ch = CopyFromReg t0, Register:i64 %20
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t38: i64,ch = CopyFromReg t0, Register:i64 %20

Legalizing node: t64: ch = store<(store (s64) into stack + 48)> t49, t38, t63, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t38: i64,ch = CopyFromReg t0, Register:i64 %20
Legal operand
Analyzing operand: t63: i64 = add t51, Constant:i64<48>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t64: ch = store<(store (s64) into stack + 48)> t49, t38, t63, undef:i64

Legalizing node: t40: i64,ch = CopyFromReg t0, Register:i64 %23
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t40: i64,ch = CopyFromReg t0, Register:i64 %23

Legalizing node: t70: ch = store<(store (s64) into stack + 64)> t49, t40, t69, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t40: i64,ch = CopyFromReg t0, Register:i64 %23
Legal operand
Analyzing operand: t69: i64 = add t51, Constant:i64<64>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t70: ch = store<(store (s64) into stack + 64)> t49, t40, t69, undef:i64

Legalizing node: t42: i64,ch = CopyFromReg t0, Register:i64 %26
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t42: i64,ch = CopyFromReg t0, Register:i64 %26

Legalizing node: t76: ch = store<(store (s64) into stack + 80)> t49, t42, t75, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t42: i64,ch = CopyFromReg t0, Register:i64 %26
Legal operand
Analyzing operand: t75: i64 = add t51, Constant:i64<80>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t76: ch = store<(store (s64) into stack + 80)> t49, t42, t75, undef:i64

Legalizing node: t44: i64,ch = CopyFromReg t0, Register:i64 %29
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t44: i64,ch = CopyFromReg t0, Register:i64 %29

Legalizing node: t82: ch = store<(store (s64) into stack + 96)> t49, t44, t81, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t44: i64,ch = CopyFromReg t0, Register:i64 %29
Legal operand
Analyzing operand: t81: i64 = add t51, Constant:i64<96>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t82: ch = store<(store (s64) into stack + 96)> t49, t44, t81, undef:i64

Legalizing node: t46: i64,ch = CopyFromReg t0, Register:i64 %32
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Legally typed node: t46: i64,ch = CopyFromReg t0, Register:i64 %32

Legalizing node: t88: ch = store<(store (s64) into stack + 112)> t49, t46, t87, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t46: i64,ch = CopyFromReg t0, Register:i64 %32
Legal operand
Analyzing operand: t87: i64 = add t51, Constant:i64<112>
Legal operand
Analyzing operand: t12: i64 = undef
Legal operand
Legally typed node: t88: ch = store<(store (s64) into stack + 112)> t49, t46, t87, undef:i64

Legalizing node: t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97
Analyzing result type: ch
Legal result type
Analyzing operand: t52: ch = store<(store (s64) into stack)> t49, t32, t51, undef:i64
Legal operand
Analyzing operand: t54: ch = store<(store (s64) into stack + 8)> t49, Constant:i64<1>, t53, undef:i64
Legal operand
Analyzing operand: t56: ch = store<(store (s64) into stack + 16)> t49, t34, t55, undef:i64
Legal operand
Analyzing operand: t58: ch = store<(store (s64) into stack + 24)> t49, Constant:i64<1>, t57, undef:i64
Legal operand
Analyzing operand: t60: ch = store<(store (s64) into stack + 32)> t49, t36, t59, undef:i64
Legal operand
Analyzing operand: t62: ch = store<(store (s64) into stack + 40)> t49, Constant:i64<1>, t61, undef:i64
Legal operand
Analyzing operand: t64: ch = store<(store (s64) into stack + 48)> t49, t38, t63, undef:i64
Legal operand
Analyzing operand: t67: ch = store<(store (s64) into stack + 56)> t49, Constant:i64<1>, t66, undef:i64
Legal operand
Analyzing operand: t70: ch = store<(store (s64) into stack + 64)> t49, t40, t69, undef:i64
Legal operand
Analyzing operand: t73: ch = store<(store (s64) into stack + 72)> t49, Constant:i64<1>, t72, undef:i64
Legal operand
Analyzing operand: t76: ch = store<(store (s64) into stack + 80)> t49, t42, t75, undef:i64
Legal operand
Analyzing operand: t79: ch = store<(store (s64) into stack + 88)> t49, Constant:i64<1>, t78, undef:i64
Legal operand
Analyzing operand: t82: ch = store<(store (s64) into stack + 96)> t49, t44, t81, undef:i64
Legal operand
Analyzing operand: t85: ch = store<(store (s64) into stack + 104)> t49, Constant:i64<1>, t84, undef:i64
Legal operand
Analyzing operand: t88: ch = store<(store (s64) into stack + 112)> t49, t46, t87, undef:i64
Legal operand
Analyzing operand: t91: ch = store<(store (s64) into stack + 120)> t49, Constant:i64<1>, t90, undef:i64
Legal operand
Analyzing operand: t94: ch = store<(store (s64) into stack + 128)> t49, t9, t93, undef:i64
Legal operand
Analyzing operand: t97: ch = store<(store (s32) into stack + 136)> t49, Constant:i32<1>, t96, undef:i64
Legal operand
Legally typed node: t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97

Legalizing node: t100: ch,glue = CopyToReg t98, Register:i32 $edi, Constant:i32<1>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97
Legal operand
Analyzing operand: t1: i32 = Constant<1>
Legal operand
Legally typed node: t100: ch,glue = CopyToReg t98, Register:i32 $edi, Constant:i32<1>

Legalizing node: t102: ch,glue = CopyToReg t100, Register:i64 $rsi, Constant:i64<0>, t100:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t100: ch,glue = CopyToReg t98, Register:i32 $edi, Constant:i32<1>
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Analyzing operand: t100: ch,glue = CopyToReg t98, Register:i32 $edi, Constant:i32<1>
Legal operand
Legally typed node: t102: ch,glue = CopyToReg t100, Register:i64 $rsi, Constant:i64<0>, t100:1

Legalizing node: t104: ch,glue = CopyToReg t102, Register:i64 $rdx, Constant:i64<3>, t102:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t102: ch,glue = CopyToReg t100, Register:i64 $rsi, Constant:i64<0>, t100:1
Legal operand
Analyzing operand: t29: i64 = Constant<3>
Legal operand
Analyzing operand: t102: ch,glue = CopyToReg t100, Register:i64 $rsi, Constant:i64<0>, t100:1
Legal operand
Legally typed node: t104: ch,glue = CopyToReg t102, Register:i64 $rdx, Constant:i64<3>, t102:1

Legalizing node: t106: ch,glue = CopyToReg t104, Register:i64 $rcx, Constant:i64<0>, t104:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t104: ch,glue = CopyToReg t102, Register:i64 $rdx, Constant:i64<3>, t102:1
Legal operand
Analyzing operand: t8: i64 = Constant<0>
Legal operand
Analyzing operand: t104: ch,glue = CopyToReg t102, Register:i64 $rdx, Constant:i64<3>, t102:1
Legal operand
Legally typed node: t106: ch,glue = CopyToReg t104, Register:i64 $rcx, Constant:i64<0>, t104:1

Legalizing node: t108: ch,glue = CopyToReg t106, Register:i64 $r8, Constant:i64<-1>, t106:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t106: ch,glue = CopyToReg t104, Register:i64 $rcx, Constant:i64<0>, t104:1
Legal operand
Analyzing operand: t30: i64 = Constant<-1>
Legal operand
Analyzing operand: t106: ch,glue = CopyToReg t104, Register:i64 $rcx, Constant:i64<0>, t104:1
Legal operand
Legally typed node: t108: ch,glue = CopyToReg t106, Register:i64 $r8, Constant:i64<-1>, t106:1

Legalizing node: t110: ch,glue = CopyToReg t108, Register:i64 $r9, Constant:i64<1>, t108:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t108: ch,glue = CopyToReg t106, Register:i64 $r8, Constant:i64<-1>, t106:1
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Analyzing operand: t108: ch,glue = CopyToReg t106, Register:i64 $r8, Constant:i64<-1>, t106:1
Legal operand
Legally typed node: t110: ch,glue = CopyToReg t108, Register:i64 $r9, Constant:i64<1>, t108:1

Legalizing node: t112: ch,glue = X86ISD::CALL t110, GlobalAddress:i64<ptr @read_input_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t110: ch,glue = CopyToReg t108, Register:i64 $r9, Constant:i64<1>, t108:1
Legal operand
Analyzing operand: t28: i64 = GlobalAddress<ptr @read_input_2D_f64> 0
Legal operand
Analyzing operand: t111: Untyped = RegisterMask
Legal operand
Analyzing operand: t110: ch,glue = CopyToReg t108, Register:i64 $r9, Constant:i64<1>, t108:1
Legal operand
Legally typed node: t112: ch,glue = X86ISD::CALL t110, GlobalAddress:i64<ptr @read_input_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110:1

Legalizing node: t113: ch,glue = callseq_end t112, TargetConstant:i64<144>, TargetConstant:i64<0>, t112:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t112: ch,glue = X86ISD::CALL t110, GlobalAddress:i64<ptr @read_input_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110:1
Legal operand
Analyzing operand: t112: ch,glue = X86ISD::CALL t110, GlobalAddress:i64<ptr @read_input_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110:1
Legal operand
Legally typed node: t113: ch,glue = callseq_end t112, TargetConstant:i64<144>, TargetConstant:i64<0>, t112:1

Legalizing node: t115: ch,glue = callseq_start t113, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t113: ch,glue = callseq_end t112, TargetConstant:i64<144>, TargetConstant:i64<0>, t112:1
Legal operand
Legally typed node: t115: ch,glue = callseq_start t113, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t117: ch,glue = CopyToReg t115, Register:i64 $rdi, Constant:i64<1>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t115: ch,glue = callseq_start t113, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Legally typed node: t117: ch,glue = CopyToReg t115, Register:i64 $rdi, Constant:i64<1>

Legalizing node: t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t117: ch,glue = CopyToReg t115, Register:i64 $rdi, Constant:i64<1>
Legal operand
Analyzing operand: t32: i64,ch = CopyFromReg t0, Register:i64 %11
Legal operand
Analyzing operand: t117: ch,glue = CopyToReg t115, Register:i64 $rdi, Constant:i64<1>
Legal operand
Legally typed node: t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1

Legalizing node: t119: ch,glue = X86ISD::CALL t118, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1
Legal operand
Analyzing operand: t114: i64 = GlobalAddress<ptr @comet_print_memref_i64> 0
Legal operand
Analyzing operand: t111: Untyped = RegisterMask
Legal operand
Analyzing operand: t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1
Legal operand
Legally typed node: t119: ch,glue = X86ISD::CALL t118, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118:1

Legalizing node: t120: ch,glue = callseq_end t119, TargetConstant:i64<0>, TargetConstant:i64<0>, t119:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t119: ch,glue = X86ISD::CALL t118, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118:1
Legal operand
Analyzing operand: t119: ch,glue = X86ISD::CALL t118, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118:1
Legal operand
Legally typed node: t120: ch,glue = callseq_end t119, TargetConstant:i64<0>, TargetConstant:i64<0>, t119:1

Legalizing node: t121: ch,glue = callseq_start t120, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t120: ch,glue = callseq_end t119, TargetConstant:i64<0>, TargetConstant:i64<0>, t119:1
Legal operand
Legally typed node: t121: ch,glue = callseq_start t120, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t122: ch,glue = CopyToReg t121, Register:i64 $rdi, Constant:i64<1>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t121: ch,glue = callseq_start t120, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Legally typed node: t122: ch,glue = CopyToReg t121, Register:i64 $rdi, Constant:i64<1>

Legalizing node: t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t122: ch,glue = CopyToReg t121, Register:i64 $rdi, Constant:i64<1>
Legal operand
Analyzing operand: t34: i64,ch = CopyFromReg t0, Register:i64 %14
Legal operand
Analyzing operand: t122: ch,glue = CopyToReg t121, Register:i64 $rdi, Constant:i64<1>
Legal operand
Legally typed node: t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1

Legalizing node: t124: ch,glue = X86ISD::CALL t123, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1
Legal operand
Analyzing operand: t114: i64 = GlobalAddress<ptr @comet_print_memref_i64> 0
Legal operand
Analyzing operand: t111: Untyped = RegisterMask
Legal operand
Analyzing operand: t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1
Legal operand
Legally typed node: t124: ch,glue = X86ISD::CALL t123, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123:1

Legalizing node: t125: ch,glue = callseq_end t124, TargetConstant:i64<0>, TargetConstant:i64<0>, t124:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t124: ch,glue = X86ISD::CALL t123, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123:1
Legal operand
Analyzing operand: t124: ch,glue = X86ISD::CALL t123, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123:1
Legal operand
Legally typed node: t125: ch,glue = callseq_end t124, TargetConstant:i64<0>, TargetConstant:i64<0>, t124:1

Legalizing node: t126: ch,glue = callseq_start t125, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t125: ch,glue = callseq_end t124, TargetConstant:i64<0>, TargetConstant:i64<0>, t124:1
Legal operand
Legally typed node: t126: ch,glue = callseq_start t125, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t127: ch,glue = CopyToReg t126, Register:i64 $rdi, Constant:i64<1>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t126: ch,glue = callseq_start t125, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Legally typed node: t127: ch,glue = CopyToReg t126, Register:i64 $rdi, Constant:i64<1>

Legalizing node: t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t127: ch,glue = CopyToReg t126, Register:i64 $rdi, Constant:i64<1>
Legal operand
Analyzing operand: t36: i64,ch = CopyFromReg t0, Register:i64 %17
Legal operand
Analyzing operand: t127: ch,glue = CopyToReg t126, Register:i64 $rdi, Constant:i64<1>
Legal operand
Legally typed node: t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1

Legalizing node: t129: ch,glue = X86ISD::CALL t128, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1
Legal operand
Analyzing operand: t114: i64 = GlobalAddress<ptr @comet_print_memref_i64> 0
Legal operand
Analyzing operand: t111: Untyped = RegisterMask
Legal operand
Analyzing operand: t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1
Legal operand
Legally typed node: t129: ch,glue = X86ISD::CALL t128, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128:1

Legalizing node: t130: ch,glue = callseq_end t129, TargetConstant:i64<0>, TargetConstant:i64<0>, t129:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t129: ch,glue = X86ISD::CALL t128, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128:1
Legal operand
Analyzing operand: t129: ch,glue = X86ISD::CALL t128, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128:1
Legal operand
Legally typed node: t130: ch,glue = callseq_end t129, TargetConstant:i64<0>, TargetConstant:i64<0>, t129:1

Legalizing node: t131: ch,glue = callseq_start t130, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t130: ch,glue = callseq_end t129, TargetConstant:i64<0>, TargetConstant:i64<0>, t129:1
Legal operand
Legally typed node: t131: ch,glue = callseq_start t130, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t132: ch,glue = CopyToReg t131, Register:i64 $rdi, Constant:i64<1>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t131: ch,glue = callseq_start t130, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Legally typed node: t132: ch,glue = CopyToReg t131, Register:i64 $rdi, Constant:i64<1>

Legalizing node: t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t132: ch,glue = CopyToReg t131, Register:i64 $rdi, Constant:i64<1>
Legal operand
Analyzing operand: t38: i64,ch = CopyFromReg t0, Register:i64 %20
Legal operand
Analyzing operand: t132: ch,glue = CopyToReg t131, Register:i64 $rdi, Constant:i64<1>
Legal operand
Legally typed node: t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1

Legalizing node: t134: ch,glue = X86ISD::CALL t133, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1
Legal operand
Analyzing operand: t114: i64 = GlobalAddress<ptr @comet_print_memref_i64> 0
Legal operand
Analyzing operand: t111: Untyped = RegisterMask
Legal operand
Analyzing operand: t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1
Legal operand
Legally typed node: t134: ch,glue = X86ISD::CALL t133, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133:1

Legalizing node: t135: ch,glue = callseq_end t134, TargetConstant:i64<0>, TargetConstant:i64<0>, t134:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t134: ch,glue = X86ISD::CALL t133, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133:1
Legal operand
Analyzing operand: t134: ch,glue = X86ISD::CALL t133, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133:1
Legal operand
Legally typed node: t135: ch,glue = callseq_end t134, TargetConstant:i64<0>, TargetConstant:i64<0>, t134:1

Legalizing node: t136: ch,glue = callseq_start t135, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t135: ch,glue = callseq_end t134, TargetConstant:i64<0>, TargetConstant:i64<0>, t134:1
Legal operand
Legally typed node: t136: ch,glue = callseq_start t135, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t137: ch,glue = CopyToReg t136, Register:i64 $rdi, Constant:i64<1>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t136: ch,glue = callseq_start t135, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Legally typed node: t137: ch,glue = CopyToReg t136, Register:i64 $rdi, Constant:i64<1>

Legalizing node: t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t137: ch,glue = CopyToReg t136, Register:i64 $rdi, Constant:i64<1>
Legal operand
Analyzing operand: t40: i64,ch = CopyFromReg t0, Register:i64 %23
Legal operand
Analyzing operand: t137: ch,glue = CopyToReg t136, Register:i64 $rdi, Constant:i64<1>
Legal operand
Legally typed node: t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1

Legalizing node: t139: ch,glue = X86ISD::CALL t138, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1
Legal operand
Analyzing operand: t114: i64 = GlobalAddress<ptr @comet_print_memref_i64> 0
Legal operand
Analyzing operand: t111: Untyped = RegisterMask
Legal operand
Analyzing operand: t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1
Legal operand
Legally typed node: t139: ch,glue = X86ISD::CALL t138, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138:1

Legalizing node: t140: ch,glue = callseq_end t139, TargetConstant:i64<0>, TargetConstant:i64<0>, t139:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t139: ch,glue = X86ISD::CALL t138, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138:1
Legal operand
Analyzing operand: t139: ch,glue = X86ISD::CALL t138, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138:1
Legal operand
Legally typed node: t140: ch,glue = callseq_end t139, TargetConstant:i64<0>, TargetConstant:i64<0>, t139:1

Legalizing node: t141: ch,glue = callseq_start t140, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t140: ch,glue = callseq_end t139, TargetConstant:i64<0>, TargetConstant:i64<0>, t139:1
Legal operand
Legally typed node: t141: ch,glue = callseq_start t140, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t142: ch,glue = CopyToReg t141, Register:i64 $rdi, Constant:i64<1>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t141: ch,glue = callseq_start t140, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Legally typed node: t142: ch,glue = CopyToReg t141, Register:i64 $rdi, Constant:i64<1>

Legalizing node: t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t142: ch,glue = CopyToReg t141, Register:i64 $rdi, Constant:i64<1>
Legal operand
Analyzing operand: t42: i64,ch = CopyFromReg t0, Register:i64 %26
Legal operand
Analyzing operand: t142: ch,glue = CopyToReg t141, Register:i64 $rdi, Constant:i64<1>
Legal operand
Legally typed node: t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1

Legalizing node: t144: ch,glue = X86ISD::CALL t143, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1
Legal operand
Analyzing operand: t114: i64 = GlobalAddress<ptr @comet_print_memref_i64> 0
Legal operand
Analyzing operand: t111: Untyped = RegisterMask
Legal operand
Analyzing operand: t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1
Legal operand
Legally typed node: t144: ch,glue = X86ISD::CALL t143, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143:1

Legalizing node: t145: ch,glue = callseq_end t144, TargetConstant:i64<0>, TargetConstant:i64<0>, t144:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t144: ch,glue = X86ISD::CALL t143, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143:1
Legal operand
Analyzing operand: t144: ch,glue = X86ISD::CALL t143, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143:1
Legal operand
Legally typed node: t145: ch,glue = callseq_end t144, TargetConstant:i64<0>, TargetConstant:i64<0>, t144:1

Legalizing node: t146: ch,glue = callseq_start t145, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t145: ch,glue = callseq_end t144, TargetConstant:i64<0>, TargetConstant:i64<0>, t144:1
Legal operand
Legally typed node: t146: ch,glue = callseq_start t145, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t147: ch,glue = CopyToReg t146, Register:i64 $rdi, Constant:i64<1>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t146: ch,glue = callseq_start t145, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Legally typed node: t147: ch,glue = CopyToReg t146, Register:i64 $rdi, Constant:i64<1>

Legalizing node: t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t147: ch,glue = CopyToReg t146, Register:i64 $rdi, Constant:i64<1>
Legal operand
Analyzing operand: t44: i64,ch = CopyFromReg t0, Register:i64 %29
Legal operand
Analyzing operand: t147: ch,glue = CopyToReg t146, Register:i64 $rdi, Constant:i64<1>
Legal operand
Legally typed node: t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1

Legalizing node: t149: ch,glue = X86ISD::CALL t148, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1
Legal operand
Analyzing operand: t114: i64 = GlobalAddress<ptr @comet_print_memref_i64> 0
Legal operand
Analyzing operand: t111: Untyped = RegisterMask
Legal operand
Analyzing operand: t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1
Legal operand
Legally typed node: t149: ch,glue = X86ISD::CALL t148, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148:1

Legalizing node: t150: ch,glue = callseq_end t149, TargetConstant:i64<0>, TargetConstant:i64<0>, t149:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t149: ch,glue = X86ISD::CALL t148, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148:1
Legal operand
Analyzing operand: t149: ch,glue = X86ISD::CALL t148, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148:1
Legal operand
Legally typed node: t150: ch,glue = callseq_end t149, TargetConstant:i64<0>, TargetConstant:i64<0>, t149:1

Legalizing node: t151: ch,glue = callseq_start t150, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t150: ch,glue = callseq_end t149, TargetConstant:i64<0>, TargetConstant:i64<0>, t149:1
Legal operand
Legally typed node: t151: ch,glue = callseq_start t150, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t152: ch,glue = CopyToReg t151, Register:i64 $rdi, Constant:i64<1>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t151: ch,glue = callseq_start t150, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Legally typed node: t152: ch,glue = CopyToReg t151, Register:i64 $rdi, Constant:i64<1>

Legalizing node: t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t152: ch,glue = CopyToReg t151, Register:i64 $rdi, Constant:i64<1>
Legal operand
Analyzing operand: t46: i64,ch = CopyFromReg t0, Register:i64 %32
Legal operand
Analyzing operand: t152: ch,glue = CopyToReg t151, Register:i64 $rdi, Constant:i64<1>
Legal operand
Legally typed node: t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1

Legalizing node: t154: ch,glue = X86ISD::CALL t153, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1
Legal operand
Analyzing operand: t114: i64 = GlobalAddress<ptr @comet_print_memref_i64> 0
Legal operand
Analyzing operand: t111: Untyped = RegisterMask
Legal operand
Analyzing operand: t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1
Legal operand
Legally typed node: t154: ch,glue = X86ISD::CALL t153, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153:1

Legalizing node: t155: ch,glue = callseq_end t154, TargetConstant:i64<0>, TargetConstant:i64<0>, t154:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t154: ch,glue = X86ISD::CALL t153, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153:1
Legal operand
Analyzing operand: t154: ch,glue = X86ISD::CALL t153, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153:1
Legal operand
Legally typed node: t155: ch,glue = callseq_end t154, TargetConstant:i64<0>, TargetConstant:i64<0>, t154:1

Legalizing node: t157: ch,glue = callseq_start t155, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t155: ch,glue = callseq_end t154, TargetConstant:i64<0>, TargetConstant:i64<0>, t154:1
Legal operand
Legally typed node: t157: ch,glue = callseq_start t155, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t158: ch,glue = CopyToReg t157, Register:i64 $rdi, Constant:i64<1>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t157: ch,glue = callseq_start t155, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<1>
Legal operand
Legally typed node: t158: ch,glue = CopyToReg t157, Register:i64 $rdi, Constant:i64<1>

Legalizing node: t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t9, t158:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t158: ch,glue = CopyToReg t157, Register:i64 $rdi, Constant:i64<1>
Legal operand
Analyzing operand: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Legal operand
Analyzing operand: t158: ch,glue = CopyToReg t157, Register:i64 $rdi, Constant:i64<1>
Legal operand
Legally typed node: t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t9, t158:1

Legalizing node: t160: ch,glue = X86ISD::CALL t159, GlobalAddress:i64<ptr @comet_print_memref_f64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t9, t158:1
Legal operand
Analyzing operand: t156: i64 = GlobalAddress<ptr @comet_print_memref_f64> 0
Legal operand
Analyzing operand: t111: Untyped = RegisterMask
Legal operand
Analyzing operand: t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t9, t158:1
Legal operand
Legally typed node: t160: ch,glue = X86ISD::CALL t159, GlobalAddress:i64<ptr @comet_print_memref_f64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159:1

Legalizing node: t161: ch,glue = callseq_end t160, TargetConstant:i64<0>, TargetConstant:i64<0>, t160:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t160: ch,glue = X86ISD::CALL t159, GlobalAddress:i64<ptr @comet_print_memref_f64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159:1
Legal operand
Analyzing operand: t160: ch,glue = X86ISD::CALL t159, GlobalAddress:i64<ptr @comet_print_memref_f64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159:1
Legal operand
Legally typed node: t161: ch,glue = callseq_end t160, TargetConstant:i64<0>, TargetConstant:i64<0>, t160:1

Legalizing node: t163: ch = X86ISD::RET_FLAG t161, TargetConstant:i32<0>
Analyzing result type: ch
Legal result type
Analyzing operand: t161: ch,glue = callseq_end t160, TargetConstant:i64<0>, TargetConstant:i64<0>, t160:1
Legal operand
Legally typed node: t163: ch = X86ISD::RET_FLAG t161, TargetConstant:i32<0>

Legalizing node: t65535: ch = handlenode t163
Analyzing result type: ch
Legal result type
Analyzing operand: t163: ch = X86ISD::RET_FLAG t161, TargetConstant:i32<0>
Legal operand
Legally typed node: t65535: ch = handlenode t163

Type-legalized selection DAG: %bb.18 'main:._crit_edge112'
SelectionDAG has 162 nodes:
  t0: ch,glue = EntryToken
  t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
  t11: i64,ch = CopyFromReg t0, Register:i64 %34
  t32: i64,ch = CopyFromReg t0, Register:i64 %11
  t34: i64,ch = CopyFromReg t0, Register:i64 %14
  t36: i64,ch = CopyFromReg t0, Register:i64 %17
  t38: i64,ch = CopyFromReg t0, Register:i64 %20
  t40: i64,ch = CopyFromReg t0, Register:i64 %23
  t42: i64,ch = CopyFromReg t0, Register:i64 %26
  t44: i64,ch = CopyFromReg t0, Register:i64 %29
  t46: i64,ch = CopyFromReg t0, Register:i64 %32
      t13: ch = store<(store (s64) into %ir.46)> t9:1, t11, t9, undef:i64
        t15: i64 = add nuw t9, Constant:i64<8>
      t16: ch = store<(store (s64) into %ir..repack81)> t9:1, t11, t15, undef:i64
        t18: i64 = add nuw t9, Constant:i64<16>
      t19: ch = store<(store (s64) into %ir..repack83)> t9:1, Constant:i64<0>, t18, undef:i64
        t23: i64,ch = CopyFromReg t0, Register:i64 %8
        t21: i64 = add nuw t9, Constant:i64<24>
      t24: ch = store<(store (s64) into %ir..repack85)> t9:1, t23, t21, undef:i64
        t26: i64 = add nuw t9, Constant:i64<32>
      t164: ch = store<(store (s64) into %ir..repack87)> t9:1, Constant:i64<1>, t26, undef:i64
    t165: ch = TokenFactor t13, t16, t19, t24, t164
  t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
  t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
      t52: ch = store<(store (s64) into stack)> t49, t32, t51, undef:i64
        t53: i64 = add t51, Constant:i64<8>
      t54: ch = store<(store (s64) into stack + 8)> t49, Constant:i64<1>, t53, undef:i64
        t55: i64 = add t51, Constant:i64<16>
      t56: ch = store<(store (s64) into stack + 16)> t49, t34, t55, undef:i64
        t57: i64 = add t51, Constant:i64<24>
      t58: ch = store<(store (s64) into stack + 24)> t49, Constant:i64<1>, t57, undef:i64
        t59: i64 = add t51, Constant:i64<32>
      t60: ch = store<(store (s64) into stack + 32)> t49, t36, t59, undef:i64
        t61: i64 = add t51, Constant:i64<40>
      t62: ch = store<(store (s64) into stack + 40)> t49, Constant:i64<1>, t61, undef:i64
        t63: i64 = add t51, Constant:i64<48>
      t64: ch = store<(store (s64) into stack + 48)> t49, t38, t63, undef:i64
        t66: i64 = add t51, Constant:i64<56>
      t67: ch = store<(store (s64) into stack + 56)> t49, Constant:i64<1>, t66, undef:i64
        t69: i64 = add t51, Constant:i64<64>
      t70: ch = store<(store (s64) into stack + 64)> t49, t40, t69, undef:i64
        t72: i64 = add t51, Constant:i64<72>
      t73: ch = store<(store (s64) into stack + 72)> t49, Constant:i64<1>, t72, undef:i64
        t75: i64 = add t51, Constant:i64<80>
      t76: ch = store<(store (s64) into stack + 80)> t49, t42, t75, undef:i64
        t78: i64 = add t51, Constant:i64<88>
      t79: ch = store<(store (s64) into stack + 88)> t49, Constant:i64<1>, t78, undef:i64
        t81: i64 = add t51, Constant:i64<96>
      t82: ch = store<(store (s64) into stack + 96)> t49, t44, t81, undef:i64
        t84: i64 = add t51, Constant:i64<104>
      t85: ch = store<(store (s64) into stack + 104)> t49, Constant:i64<1>, t84, undef:i64
        t87: i64 = add t51, Constant:i64<112>
      t88: ch = store<(store (s64) into stack + 112)> t49, t46, t87, undef:i64
        t90: i64 = add t51, Constant:i64<120>
      t91: ch = store<(store (s64) into stack + 120)> t49, Constant:i64<1>, t90, undef:i64
        t93: i64 = add t51, Constant:i64<128>
      t94: ch = store<(store (s64) into stack + 128)> t49, t9, t93, undef:i64
        t96: i64 = add t51, Constant:i64<136>
      t97: ch = store<(store (s32) into stack + 136)> t49, Constant:i32<1>, t96, undef:i64
    t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97
  t100: ch,glue = CopyToReg t98, Register:i32 $edi, Constant:i32<1>
  t102: ch,glue = CopyToReg t100, Register:i64 $rsi, Constant:i64<0>, t100:1
  t104: ch,glue = CopyToReg t102, Register:i64 $rdx, Constant:i64<3>, t102:1
  t106: ch,glue = CopyToReg t104, Register:i64 $rcx, Constant:i64<0>, t104:1
  t108: ch,glue = CopyToReg t106, Register:i64 $r8, Constant:i64<-1>, t106:1
  t110: ch,glue = CopyToReg t108, Register:i64 $r9, Constant:i64<1>, t108:1
  t112: ch,glue = X86ISD::CALL t110, GlobalAddress:i64<ptr @read_input_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110:1
      t113: ch,glue = callseq_end t112, TargetConstant:i64<144>, TargetConstant:i64<0>, t112:1
    t115: ch,glue = callseq_start t113, TargetConstant:i64<0>, TargetConstant:i64<0>
  t117: ch,glue = CopyToReg t115, Register:i64 $rdi, Constant:i64<1>
  t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1
  t119: ch,glue = X86ISD::CALL t118, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118:1
      t120: ch,glue = callseq_end t119, TargetConstant:i64<0>, TargetConstant:i64<0>, t119:1
    t121: ch,glue = callseq_start t120, TargetConstant:i64<0>, TargetConstant:i64<0>
  t122: ch,glue = CopyToReg t121, Register:i64 $rdi, Constant:i64<1>
  t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1
  t124: ch,glue = X86ISD::CALL t123, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123:1
      t125: ch,glue = callseq_end t124, TargetConstant:i64<0>, TargetConstant:i64<0>, t124:1
    t126: ch,glue = callseq_start t125, TargetConstant:i64<0>, TargetConstant:i64<0>
  t127: ch,glue = CopyToReg t126, Register:i64 $rdi, Constant:i64<1>
  t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1
  t129: ch,glue = X86ISD::CALL t128, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128:1
      t130: ch,glue = callseq_end t129, TargetConstant:i64<0>, TargetConstant:i64<0>, t129:1
    t131: ch,glue = callseq_start t130, TargetConstant:i64<0>, TargetConstant:i64<0>
  t132: ch,glue = CopyToReg t131, Register:i64 $rdi, Constant:i64<1>
  t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1
  t134: ch,glue = X86ISD::CALL t133, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133:1
      t135: ch,glue = callseq_end t134, TargetConstant:i64<0>, TargetConstant:i64<0>, t134:1
    t136: ch,glue = callseq_start t135, TargetConstant:i64<0>, TargetConstant:i64<0>
  t137: ch,glue = CopyToReg t136, Register:i64 $rdi, Constant:i64<1>
  t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1
  t139: ch,glue = X86ISD::CALL t138, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138:1
      t140: ch,glue = callseq_end t139, TargetConstant:i64<0>, TargetConstant:i64<0>, t139:1
    t141: ch,glue = callseq_start t140, TargetConstant:i64<0>, TargetConstant:i64<0>
  t142: ch,glue = CopyToReg t141, Register:i64 $rdi, Constant:i64<1>
  t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1
  t144: ch,glue = X86ISD::CALL t143, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143:1
      t145: ch,glue = callseq_end t144, TargetConstant:i64<0>, TargetConstant:i64<0>, t144:1
    t146: ch,glue = callseq_start t145, TargetConstant:i64<0>, TargetConstant:i64<0>
  t147: ch,glue = CopyToReg t146, Register:i64 $rdi, Constant:i64<1>
  t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1
  t149: ch,glue = X86ISD::CALL t148, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148:1
      t150: ch,glue = callseq_end t149, TargetConstant:i64<0>, TargetConstant:i64<0>, t149:1
    t151: ch,glue = callseq_start t150, TargetConstant:i64<0>, TargetConstant:i64<0>
  t152: ch,glue = CopyToReg t151, Register:i64 $rdi, Constant:i64<1>
  t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1
  t154: ch,glue = X86ISD::CALL t153, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153:1
      t155: ch,glue = callseq_end t154, TargetConstant:i64<0>, TargetConstant:i64<0>, t154:1
    t157: ch,glue = callseq_start t155, TargetConstant:i64<0>, TargetConstant:i64<0>
  t158: ch,glue = CopyToReg t157, Register:i64 $rdi, Constant:i64<1>
  t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t9, t158:1
  t160: ch,glue = X86ISD::CALL t159, GlobalAddress:i64<ptr @comet_print_memref_f64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159:1
    t161: ch,glue = callseq_end t160, TargetConstant:i64<0>, TargetConstant:i64<0>, t160:1
  t163: ch = X86ISD::RET_FLAG t161, TargetConstant:i32<0>



Legalizing: t163: ch = X86ISD::RET_FLAG t161, TargetConstant:i32<0>
Legal node: nothing to do

Legalizing: t161: ch,glue = callseq_end t160, TargetConstant:i64<0>, TargetConstant:i64<0>, t160:1

Legalizing: t160: ch,glue = X86ISD::CALL t159, GlobalAddress:i64<ptr @comet_print_memref_f64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159:1
Legal node: nothing to do

Legalizing: t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t9, t158:1
Legal node: nothing to do

Legalizing: t158: ch,glue = CopyToReg t157, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Legalizing: t157: ch,glue = callseq_start t155, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t155: ch,glue = callseq_end t154, TargetConstant:i64<0>, TargetConstant:i64<0>, t154:1

Legalizing: t154: ch,glue = X86ISD::CALL t153, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153:1
Legal node: nothing to do

Legalizing: t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1
Legal node: nothing to do

Legalizing: t152: ch,glue = CopyToReg t151, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Legalizing: t151: ch,glue = callseq_start t150, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t150: ch,glue = callseq_end t149, TargetConstant:i64<0>, TargetConstant:i64<0>, t149:1

Legalizing: t149: ch,glue = X86ISD::CALL t148, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148:1
Legal node: nothing to do

Legalizing: t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1
Legal node: nothing to do

Legalizing: t147: ch,glue = CopyToReg t146, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Legalizing: t146: ch,glue = callseq_start t145, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t145: ch,glue = callseq_end t144, TargetConstant:i64<0>, TargetConstant:i64<0>, t144:1

Legalizing: t144: ch,glue = X86ISD::CALL t143, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143:1
Legal node: nothing to do

Legalizing: t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1
Legal node: nothing to do

Legalizing: t142: ch,glue = CopyToReg t141, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Legalizing: t141: ch,glue = callseq_start t140, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t140: ch,glue = callseq_end t139, TargetConstant:i64<0>, TargetConstant:i64<0>, t139:1

Legalizing: t139: ch,glue = X86ISD::CALL t138, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138:1
Legal node: nothing to do

Legalizing: t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1
Legal node: nothing to do

Legalizing: t137: ch,glue = CopyToReg t136, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Legalizing: t136: ch,glue = callseq_start t135, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t135: ch,glue = callseq_end t134, TargetConstant:i64<0>, TargetConstant:i64<0>, t134:1

Legalizing: t134: ch,glue = X86ISD::CALL t133, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133:1
Legal node: nothing to do

Legalizing: t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1
Legal node: nothing to do

Legalizing: t132: ch,glue = CopyToReg t131, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Legalizing: t131: ch,glue = callseq_start t130, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t130: ch,glue = callseq_end t129, TargetConstant:i64<0>, TargetConstant:i64<0>, t129:1

Legalizing: t129: ch,glue = X86ISD::CALL t128, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128:1
Legal node: nothing to do

Legalizing: t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1
Legal node: nothing to do

Legalizing: t127: ch,glue = CopyToReg t126, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Legalizing: t126: ch,glue = callseq_start t125, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t125: ch,glue = callseq_end t124, TargetConstant:i64<0>, TargetConstant:i64<0>, t124:1

Legalizing: t124: ch,glue = X86ISD::CALL t123, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123:1
Legal node: nothing to do

Legalizing: t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1
Legal node: nothing to do

Legalizing: t122: ch,glue = CopyToReg t121, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Legalizing: t121: ch,glue = callseq_start t120, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t120: ch,glue = callseq_end t119, TargetConstant:i64<0>, TargetConstant:i64<0>, t119:1

Legalizing: t119: ch,glue = X86ISD::CALL t118, GlobalAddress:i64<ptr @comet_print_memref_i64> 0, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118:1
Legal node: nothing to do

Legalizing: t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1
Legal node: nothing to do

Legalizing: t117: ch,glue = CopyToReg t115, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Legalizing: t115: ch,glue = callseq_start t113, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t113: ch,glue = callseq_end t112, TargetConstant:i64<144>, TargetConstant:i64<0>, t112:1

Legalizing: t112: ch,glue = X86ISD::CALL t110, GlobalAddress:i64<ptr @read_input_2D_f64> 0, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110:1
Legal node: nothing to do

Legalizing: t110: ch,glue = CopyToReg t108, Register:i64 $r9, Constant:i64<1>, t108:1
Legal node: nothing to do

Legalizing: t108: ch,glue = CopyToReg t106, Register:i64 $r8, Constant:i64<-1>, t106:1
Legal node: nothing to do

Legalizing: t106: ch,glue = CopyToReg t104, Register:i64 $rcx, Constant:i64<0>, t104:1
Legal node: nothing to do

Legalizing: t104: ch,glue = CopyToReg t102, Register:i64 $rdx, Constant:i64<3>, t102:1
Legal node: nothing to do

Legalizing: t102: ch,glue = CopyToReg t100, Register:i64 $rsi, Constant:i64<0>, t100:1
Legal node: nothing to do

Legalizing: t100: ch,glue = CopyToReg t98, Register:i32 $edi, Constant:i32<1>
Legal node: nothing to do

Legalizing: t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97
Legal node: nothing to do

Legalizing: t54: ch = store<(store (s64) into stack + 8)> t49, Constant:i64<1>, t53, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t56: ch = store<(store (s64) into stack + 16)> t49, t34, t55, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t58: ch = store<(store (s64) into stack + 24)> t49, Constant:i64<1>, t57, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t60: ch = store<(store (s64) into stack + 32)> t49, t36, t59, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t62: ch = store<(store (s64) into stack + 40)> t49, Constant:i64<1>, t61, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t64: ch = store<(store (s64) into stack + 48)> t49, t38, t63, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t67: ch = store<(store (s64) into stack + 56)> t49, Constant:i64<1>, t66, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t70: ch = store<(store (s64) into stack + 64)> t49, t40, t69, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t73: ch = store<(store (s64) into stack + 72)> t49, Constant:i64<1>, t72, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t76: ch = store<(store (s64) into stack + 80)> t49, t42, t75, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t79: ch = store<(store (s64) into stack + 88)> t49, Constant:i64<1>, t78, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t82: ch = store<(store (s64) into stack + 96)> t49, t44, t81, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t85: ch = store<(store (s64) into stack + 104)> t49, Constant:i64<1>, t84, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t88: ch = store<(store (s64) into stack + 112)> t49, t46, t87, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t91: ch = store<(store (s64) into stack + 120)> t49, Constant:i64<1>, t90, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t94: ch = store<(store (s64) into stack + 128)> t49, t9, t93, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t97: ch = store<(store (s32) into stack + 136)> t49, Constant:i32<1>, t96, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t52: ch = store<(store (s64) into stack)> t49, t32, t51, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t53: i64 = add t51, Constant:i64<8>
Legal node: nothing to do

Legalizing: t55: i64 = add t51, Constant:i64<16>
Legal node: nothing to do

Legalizing: t57: i64 = add t51, Constant:i64<24>
Legal node: nothing to do

Legalizing: t59: i64 = add t51, Constant:i64<32>
Legal node: nothing to do

Legalizing: t61: i64 = add t51, Constant:i64<40>
Legal node: nothing to do

Legalizing: t63: i64 = add t51, Constant:i64<48>
Legal node: nothing to do

Legalizing: t66: i64 = add t51, Constant:i64<56>
Legal node: nothing to do

Legalizing: t69: i64 = add t51, Constant:i64<64>
Legal node: nothing to do

Legalizing: t72: i64 = add t51, Constant:i64<72>
Legal node: nothing to do

Legalizing: t75: i64 = add t51, Constant:i64<80>
Legal node: nothing to do

Legalizing: t78: i64 = add t51, Constant:i64<88>
Legal node: nothing to do

Legalizing: t81: i64 = add t51, Constant:i64<96>
Legal node: nothing to do

Legalizing: t84: i64 = add t51, Constant:i64<104>
Legal node: nothing to do

Legalizing: t87: i64 = add t51, Constant:i64<112>
Legal node: nothing to do

Legalizing: t90: i64 = add t51, Constant:i64<120>
Legal node: nothing to do

Legalizing: t93: i64 = add t51, Constant:i64<128>
Legal node: nothing to do

Legalizing: t96: i64 = add t51, Constant:i64<136>
Legal node: nothing to do

Legalizing: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal node: nothing to do

Legalizing: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>

Legalizing: t165: ch = TokenFactor t13, t16, t19, t24, t164
Legal node: nothing to do

Legalizing: t16: ch = store<(store (s64) into %ir..repack81)> t9:1, t11, t15, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t19: ch = store<(store (s64) into %ir..repack83)> t9:1, Constant:i64<0>, t18, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t24: ch = store<(store (s64) into %ir..repack85)> t9:1, t23, t21, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t164: ch = store<(store (s64) into %ir..repack87)> t9:1, Constant:i64<1>, t26, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t13: ch = store<(store (s64) into %ir.46)> t9:1, t11, t9, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t15: i64 = add nuw t9, Constant:i64<8>
Legal node: nothing to do

Legalizing: t18: i64 = add nuw t9, Constant:i64<16>
Legal node: nothing to do

Legalizing: t21: i64 = add nuw t9, Constant:i64<24>
Legal node: nothing to do

Legalizing: t26: i64 = add nuw t9, Constant:i64<32>
Legal node: nothing to do

Legalizing: t46: i64,ch = CopyFromReg t0, Register:i64 %32
Legal node: nothing to do

Legalizing: t44: i64,ch = CopyFromReg t0, Register:i64 %29
Legal node: nothing to do

Legalizing: t42: i64,ch = CopyFromReg t0, Register:i64 %26
Legal node: nothing to do

Legalizing: t40: i64,ch = CopyFromReg t0, Register:i64 %23
Legal node: nothing to do

Legalizing: t38: i64,ch = CopyFromReg t0, Register:i64 %20
Legal node: nothing to do

Legalizing: t36: i64,ch = CopyFromReg t0, Register:i64 %17
Legal node: nothing to do

Legalizing: t34: i64,ch = CopyFromReg t0, Register:i64 %14
Legal node: nothing to do

Legalizing: t32: i64,ch = CopyFromReg t0, Register:i64 %11
Legal node: nothing to do

Legalizing: t23: i64,ch = CopyFromReg t0, Register:i64 %8
Legal node: nothing to do

Legalizing: t11: i64,ch = CopyFromReg t0, Register:i64 %34
Legal node: nothing to do

Legalizing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
Trying custom legalization
Creating new node: t166: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t167: i64,ch = CopyFromReg t166, Register:i64 $rsp
Creating new node: t168: i64 = sub t167, Constant:i64<48>
Creating new node: t169: ch = CopyToReg t167:1, Register:i64 $rsp, t168
Creating new node: t170: ch,glue = callseq_end t169, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t171: i64,ch = merge_values t168, t170
Successfully custom legalized node
 ... replacing: t9: i64,ch = dynamic_stackalloc t0, Constant:i64<48>, Constant:i64<0>
     with:      t171: i64,ch = merge_values t168, t170
      and:      t171: i64,ch = merge_values t168, t170

Legalizing: t162: i32 = TargetConstant<0>

Legalizing: t156: i64 = GlobalAddress<ptr @comet_print_memref_f64> 0
Trying custom legalization
Creating new node: t173: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_f64> 0
Successfully custom legalized node
 ... replacing: t156: i64 = GlobalAddress<ptr @comet_print_memref_f64> 0
     with:      t173: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_f64> 0

Legalizing: t116: i64 = Register $rdi

Legalizing: t114: i64 = GlobalAddress<ptr @comet_print_memref_i64> 0
Trying custom legalization
Creating new node: t175: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_i64> 0
Successfully custom legalized node
 ... replacing: t114: i64 = GlobalAddress<ptr @comet_print_memref_i64> 0
     with:      t175: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_i64> 0

Legalizing: t111: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t109: i64 = Register $r9

Legalizing: t107: i64 = Register $r8

Legalizing: t105: i64 = Register $rcx

Legalizing: t103: i64 = Register $rdx

Legalizing: t101: i64 = Register $rsi

Legalizing: t99: i32 = Register $edi

Legalizing: t95: i64 = Constant<136>
Legal node: nothing to do

Legalizing: t92: i64 = Constant<128>
Legal node: nothing to do

Legalizing: t89: i64 = Constant<120>
Legal node: nothing to do

Legalizing: t86: i64 = Constant<112>
Legal node: nothing to do

Legalizing: t83: i64 = Constant<104>
Legal node: nothing to do

Legalizing: t80: i64 = Constant<96>
Legal node: nothing to do

Legalizing: t77: i64 = Constant<88>
Legal node: nothing to do

Legalizing: t74: i64 = Constant<80>
Legal node: nothing to do

Legalizing: t71: i64 = Constant<72>
Legal node: nothing to do

Legalizing: t68: i64 = Constant<64>
Legal node: nothing to do

Legalizing: t65: i64 = Constant<56>
Legal node: nothing to do

Legalizing: t50: i64 = Register $rsp

Legalizing: t48: i64 = TargetConstant<0>

Legalizing: t47: i64 = TargetConstant<144>

Legalizing: t45: i64 = Register %32

Legalizing: t43: i64 = Register %29

Legalizing: t41: i64 = Register %26

Legalizing: t39: i64 = Register %23

Legalizing: t37: i64 = Register %20

Legalizing: t35: i64 = Register %17

Legalizing: t33: i64 = Register %14

Legalizing: t31: i64 = Register %11

Legalizing: t30: i64 = Constant<-1>
Legal node: nothing to do

Legalizing: t29: i64 = Constant<3>
Legal node: nothing to do

Legalizing: t28: i64 = GlobalAddress<ptr @read_input_2D_f64> 0
Trying custom legalization
Creating new node: t177: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0
Successfully custom legalized node
 ... replacing: t28: i64 = GlobalAddress<ptr @read_input_2D_f64> 0
     with:      t177: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0

Legalizing: t25: i64 = Constant<32>
Legal node: nothing to do

Legalizing: t22: i64 = Register %8

Legalizing: t20: i64 = Constant<24>
Legal node: nothing to do

Legalizing: t17: i64 = Constant<16>
Legal node: nothing to do

Legalizing: t14: i64 = Constant<8>
Legal node: nothing to do

Legalizing: t12: i64 = undef
Legal node: nothing to do

Legalizing: t10: i64 = Register %34

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t7: i64 = Constant<48>
Legal node: nothing to do

Legalizing: t3: i64 = Constant<40>
Legal node: nothing to do

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Legalizing: t1: i32 = Constant<1>
Legal node: nothing to do

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t177: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0
Legal node: nothing to do

Legalizing: t176: i64 = TargetGlobalAddress<ptr @read_input_2D_f64> 0
Legal node: nothing to do

Legalizing: t175: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_i64> 0
Legal node: nothing to do

Legalizing: t174: i64 = TargetGlobalAddress<ptr @comet_print_memref_i64> 0
Legal node: nothing to do

Legalizing: t173: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_f64> 0
Legal node: nothing to do

Legalizing: t172: i64 = TargetGlobalAddress<ptr @comet_print_memref_f64> 0
Legal node: nothing to do

Legalizing: t171: i64,ch = merge_values t168, t170
Trying to expand node
Successfully expanded node
 ... replacing: t171: i64,ch = merge_values t168, t170
     with:      t168: i64 = sub t167, Constant:i64<48>
      and:      t170: ch,glue = callseq_end t169, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t170: ch,glue = callseq_end t169, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t169: ch = CopyToReg t167:1, Register:i64 $rsp, t168
Legal node: nothing to do

Legalizing: t168: i64 = sub t167, Constant:i64<48>
Legal node: nothing to do

Legalizing: t167: i64,ch = CopyFromReg t166, Register:i64 $rsp
Legal node: nothing to do

Legalizing: t166: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legalized selection DAG: %bb.18 'main:._crit_edge112'
SelectionDAG has 169 nodes:
  t0: ch,glue = EntryToken
  t11: i64,ch = CopyFromReg t0, Register:i64 %34
  t32: i64,ch = CopyFromReg t0, Register:i64 %11
  t34: i64,ch = CopyFromReg t0, Register:i64 %14
  t36: i64,ch = CopyFromReg t0, Register:i64 %17
  t38: i64,ch = CopyFromReg t0, Register:i64 %20
  t40: i64,ch = CopyFromReg t0, Register:i64 %23
  t42: i64,ch = CopyFromReg t0, Register:i64 %26
  t44: i64,ch = CopyFromReg t0, Register:i64 %29
  t46: i64,ch = CopyFromReg t0, Register:i64 %32
      t13: ch = store<(store (s64) into %ir.46)> t170, t11, t168, undef:i64
        t15: i64 = add nuw t168, Constant:i64<8>
      t16: ch = store<(store (s64) into %ir..repack81)> t170, t11, t15, undef:i64
        t18: i64 = add nuw t168, Constant:i64<16>
      t19: ch = store<(store (s64) into %ir..repack83)> t170, Constant:i64<0>, t18, undef:i64
        t23: i64,ch = CopyFromReg t0, Register:i64 %8
        t21: i64 = add nuw t168, Constant:i64<24>
      t24: ch = store<(store (s64) into %ir..repack85)> t170, t23, t21, undef:i64
        t26: i64 = add nuw t168, Constant:i64<32>
      t164: ch = store<(store (s64) into %ir..repack87)> t170, Constant:i64<1>, t26, undef:i64
    t165: ch = TokenFactor t13, t16, t19, t24, t164
  t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
  t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
      t52: ch = store<(store (s64) into stack)> t49, t32, t51, undef:i64
        t53: i64 = add t51, Constant:i64<8>
      t54: ch = store<(store (s64) into stack + 8)> t49, Constant:i64<1>, t53, undef:i64
        t55: i64 = add t51, Constant:i64<16>
      t56: ch = store<(store (s64) into stack + 16)> t49, t34, t55, undef:i64
        t57: i64 = add t51, Constant:i64<24>
      t58: ch = store<(store (s64) into stack + 24)> t49, Constant:i64<1>, t57, undef:i64
        t59: i64 = add t51, Constant:i64<32>
      t60: ch = store<(store (s64) into stack + 32)> t49, t36, t59, undef:i64
        t61: i64 = add t51, Constant:i64<40>
      t62: ch = store<(store (s64) into stack + 40)> t49, Constant:i64<1>, t61, undef:i64
        t63: i64 = add t51, Constant:i64<48>
      t64: ch = store<(store (s64) into stack + 48)> t49, t38, t63, undef:i64
        t66: i64 = add t51, Constant:i64<56>
      t67: ch = store<(store (s64) into stack + 56)> t49, Constant:i64<1>, t66, undef:i64
        t69: i64 = add t51, Constant:i64<64>
      t70: ch = store<(store (s64) into stack + 64)> t49, t40, t69, undef:i64
        t72: i64 = add t51, Constant:i64<72>
      t73: ch = store<(store (s64) into stack + 72)> t49, Constant:i64<1>, t72, undef:i64
        t75: i64 = add t51, Constant:i64<80>
      t76: ch = store<(store (s64) into stack + 80)> t49, t42, t75, undef:i64
        t78: i64 = add t51, Constant:i64<88>
      t79: ch = store<(store (s64) into stack + 88)> t49, Constant:i64<1>, t78, undef:i64
        t81: i64 = add t51, Constant:i64<96>
      t82: ch = store<(store (s64) into stack + 96)> t49, t44, t81, undef:i64
        t84: i64 = add t51, Constant:i64<104>
      t85: ch = store<(store (s64) into stack + 104)> t49, Constant:i64<1>, t84, undef:i64
        t87: i64 = add t51, Constant:i64<112>
      t88: ch = store<(store (s64) into stack + 112)> t49, t46, t87, undef:i64
        t90: i64 = add t51, Constant:i64<120>
      t91: ch = store<(store (s64) into stack + 120)> t49, Constant:i64<1>, t90, undef:i64
        t93: i64 = add t51, Constant:i64<128>
      t94: ch = store<(store (s64) into stack + 128)> t49, t168, t93, undef:i64
        t96: i64 = add t51, Constant:i64<136>
      t97: ch = store<(store (s32) into stack + 136)> t49, Constant:i32<1>, t96, undef:i64
    t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97
  t100: ch,glue = CopyToReg t98, Register:i32 $edi, Constant:i32<1>
  t102: ch,glue = CopyToReg t100, Register:i64 $rsi, Constant:i64<0>, t100:1
  t104: ch,glue = CopyToReg t102, Register:i64 $rdx, Constant:i64<3>, t102:1
  t106: ch,glue = CopyToReg t104, Register:i64 $rcx, Constant:i64<0>, t104:1
  t108: ch,glue = CopyToReg t106, Register:i64 $r8, Constant:i64<-1>, t106:1
  t110: ch,glue = CopyToReg t108, Register:i64 $r9, Constant:i64<1>, t108:1
    t177: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0
  t112: ch,glue = X86ISD::CALL t110, t177, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110:1
      t113: ch,glue = callseq_end t112, TargetConstant:i64<144>, TargetConstant:i64<0>, t112:1
    t115: ch,glue = callseq_start t113, TargetConstant:i64<0>, TargetConstant:i64<0>
  t117: ch,glue = CopyToReg t115, Register:i64 $rdi, Constant:i64<1>
  t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1
  t119: ch,glue = X86ISD::CALL t118, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118:1
      t120: ch,glue = callseq_end t119, TargetConstant:i64<0>, TargetConstant:i64<0>, t119:1
    t121: ch,glue = callseq_start t120, TargetConstant:i64<0>, TargetConstant:i64<0>
  t122: ch,glue = CopyToReg t121, Register:i64 $rdi, Constant:i64<1>
  t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1
  t124: ch,glue = X86ISD::CALL t123, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123:1
      t125: ch,glue = callseq_end t124, TargetConstant:i64<0>, TargetConstant:i64<0>, t124:1
    t126: ch,glue = callseq_start t125, TargetConstant:i64<0>, TargetConstant:i64<0>
  t127: ch,glue = CopyToReg t126, Register:i64 $rdi, Constant:i64<1>
  t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1
  t129: ch,glue = X86ISD::CALL t128, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128:1
      t130: ch,glue = callseq_end t129, TargetConstant:i64<0>, TargetConstant:i64<0>, t129:1
    t131: ch,glue = callseq_start t130, TargetConstant:i64<0>, TargetConstant:i64<0>
  t132: ch,glue = CopyToReg t131, Register:i64 $rdi, Constant:i64<1>
  t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1
  t134: ch,glue = X86ISD::CALL t133, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133:1
      t135: ch,glue = callseq_end t134, TargetConstant:i64<0>, TargetConstant:i64<0>, t134:1
    t136: ch,glue = callseq_start t135, TargetConstant:i64<0>, TargetConstant:i64<0>
  t137: ch,glue = CopyToReg t136, Register:i64 $rdi, Constant:i64<1>
  t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1
  t139: ch,glue = X86ISD::CALL t138, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138:1
      t140: ch,glue = callseq_end t139, TargetConstant:i64<0>, TargetConstant:i64<0>, t139:1
    t141: ch,glue = callseq_start t140, TargetConstant:i64<0>, TargetConstant:i64<0>
  t142: ch,glue = CopyToReg t141, Register:i64 $rdi, Constant:i64<1>
  t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1
  t144: ch,glue = X86ISD::CALL t143, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143:1
      t145: ch,glue = callseq_end t144, TargetConstant:i64<0>, TargetConstant:i64<0>, t144:1
    t146: ch,glue = callseq_start t145, TargetConstant:i64<0>, TargetConstant:i64<0>
  t147: ch,glue = CopyToReg t146, Register:i64 $rdi, Constant:i64<1>
  t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1
  t149: ch,glue = X86ISD::CALL t148, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148:1
      t150: ch,glue = callseq_end t149, TargetConstant:i64<0>, TargetConstant:i64<0>, t149:1
    t151: ch,glue = callseq_start t150, TargetConstant:i64<0>, TargetConstant:i64<0>
  t152: ch,glue = CopyToReg t151, Register:i64 $rdi, Constant:i64<1>
  t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1
  t154: ch,glue = X86ISD::CALL t153, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153:1
      t155: ch,glue = callseq_end t154, TargetConstant:i64<0>, TargetConstant:i64<0>, t154:1
    t157: ch,glue = callseq_start t155, TargetConstant:i64<0>, TargetConstant:i64<0>
  t158: ch,glue = CopyToReg t157, Register:i64 $rdi, Constant:i64<1>
  t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t168, t158:1
    t173: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_f64> 0
  t160: ch,glue = X86ISD::CALL t159, t173, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159:1
    t166: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t167: i64,ch = CopyFromReg t166, Register:i64 $rsp
  t168: i64 = sub t167, Constant:i64<48>
    t169: ch = CopyToReg t167:1, Register:i64 $rsp, t168
  t170: ch,glue = callseq_end t169, TargetConstant:i64<0>, TargetConstant:i64<0>
  t175: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_i64> 0
    t161: ch,glue = callseq_end t160, TargetConstant:i64<0>, TargetConstant:i64<0>, t160:1
  t163: ch = X86ISD::RET_FLAG t161, TargetConstant:i32<0>



Legalizing: t177: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0
Legal node: nothing to do

Combining: t177: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0

Legalizing: t176: i64 = TargetGlobalAddress<ptr @read_input_2D_f64> 0
Legal node: nothing to do

Combining: t176: i64 = TargetGlobalAddress<ptr @read_input_2D_f64> 0

Legalizing: t175: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_i64> 0
Legal node: nothing to do

Combining: t175: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_i64> 0

Legalizing: t174: i64 = TargetGlobalAddress<ptr @comet_print_memref_i64> 0
Legal node: nothing to do

Combining: t174: i64 = TargetGlobalAddress<ptr @comet_print_memref_i64> 0

Legalizing: t173: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_f64> 0
Legal node: nothing to do

Combining: t173: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_f64> 0

Legalizing: t172: i64 = TargetGlobalAddress<ptr @comet_print_memref_f64> 0
Legal node: nothing to do

Combining: t172: i64 = TargetGlobalAddress<ptr @comet_print_memref_f64> 0

Legalizing: t170: ch,glue = callseq_end t169, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t170: ch,glue = callseq_end t169, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t169: ch = CopyToReg t167:1, Register:i64 $rsp, t168
Legal node: nothing to do

Combining: t169: ch = CopyToReg t167:1, Register:i64 $rsp, t168

Legalizing: t168: i64 = sub t167, Constant:i64<48>
Legal node: nothing to do

Combining: t168: i64 = sub t167, Constant:i64<48>
Creating constant: t178: i64 = Constant<-48>
Creating new node: t179: i64 = add t167, Constant:i64<-48>
 ... into: t179: i64 = add t167, Constant:i64<-48>

Legalizing: t169: ch = CopyToReg t167:1, Register:i64 $rsp, t179
Legal node: nothing to do

Combining: t169: ch = CopyToReg t167:1, Register:i64 $rsp, t179

Legalizing: t179: i64 = add t167, Constant:i64<-48>
Legal node: nothing to do

Combining: t179: i64 = add t167, Constant:i64<-48>

Legalizing: t178: i64 = Constant<-48>
Legal node: nothing to do

Combining: t178: i64 = Constant<-48>

Legalizing: t167: i64,ch = CopyFromReg t166, Register:i64 $rsp
Legal node: nothing to do

Combining: t167: i64,ch = CopyFromReg t166, Register:i64 $rsp

Legalizing: t166: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t166: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t163: ch = X86ISD::RET_FLAG t161, TargetConstant:i32<0>
Legal node: nothing to do

Combining: t163: ch = X86ISD::RET_FLAG t161, TargetConstant:i32<0>

Legalizing: t161: ch,glue = callseq_end t160, TargetConstant:i64<0>, TargetConstant:i64<0>, t160:1

Combining: t161: ch,glue = callseq_end t160, TargetConstant:i64<0>, TargetConstant:i64<0>, t160:1

Legalizing: t160: ch,glue = X86ISD::CALL t159, t173, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159:1
Legal node: nothing to do

Combining: t160: ch,glue = X86ISD::CALL t159, t173, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159:1

Legalizing: t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t179, t158:1
Legal node: nothing to do

Combining: t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t179, t158:1

Legalizing: t158: ch,glue = CopyToReg t157, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Combining: t158: ch,glue = CopyToReg t157, Register:i64 $rdi, Constant:i64<1>

Legalizing: t157: ch,glue = callseq_start t155, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t157: ch,glue = callseq_start t155, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t155: ch,glue = callseq_end t154, TargetConstant:i64<0>, TargetConstant:i64<0>, t154:1

Combining: t155: ch,glue = callseq_end t154, TargetConstant:i64<0>, TargetConstant:i64<0>, t154:1

Legalizing: t154: ch,glue = X86ISD::CALL t153, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153:1
Legal node: nothing to do

Combining: t154: ch,glue = X86ISD::CALL t153, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153:1

Legalizing: t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1
Legal node: nothing to do

Combining: t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1

Legalizing: t152: ch,glue = CopyToReg t151, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Combining: t152: ch,glue = CopyToReg t151, Register:i64 $rdi, Constant:i64<1>

Legalizing: t151: ch,glue = callseq_start t150, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t151: ch,glue = callseq_start t150, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t150: ch,glue = callseq_end t149, TargetConstant:i64<0>, TargetConstant:i64<0>, t149:1

Combining: t150: ch,glue = callseq_end t149, TargetConstant:i64<0>, TargetConstant:i64<0>, t149:1

Legalizing: t149: ch,glue = X86ISD::CALL t148, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148:1
Legal node: nothing to do

Combining: t149: ch,glue = X86ISD::CALL t148, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148:1

Legalizing: t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1
Legal node: nothing to do

Combining: t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1

Legalizing: t147: ch,glue = CopyToReg t146, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Combining: t147: ch,glue = CopyToReg t146, Register:i64 $rdi, Constant:i64<1>

Legalizing: t146: ch,glue = callseq_start t145, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t146: ch,glue = callseq_start t145, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t145: ch,glue = callseq_end t144, TargetConstant:i64<0>, TargetConstant:i64<0>, t144:1

Combining: t145: ch,glue = callseq_end t144, TargetConstant:i64<0>, TargetConstant:i64<0>, t144:1

Legalizing: t144: ch,glue = X86ISD::CALL t143, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143:1
Legal node: nothing to do

Combining: t144: ch,glue = X86ISD::CALL t143, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143:1

Legalizing: t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1
Legal node: nothing to do

Combining: t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1

Legalizing: t142: ch,glue = CopyToReg t141, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Combining: t142: ch,glue = CopyToReg t141, Register:i64 $rdi, Constant:i64<1>

Legalizing: t141: ch,glue = callseq_start t140, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t141: ch,glue = callseq_start t140, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t140: ch,glue = callseq_end t139, TargetConstant:i64<0>, TargetConstant:i64<0>, t139:1

Combining: t140: ch,glue = callseq_end t139, TargetConstant:i64<0>, TargetConstant:i64<0>, t139:1

Legalizing: t139: ch,glue = X86ISD::CALL t138, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138:1
Legal node: nothing to do

Combining: t139: ch,glue = X86ISD::CALL t138, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138:1

Legalizing: t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1
Legal node: nothing to do

Combining: t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1

Legalizing: t137: ch,glue = CopyToReg t136, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Combining: t137: ch,glue = CopyToReg t136, Register:i64 $rdi, Constant:i64<1>

Legalizing: t136: ch,glue = callseq_start t135, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t136: ch,glue = callseq_start t135, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t135: ch,glue = callseq_end t134, TargetConstant:i64<0>, TargetConstant:i64<0>, t134:1

Combining: t135: ch,glue = callseq_end t134, TargetConstant:i64<0>, TargetConstant:i64<0>, t134:1

Legalizing: t134: ch,glue = X86ISD::CALL t133, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133:1
Legal node: nothing to do

Combining: t134: ch,glue = X86ISD::CALL t133, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133:1

Legalizing: t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1
Legal node: nothing to do

Combining: t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1

Legalizing: t132: ch,glue = CopyToReg t131, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Combining: t132: ch,glue = CopyToReg t131, Register:i64 $rdi, Constant:i64<1>

Legalizing: t131: ch,glue = callseq_start t130, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t131: ch,glue = callseq_start t130, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t130: ch,glue = callseq_end t129, TargetConstant:i64<0>, TargetConstant:i64<0>, t129:1

Combining: t130: ch,glue = callseq_end t129, TargetConstant:i64<0>, TargetConstant:i64<0>, t129:1

Legalizing: t129: ch,glue = X86ISD::CALL t128, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128:1
Legal node: nothing to do

Combining: t129: ch,glue = X86ISD::CALL t128, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128:1

Legalizing: t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1
Legal node: nothing to do

Combining: t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1

Legalizing: t127: ch,glue = CopyToReg t126, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Combining: t127: ch,glue = CopyToReg t126, Register:i64 $rdi, Constant:i64<1>

Legalizing: t126: ch,glue = callseq_start t125, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t126: ch,glue = callseq_start t125, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t125: ch,glue = callseq_end t124, TargetConstant:i64<0>, TargetConstant:i64<0>, t124:1

Combining: t125: ch,glue = callseq_end t124, TargetConstant:i64<0>, TargetConstant:i64<0>, t124:1

Legalizing: t124: ch,glue = X86ISD::CALL t123, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123:1
Legal node: nothing to do

Combining: t124: ch,glue = X86ISD::CALL t123, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123:1

Legalizing: t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1
Legal node: nothing to do

Combining: t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1

Legalizing: t122: ch,glue = CopyToReg t121, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Combining: t122: ch,glue = CopyToReg t121, Register:i64 $rdi, Constant:i64<1>

Legalizing: t121: ch,glue = callseq_start t120, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t121: ch,glue = callseq_start t120, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t120: ch,glue = callseq_end t119, TargetConstant:i64<0>, TargetConstant:i64<0>, t119:1

Combining: t120: ch,glue = callseq_end t119, TargetConstant:i64<0>, TargetConstant:i64<0>, t119:1

Legalizing: t119: ch,glue = X86ISD::CALL t118, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118:1
Legal node: nothing to do

Combining: t119: ch,glue = X86ISD::CALL t118, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118:1

Legalizing: t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1
Legal node: nothing to do

Combining: t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1

Legalizing: t117: ch,glue = CopyToReg t115, Register:i64 $rdi, Constant:i64<1>
Legal node: nothing to do

Combining: t117: ch,glue = CopyToReg t115, Register:i64 $rdi, Constant:i64<1>

Legalizing: t115: ch,glue = callseq_start t113, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t115: ch,glue = callseq_start t113, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t113: ch,glue = callseq_end t112, TargetConstant:i64<144>, TargetConstant:i64<0>, t112:1

Combining: t113: ch,glue = callseq_end t112, TargetConstant:i64<144>, TargetConstant:i64<0>, t112:1

Legalizing: t112: ch,glue = X86ISD::CALL t110, t177, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110:1
Legal node: nothing to do

Combining: t112: ch,glue = X86ISD::CALL t110, t177, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110:1

Legalizing: t110: ch,glue = CopyToReg t108, Register:i64 $r9, Constant:i64<1>, t108:1
Legal node: nothing to do

Combining: t110: ch,glue = CopyToReg t108, Register:i64 $r9, Constant:i64<1>, t108:1

Legalizing: t108: ch,glue = CopyToReg t106, Register:i64 $r8, Constant:i64<-1>, t106:1
Legal node: nothing to do

Combining: t108: ch,glue = CopyToReg t106, Register:i64 $r8, Constant:i64<-1>, t106:1

Legalizing: t106: ch,glue = CopyToReg t104, Register:i64 $rcx, Constant:i64<0>, t104:1
Legal node: nothing to do

Combining: t106: ch,glue = CopyToReg t104, Register:i64 $rcx, Constant:i64<0>, t104:1

Legalizing: t104: ch,glue = CopyToReg t102, Register:i64 $rdx, Constant:i64<3>, t102:1
Legal node: nothing to do

Combining: t104: ch,glue = CopyToReg t102, Register:i64 $rdx, Constant:i64<3>, t102:1

Legalizing: t102: ch,glue = CopyToReg t100, Register:i64 $rsi, Constant:i64<0>, t100:1
Legal node: nothing to do

Combining: t102: ch,glue = CopyToReg t100, Register:i64 $rsi, Constant:i64<0>, t100:1

Legalizing: t100: ch,glue = CopyToReg t98, Register:i32 $edi, Constant:i32<1>
Legal node: nothing to do

Combining: t100: ch,glue = CopyToReg t98, Register:i32 $edi, Constant:i32<1>

Legalizing: t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97
Legal node: nothing to do

Combining: t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97

Legalizing: t54: ch = store<(store (s64) into stack + 8)> t49, Constant:i64<1>, t53, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t54: ch = store<(store (s64) into stack + 8)> t49, Constant:i64<1>, t53, undef:i64

Legalizing: t56: ch = store<(store (s64) into stack + 16)> t49, t34, t55, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t56: ch = store<(store (s64) into stack + 16)> t49, t34, t55, undef:i64

Legalizing: t58: ch = store<(store (s64) into stack + 24)> t49, Constant:i64<1>, t57, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t58: ch = store<(store (s64) into stack + 24)> t49, Constant:i64<1>, t57, undef:i64

Legalizing: t60: ch = store<(store (s64) into stack + 32)> t49, t36, t59, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t60: ch = store<(store (s64) into stack + 32)> t49, t36, t59, undef:i64

Legalizing: t62: ch = store<(store (s64) into stack + 40)> t49, Constant:i64<1>, t61, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t62: ch = store<(store (s64) into stack + 40)> t49, Constant:i64<1>, t61, undef:i64

Legalizing: t64: ch = store<(store (s64) into stack + 48)> t49, t38, t63, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t64: ch = store<(store (s64) into stack + 48)> t49, t38, t63, undef:i64

Legalizing: t67: ch = store<(store (s64) into stack + 56)> t49, Constant:i64<1>, t66, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t67: ch = store<(store (s64) into stack + 56)> t49, Constant:i64<1>, t66, undef:i64

Legalizing: t70: ch = store<(store (s64) into stack + 64)> t49, t40, t69, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t70: ch = store<(store (s64) into stack + 64)> t49, t40, t69, undef:i64

Legalizing: t73: ch = store<(store (s64) into stack + 72)> t49, Constant:i64<1>, t72, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t73: ch = store<(store (s64) into stack + 72)> t49, Constant:i64<1>, t72, undef:i64

Legalizing: t76: ch = store<(store (s64) into stack + 80)> t49, t42, t75, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t76: ch = store<(store (s64) into stack + 80)> t49, t42, t75, undef:i64

Legalizing: t79: ch = store<(store (s64) into stack + 88)> t49, Constant:i64<1>, t78, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t79: ch = store<(store (s64) into stack + 88)> t49, Constant:i64<1>, t78, undef:i64

Legalizing: t82: ch = store<(store (s64) into stack + 96)> t49, t44, t81, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t82: ch = store<(store (s64) into stack + 96)> t49, t44, t81, undef:i64

Legalizing: t85: ch = store<(store (s64) into stack + 104)> t49, Constant:i64<1>, t84, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t85: ch = store<(store (s64) into stack + 104)> t49, Constant:i64<1>, t84, undef:i64

Legalizing: t88: ch = store<(store (s64) into stack + 112)> t49, t46, t87, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t88: ch = store<(store (s64) into stack + 112)> t49, t46, t87, undef:i64

Legalizing: t91: ch = store<(store (s64) into stack + 120)> t49, Constant:i64<1>, t90, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t91: ch = store<(store (s64) into stack + 120)> t49, Constant:i64<1>, t90, undef:i64

Legalizing: t94: ch = store<(store (s64) into stack + 128)> t49, t179, t93, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t94: ch = store<(store (s64) into stack + 128)> t49, t179, t93, undef:i64

Legalizing: t97: ch = store<(store (s32) into stack + 136)> t49, Constant:i32<1>, t96, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t97: ch = store<(store (s32) into stack + 136)> t49, Constant:i32<1>, t96, undef:i64

Legalizing: t52: ch = store<(store (s64) into stack)> t49, t32, t51, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t52: ch = store<(store (s64) into stack)> t49, t32, t51, undef:i64

Legalizing: t53: i64 = add t51, Constant:i64<8>
Legal node: nothing to do

Combining: t53: i64 = add t51, Constant:i64<8>

Legalizing: t55: i64 = add t51, Constant:i64<16>
Legal node: nothing to do

Combining: t55: i64 = add t51, Constant:i64<16>

Legalizing: t57: i64 = add t51, Constant:i64<24>
Legal node: nothing to do

Combining: t57: i64 = add t51, Constant:i64<24>

Legalizing: t59: i64 = add t51, Constant:i64<32>
Legal node: nothing to do

Combining: t59: i64 = add t51, Constant:i64<32>

Legalizing: t61: i64 = add t51, Constant:i64<40>
Legal node: nothing to do

Combining: t61: i64 = add t51, Constant:i64<40>

Legalizing: t63: i64 = add t51, Constant:i64<48>
Legal node: nothing to do

Combining: t63: i64 = add t51, Constant:i64<48>

Legalizing: t66: i64 = add t51, Constant:i64<56>
Legal node: nothing to do

Combining: t66: i64 = add t51, Constant:i64<56>

Legalizing: t69: i64 = add t51, Constant:i64<64>
Legal node: nothing to do

Combining: t69: i64 = add t51, Constant:i64<64>

Legalizing: t72: i64 = add t51, Constant:i64<72>
Legal node: nothing to do

Combining: t72: i64 = add t51, Constant:i64<72>

Legalizing: t75: i64 = add t51, Constant:i64<80>
Legal node: nothing to do

Combining: t75: i64 = add t51, Constant:i64<80>

Legalizing: t78: i64 = add t51, Constant:i64<88>
Legal node: nothing to do

Combining: t78: i64 = add t51, Constant:i64<88>

Legalizing: t81: i64 = add t51, Constant:i64<96>
Legal node: nothing to do

Combining: t81: i64 = add t51, Constant:i64<96>

Legalizing: t84: i64 = add t51, Constant:i64<104>
Legal node: nothing to do

Combining: t84: i64 = add t51, Constant:i64<104>

Legalizing: t87: i64 = add t51, Constant:i64<112>
Legal node: nothing to do

Combining: t87: i64 = add t51, Constant:i64<112>

Legalizing: t90: i64 = add t51, Constant:i64<120>
Legal node: nothing to do

Combining: t90: i64 = add t51, Constant:i64<120>

Legalizing: t93: i64 = add t51, Constant:i64<128>
Legal node: nothing to do

Combining: t93: i64 = add t51, Constant:i64<128>

Legalizing: t96: i64 = add t51, Constant:i64<136>
Legal node: nothing to do

Combining: t96: i64 = add t51, Constant:i64<136>

Legalizing: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
Legal node: nothing to do

Combining: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp

Legalizing: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>

Combining: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>

Legalizing: t165: ch = TokenFactor t13, t16, t19, t24, t164
Legal node: nothing to do

Combining: t165: ch = TokenFactor t13, t16, t19, t24, t164

Legalizing: t16: ch = store<(store (s64) into %ir..repack81)> t170, t11, t15, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t16: ch = store<(store (s64) into %ir..repack81)> t170, t11, t15, undef:i64

Legalizing: t19: ch = store<(store (s64) into %ir..repack83)> t170, Constant:i64<0>, t18, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t19: ch = store<(store (s64) into %ir..repack83)> t170, Constant:i64<0>, t18, undef:i64

Legalizing: t24: ch = store<(store (s64) into %ir..repack85)> t170, t23, t21, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t24: ch = store<(store (s64) into %ir..repack85)> t170, t23, t21, undef:i64

Legalizing: t164: ch = store<(store (s64) into %ir..repack87)> t170, Constant:i64<1>, t26, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t164: ch = store<(store (s64) into %ir..repack87)> t170, Constant:i64<1>, t26, undef:i64

Legalizing: t13: ch = store<(store (s64) into %ir.46)> t170, t11, t179, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t13: ch = store<(store (s64) into %ir.46)> t170, t11, t179, undef:i64

Legalizing: t15: i64 = add nuw t179, Constant:i64<8>
Legal node: nothing to do

Combining: t15: i64 = add nuw t179, Constant:i64<8>
Creating constant: t180: i64 = Constant<-40>
Creating new node: t181: i64 = add t167, Constant:i64<-40>
 ... into: t181: i64 = add t167, Constant:i64<-40>

Legalizing: t179: i64 = add t167, Constant:i64<-48>
Legal node: nothing to do

Combining: t179: i64 = add t167, Constant:i64<-48>

Legalizing: t16: ch = store<(store (s64) into %ir..repack81)> t170, t11, t181, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t16: ch = store<(store (s64) into %ir..repack81)> t170, t11, t181, undef:i64

Legalizing: t181: i64 = add t167, Constant:i64<-40>
Legal node: nothing to do

Combining: t181: i64 = add t167, Constant:i64<-40>

Legalizing: t180: i64 = Constant<-40>
Legal node: nothing to do

Combining: t180: i64 = Constant<-40>

Legalizing: t18: i64 = add nuw t179, Constant:i64<16>
Legal node: nothing to do

Combining: t18: i64 = add nuw t179, Constant:i64<16>
Creating constant: t182: i64 = Constant<-32>
Creating new node: t183: i64 = add t167, Constant:i64<-32>
 ... into: t183: i64 = add t167, Constant:i64<-32>

Legalizing: t179: i64 = add t167, Constant:i64<-48>
Legal node: nothing to do

Combining: t179: i64 = add t167, Constant:i64<-48>

Legalizing: t19: ch = store<(store (s64) into %ir..repack83)> t170, Constant:i64<0>, t183, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t19: ch = store<(store (s64) into %ir..repack83)> t170, Constant:i64<0>, t183, undef:i64

Legalizing: t183: i64 = add t167, Constant:i64<-32>
Legal node: nothing to do

Combining: t183: i64 = add t167, Constant:i64<-32>

Legalizing: t182: i64 = Constant<-32>
Legal node: nothing to do

Combining: t182: i64 = Constant<-32>

Legalizing: t21: i64 = add nuw t179, Constant:i64<24>
Legal node: nothing to do

Combining: t21: i64 = add nuw t179, Constant:i64<24>
Creating constant: t184: i64 = Constant<-24>
Creating new node: t185: i64 = add t167, Constant:i64<-24>
 ... into: t185: i64 = add t167, Constant:i64<-24>

Legalizing: t179: i64 = add t167, Constant:i64<-48>
Legal node: nothing to do

Combining: t179: i64 = add t167, Constant:i64<-48>

Legalizing: t24: ch = store<(store (s64) into %ir..repack85)> t170, t23, t185, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t24: ch = store<(store (s64) into %ir..repack85)> t170, t23, t185, undef:i64

Legalizing: t185: i64 = add t167, Constant:i64<-24>
Legal node: nothing to do

Combining: t185: i64 = add t167, Constant:i64<-24>

Legalizing: t184: i64 = Constant<-24>
Legal node: nothing to do

Combining: t184: i64 = Constant<-24>

Legalizing: t26: i64 = add nuw t179, Constant:i64<32>
Legal node: nothing to do

Combining: t26: i64 = add nuw t179, Constant:i64<32>
Creating constant: t186: i64 = Constant<-16>
Creating new node: t187: i64 = add t167, Constant:i64<-16>
 ... into: t187: i64 = add t167, Constant:i64<-16>

Legalizing: t179: i64 = add t167, Constant:i64<-48>
Legal node: nothing to do

Combining: t179: i64 = add t167, Constant:i64<-48>

Legalizing: t164: ch = store<(store (s64) into %ir..repack87)> t170, Constant:i64<1>, t187, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t164: ch = store<(store (s64) into %ir..repack87)> t170, Constant:i64<1>, t187, undef:i64

Legalizing: t187: i64 = add t167, Constant:i64<-16>
Legal node: nothing to do

Combining: t187: i64 = add t167, Constant:i64<-16>

Legalizing: t186: i64 = Constant<-16>
Legal node: nothing to do

Combining: t186: i64 = Constant<-16>

Legalizing: t46: i64,ch = CopyFromReg t0, Register:i64 %32
Legal node: nothing to do

Combining: t46: i64,ch = CopyFromReg t0, Register:i64 %32

Legalizing: t44: i64,ch = CopyFromReg t0, Register:i64 %29
Legal node: nothing to do

Combining: t44: i64,ch = CopyFromReg t0, Register:i64 %29

Legalizing: t42: i64,ch = CopyFromReg t0, Register:i64 %26
Legal node: nothing to do

Combining: t42: i64,ch = CopyFromReg t0, Register:i64 %26

Legalizing: t40: i64,ch = CopyFromReg t0, Register:i64 %23
Legal node: nothing to do

Combining: t40: i64,ch = CopyFromReg t0, Register:i64 %23

Legalizing: t38: i64,ch = CopyFromReg t0, Register:i64 %20
Legal node: nothing to do

Combining: t38: i64,ch = CopyFromReg t0, Register:i64 %20

Legalizing: t36: i64,ch = CopyFromReg t0, Register:i64 %17
Legal node: nothing to do

Combining: t36: i64,ch = CopyFromReg t0, Register:i64 %17

Legalizing: t34: i64,ch = CopyFromReg t0, Register:i64 %14
Legal node: nothing to do

Combining: t34: i64,ch = CopyFromReg t0, Register:i64 %14

Legalizing: t32: i64,ch = CopyFromReg t0, Register:i64 %11
Legal node: nothing to do

Combining: t32: i64,ch = CopyFromReg t0, Register:i64 %11

Legalizing: t23: i64,ch = CopyFromReg t0, Register:i64 %8
Legal node: nothing to do

Combining: t23: i64,ch = CopyFromReg t0, Register:i64 %8

Legalizing: t11: i64,ch = CopyFromReg t0, Register:i64 %34
Legal node: nothing to do

Combining: t11: i64,ch = CopyFromReg t0, Register:i64 %34

Legalizing: t162: i32 = TargetConstant<0>

Combining: t162: i32 = TargetConstant<0>

Legalizing: t116: i64 = Register $rdi

Combining: t116: i64 = Register $rdi

Legalizing: t111: Untyped = RegisterMask
Legal node: nothing to do

Combining: t111: Untyped = RegisterMask

Legalizing: t109: i64 = Register $r9

Combining: t109: i64 = Register $r9

Legalizing: t107: i64 = Register $r8

Combining: t107: i64 = Register $r8

Legalizing: t105: i64 = Register $rcx

Combining: t105: i64 = Register $rcx

Legalizing: t103: i64 = Register $rdx

Combining: t103: i64 = Register $rdx

Legalizing: t101: i64 = Register $rsi

Combining: t101: i64 = Register $rsi

Legalizing: t99: i32 = Register $edi

Combining: t99: i32 = Register $edi

Legalizing: t95: i64 = Constant<136>
Legal node: nothing to do

Combining: t95: i64 = Constant<136>

Legalizing: t92: i64 = Constant<128>
Legal node: nothing to do

Combining: t92: i64 = Constant<128>

Legalizing: t89: i64 = Constant<120>
Legal node: nothing to do

Combining: t89: i64 = Constant<120>

Legalizing: t86: i64 = Constant<112>
Legal node: nothing to do

Combining: t86: i64 = Constant<112>

Legalizing: t83: i64 = Constant<104>
Legal node: nothing to do

Combining: t83: i64 = Constant<104>

Legalizing: t80: i64 = Constant<96>
Legal node: nothing to do

Combining: t80: i64 = Constant<96>

Legalizing: t77: i64 = Constant<88>
Legal node: nothing to do

Combining: t77: i64 = Constant<88>

Legalizing: t74: i64 = Constant<80>
Legal node: nothing to do

Combining: t74: i64 = Constant<80>

Legalizing: t71: i64 = Constant<72>
Legal node: nothing to do

Combining: t71: i64 = Constant<72>

Legalizing: t68: i64 = Constant<64>
Legal node: nothing to do

Combining: t68: i64 = Constant<64>

Legalizing: t65: i64 = Constant<56>
Legal node: nothing to do

Combining: t65: i64 = Constant<56>

Legalizing: t50: i64 = Register $rsp

Combining: t50: i64 = Register $rsp

Legalizing: t48: i64 = TargetConstant<0>

Combining: t48: i64 = TargetConstant<0>

Legalizing: t47: i64 = TargetConstant<144>

Combining: t47: i64 = TargetConstant<144>

Legalizing: t45: i64 = Register %32

Combining: t45: i64 = Register %32

Legalizing: t43: i64 = Register %29

Combining: t43: i64 = Register %29

Legalizing: t41: i64 = Register %26

Combining: t41: i64 = Register %26

Legalizing: t39: i64 = Register %23

Combining: t39: i64 = Register %23

Legalizing: t37: i64 = Register %20

Combining: t37: i64 = Register %20

Legalizing: t35: i64 = Register %17

Combining: t35: i64 = Register %17

Legalizing: t33: i64 = Register %14

Combining: t33: i64 = Register %14

Legalizing: t31: i64 = Register %11

Combining: t31: i64 = Register %11

Legalizing: t30: i64 = Constant<-1>
Legal node: nothing to do

Combining: t30: i64 = Constant<-1>

Legalizing: t29: i64 = Constant<3>
Legal node: nothing to do

Combining: t29: i64 = Constant<3>

Legalizing: t25: i64 = Constant<32>
Legal node: nothing to do

Combining: t25: i64 = Constant<32>

Legalizing: t22: i64 = Register %8

Combining: t22: i64 = Register %8

Legalizing: t20: i64 = Constant<24>
Legal node: nothing to do

Combining: t20: i64 = Constant<24>

Legalizing: t17: i64 = Constant<16>
Legal node: nothing to do

Combining: t17: i64 = Constant<16>

Legalizing: t14: i64 = Constant<8>
Legal node: nothing to do

Combining: t14: i64 = Constant<8>

Legalizing: t12: i64 = undef
Legal node: nothing to do

Combining: t12: i64 = undef

Legalizing: t10: i64 = Register %34

Combining: t10: i64 = Register %34

Legalizing: t8: i64 = Constant<0>
Legal node: nothing to do

Combining: t8: i64 = Constant<0>

Legalizing: t7: i64 = Constant<48>
Legal node: nothing to do

Combining: t7: i64 = Constant<48>

Legalizing: t3: i64 = Constant<40>
Legal node: nothing to do

Combining: t3: i64 = Constant<40>

Legalizing: t2: i64 = Constant<1>
Legal node: nothing to do

Combining: t2: i64 = Constant<1>

Legalizing: t1: i32 = Constant<1>
Legal node: nothing to do

Combining: t1: i32 = Constant<1>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.18 'main:._crit_edge112'
SelectionDAG has 174 nodes:
  t0: ch,glue = EntryToken
  t11: i64,ch = CopyFromReg t0, Register:i64 %34
  t32: i64,ch = CopyFromReg t0, Register:i64 %11
  t34: i64,ch = CopyFromReg t0, Register:i64 %14
  t36: i64,ch = CopyFromReg t0, Register:i64 %17
  t38: i64,ch = CopyFromReg t0, Register:i64 %20
  t40: i64,ch = CopyFromReg t0, Register:i64 %23
  t42: i64,ch = CopyFromReg t0, Register:i64 %26
  t44: i64,ch = CopyFromReg t0, Register:i64 %29
  t46: i64,ch = CopyFromReg t0, Register:i64 %32
      t13: ch = store<(store (s64) into %ir.46)> t170, t11, t179, undef:i64
        t181: i64 = add t167, Constant:i64<-40>
      t16: ch = store<(store (s64) into %ir..repack81)> t170, t11, t181, undef:i64
        t183: i64 = add t167, Constant:i64<-32>
      t19: ch = store<(store (s64) into %ir..repack83)> t170, Constant:i64<0>, t183, undef:i64
        t23: i64,ch = CopyFromReg t0, Register:i64 %8
        t185: i64 = add t167, Constant:i64<-24>
      t24: ch = store<(store (s64) into %ir..repack85)> t170, t23, t185, undef:i64
        t187: i64 = add t167, Constant:i64<-16>
      t164: ch = store<(store (s64) into %ir..repack87)> t170, Constant:i64<1>, t187, undef:i64
    t165: ch = TokenFactor t13, t16, t19, t24, t164
  t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
  t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
      t52: ch = store<(store (s64) into stack)> t49, t32, t51, undef:i64
        t53: i64 = add t51, Constant:i64<8>
      t54: ch = store<(store (s64) into stack + 8)> t49, Constant:i64<1>, t53, undef:i64
        t55: i64 = add t51, Constant:i64<16>
      t56: ch = store<(store (s64) into stack + 16)> t49, t34, t55, undef:i64
        t57: i64 = add t51, Constant:i64<24>
      t58: ch = store<(store (s64) into stack + 24)> t49, Constant:i64<1>, t57, undef:i64
        t59: i64 = add t51, Constant:i64<32>
      t60: ch = store<(store (s64) into stack + 32)> t49, t36, t59, undef:i64
        t61: i64 = add t51, Constant:i64<40>
      t62: ch = store<(store (s64) into stack + 40)> t49, Constant:i64<1>, t61, undef:i64
        t63: i64 = add t51, Constant:i64<48>
      t64: ch = store<(store (s64) into stack + 48)> t49, t38, t63, undef:i64
        t66: i64 = add t51, Constant:i64<56>
      t67: ch = store<(store (s64) into stack + 56)> t49, Constant:i64<1>, t66, undef:i64
        t69: i64 = add t51, Constant:i64<64>
      t70: ch = store<(store (s64) into stack + 64)> t49, t40, t69, undef:i64
        t72: i64 = add t51, Constant:i64<72>
      t73: ch = store<(store (s64) into stack + 72)> t49, Constant:i64<1>, t72, undef:i64
        t75: i64 = add t51, Constant:i64<80>
      t76: ch = store<(store (s64) into stack + 80)> t49, t42, t75, undef:i64
        t78: i64 = add t51, Constant:i64<88>
      t79: ch = store<(store (s64) into stack + 88)> t49, Constant:i64<1>, t78, undef:i64
        t81: i64 = add t51, Constant:i64<96>
      t82: ch = store<(store (s64) into stack + 96)> t49, t44, t81, undef:i64
        t84: i64 = add t51, Constant:i64<104>
      t85: ch = store<(store (s64) into stack + 104)> t49, Constant:i64<1>, t84, undef:i64
        t87: i64 = add t51, Constant:i64<112>
      t88: ch = store<(store (s64) into stack + 112)> t49, t46, t87, undef:i64
        t90: i64 = add t51, Constant:i64<120>
      t91: ch = store<(store (s64) into stack + 120)> t49, Constant:i64<1>, t90, undef:i64
        t93: i64 = add t51, Constant:i64<128>
      t94: ch = store<(store (s64) into stack + 128)> t49, t179, t93, undef:i64
        t96: i64 = add t51, Constant:i64<136>
      t97: ch = store<(store (s32) into stack + 136)> t49, Constant:i32<1>, t96, undef:i64
    t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97
  t100: ch,glue = CopyToReg t98, Register:i32 $edi, Constant:i32<1>
  t102: ch,glue = CopyToReg t100, Register:i64 $rsi, Constant:i64<0>, t100:1
  t104: ch,glue = CopyToReg t102, Register:i64 $rdx, Constant:i64<3>, t102:1
  t106: ch,glue = CopyToReg t104, Register:i64 $rcx, Constant:i64<0>, t104:1
  t108: ch,glue = CopyToReg t106, Register:i64 $r8, Constant:i64<-1>, t106:1
  t110: ch,glue = CopyToReg t108, Register:i64 $r9, Constant:i64<1>, t108:1
    t177: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0
  t112: ch,glue = X86ISD::CALL t110, t177, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110:1
      t113: ch,glue = callseq_end t112, TargetConstant:i64<144>, TargetConstant:i64<0>, t112:1
    t115: ch,glue = callseq_start t113, TargetConstant:i64<0>, TargetConstant:i64<0>
  t117: ch,glue = CopyToReg t115, Register:i64 $rdi, Constant:i64<1>
  t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1
  t119: ch,glue = X86ISD::CALL t118, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118:1
      t120: ch,glue = callseq_end t119, TargetConstant:i64<0>, TargetConstant:i64<0>, t119:1
    t121: ch,glue = callseq_start t120, TargetConstant:i64<0>, TargetConstant:i64<0>
  t122: ch,glue = CopyToReg t121, Register:i64 $rdi, Constant:i64<1>
  t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1
  t124: ch,glue = X86ISD::CALL t123, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123:1
      t125: ch,glue = callseq_end t124, TargetConstant:i64<0>, TargetConstant:i64<0>, t124:1
    t126: ch,glue = callseq_start t125, TargetConstant:i64<0>, TargetConstant:i64<0>
  t127: ch,glue = CopyToReg t126, Register:i64 $rdi, Constant:i64<1>
  t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1
  t129: ch,glue = X86ISD::CALL t128, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128:1
      t130: ch,glue = callseq_end t129, TargetConstant:i64<0>, TargetConstant:i64<0>, t129:1
    t131: ch,glue = callseq_start t130, TargetConstant:i64<0>, TargetConstant:i64<0>
  t132: ch,glue = CopyToReg t131, Register:i64 $rdi, Constant:i64<1>
  t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1
  t134: ch,glue = X86ISD::CALL t133, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133:1
      t135: ch,glue = callseq_end t134, TargetConstant:i64<0>, TargetConstant:i64<0>, t134:1
    t136: ch,glue = callseq_start t135, TargetConstant:i64<0>, TargetConstant:i64<0>
  t137: ch,glue = CopyToReg t136, Register:i64 $rdi, Constant:i64<1>
  t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1
  t139: ch,glue = X86ISD::CALL t138, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138:1
      t140: ch,glue = callseq_end t139, TargetConstant:i64<0>, TargetConstant:i64<0>, t139:1
    t141: ch,glue = callseq_start t140, TargetConstant:i64<0>, TargetConstant:i64<0>
  t142: ch,glue = CopyToReg t141, Register:i64 $rdi, Constant:i64<1>
  t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1
  t144: ch,glue = X86ISD::CALL t143, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143:1
      t145: ch,glue = callseq_end t144, TargetConstant:i64<0>, TargetConstant:i64<0>, t144:1
    t146: ch,glue = callseq_start t145, TargetConstant:i64<0>, TargetConstant:i64<0>
  t147: ch,glue = CopyToReg t146, Register:i64 $rdi, Constant:i64<1>
  t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1
  t149: ch,glue = X86ISD::CALL t148, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148:1
      t150: ch,glue = callseq_end t149, TargetConstant:i64<0>, TargetConstant:i64<0>, t149:1
    t151: ch,glue = callseq_start t150, TargetConstant:i64<0>, TargetConstant:i64<0>
  t152: ch,glue = CopyToReg t151, Register:i64 $rdi, Constant:i64<1>
  t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1
  t154: ch,glue = X86ISD::CALL t153, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153:1
      t155: ch,glue = callseq_end t154, TargetConstant:i64<0>, TargetConstant:i64<0>, t154:1
    t157: ch,glue = callseq_start t155, TargetConstant:i64<0>, TargetConstant:i64<0>
  t158: ch,glue = CopyToReg t157, Register:i64 $rdi, Constant:i64<1>
  t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t179, t158:1
    t173: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_f64> 0
  t160: ch,glue = X86ISD::CALL t159, t173, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159:1
    t166: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t167: i64,ch = CopyFromReg t166, Register:i64 $rsp
    t169: ch = CopyToReg t167:1, Register:i64 $rsp, t179
  t170: ch,glue = callseq_end t169, TargetConstant:i64<0>, TargetConstant:i64<0>
  t175: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_i64> 0
  t179: i64 = add t167, Constant:i64<-48>
    t161: ch,glue = callseq_end t160, TargetConstant:i64<0>, TargetConstant:i64<0>, t160:1
  t163: ch = X86ISD::RET_FLAG t161, TargetConstant:i32<0>


===== Instruction selection begins: %bb.18 '._crit_edge112'

ISEL: Starting selection on root node: t163: ch = X86ISD::RET_FLAG t161, TargetConstant:i32<0>
ISEL: Starting pattern match
  Initial Opcode index to 131557
  Morphed node: t163: ch = RET TargetConstant:i32<0>, t161
ISEL: Match complete!

ISEL: Starting selection on root node: t161: ch,glue = callseq_end t160, TargetConstant:i64<0>, TargetConstant:i64<0>, t160:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t161: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t160, t160:1
ISEL: Match complete!

ISEL: Starting selection on root node: t160: ch,glue = X86ISD::CALL t159, t173, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t160: ch,glue = CALL64r t173, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159, t159:1
ISEL: Match complete!

ISEL: Starting selection on root node: t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t179, t158:1

ISEL: Starting selection on root node: t158: ch,glue = CopyToReg t157, Register:i64 $rdi, Constant:i64<1>

ISEL: Starting selection on root node: t157: ch,glue = callseq_start t155, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t157: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t155
ISEL: Match complete!

ISEL: Starting selection on root node: t155: ch,glue = callseq_end t154, TargetConstant:i64<0>, TargetConstant:i64<0>, t154:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t155: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t154, t154:1
ISEL: Match complete!

ISEL: Starting selection on root node: t154: ch,glue = X86ISD::CALL t153, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t154: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153, t153:1
ISEL: Match complete!

ISEL: Starting selection on root node: t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1

ISEL: Starting selection on root node: t152: ch,glue = CopyToReg t151, Register:i64 $rdi, Constant:i64<1>

ISEL: Starting selection on root node: t151: ch,glue = callseq_start t150, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t151: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t150
ISEL: Match complete!

ISEL: Starting selection on root node: t150: ch,glue = callseq_end t149, TargetConstant:i64<0>, TargetConstant:i64<0>, t149:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t150: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t149, t149:1
ISEL: Match complete!

ISEL: Starting selection on root node: t149: ch,glue = X86ISD::CALL t148, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t149: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148, t148:1
ISEL: Match complete!

ISEL: Starting selection on root node: t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1

ISEL: Starting selection on root node: t147: ch,glue = CopyToReg t146, Register:i64 $rdi, Constant:i64<1>

ISEL: Starting selection on root node: t146: ch,glue = callseq_start t145, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t146: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t145
ISEL: Match complete!

ISEL: Starting selection on root node: t145: ch,glue = callseq_end t144, TargetConstant:i64<0>, TargetConstant:i64<0>, t144:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t145: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t144, t144:1
ISEL: Match complete!

ISEL: Starting selection on root node: t144: ch,glue = X86ISD::CALL t143, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t144: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143, t143:1
ISEL: Match complete!

ISEL: Starting selection on root node: t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1

ISEL: Starting selection on root node: t142: ch,glue = CopyToReg t141, Register:i64 $rdi, Constant:i64<1>

ISEL: Starting selection on root node: t141: ch,glue = callseq_start t140, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t141: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t140
ISEL: Match complete!

ISEL: Starting selection on root node: t140: ch,glue = callseq_end t139, TargetConstant:i64<0>, TargetConstant:i64<0>, t139:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t140: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t139, t139:1
ISEL: Match complete!

ISEL: Starting selection on root node: t139: ch,glue = X86ISD::CALL t138, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t139: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138, t138:1
ISEL: Match complete!

ISEL: Starting selection on root node: t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1

ISEL: Starting selection on root node: t137: ch,glue = CopyToReg t136, Register:i64 $rdi, Constant:i64<1>

ISEL: Starting selection on root node: t136: ch,glue = callseq_start t135, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t136: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t135
ISEL: Match complete!

ISEL: Starting selection on root node: t135: ch,glue = callseq_end t134, TargetConstant:i64<0>, TargetConstant:i64<0>, t134:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t135: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t134, t134:1
ISEL: Match complete!

ISEL: Starting selection on root node: t134: ch,glue = X86ISD::CALL t133, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t134: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133, t133:1
ISEL: Match complete!

ISEL: Starting selection on root node: t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1

ISEL: Starting selection on root node: t132: ch,glue = CopyToReg t131, Register:i64 $rdi, Constant:i64<1>

ISEL: Starting selection on root node: t131: ch,glue = callseq_start t130, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t131: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t130
ISEL: Match complete!

ISEL: Starting selection on root node: t130: ch,glue = callseq_end t129, TargetConstant:i64<0>, TargetConstant:i64<0>, t129:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t130: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t129, t129:1
ISEL: Match complete!

ISEL: Starting selection on root node: t129: ch,glue = X86ISD::CALL t128, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t129: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128, t128:1
ISEL: Match complete!

ISEL: Starting selection on root node: t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1

ISEL: Starting selection on root node: t127: ch,glue = CopyToReg t126, Register:i64 $rdi, Constant:i64<1>

ISEL: Starting selection on root node: t126: ch,glue = callseq_start t125, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t126: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t125
ISEL: Match complete!

ISEL: Starting selection on root node: t125: ch,glue = callseq_end t124, TargetConstant:i64<0>, TargetConstant:i64<0>, t124:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t125: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t124, t124:1
ISEL: Match complete!

ISEL: Starting selection on root node: t124: ch,glue = X86ISD::CALL t123, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t124: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123, t123:1
ISEL: Match complete!

ISEL: Starting selection on root node: t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1

ISEL: Starting selection on root node: t122: ch,glue = CopyToReg t121, Register:i64 $rdi, Constant:i64<1>

ISEL: Starting selection on root node: t121: ch,glue = callseq_start t120, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t121: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t120
ISEL: Match complete!

ISEL: Starting selection on root node: t120: ch,glue = callseq_end t119, TargetConstant:i64<0>, TargetConstant:i64<0>, t119:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t120: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t119, t119:1
ISEL: Match complete!

ISEL: Starting selection on root node: t119: ch,glue = X86ISD::CALL t118, t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t119: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118, t118:1
ISEL: Match complete!

ISEL: Starting selection on root node: t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1

ISEL: Starting selection on root node: t117: ch,glue = CopyToReg t115, Register:i64 $rdi, Constant:i64<1>

ISEL: Starting selection on root node: t115: ch,glue = callseq_start t113, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t115: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t113
ISEL: Match complete!

ISEL: Starting selection on root node: t113: ch,glue = callseq_end t112, TargetConstant:i64<144>, TargetConstant:i64<0>, t112:1
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t113: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<144>, TargetConstant:i64<0>, t112, t112:1
ISEL: Match complete!

ISEL: Starting selection on root node: t112: ch,glue = X86ISD::CALL t110, t177, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110:1
ISEL: Starting pattern match
  Initial Opcode index to 95659
  Match failed at index 95664
  Continuing at 95747
  Match failed at index 95753
  Continuing at 95822
  Match failed at index 95823
  Continuing at 95834
  Match failed at index 95835
  Continuing at 95859
  Morphed node: t112: ch,glue = CALL64r t177, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110, t110:1
ISEL: Match complete!

ISEL: Starting selection on root node: t110: ch,glue = CopyToReg t108, Register:i64 $r9, Constant:i64<1>, t108:1

ISEL: Starting selection on root node: t108: ch,glue = CopyToReg t106, Register:i64 $r8, Constant:i64<-1>, t106:1

ISEL: Starting selection on root node: t106: ch,glue = CopyToReg t104, Register:i64 $rcx, Constant:i64<0>, t104:1

ISEL: Starting selection on root node: t104: ch,glue = CopyToReg t102, Register:i64 $rdx, Constant:i64<3>, t102:1

ISEL: Starting selection on root node: t102: ch,glue = CopyToReg t100, Register:i64 $rsi, Constant:i64<0>, t100:1

ISEL: Starting selection on root node: t100: ch,glue = CopyToReg t98, Register:i32 $edi, Constant:i32<1>

ISEL: Starting selection on root node: t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97

ISEL: Starting selection on root node: t54: ch = store<(store (s64) into stack + 8)> t49, Constant:i64<1>, t53, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t188: i8 = TargetConstant<1>
Creating constant: t190: i32 = TargetConstant<8>
Creating constant: t192: i64 = TargetConstant<1>
  Morphed node: t54: ch = MOV64mi32<Mem:(store (s64) into stack + 8)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<1>, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t56: ch = store<(store (s64) into stack + 16)> t49, t34, t55, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t193: i32 = TargetConstant<16>
  Morphed node: t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t58: ch = store<(store (s64) into stack + 24)> t49, Constant:i64<1>, t57, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t194: i32 = TargetConstant<24>
  Morphed node: t58: ch = MOV64mi32<Mem:(store (s64) into stack + 24)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<1>, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t60: ch = store<(store (s64) into stack + 32)> t49, t36, t59, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t195: i32 = TargetConstant<32>
  Morphed node: t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t62: ch = store<(store (s64) into stack + 40)> t49, Constant:i64<1>, t61, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t196: i32 = TargetConstant<40>
  Morphed node: t62: ch = MOV64mi32<Mem:(store (s64) into stack + 40)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, TargetConstant:i64<1>, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t64: ch = store<(store (s64) into stack + 48)> t49, t38, t63, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t197: i32 = TargetConstant<48>
  Morphed node: t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t67: ch = store<(store (s64) into stack + 56)> t49, Constant:i64<1>, t66, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t198: i32 = TargetConstant<56>
  Morphed node: t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t70: ch = store<(store (s64) into stack + 64)> t49, t40, t69, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t199: i32 = TargetConstant<64>
  Morphed node: t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t73: ch = store<(store (s64) into stack + 72)> t49, Constant:i64<1>, t72, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t200: i32 = TargetConstant<72>
  Morphed node: t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t76: ch = store<(store (s64) into stack + 80)> t49, t42, t75, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t201: i32 = TargetConstant<80>
  Morphed node: t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t79: ch = store<(store (s64) into stack + 88)> t49, Constant:i64<1>, t78, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t202: i32 = TargetConstant<88>
  Morphed node: t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t82: ch = store<(store (s64) into stack + 96)> t49, t44, t81, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t203: i32 = TargetConstant<96>
  Morphed node: t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t85: ch = store<(store (s64) into stack + 104)> t49, Constant:i64<1>, t84, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t204: i32 = TargetConstant<104>
  Morphed node: t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t88: ch = store<(store (s64) into stack + 112)> t49, t46, t87, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t205: i32 = TargetConstant<112>
  Morphed node: t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t91: ch = store<(store (s64) into stack + 120)> t49, Constant:i64<1>, t90, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t206: i32 = TargetConstant<120>
  Morphed node: t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t94: ch = store<(store (s64) into stack + 128)> t49, t179, t93, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  OpcodeSwitch from 1108 to 6832
  Match failed at index 6836
  Continuing at 7800
  Match failed at index 7810
  Continuing at 7853
  Match failed at index 7854
  Continuing at 7903
  Match failed at index 7908
  Continuing at 7951
  Match failed at index 7952
  Continuing at 8001
  Match failed at index 8006
  Continuing at 8049
  Match failed at index 8050
  Continuing at 8099
  Match failed at index 8100
  Continuing at 8149
  Continuing at 8150
  Match failed at index 8153
  Continuing at 8280
  Match failed at index 8284
  Continuing at 8410
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t207: i32 = TargetConstant<128>
  Morphed node: t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t97: ch = store<(store (s32) into stack + 136)> t49, Constant:i32<1>, t96, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  TypeSwitch[i32] from 16336 to 16389
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t51: i64,ch = CopyFromReg t49, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t208: i32 = TargetConstant<136>
Creating constant: t209: i32 = TargetConstant<1>
  Morphed node: t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t52: ch = store<(store (s64) into stack)> t49, t32, t51, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Morphed node: t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t51: i64,ch = CopyFromReg t49, Register:i64 $rsp

ISEL: Starting selection on root node: t49: ch,glue = callseq_start t165, TargetConstant:i64<144>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t49: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<144>, TargetConstant:i64<0>, TargetConstant:i32<0>, t165
ISEL: Match complete!

ISEL: Starting selection on root node: t165: ch = TokenFactor t13, t16, t19, t24, t164

ISEL: Starting selection on root node: t13: ch = store<(store (s64) into %ir.46)> t170, t11, t179, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t167: i64,ch = CopyFromReg t166, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t210: i32 = TargetConstant<-48>
  Morphed node: t13: ch = MOV64mr<Mem:(store (s64) into %ir.46)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t11, t170
ISEL: Match complete!

ISEL: Starting selection on root node: t16: ch = store<(store (s64) into %ir..repack81)> t170, t11, t181, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t167: i64,ch = CopyFromReg t166, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t211: i32 = TargetConstant<-40>
  Morphed node: t16: ch = MOV64mr<Mem:(store (s64) into %ir..repack81)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t11, t170
ISEL: Match complete!

ISEL: Starting selection on root node: t19: ch = store<(store (s64) into %ir..repack83)> t170, Constant:i64<0>, t183, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Skipped scope entry (due to false predicate) at index 16132, continuing at 16162
  Skipped scope entry (due to false predicate) at index 16163, continuing at 16193
  Match failed at index 16203
  Continuing at 16224
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t167: i64,ch = CopyFromReg t166, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t212: i32 = TargetConstant<-32>
  Morphed node: t19: ch = MOV64mi32<Mem:(store (s64) into %ir..repack83)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t170
ISEL: Match complete!

ISEL: Starting selection on root node: t24: ch = store<(store (s64) into %ir..repack85)> t170, t23, t185, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Skipped scope entry (due to false predicate) at index 16329, continuing at 16446
  Match failed at index 16449
  Continuing at 16475
  Match failed at index 16478
  Continuing at 16504
  Match failed at index 16507
  Continuing at 16533
  Match failed at index 16534
  Continuing at 16564
  Continuing at 16565
  Match failed at index 16567
  Continuing at 16648
  Skipped scope entry (due to false predicate) at index 16653, continuing at 16735
  Skipped scope entry (due to false predicate) at index 16736, continuing at 16844
  Skipped scope entry (due to false predicate) at index 16845, continuing at 16920
  Skipped scope entry (due to false predicate) at index 16921, continuing at 16943
  Skipped scope entry (due to false predicate) at index 16944, continuing at 16966
  Skipped scope entry (due to false predicate) at index 16967, continuing at 16989
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t167: i64,ch = CopyFromReg t166, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t213: i32 = TargetConstant<-24>
  Morphed node: t24: ch = MOV64mr<Mem:(store (s64) into %ir..repack85)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t23, t170
ISEL: Match complete!

ISEL: Starting selection on root node: t164: ch = store<(store (s64) into %ir..repack87)> t170, Constant:i64<1>, t187, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 550
  Match failed at index 551
  Continuing at 600
  Match failed at index 601
  Continuing at 668
  Match failed at index 669
  Continuing at 736
  Match failed at index 737
  Continuing at 786
  Match failed at index 787
  Continuing at 854
  Match failed at index 855
  Continuing at 883
  Match failed at index 884
  Continuing at 912
  Match failed at index 913
  Continuing at 941
  Match failed at index 942
  Continuing at 970
  Match failed at index 971
  Continuing at 999
  Match failed at index 1000
  Continuing at 1028
  Match failed at index 1029
  Continuing at 1066
  Match failed at index 1067
  Continuing at 1104
  Continuing at 1105
  Match failed at index 1108
  Continuing at 14285
  Match failed at index 14289
  Continuing at 15528
  Match failed at index 15531
  Continuing at 16127
  Match failed at index 16128
  Continuing at 16225
  Match failed at index 16226
  Continuing at 16323
  Match failed at index 16336
  Continuing at 16413
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t167: i64,ch = CopyFromReg t166, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t214: i32 = TargetConstant<-16>
  Morphed node: t164: ch = MOV64mi32<Mem:(store (s64) into %ir..repack87)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t170
ISEL: Match complete!

ISEL: Starting selection on root node: t170: ch,glue = callseq_end t169, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130527
  Skipped scope entry (due to false predicate) at index 130543, continuing at 130554
  Morphed node: t170: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t169
ISEL: Match complete!

ISEL: Starting selection on root node: t169: ch = CopyToReg t167:1, Register:i64 $rsp, t179

ISEL: Starting selection on root node: t179: i64 = add t167, Constant:i64<-48>
ISEL: Starting pattern match
  Initial Opcode index to 102161
  Match failed at index 102165
  Continuing at 102268
  Match failed at index 102270
  Continuing at 102377
  TypeSwitch[i64] from 102379 to 102420
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7ff7b10911a0
Base_Reg t167: i64,ch = CopyFromReg t166, Register:i64 $rsp
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 102420
  Continuing at 102435
  Match failed at index 102438
  Continuing at 102459
  Match failed at index 102461
  Continuing at 102483
  Skipped scope entry (due to false predicate) at index 102488, continuing at 102540
  Skipped scope entry (due to false predicate) at index 102541, continuing at 102593
  Skipped scope entry (due to false predicate) at index 102594, continuing at 102644
  Skipped scope entry (due to false predicate) at index 102645, continuing at 102669
  Match failed at index 102683
  Continuing at 102696
  Match failed at index 102700
  Continuing at 102713
Creating constant: t216: i64 = TargetConstant<-48>
  Morphed node: t179: i64,i32 = ADD64ri8 t167, TargetConstant:i64<-48>
ISEL: Match complete!

ISEL: Starting selection on root node: t167: i64,ch = CopyFromReg t166, Register:i64 $rsp

ISEL: Starting selection on root node: t177: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132007
  Match failed at index 132010
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t177: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t175: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_i64> 0
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132007
  Match failed at index 132010
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t175: i64 = MOV64ri TargetGlobalAddress:i64<ptr @comet_print_memref_i64> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t173: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @comet_print_memref_f64> 0
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132007
  Match failed at index 132010
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t173: i64 = MOV64ri TargetGlobalAddress:i64<ptr @comet_print_memref_f64> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t166: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 130570
  Skipped scope entry (due to false predicate) at index 130585, continuing at 130600
  Morphed node: t166: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t46: i64,ch = CopyFromReg t0, Register:i64 %32

ISEL: Starting selection on root node: t44: i64,ch = CopyFromReg t0, Register:i64 %29

ISEL: Starting selection on root node: t42: i64,ch = CopyFromReg t0, Register:i64 %26

ISEL: Starting selection on root node: t40: i64,ch = CopyFromReg t0, Register:i64 %23

ISEL: Starting selection on root node: t38: i64,ch = CopyFromReg t0, Register:i64 %20

ISEL: Starting selection on root node: t36: i64,ch = CopyFromReg t0, Register:i64 %17

ISEL: Starting selection on root node: t34: i64,ch = CopyFromReg t0, Register:i64 %14

ISEL: Starting selection on root node: t32: i64,ch = CopyFromReg t0, Register:i64 %11

ISEL: Starting selection on root node: t23: i64,ch = CopyFromReg t0, Register:i64 %8

ISEL: Starting selection on root node: t11: i64,ch = CopyFromReg t0, Register:i64 %34

ISEL: Starting selection on root node: t176: i64 = TargetGlobalAddress<ptr @read_input_2D_f64> 0

ISEL: Starting selection on root node: t174: i64 = TargetGlobalAddress<ptr @comet_print_memref_i64> 0

ISEL: Starting selection on root node: t172: i64 = TargetGlobalAddress<ptr @comet_print_memref_f64> 0

ISEL: Starting selection on root node: t162: i32 = TargetConstant<0>

ISEL: Starting selection on root node: t116: i64 = Register $rdi

ISEL: Starting selection on root node: t111: Untyped = RegisterMask

ISEL: Starting selection on root node: t109: i64 = Register $r9

ISEL: Starting selection on root node: t107: i64 = Register $r8

ISEL: Starting selection on root node: t105: i64 = Register $rcx

ISEL: Starting selection on root node: t103: i64 = Register $rdx

ISEL: Starting selection on root node: t101: i64 = Register $rsi

ISEL: Starting selection on root node: t99: i32 = Register $edi

ISEL: Starting selection on root node: t50: i64 = Register $rsp

ISEL: Starting selection on root node: t48: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t47: i64 = TargetConstant<144>

ISEL: Starting selection on root node: t45: i64 = Register %32

ISEL: Starting selection on root node: t43: i64 = Register %29

ISEL: Starting selection on root node: t41: i64 = Register %26

ISEL: Starting selection on root node: t39: i64 = Register %23

ISEL: Starting selection on root node: t37: i64 = Register %20

ISEL: Starting selection on root node: t35: i64 = Register %17

ISEL: Starting selection on root node: t33: i64 = Register %14

ISEL: Starting selection on root node: t31: i64 = Register %11

ISEL: Starting selection on root node: t30: i64 = Constant<-1>
ISEL: Starting pattern match
  Initial Opcode index to 127987
  Skipped scope entry (due to false predicate) at index 127989, continuing at 128066
  Skipped scope entry (due to false predicate) at index 128067, continuing at 128104
  Match failed at index 128107
  Continuing at 128142
  TypeSwitch[i64] from 128144 to 128175
  Match failed at index 128179
  Continuing at 128190
  Match failed at index 128191
  Continuing at 128202
Creating constant: t217: i64 = TargetConstant<-1>
  Morphed node: t30: i64 = MOV64ri32 TargetConstant:i64<-1>
ISEL: Match complete!

ISEL: Starting selection on root node: t29: i64 = Constant<3>
ISEL: Starting pattern match
  Initial Opcode index to 127987
  Skipped scope entry (due to false predicate) at index 127989, continuing at 128066
  Skipped scope entry (due to false predicate) at index 128067, continuing at 128104
  Skipped scope entry (due to false predicate) at index 128105, continuing at 128142
  TypeSwitch[i64] from 128144 to 128175
  Match failed at index 128179
  Continuing at 128190
Creating constant: t218: i64 = TargetConstant<3>
  Morphed node: t29: i64 = MOV32ri64 TargetConstant:i64<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t22: i64 = Register %8

ISEL: Starting selection on root node: t10: i64 = Register %34

ISEL: Starting selection on root node: t8: i64 = Constant<0>
ISEL: Starting pattern match
  Initial Opcode index to 127987
  TypeSwitch[i64] from 127991 to 128043
Creating new machine node: t219: i32,i32 = MOV32r0
  Created node: t219: i32,i32 = MOV32r0
Creating constant: t220: i32 = TargetConstant<6>
  Morphed node: t8: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>
ISEL: Match complete!

ISEL: Starting selection on root node: t2: i64 = Constant<1>
ISEL: Starting pattern match
  Initial Opcode index to 127987
  Skipped scope entry (due to false predicate) at index 127989, continuing at 128066
  Match failed at index 128069
  Continuing at 128104
  Match failed at index 128105
  Continuing at 128142
  TypeSwitch[i64] from 128144 to 128175
  Match failed at index 128179
  Continuing at 128190
  Morphed node: t2: i64 = MOV32ri64 TargetConstant:i64<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i32 = Constant<1>
ISEL: Starting pattern match
  Initial Opcode index to 127987
  Skipped scope entry (due to false predicate) at index 127989, continuing at 128066
  TypeSwitch[i32] from 128069 to 128072
  Match failed at index 128072
  Continuing at 128104
  Match failed at index 128105
  Continuing at 128142
  TypeSwitch[i32] from 128144 to 128147
  Match failed at index 128151
  Continuing at 128162
  Morphed node: t1: i32 = MOV32ri TargetConstant:i32<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.18 'main:._crit_edge112'
SelectionDAG has 163 nodes:
  t0: ch,glue = EntryToken
  t2: i64 = MOV32ri64 TargetConstant:i64<1>
  t8: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>
  t11: i64,ch = CopyFromReg t0, Register:i64 %34
  t32: i64,ch = CopyFromReg t0, Register:i64 %11
  t34: i64,ch = CopyFromReg t0, Register:i64 %14
  t36: i64,ch = CopyFromReg t0, Register:i64 %17
  t38: i64,ch = CopyFromReg t0, Register:i64 %20
  t40: i64,ch = CopyFromReg t0, Register:i64 %23
  t42: i64,ch = CopyFromReg t0, Register:i64 %26
  t44: i64,ch = CopyFromReg t0, Register:i64 %29
  t46: i64,ch = CopyFromReg t0, Register:i64 %32
  t175: i64 = MOV64ri TargetGlobalAddress:i64<ptr @comet_print_memref_i64> 0
    t166: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
  t167: i64,ch = CopyFromReg t166:1, Register:i64 $rsp
  t179: i64,i32 = ADD64ri8 t167, TargetConstant:i64<-48>
    t169: ch = CopyToReg t167:1, Register:i64 $rsp, t179
  t170: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t169
      t13: ch = MOV64mr<Mem:(store (s64) into %ir.46)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t11, t170:1
      t16: ch = MOV64mr<Mem:(store (s64) into %ir..repack81)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t11, t170:1
      t19: ch = MOV64mi32<Mem:(store (s64) into %ir..repack83)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t170:1
        t23: i64,ch = CopyFromReg t0, Register:i64 %8
      t24: ch = MOV64mr<Mem:(store (s64) into %ir..repack85)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t23, t170:1
      t164: ch = MOV64mi32<Mem:(store (s64) into %ir..repack87)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t170:1
    t165: ch = TokenFactor t13, t16, t19, t24, t164
  t49: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<144>, TargetConstant:i64<0>, TargetConstant:i32<0>, t165
  t51: i64,ch = CopyFromReg t49:1, Register:i64 $rsp
      t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1
      t54: ch = MOV64mi32<Mem:(store (s64) into stack + 8)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1
      t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1
      t58: ch = MOV64mi32<Mem:(store (s64) into stack + 24)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1
      t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1
      t62: ch = MOV64mi32<Mem:(store (s64) into stack + 40)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1
      t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1
      t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1
      t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1
      t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1
      t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1
      t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1
      t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1
      t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1
      t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1
      t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1
      t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1
      t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1
    t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97
    t1: i32 = MOV32ri TargetConstant:i32<1>
  t100: ch,glue = CopyToReg t98, Register:i32 $edi, t1
  t102: ch,glue = CopyToReg t100, Register:i64 $rsi, t8, t100:1
    t29: i64 = MOV32ri64 TargetConstant:i64<3>
  t104: ch,glue = CopyToReg t102, Register:i64 $rdx, t29, t102:1
  t106: ch,glue = CopyToReg t104, Register:i64 $rcx, t8, t104:1
    t30: i64 = MOV64ri32 TargetConstant:i64<-1>
  t108: ch,glue = CopyToReg t106, Register:i64 $r8, t30, t106:1
  t110: ch,glue = CopyToReg t108, Register:i64 $r9, t2, t108:1
    t177: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0
  t112: ch,glue = CALL64r t177, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110, t110:1
      t113: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<144>, TargetConstant:i64<0>, t112, t112:1
    t115: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t113:1
  t117: ch,glue = CopyToReg t115:1, Register:i64 $rdi, t2
  t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1
  t119: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118, t118:1
      t120: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t119, t119:1
    t121: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t120:1
  t122: ch,glue = CopyToReg t121:1, Register:i64 $rdi, t2
  t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1
  t124: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123, t123:1
      t125: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t124, t124:1
    t126: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t125:1
  t127: ch,glue = CopyToReg t126:1, Register:i64 $rdi, t2
  t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1
  t129: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128, t128:1
      t130: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t129, t129:1
    t131: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t130:1
  t132: ch,glue = CopyToReg t131:1, Register:i64 $rdi, t2
  t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1
  t134: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133, t133:1
      t135: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t134, t134:1
    t136: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t135:1
  t137: ch,glue = CopyToReg t136:1, Register:i64 $rdi, t2
  t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1
  t139: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138, t138:1
      t140: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t139, t139:1
    t141: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t140:1
  t142: ch,glue = CopyToReg t141:1, Register:i64 $rdi, t2
  t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1
  t144: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143, t143:1
      t145: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t144, t144:1
    t146: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t145:1
  t147: ch,glue = CopyToReg t146:1, Register:i64 $rdi, t2
  t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1
  t149: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148, t148:1
      t150: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t149, t149:1
    t151: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t150:1
  t152: ch,glue = CopyToReg t151:1, Register:i64 $rdi, t2
  t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1
  t154: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153, t153:1
      t155: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t154, t154:1
    t157: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t155:1
  t158: ch,glue = CopyToReg t157:1, Register:i64 $rdi, t2
  t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t179, t158:1
    t173: i64 = MOV64ri TargetGlobalAddress:i64<ptr @comet_print_memref_f64> 0
  t160: ch,glue = CALL64r t173, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159, t159:1
  t215: i32 = Register $noreg
    t161: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t160, t160:1
  t163: ch = RET TargetConstant:i32<0>, t161:1


********** List Scheduling %bb.18 '._crit_edge112' **********
SU(0): t163: ch = RET TargetConstant:i32<0>, t161:1

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 28
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t161: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t160, t160:1

    t158: ch,glue = CopyToReg t157:1, Register:i64 $rdi, t2

    t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t179, t158:1

    t160: ch,glue = CALL64r t173, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159, t159:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 27
  Height             : 1
  Predecessors:
    SU(70): Data Latency=1
    SU(2): Data Latency=1
    SU(6): Ord  Latency=1 Barrier
    SU(5): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t179: i64,i32 = ADD64ri8 t167, TargetConstant:i64<-48>

  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 26
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
    SU(43): Data Latency=1
    SU(51): Data Latency=1
SU(3): t167: i64,ch = CopyFromReg t166:1, Register:i64 $rsp

  # preds left       : 1
  # succs left       : 7
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 27
  Predecessors:
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(2): Data Latency=1
    SU(41): Data Latency=1
    SU(43): Ord  Latency=1 Barrier
    SU(44): Data Latency=1
    SU(46): Data Latency=1
    SU(47): Data Latency=1
    SU(49): Data Latency=1
SU(4): t166: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 28
  Successors:
    SU(3): Ord  Latency=1 Barrier
SU(5): t2: i64 = MOV32ri64 TargetConstant:i64<1>

  # preds left       : 0
  # succs left       : 10
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 20
  Successors:
    SU(1): Data Latency=1
    SU(7): Data Latency=1
    SU(10): Data Latency=1
    SU(13): Data Latency=1
    SU(16): Data Latency=1
    SU(19): Data Latency=1
    SU(22): Data Latency=1
    SU(25): Data Latency=1
    SU(28): Data Latency=1
    SU(31): Data Latency=1
SU(6): t157: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t155:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 26
  Height             : 2
  Predecessors:
    SU(7): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(7): t155: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t154, t154:1

    t152: ch,glue = CopyToReg t151:1, Register:i64 $rdi, t2

    t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1

    t154: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153, t153:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 25
  Height             : 3
  Predecessors:
    SU(69): Data Latency=1
    SU(8): Data Latency=1
    SU(9): Ord  Latency=1 Barrier
    SU(5): Data Latency=1
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(8): t46: i64,ch = CopyFromReg t0, Register:i64 %32

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 21
  Successors:
    SU(7): Data Latency=1
    SU(53): Data Latency=1
SU(9): t151: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t150:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 24
  Height             : 4
  Predecessors:
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(7): Ord  Latency=1 Barrier
SU(10): t150: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t149, t149:1

    t147: ch,glue = CopyToReg t146:1, Register:i64 $rdi, t2

    t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1

    t149: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148, t148:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 23
  Height             : 5
  Predecessors:
    SU(69): Data Latency=1
    SU(11): Data Latency=1
    SU(12): Ord  Latency=1 Barrier
    SU(5): Data Latency=1
  Successors:
    SU(9): Ord  Latency=1 Barrier
SU(11): t44: i64,ch = CopyFromReg t0, Register:i64 %29

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 21
  Successors:
    SU(10): Data Latency=1
    SU(55): Data Latency=1
SU(12): t146: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t145:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 22
  Height             : 6
  Predecessors:
    SU(13): Ord  Latency=1 Barrier
  Successors:
    SU(10): Ord  Latency=1 Barrier
SU(13): t145: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t144, t144:1

    t142: ch,glue = CopyToReg t141:1, Register:i64 $rdi, t2

    t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1

    t144: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143, t143:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 21
  Height             : 7
  Predecessors:
    SU(69): Data Latency=1
    SU(14): Data Latency=1
    SU(15): Ord  Latency=1 Barrier
    SU(5): Data Latency=1
  Successors:
    SU(12): Ord  Latency=1 Barrier
SU(14): t42: i64,ch = CopyFromReg t0, Register:i64 %26

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 21
  Successors:
    SU(13): Data Latency=1
    SU(57): Data Latency=1
SU(15): t141: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t140:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 20
  Height             : 8
  Predecessors:
    SU(16): Ord  Latency=1 Barrier
  Successors:
    SU(13): Ord  Latency=1 Barrier
SU(16): t140: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t139, t139:1

    t137: ch,glue = CopyToReg t136:1, Register:i64 $rdi, t2

    t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1

    t139: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138, t138:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 19
  Height             : 9
  Predecessors:
    SU(69): Data Latency=1
    SU(17): Data Latency=1
    SU(18): Ord  Latency=1 Barrier
    SU(5): Data Latency=1
  Successors:
    SU(15): Ord  Latency=1 Barrier
SU(17): t40: i64,ch = CopyFromReg t0, Register:i64 %23

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 21
  Successors:
    SU(16): Data Latency=1
    SU(59): Data Latency=1
SU(18): t136: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t135:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 18
  Height             : 10
  Predecessors:
    SU(19): Ord  Latency=1 Barrier
  Successors:
    SU(16): Ord  Latency=1 Barrier
SU(19): t135: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t134, t134:1

    t132: ch,glue = CopyToReg t131:1, Register:i64 $rdi, t2

    t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1

    t134: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133, t133:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 17
  Height             : 11
  Predecessors:
    SU(69): Data Latency=1
    SU(20): Data Latency=1
    SU(21): Ord  Latency=1 Barrier
    SU(5): Data Latency=1
  Successors:
    SU(18): Ord  Latency=1 Barrier
SU(20): t38: i64,ch = CopyFromReg t0, Register:i64 %20

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 21
  Successors:
    SU(19): Data Latency=1
    SU(61): Data Latency=1
SU(21): t131: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t130:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 16
  Height             : 12
  Predecessors:
    SU(22): Ord  Latency=1 Barrier
  Successors:
    SU(19): Ord  Latency=1 Barrier
SU(22): t130: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t129, t129:1

    t127: ch,glue = CopyToReg t126:1, Register:i64 $rdi, t2

    t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1

    t129: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128, t128:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 15
  Height             : 13
  Predecessors:
    SU(69): Data Latency=1
    SU(23): Data Latency=1
    SU(24): Ord  Latency=1 Barrier
    SU(5): Data Latency=1
  Successors:
    SU(21): Ord  Latency=1 Barrier
SU(23): t36: i64,ch = CopyFromReg t0, Register:i64 %17

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 21
  Successors:
    SU(22): Data Latency=1
    SU(63): Data Latency=1
SU(24): t126: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t125:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 14
  Height             : 14
  Predecessors:
    SU(25): Ord  Latency=1 Barrier
  Successors:
    SU(22): Ord  Latency=1 Barrier
SU(25): t125: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t124, t124:1

    t122: ch,glue = CopyToReg t121:1, Register:i64 $rdi, t2

    t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1

    t124: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123, t123:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 13
  Height             : 15
  Predecessors:
    SU(69): Data Latency=1
    SU(26): Data Latency=1
    SU(27): Ord  Latency=1 Barrier
    SU(5): Data Latency=1
  Successors:
    SU(24): Ord  Latency=1 Barrier
SU(26): t34: i64,ch = CopyFromReg t0, Register:i64 %14

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 21
  Successors:
    SU(25): Data Latency=1
    SU(65): Data Latency=1
SU(27): t121: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t120:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 16
  Predecessors:
    SU(28): Ord  Latency=1 Barrier
  Successors:
    SU(25): Ord  Latency=1 Barrier
SU(28): t120: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t119, t119:1

    t117: ch,glue = CopyToReg t115:1, Register:i64 $rdi, t2

    t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1

    t119: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118, t118:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 11
  Height             : 17
  Predecessors:
    SU(69): Data Latency=1
    SU(29): Data Latency=1
    SU(30): Ord  Latency=1 Barrier
    SU(5): Data Latency=1
  Successors:
    SU(27): Ord  Latency=1 Barrier
SU(29): t32: i64,ch = CopyFromReg t0, Register:i64 %11

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 21
  Successors:
    SU(28): Data Latency=1
    SU(67): Data Latency=1
SU(30): t115: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t113:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 18
  Predecessors:
    SU(31): Ord  Latency=1 Barrier
  Successors:
    SU(28): Ord  Latency=1 Barrier
SU(31): t113: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<144>, TargetConstant:i64<0>, t112, t112:1

    t100: ch,glue = CopyToReg t98, Register:i32 $edi, t1

    t102: ch,glue = CopyToReg t100, Register:i64 $rsi, t8, t100:1

    t104: ch,glue = CopyToReg t102, Register:i64 $rdx, t29, t102:1

    t106: ch,glue = CopyToReg t104, Register:i64 $rcx, t8, t104:1

    t108: ch,glue = CopyToReg t106, Register:i64 $r8, t30, t106:1

    t110: ch,glue = CopyToReg t108, Register:i64 $r9, t2, t108:1

    t112: ch,glue = CALL64r t177, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110, t110:1

  # preds left       : 7
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 19
  Predecessors:
    SU(68): Data Latency=1
    SU(5): Data Latency=1
    SU(32): Data Latency=1
    SU(33): Data Latency=1
    SU(35): Data Latency=1
    SU(37): Ord  Latency=0 Barrier
    SU(36): Data Latency=1
  Successors:
    SU(30): Ord  Latency=1 Barrier
SU(32): t30: i64 = MOV64ri32 TargetConstant:i64<-1>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 20
  Successors:
    SU(31): Data Latency=1
SU(33): t8: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 20
  Predecessors:
    SU(34): Data Latency=1
  Successors:
    SU(31): Data Latency=1
SU(34): t219: i32,i32 = MOV32r0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 21
  Successors:
    SU(33): Data Latency=1
SU(35): t29: i64 = MOV32ri64 TargetConstant:i64<3>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 20
  Successors:
    SU(31): Data Latency=1
SU(36): t1: i32 = MOV32ri TargetConstant:i32<1>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 20
  Successors:
    SU(31): Data Latency=1
SU(37): t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97

  # preds left       : 18
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 9
  Height             : 19
  Predecessors:
    SU(67): Ord  Latency=1 Barrier
    SU(66): Ord  Latency=1 Barrier
    SU(65): Ord  Latency=1 Barrier
    SU(64): Ord  Latency=1 Barrier
    SU(63): Ord  Latency=1 Barrier
    SU(62): Ord  Latency=1 Barrier
    SU(61): Ord  Latency=1 Barrier
    SU(60): Ord  Latency=1 Barrier
    SU(59): Ord  Latency=1 Barrier
    SU(58): Ord  Latency=1 Barrier
    SU(57): Ord  Latency=1 Barrier
    SU(56): Ord  Latency=1 Barrier
    SU(55): Ord  Latency=1 Barrier
    SU(54): Ord  Latency=1 Barrier
    SU(53): Ord  Latency=1 Barrier
    SU(52): Ord  Latency=1 Barrier
    SU(51): Ord  Latency=1 Barrier
    SU(38): Ord  Latency=1 Barrier
  Successors:
    SU(31): Ord  Latency=0 Barrier
SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(39): t49: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<144>, TargetConstant:i64<0>, TargetConstant:i32<0>, t165

  # preds left       : 1
  # succs left       : 19
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 22
  Predecessors:
    SU(40): Ord  Latency=0 Barrier
  Successors:
    SU(38): Ord  Latency=1 Barrier
    SU(50): Ord  Latency=1 Barrier
    SU(51): Ord  Latency=1 Barrier
    SU(52): Ord  Latency=1 Barrier
    SU(53): Ord  Latency=1 Barrier
    SU(54): Ord  Latency=1 Barrier
    SU(55): Ord  Latency=1 Barrier
    SU(56): Ord  Latency=1 Barrier
    SU(57): Ord  Latency=1 Barrier
    SU(58): Ord  Latency=1 Barrier
    SU(59): Ord  Latency=1 Barrier
    SU(60): Ord  Latency=1 Barrier
    SU(61): Ord  Latency=1 Barrier
    SU(62): Ord  Latency=1 Barrier
    SU(63): Ord  Latency=1 Barrier
    SU(64): Ord  Latency=1 Barrier
    SU(65): Ord  Latency=1 Barrier
    SU(66): Ord  Latency=1 Barrier
    SU(67): Ord  Latency=1 Barrier
SU(40): t165: ch = TokenFactor t13, t16, t19, t24, t164

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 22
  Predecessors:
    SU(49): Ord  Latency=1 Barrier
    SU(47): Ord  Latency=1 Barrier
    SU(46): Ord  Latency=1 Barrier
    SU(44): Ord  Latency=1 Barrier
    SU(41): Ord  Latency=1 Barrier
  Successors:
    SU(39): Ord  Latency=0 Barrier
SU(41): t164: ch = MOV64mi32<Mem:(store (s64) into %ir..repack87)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t170:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 23
  Predecessors:
    SU(3): Data Latency=1
    SU(42): Ord  Latency=1 Barrier
  Successors:
    SU(40): Ord  Latency=1 Barrier
SU(42): t170: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t169

  # preds left       : 1
  # succs left       : 5
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 24
  Predecessors:
    SU(43): Ord  Latency=1 Barrier
  Successors:
    SU(41): Ord  Latency=1 Barrier
    SU(44): Ord  Latency=1 Barrier
    SU(46): Ord  Latency=1 Barrier
    SU(47): Ord  Latency=1 Barrier
    SU(49): Ord  Latency=1 Barrier
SU(43): t169: ch = CopyToReg t167:1, Register:i64 $rsp, t179

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 25
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
  Successors:
    SU(42): Ord  Latency=1 Barrier
SU(44): t24: ch = MOV64mr<Mem:(store (s64) into %ir..repack85)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t23, t170:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 23
  Predecessors:
    SU(3): Data Latency=1
    SU(45): Data Latency=1
    SU(42): Ord  Latency=1 Barrier
  Successors:
    SU(40): Ord  Latency=1 Barrier
SU(45): t23: i64,ch = CopyFromReg t0, Register:i64 %8

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 24
  Successors:
    SU(44): Data Latency=1
SU(46): t19: ch = MOV64mi32<Mem:(store (s64) into %ir..repack83)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t170:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 23
  Predecessors:
    SU(3): Data Latency=1
    SU(42): Ord  Latency=1 Barrier
  Successors:
    SU(40): Ord  Latency=1 Barrier
SU(47): t16: ch = MOV64mr<Mem:(store (s64) into %ir..repack81)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t11, t170:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 23
  Predecessors:
    SU(3): Data Latency=1
    SU(48): Data Latency=1
    SU(42): Ord  Latency=1 Barrier
  Successors:
    SU(40): Ord  Latency=1 Barrier
SU(48): t11: i64,ch = CopyFromReg t0, Register:i64 %34

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 24
  Successors:
    SU(47): Data Latency=1
    SU(49): Data Latency=1
SU(49): t13: ch = MOV64mr<Mem:(store (s64) into %ir.46)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t11, t170:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 23
  Predecessors:
    SU(3): Data Latency=1
    SU(48): Data Latency=1
    SU(42): Ord  Latency=1 Barrier
  Successors:
    SU(40): Ord  Latency=1 Barrier
SU(50): t51: i64,ch = CopyFromReg t49:1, Register:i64 $rsp

  # preds left       : 1
  # succs left       : 18
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 21
  Predecessors:
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(38): Data Latency=1
    SU(51): Data Latency=1
    SU(52): Data Latency=1
    SU(53): Data Latency=1
    SU(54): Data Latency=1
    SU(55): Data Latency=1
    SU(56): Data Latency=1
    SU(57): Data Latency=1
    SU(58): Data Latency=1
    SU(59): Data Latency=1
    SU(60): Data Latency=1
    SU(61): Data Latency=1
    SU(62): Data Latency=1
    SU(63): Data Latency=1
    SU(64): Data Latency=1
    SU(65): Data Latency=1
    SU(66): Data Latency=1
    SU(67): Data Latency=1
SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(2): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(8): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(11): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(14): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(58): t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(17): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(60): t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(20): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(62): t62: ch = MOV64mi32<Mem:(store (s64) into stack + 40)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(23): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(64): t58: ch = MOV64mi32<Mem:(store (s64) into stack + 24)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(26): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(66): t54: ch = MOV64mi32<Mem:(store (s64) into stack + 8)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 20
  Predecessors:
    SU(50): Data Latency=1
    SU(29): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(68): t177: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 20
  Successors:
    SU(31): Data Latency=1
SU(69): t175: i64 = MOV64ri TargetGlobalAddress:i64<ptr @comet_print_memref_i64> 0

  # preds left       : 0
  # succs left       : 8
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 18
  Successors:
    SU(7): Data Latency=1
    SU(10): Data Latency=1
    SU(13): Data Latency=1
    SU(16): Data Latency=1
    SU(19): Data Latency=1
    SU(22): Data Latency=1
    SU(25): Data Latency=1
    SU(28): Data Latency=1
SU(70): t173: i64 = MOV64ri TargetGlobalAddress:i64<ptr @comet_print_memref_f64> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t163: ch = RET TargetConstant:i32<0>, t161:1


*** Scheduling [0]: SU(0): t163: ch = RET TargetConstant:i32<0>, t161:1


Examining Available:
Height 1: SU(1): t161: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t160, t160:1

    t158: ch,glue = CopyToReg t157:1, Register:i64 $rdi, t2

    t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t179, t158:1

    t160: ch,glue = CALL64r t173, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159, t159:1


*** Scheduling [1]: SU(1): t161: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t160, t160:1

    t158: ch,glue = CopyToReg t157:1, Register:i64 $rdi, t2

    t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t179, t158:1

    t160: ch,glue = CALL64r t173, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159, t159:1


Examining Available:
Height 2: SU(70): t173: i64 = MOV64ri TargetGlobalAddress:i64<ptr @comet_print_memref_f64> 0

Height 2: SU(6): t157: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t155:1


*** Scheduling [2]: SU(70): t173: i64 = MOV64ri TargetGlobalAddress:i64<ptr @comet_print_memref_f64> 0


Examining Available:
Height 2: SU(6): t157: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t155:1


*** Scheduling [3]: SU(6): t157: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t155:1


Examining Available:
Height 4: SU(7): t155: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t154, t154:1

    t152: ch,glue = CopyToReg t151:1, Register:i64 $rdi, t2

    t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1

    t154: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153, t153:1


*** Scheduling [4]: SU(7): t155: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t154, t154:1

    t152: ch,glue = CopyToReg t151:1, Register:i64 $rdi, t2

    t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1

    t154: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153, t153:1


Examining Available:
Height 5: SU(9): t151: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t150:1


*** Scheduling [5]: SU(9): t151: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t150:1


Examining Available:
Height 6: SU(10): t150: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t149, t149:1

    t147: ch,glue = CopyToReg t146:1, Register:i64 $rdi, t2

    t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1

    t149: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148, t148:1


*** Scheduling [6]: SU(10): t150: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t149, t149:1

    t147: ch,glue = CopyToReg t146:1, Register:i64 $rdi, t2

    t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1

    t149: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148, t148:1


Examining Available:
Height 7: SU(12): t146: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t145:1


*** Scheduling [7]: SU(12): t146: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t145:1


Examining Available:
Height 8: SU(13): t145: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t144, t144:1

    t142: ch,glue = CopyToReg t141:1, Register:i64 $rdi, t2

    t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1

    t144: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143, t143:1


*** Scheduling [8]: SU(13): t145: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t144, t144:1

    t142: ch,glue = CopyToReg t141:1, Register:i64 $rdi, t2

    t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1

    t144: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143, t143:1


Examining Available:
Height 9: SU(15): t141: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t140:1


*** Scheduling [9]: SU(15): t141: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t140:1


Examining Available:
Height 10: SU(16): t140: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t139, t139:1

    t137: ch,glue = CopyToReg t136:1, Register:i64 $rdi, t2

    t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1

    t139: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138, t138:1


*** Scheduling [10]: SU(16): t140: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t139, t139:1

    t137: ch,glue = CopyToReg t136:1, Register:i64 $rdi, t2

    t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1

    t139: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138, t138:1


Examining Available:
Height 11: SU(18): t136: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t135:1


*** Scheduling [11]: SU(18): t136: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t135:1


Examining Available:
Height 12: SU(19): t135: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t134, t134:1

    t132: ch,glue = CopyToReg t131:1, Register:i64 $rdi, t2

    t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1

    t134: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133, t133:1


*** Scheduling [12]: SU(19): t135: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t134, t134:1

    t132: ch,glue = CopyToReg t131:1, Register:i64 $rdi, t2

    t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1

    t134: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133, t133:1


Examining Available:
Height 13: SU(21): t131: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t130:1


*** Scheduling [13]: SU(21): t131: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t130:1


Examining Available:
Height 14: SU(22): t130: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t129, t129:1

    t127: ch,glue = CopyToReg t126:1, Register:i64 $rdi, t2

    t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1

    t129: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128, t128:1


*** Scheduling [14]: SU(22): t130: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t129, t129:1

    t127: ch,glue = CopyToReg t126:1, Register:i64 $rdi, t2

    t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1

    t129: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128, t128:1


Examining Available:
Height 15: SU(24): t126: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t125:1


*** Scheduling [15]: SU(24): t126: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t125:1


Examining Available:
Height 16: SU(25): t125: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t124, t124:1

    t122: ch,glue = CopyToReg t121:1, Register:i64 $rdi, t2

    t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1

    t124: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123, t123:1


*** Scheduling [16]: SU(25): t125: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t124, t124:1

    t122: ch,glue = CopyToReg t121:1, Register:i64 $rdi, t2

    t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1

    t124: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123, t123:1


Examining Available:
Height 17: SU(27): t121: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t120:1


*** Scheduling [17]: SU(27): t121: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t120:1


Examining Available:
Height 18: SU(28): t120: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t119, t119:1

    t117: ch,glue = CopyToReg t115:1, Register:i64 $rdi, t2

    t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1

    t119: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118, t118:1


*** Scheduling [18]: SU(28): t120: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t119, t119:1

    t117: ch,glue = CopyToReg t115:1, Register:i64 $rdi, t2

    t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1

    t119: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118, t118:1


Examining Available:
Height 19: SU(69): t175: i64 = MOV64ri TargetGlobalAddress:i64<ptr @comet_print_memref_i64> 0

Height 19: SU(30): t115: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t113:1


*** Scheduling [19]: SU(69): t175: i64 = MOV64ri TargetGlobalAddress:i64<ptr @comet_print_memref_i64> 0


Examining Available:
Height 19: SU(30): t115: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t113:1


*** Scheduling [20]: SU(30): t115: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t113:1


Examining Available:
Height 21: SU(31): t113: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<144>, TargetConstant:i64<0>, t112, t112:1

    t100: ch,glue = CopyToReg t98, Register:i32 $edi, t1

    t102: ch,glue = CopyToReg t100, Register:i64 $rsi, t8, t100:1

    t104: ch,glue = CopyToReg t102, Register:i64 $rdx, t29, t102:1

    t106: ch,glue = CopyToReg t104, Register:i64 $rcx, t8, t104:1

    t108: ch,glue = CopyToReg t106, Register:i64 $r8, t30, t106:1

    t110: ch,glue = CopyToReg t108, Register:i64 $r9, t2, t108:1

    t112: ch,glue = CALL64r t177, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110, t110:1


*** Scheduling [21]: SU(31): t113: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<144>, TargetConstant:i64<0>, t112, t112:1

    t100: ch,glue = CopyToReg t98, Register:i32 $edi, t1

    t102: ch,glue = CopyToReg t100, Register:i64 $rsi, t8, t100:1

    t104: ch,glue = CopyToReg t102, Register:i64 $rdx, t29, t102:1

    t106: ch,glue = CopyToReg t104, Register:i64 $rcx, t8, t104:1

    t108: ch,glue = CopyToReg t106, Register:i64 $r8, t30, t106:1

    t110: ch,glue = CopyToReg t108, Register:i64 $r9, t2, t108:1

    t112: ch,glue = CALL64r t177, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110, t110:1


Examining Available:
Height 21: SU(37): t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97

Height 22: SU(5): t2: i64 = MOV32ri64 TargetConstant:i64<1>

Height 22: SU(32): t30: i64 = MOV64ri32 TargetConstant:i64<-1>

Height 22: SU(35): t29: i64 = MOV32ri64 TargetConstant:i64<3>

Height 22: SU(36): t1: i32 = MOV32ri TargetConstant:i32<1>

Height 22: SU(33): t8: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

Height 22: SU(68): t177: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0


*** Scheduling [22]: SU(37): t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97


Examining Available:
Height 22: SU(5): t2: i64 = MOV32ri64 TargetConstant:i64<1>

Height 22: SU(32): t30: i64 = MOV64ri32 TargetConstant:i64<-1>

Height 22: SU(35): t29: i64 = MOV32ri64 TargetConstant:i64<3>

Height 22: SU(36): t1: i32 = MOV32ri TargetConstant:i32<1>

Height 22: SU(33): t8: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

Height 22: SU(68): t177: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0

Height 23: SU(66): t54: ch = MOV64mi32<Mem:(store (s64) into stack + 8)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(64): t58: ch = MOV64mi32<Mem:(store (s64) into stack + 24)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(62): t62: ch = MOV64mi32<Mem:(store (s64) into stack + 40)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(60): t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(58): t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [23]: SU(5): t2: i64 = MOV32ri64 TargetConstant:i64<1>


Examining Available:
Height 22: SU(32): t30: i64 = MOV64ri32 TargetConstant:i64<-1>

Height 22: SU(35): t29: i64 = MOV32ri64 TargetConstant:i64<3>

Height 22: SU(36): t1: i32 = MOV32ri TargetConstant:i32<1>

Height 22: SU(33): t8: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

Height 22: SU(68): t177: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0

Height 23: SU(66): t54: ch = MOV64mi32<Mem:(store (s64) into stack + 8)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(64): t58: ch = MOV64mi32<Mem:(store (s64) into stack + 24)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(62): t62: ch = MOV64mi32<Mem:(store (s64) into stack + 40)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(60): t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(58): t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [24]: SU(32): t30: i64 = MOV64ri32 TargetConstant:i64<-1>


Examining Available:
Height 22: SU(35): t29: i64 = MOV32ri64 TargetConstant:i64<3>

Height 22: SU(36): t1: i32 = MOV32ri TargetConstant:i32<1>

Height 22: SU(33): t8: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

Height 22: SU(68): t177: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0

Height 23: SU(66): t54: ch = MOV64mi32<Mem:(store (s64) into stack + 8)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(64): t58: ch = MOV64mi32<Mem:(store (s64) into stack + 24)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(62): t62: ch = MOV64mi32<Mem:(store (s64) into stack + 40)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(60): t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(58): t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [25]: SU(35): t29: i64 = MOV32ri64 TargetConstant:i64<3>


Examining Available:
Height 22: SU(36): t1: i32 = MOV32ri TargetConstant:i32<1>

Height 22: SU(33): t8: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

Height 22: SU(68): t177: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0

Height 23: SU(66): t54: ch = MOV64mi32<Mem:(store (s64) into stack + 8)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(64): t58: ch = MOV64mi32<Mem:(store (s64) into stack + 24)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(62): t62: ch = MOV64mi32<Mem:(store (s64) into stack + 40)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(60): t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(58): t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [26]: SU(36): t1: i32 = MOV32ri TargetConstant:i32<1>


Examining Available:
Height 22: SU(33): t8: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

Height 22: SU(68): t177: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0

Height 23: SU(66): t54: ch = MOV64mi32<Mem:(store (s64) into stack + 8)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(64): t58: ch = MOV64mi32<Mem:(store (s64) into stack + 24)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(62): t62: ch = MOV64mi32<Mem:(store (s64) into stack + 40)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(60): t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(58): t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [27]: SU(33): t8: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>


Examining Available:
Height 28: SU(34): t219: i32,i32 = MOV32r0

Height 22: SU(68): t177: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0

Height 23: SU(66): t54: ch = MOV64mi32<Mem:(store (s64) into stack + 8)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(64): t58: ch = MOV64mi32<Mem:(store (s64) into stack + 24)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(62): t62: ch = MOV64mi32<Mem:(store (s64) into stack + 40)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(60): t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(58): t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [28]: SU(34): t219: i32,i32 = MOV32r0


Examining Available:
Height 22: SU(68): t177: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0

Height 23: SU(66): t54: ch = MOV64mi32<Mem:(store (s64) into stack + 8)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(64): t58: ch = MOV64mi32<Mem:(store (s64) into stack + 24)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(62): t62: ch = MOV64mi32<Mem:(store (s64) into stack + 40)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(60): t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(58): t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [29]: SU(68): t177: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0


Examining Available:
Height 23: SU(66): t54: ch = MOV64mi32<Mem:(store (s64) into stack + 8)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(64): t58: ch = MOV64mi32<Mem:(store (s64) into stack + 24)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(62): t62: ch = MOV64mi32<Mem:(store (s64) into stack + 40)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(60): t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(58): t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [30]: SU(66): t54: ch = MOV64mi32<Mem:(store (s64) into stack + 8)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1


Examining Available:
Height 23: SU(64): t58: ch = MOV64mi32<Mem:(store (s64) into stack + 24)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(62): t62: ch = MOV64mi32<Mem:(store (s64) into stack + 40)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(60): t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(58): t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [31]: SU(64): t58: ch = MOV64mi32<Mem:(store (s64) into stack + 24)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1


Examining Available:
Height 23: SU(62): t62: ch = MOV64mi32<Mem:(store (s64) into stack + 40)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(60): t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(58): t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [32]: SU(62): t62: ch = MOV64mi32<Mem:(store (s64) into stack + 40)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1


Examining Available:
Height 23: SU(60): t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(58): t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [33]: SU(60): t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1


Examining Available:
Height 23: SU(58): t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [34]: SU(58): t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1


Examining Available:
Height 23: SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [35]: SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1


Examining Available:
Height 23: SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [36]: SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1


Examining Available:
Height 23: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [37]: SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1


Examining Available:
Height 23: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [38]: SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1


Examining Available:
Height 23: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [39]: SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1


Examining Available:
Height 40: SU(29): t32: i64,ch = CopyFromReg t0, Register:i64 %11

Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [40]: SU(29): t32: i64,ch = CopyFromReg t0, Register:i64 %11


Examining Available:
Height 23: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [41]: SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1


Examining Available:
Height 42: SU(26): t34: i64,ch = CopyFromReg t0, Register:i64 %14

Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [42]: SU(26): t34: i64,ch = CopyFromReg t0, Register:i64 %14


Examining Available:
Height 23: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [43]: SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1


Examining Available:
Height 44: SU(23): t36: i64,ch = CopyFromReg t0, Register:i64 %17

Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [44]: SU(23): t36: i64,ch = CopyFromReg t0, Register:i64 %17


Examining Available:
Height 23: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [45]: SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1


Examining Available:
Height 46: SU(20): t38: i64,ch = CopyFromReg t0, Register:i64 %20

Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [46]: SU(20): t38: i64,ch = CopyFromReg t0, Register:i64 %20


Examining Available:
Height 23: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [47]: SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1


Examining Available:
Height 48: SU(17): t40: i64,ch = CopyFromReg t0, Register:i64 %23

Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [48]: SU(17): t40: i64,ch = CopyFromReg t0, Register:i64 %23


Examining Available:
Height 23: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [49]: SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1


Examining Available:
Height 50: SU(14): t42: i64,ch = CopyFromReg t0, Register:i64 %26

Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [50]: SU(14): t42: i64,ch = CopyFromReg t0, Register:i64 %26


Examining Available:
Height 23: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [51]: SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1


Examining Available:
Height 52: SU(11): t44: i64,ch = CopyFromReg t0, Register:i64 %29

Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [52]: SU(11): t44: i64,ch = CopyFromReg t0, Register:i64 %29


Examining Available:
Height 23: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [53]: SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1


Examining Available:
Height 54: SU(8): t46: i64,ch = CopyFromReg t0, Register:i64 %32

Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [54]: SU(8): t46: i64,ch = CopyFromReg t0, Register:i64 %32


Examining Available:
Height 23: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


*** Scheduling [55]: SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1


Examining Available:
Height 56: SU(50): t51: i64,ch = CopyFromReg t49:1, Register:i64 $rsp


*** Scheduling [56]: SU(50): t51: i64,ch = CopyFromReg t49:1, Register:i64 $rsp


Examining Available:
Height 57: SU(39): t49: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<144>, TargetConstant:i64<0>, TargetConstant:i32<0>, t165


*** Scheduling [57]: SU(39): t49: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<144>, TargetConstant:i64<0>, TargetConstant:i32<0>, t165


Examining Available:
Height 57: SU(40): t165: ch = TokenFactor t13, t16, t19, t24, t164


*** Scheduling [58]: SU(40): t165: ch = TokenFactor t13, t16, t19, t24, t164


Examining Available:
Height 59: SU(41): t164: ch = MOV64mi32<Mem:(store (s64) into %ir..repack87)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t170:1

Height 59: SU(44): t24: ch = MOV64mr<Mem:(store (s64) into %ir..repack85)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t23, t170:1

Height 59: SU(46): t19: ch = MOV64mi32<Mem:(store (s64) into %ir..repack83)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t170:1

Height 59: SU(47): t16: ch = MOV64mr<Mem:(store (s64) into %ir..repack81)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t11, t170:1

Height 59: SU(49): t13: ch = MOV64mr<Mem:(store (s64) into %ir.46)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t11, t170:1


*** Scheduling [59]: SU(41): t164: ch = MOV64mi32<Mem:(store (s64) into %ir..repack87)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t170:1


Examining Available:
Height 59: SU(44): t24: ch = MOV64mr<Mem:(store (s64) into %ir..repack85)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t23, t170:1

Height 59: SU(46): t19: ch = MOV64mi32<Mem:(store (s64) into %ir..repack83)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t170:1

Height 59: SU(47): t16: ch = MOV64mr<Mem:(store (s64) into %ir..repack81)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t11, t170:1

Height 59: SU(49): t13: ch = MOV64mr<Mem:(store (s64) into %ir.46)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t11, t170:1


*** Scheduling [60]: SU(44): t24: ch = MOV64mr<Mem:(store (s64) into %ir..repack85)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t23, t170:1


Examining Available:
Height 61: SU(45): t23: i64,ch = CopyFromReg t0, Register:i64 %8

Height 59: SU(46): t19: ch = MOV64mi32<Mem:(store (s64) into %ir..repack83)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t170:1

Height 59: SU(47): t16: ch = MOV64mr<Mem:(store (s64) into %ir..repack81)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t11, t170:1

Height 59: SU(49): t13: ch = MOV64mr<Mem:(store (s64) into %ir.46)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t11, t170:1


*** Scheduling [61]: SU(45): t23: i64,ch = CopyFromReg t0, Register:i64 %8


Examining Available:
Height 59: SU(46): t19: ch = MOV64mi32<Mem:(store (s64) into %ir..repack83)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t170:1

Height 59: SU(47): t16: ch = MOV64mr<Mem:(store (s64) into %ir..repack81)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t11, t170:1

Height 59: SU(49): t13: ch = MOV64mr<Mem:(store (s64) into %ir.46)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t11, t170:1


*** Scheduling [62]: SU(46): t19: ch = MOV64mi32<Mem:(store (s64) into %ir..repack83)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t170:1


Examining Available:
Height 59: SU(47): t16: ch = MOV64mr<Mem:(store (s64) into %ir..repack81)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t11, t170:1

Height 59: SU(49): t13: ch = MOV64mr<Mem:(store (s64) into %ir.46)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t11, t170:1


*** Scheduling [63]: SU(47): t16: ch = MOV64mr<Mem:(store (s64) into %ir..repack81)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t11, t170:1


Examining Available:
Height 59: SU(49): t13: ch = MOV64mr<Mem:(store (s64) into %ir.46)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t11, t170:1


*** Scheduling [64]: SU(49): t13: ch = MOV64mr<Mem:(store (s64) into %ir.46)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t11, t170:1


Examining Available:
Height 65: SU(48): t11: i64,ch = CopyFromReg t0, Register:i64 %34

Height 65: SU(42): t170: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t169


*** Scheduling [65]: SU(48): t11: i64,ch = CopyFromReg t0, Register:i64 %34


Examining Available:
Height 65: SU(42): t170: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t169


*** Scheduling [66]: SU(42): t170: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t169


Examining Available:
Height 67: SU(43): t169: ch = CopyToReg t167:1, Register:i64 $rsp, t179


*** Scheduling [67]: SU(43): t169: ch = CopyToReg t167:1, Register:i64 $rsp, t179


Examining Available:
Height 68: SU(2): t179: i64,i32 = ADD64ri8 t167, TargetConstant:i64<-48>


*** Scheduling [68]: SU(2): t179: i64,i32 = ADD64ri8 t167, TargetConstant:i64<-48>


Examining Available:
Height 69: SU(3): t167: i64,ch = CopyFromReg t166:1, Register:i64 $rsp


*** Scheduling [69]: SU(3): t167: i64,ch = CopyFromReg t166:1, Register:i64 $rsp


Examining Available:
Height 70: SU(4): t166: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [70]: SU(4): t166: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(4): t166: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(3): t167: i64,ch = CopyFromReg t166:1, Register:i64 $rsp

SU(2): t179: i64,i32 = ADD64ri8 t167, TargetConstant:i64<-48>

SU(43): t169: ch = CopyToReg t167:1, Register:i64 $rsp, t179

SU(42): t170: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t169

SU(48): t11: i64,ch = CopyFromReg t0, Register:i64 %34

SU(49): t13: ch = MOV64mr<Mem:(store (s64) into %ir.46)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-48>, Register:i16 $noreg, t11, t170:1

SU(47): t16: ch = MOV64mr<Mem:(store (s64) into %ir..repack81)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-40>, Register:i16 $noreg, t11, t170:1

SU(46): t19: ch = MOV64mi32<Mem:(store (s64) into %ir..repack83)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-32>, Register:i16 $noreg, TargetConstant:i64<0>, t170:1

SU(45): t23: i64,ch = CopyFromReg t0, Register:i64 %8

SU(44): t24: ch = MOV64mr<Mem:(store (s64) into %ir..repack85)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t23, t170:1

SU(41): t164: ch = MOV64mi32<Mem:(store (s64) into %ir..repack87)> t167, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-16>, Register:i16 $noreg, TargetConstant:i64<1>, t170:1

SU(40): t165: ch = TokenFactor t13, t16, t19, t24, t164

SU(39): t49: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<144>, TargetConstant:i64<0>, TargetConstant:i32<0>, t165

SU(50): t51: i64,ch = CopyFromReg t49:1, Register:i64 $rsp

SU(51): t94: ch = MOV64mr<Mem:(store (s64) into stack + 128)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<128>, Register:i16 $noreg, t179, t49:1

SU(8): t46: i64,ch = CopyFromReg t0, Register:i64 %32

SU(53): t88: ch = MOV64mr<Mem:(store (s64) into stack + 112)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<112>, Register:i16 $noreg, t46, t49:1

SU(11): t44: i64,ch = CopyFromReg t0, Register:i64 %29

SU(55): t82: ch = MOV64mr<Mem:(store (s64) into stack + 96)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<96>, Register:i16 $noreg, t44, t49:1

SU(14): t42: i64,ch = CopyFromReg t0, Register:i64 %26

SU(57): t76: ch = MOV64mr<Mem:(store (s64) into stack + 80)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<80>, Register:i16 $noreg, t42, t49:1

SU(17): t40: i64,ch = CopyFromReg t0, Register:i64 %23

SU(59): t70: ch = MOV64mr<Mem:(store (s64) into stack + 64)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<64>, Register:i16 $noreg, t40, t49:1

SU(20): t38: i64,ch = CopyFromReg t0, Register:i64 %20

SU(61): t64: ch = MOV64mr<Mem:(store (s64) into stack + 48)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, t38, t49:1

SU(23): t36: i64,ch = CopyFromReg t0, Register:i64 %17

SU(63): t60: ch = MOV64mr<Mem:(store (s64) into stack + 32)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<32>, Register:i16 $noreg, t36, t49:1

SU(26): t34: i64,ch = CopyFromReg t0, Register:i64 %14

SU(65): t56: ch = MOV64mr<Mem:(store (s64) into stack + 16)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<16>, Register:i16 $noreg, t34, t49:1

SU(29): t32: i64,ch = CopyFromReg t0, Register:i64 %11

SU(67): t52: ch = MOV64mr<Mem:(store (s64) into stack)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t32, t49:1

SU(38): t97: ch = MOV32mi<Mem:(store (s32) into stack + 136)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<136>, Register:i16 $noreg, TargetConstant:i32<1>, t49:1

SU(52): t91: ch = MOV64mi32<Mem:(store (s64) into stack + 120)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<120>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

SU(54): t85: ch = MOV64mi32<Mem:(store (s64) into stack + 104)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<104>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

SU(56): t79: ch = MOV64mi32<Mem:(store (s64) into stack + 88)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<88>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

SU(58): t73: ch = MOV64mi32<Mem:(store (s64) into stack + 72)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<72>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

SU(60): t67: ch = MOV64mi32<Mem:(store (s64) into stack + 56)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

SU(62): t62: ch = MOV64mi32<Mem:(store (s64) into stack + 40)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<40>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

SU(64): t58: ch = MOV64mi32<Mem:(store (s64) into stack + 24)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<24>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

SU(66): t54: ch = MOV64mi32<Mem:(store (s64) into stack + 8)> t51, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<1>, t49:1

SU(68): t177: i64 = MOV64ri TargetGlobalAddress:i64<ptr @read_input_2D_f64> 0

SU(34): t219: i32,i32 = MOV32r0

SU(33): t8: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

SU(36): t1: i32 = MOV32ri TargetConstant:i32<1>

SU(35): t29: i64 = MOV32ri64 TargetConstant:i64<3>

SU(32): t30: i64 = MOV64ri32 TargetConstant:i64<-1>

SU(5): t2: i64 = MOV32ri64 TargetConstant:i64<1>

SU(37): t98: ch = TokenFactor t52, t54, t56, t58, t60, t62, t64, t67, t70, t73, t76, t79, t82, t85, t88, t91, t94, t97

SU(31): t113: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<144>, TargetConstant:i64<0>, t112, t112:1

    t100: ch,glue = CopyToReg t98, Register:i32 $edi, t1

    t102: ch,glue = CopyToReg t100, Register:i64 $rsi, t8, t100:1

    t104: ch,glue = CopyToReg t102, Register:i64 $rdx, t29, t102:1

    t106: ch,glue = CopyToReg t104, Register:i64 $rcx, t8, t104:1

    t108: ch,glue = CopyToReg t106, Register:i64 $r8, t30, t106:1

    t110: ch,glue = CopyToReg t108, Register:i64 $r9, t2, t108:1

    t112: ch,glue = CALL64r t177, Register:i32 $edi, Register:i64 $rsi, Register:i64 $rdx, Register:i64 $rcx, Register:i64 $r8, Register:i64 $r9, RegisterMask:Untyped, t110, t110:1

SU(30): t115: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t113:1

SU(69): t175: i64 = MOV64ri TargetGlobalAddress:i64<ptr @comet_print_memref_i64> 0

SU(28): t120: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t119, t119:1

    t117: ch,glue = CopyToReg t115:1, Register:i64 $rdi, t2

    t118: ch,glue = CopyToReg t117, Register:i64 $rsi, t32, t117:1

    t119: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t118, t118:1

SU(27): t121: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t120:1

SU(25): t125: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t124, t124:1

    t122: ch,glue = CopyToReg t121:1, Register:i64 $rdi, t2

    t123: ch,glue = CopyToReg t122, Register:i64 $rsi, t34, t122:1

    t124: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t123, t123:1

SU(24): t126: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t125:1

SU(22): t130: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t129, t129:1

    t127: ch,glue = CopyToReg t126:1, Register:i64 $rdi, t2

    t128: ch,glue = CopyToReg t127, Register:i64 $rsi, t36, t127:1

    t129: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t128, t128:1

SU(21): t131: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t130:1

SU(19): t135: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t134, t134:1

    t132: ch,glue = CopyToReg t131:1, Register:i64 $rdi, t2

    t133: ch,glue = CopyToReg t132, Register:i64 $rsi, t38, t132:1

    t134: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t133, t133:1

SU(18): t136: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t135:1

SU(16): t140: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t139, t139:1

    t137: ch,glue = CopyToReg t136:1, Register:i64 $rdi, t2

    t138: ch,glue = CopyToReg t137, Register:i64 $rsi, t40, t137:1

    t139: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t138, t138:1

SU(15): t141: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t140:1

SU(13): t145: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t144, t144:1

    t142: ch,glue = CopyToReg t141:1, Register:i64 $rdi, t2

    t143: ch,glue = CopyToReg t142, Register:i64 $rsi, t42, t142:1

    t144: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t143, t143:1

SU(12): t146: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t145:1

SU(10): t150: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t149, t149:1

    t147: ch,glue = CopyToReg t146:1, Register:i64 $rdi, t2

    t148: ch,glue = CopyToReg t147, Register:i64 $rsi, t44, t147:1

    t149: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t148, t148:1

SU(9): t151: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t150:1

SU(7): t155: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t154, t154:1

    t152: ch,glue = CopyToReg t151:1, Register:i64 $rdi, t2

    t153: ch,glue = CopyToReg t152, Register:i64 $rsi, t46, t152:1

    t154: ch,glue = CALL64r t175, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t153, t153:1

SU(6): t157: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t155:1

SU(70): t173: i64 = MOV64ri TargetGlobalAddress:i64<ptr @comet_print_memref_f64> 0

SU(1): t161: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t160, t160:1

    t158: ch,glue = CopyToReg t157:1, Register:i64 $rdi, t2

    t159: ch,glue = CopyToReg t158, Register:i64 $rsi, t179, t158:1

    t160: ch,glue = CALL64r t173, Register:i64 $rdi, Register:i64 $rsi, RegisterMask:Untyped, t159, t159:1

SU(0): t163: ch = RET TargetConstant:i32<0>, t161:1


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=40, align=8, at location [SP+8]
  fi#1: variable sized, align=1, at location [SP+8]
  fi#2: variable sized, align=1, at location [SP+8]
  fi#3: variable sized, align=1, at location [SP+8]
  fi#4: variable sized, align=1, at location [SP+8]
  fi#5: variable sized, align=1, at location [SP+8]
  fi#6: variable sized, align=1, at location [SP+8]
  fi#7: variable sized, align=1, at location [SP+8]
  fi#8: variable sized, align=1, at location [SP+8]
  fi#9: variable sized, align=1, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %35:gr64 = MOV64ri @malloc
  %36:gr64 = MOV32ri64 56
  $rdi = COPY %36:gr64
  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:gr64 = COPY $rax
  MOV64mr %stack.0, 1, $noreg, 0, $noreg, %37:gr64 :: (store (s64) into %ir.2)
  MOV64mr %stack.0, 1, $noreg, 8, $noreg, %37:gr64 :: (store (s64) into %ir..fca.1.gep)
  MOV64mi32 %stack.0, 1, $noreg, 16, $noreg, 0 :: (store (s64) into %ir..fca.2.gep)
  MOV64mi32 %stack.0, 1, $noreg, 24, $noreg, 7 :: (store (s64) into %ir..fca.3.0.gep)
  MOV64mi32 %stack.0, 1, $noreg, 32, $noreg, 1 :: (store (s64) into %ir..fca.4.0.gep)
  ADJCALLSTACKDOWN64 16, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %38:gr64 = COPY $rsp
  %39:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  MOV64mr %38:gr64, 1, $noreg, 0, $noreg, killed %39:gr64 :: (store (s64) into stack)
  MOV32mi %38:gr64, 1, $noreg, 8, $noreg, 1 :: (store (s32) into stack + 8)
  %40:gr64 = MOV64ri @read_input_sizes_2D_f64
  %41:gr32 = MOV32r0 implicit-def dead $eflags
  %42:gr64 = SUBREG_TO_REG 0, killed %41:gr32, %subreg.sub_32bit
  %43:gr32 = MOV32ri 1
  %44:gr64 = MOV32ri64 3
  %45:gr64 = MOV64ri32 -1
  %46:gr64 = MOV32ri64 1
  $edi = COPY %43:gr32
  $rsi = COPY %42:gr64
  $rdx = COPY %44:gr64
  $rcx = COPY %42:gr64
  $r8 = COPY %45:gr64
  $r9 = COPY %46:gr64
  CALL64r killed %40:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 16, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %0:gr64 = MOV64rm %37:gr64, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
  %1:gr64 = MOV64rm %37:gr64, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
  %2:gr64 = MOV64rm %37:gr64, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
  %3:gr64 = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
  %4:gr64 = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
  %5:gr64 = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
  %6:gr64 = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
  %7:gr64 = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
  %8:gr64 = MOV64rm %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
  %9:gr64 = SHL64ri %0:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %47:gr64 = COPY $rax
  %10:gr64 = COPY %47:gr64
  TEST64rr %0:gr64, %0:gr64, implicit-def $eflags
  JCC_1 %bb.2, 14, implicit $eflags
  JMP_1 %bb.1

bb.1..lr.ph.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %48:gr64 = MOV64ri &__bzero
  $rdi = COPY %10:gr64
  $rsi = COPY %9:gr64
  CALL64r killed %48:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.2.._crit_edge:
; predecessors: %bb.0, %bb.1
  successors: %bb.3(0x50000000), %bb.4(0x30000000); %bb.3(62.50%), %bb.4(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %49:gr64 = COPY $rsp
  %11:gr64 = ADD64ri8 %49:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %11:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %49:gr64, 1, $noreg, -48, $noreg, %10:gr64 :: (store (s64) into %ir.22)
  MOV64mr %49:gr64, 1, $noreg, -40, $noreg, %10:gr64 :: (store (s64) into %ir..repack9)
  MOV64mi32 %49:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack11)
  MOV64mr %49:gr64, 1, $noreg, -24, $noreg, %0:gr64 :: (store (s64) into %ir..repack13)
  MOV64mi32 %49:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack15)
  %12:gr64 = SHL64ri %1:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %50:gr64 = MOV64ri @malloc
  $rdi = COPY %12:gr64
  CALL64r killed %50:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %51:gr64 = COPY $rax
  %13:gr64 = COPY %51:gr64
  TEST64rr %1:gr64, %1:gr64, implicit-def $eflags
  JCC_1 %bb.4, 14, implicit $eflags
  JMP_1 %bb.3

bb.3..lr.ph90.preheader:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %52:gr64 = MOV64ri &__bzero
  $rdi = COPY %13:gr64
  $rsi = COPY %12:gr64
  CALL64r killed %52:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.4.._crit_edge91:
; predecessors: %bb.2, %bb.3
  successors: %bb.5(0x50000000), %bb.6(0x30000000); %bb.5(62.50%), %bb.6(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %53:gr64 = COPY $rsp
  %14:gr64 = ADD64ri8 %53:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %14:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %53:gr64, 1, $noreg, -48, $noreg, %13:gr64 :: (store (s64) into %ir.25)
  MOV64mr %53:gr64, 1, $noreg, -40, $noreg, %13:gr64 :: (store (s64) into %ir..repack18)
  MOV64mi32 %53:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack20)
  MOV64mr %53:gr64, 1, $noreg, -24, $noreg, %1:gr64 :: (store (s64) into %ir..repack22)
  MOV64mi32 %53:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack24)
  %15:gr64 = SHL64ri %2:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = MOV64ri @malloc
  $rdi = COPY %15:gr64
  CALL64r killed %54:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %55:gr64 = COPY $rax
  %16:gr64 = COPY %55:gr64
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.6, 14, implicit $eflags
  JMP_1 %bb.5

bb.5..lr.ph93.preheader:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %56:gr64 = MOV64ri &__bzero
  $rdi = COPY %16:gr64
  $rsi = COPY %15:gr64
  CALL64r killed %56:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.6.._crit_edge94:
; predecessors: %bb.4, %bb.5
  successors: %bb.7(0x50000000), %bb.8(0x30000000); %bb.7(62.50%), %bb.8(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr64 = COPY $rsp
  %17:gr64 = ADD64ri8 %57:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %17:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %57:gr64, 1, $noreg, -48, $noreg, %16:gr64 :: (store (s64) into %ir.28)
  MOV64mr %57:gr64, 1, $noreg, -40, $noreg, %16:gr64 :: (store (s64) into %ir..repack27)
  MOV64mi32 %57:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack29)
  MOV64mr %57:gr64, 1, $noreg, -24, $noreg, %2:gr64 :: (store (s64) into %ir..repack31)
  MOV64mi32 %57:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack33)
  %18:gr64 = SHL64ri %3:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %58:gr64 = MOV64ri @malloc
  $rdi = COPY %18:gr64
  CALL64r killed %58:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %59:gr64 = COPY $rax
  %19:gr64 = COPY %59:gr64
  TEST64rr %3:gr64, %3:gr64, implicit-def $eflags
  JCC_1 %bb.8, 14, implicit $eflags
  JMP_1 %bb.7

bb.7..lr.ph96.preheader:
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %60:gr64 = MOV64ri &__bzero
  $rdi = COPY %19:gr64
  $rsi = COPY %18:gr64
  CALL64r killed %60:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.8.._crit_edge97:
; predecessors: %bb.6, %bb.7
  successors: %bb.9(0x50000000), %bb.10(0x30000000); %bb.9(62.50%), %bb.10(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %61:gr64 = COPY $rsp
  %20:gr64 = ADD64ri8 %61:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %20:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %61:gr64, 1, $noreg, -48, $noreg, %19:gr64 :: (store (s64) into %ir.31)
  MOV64mr %61:gr64, 1, $noreg, -40, $noreg, %19:gr64 :: (store (s64) into %ir..repack36)
  MOV64mi32 %61:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack38)
  MOV64mr %61:gr64, 1, $noreg, -24, $noreg, %3:gr64 :: (store (s64) into %ir..repack40)
  MOV64mi32 %61:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack42)
  %21:gr64 = SHL64ri %4:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %62:gr64 = MOV64ri @malloc
  $rdi = COPY %21:gr64
  CALL64r killed %62:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %63:gr64 = COPY $rax
  %22:gr64 = COPY %63:gr64
  TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
  JCC_1 %bb.10, 14, implicit $eflags
  JMP_1 %bb.9

bb.9..lr.ph99.preheader:
; predecessors: %bb.8
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %64:gr64 = MOV64ri &__bzero
  $rdi = COPY %22:gr64
  $rsi = COPY %21:gr64
  CALL64r killed %64:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.10.._crit_edge100:
; predecessors: %bb.8, %bb.9
  successors: %bb.11(0x50000000), %bb.12(0x30000000); %bb.11(62.50%), %bb.12(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %65:gr64 = COPY $rsp
  %23:gr64 = ADD64ri8 %65:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %23:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %65:gr64, 1, $noreg, -48, $noreg, %22:gr64 :: (store (s64) into %ir.34)
  MOV64mr %65:gr64, 1, $noreg, -40, $noreg, %22:gr64 :: (store (s64) into %ir..repack45)
  MOV64mi32 %65:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack47)
  MOV64mr %65:gr64, 1, $noreg, -24, $noreg, %4:gr64 :: (store (s64) into %ir..repack49)
  MOV64mi32 %65:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack51)
  %24:gr64 = SHL64ri %5:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %66:gr64 = MOV64ri @malloc
  $rdi = COPY %24:gr64
  CALL64r killed %66:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %67:gr64 = COPY $rax
  %25:gr64 = COPY %67:gr64
  TEST64rr %5:gr64, %5:gr64, implicit-def $eflags
  JCC_1 %bb.12, 14, implicit $eflags
  JMP_1 %bb.11

bb.11..lr.ph102.preheader:
; predecessors: %bb.10
  successors: %bb.12(0x80000000); %bb.12(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %68:gr64 = MOV64ri &__bzero
  $rdi = COPY %25:gr64
  $rsi = COPY %24:gr64
  CALL64r killed %68:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.12.._crit_edge103:
; predecessors: %bb.10, %bb.11
  successors: %bb.13(0x50000000), %bb.14(0x30000000); %bb.13(62.50%), %bb.14(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %69:gr64 = COPY $rsp
  %26:gr64 = ADD64ri8 %69:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %26:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %69:gr64, 1, $noreg, -48, $noreg, %25:gr64 :: (store (s64) into %ir.37)
  MOV64mr %69:gr64, 1, $noreg, -40, $noreg, %25:gr64 :: (store (s64) into %ir..repack54)
  MOV64mi32 %69:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack56)
  MOV64mr %69:gr64, 1, $noreg, -24, $noreg, %5:gr64 :: (store (s64) into %ir..repack58)
  MOV64mi32 %69:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack60)
  %27:gr64 = SHL64ri %6:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %70:gr64 = MOV64ri @malloc
  $rdi = COPY %27:gr64
  CALL64r killed %70:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %71:gr64 = COPY $rax
  %28:gr64 = COPY %71:gr64
  TEST64rr %6:gr64, %6:gr64, implicit-def $eflags
  JCC_1 %bb.14, 14, implicit $eflags
  JMP_1 %bb.13

bb.13..lr.ph105.preheader:
; predecessors: %bb.12
  successors: %bb.14(0x80000000); %bb.14(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %72:gr64 = MOV64ri &__bzero
  $rdi = COPY %28:gr64
  $rsi = COPY %27:gr64
  CALL64r killed %72:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.14.._crit_edge106:
; predecessors: %bb.12, %bb.13
  successors: %bb.15(0x50000000), %bb.16(0x30000000); %bb.15(62.50%), %bb.16(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %73:gr64 = COPY $rsp
  %29:gr64 = ADD64ri8 %73:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %29:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %73:gr64, 1, $noreg, -48, $noreg, %28:gr64 :: (store (s64) into %ir.40)
  MOV64mr %73:gr64, 1, $noreg, -40, $noreg, %28:gr64 :: (store (s64) into %ir..repack63)
  MOV64mi32 %73:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack65)
  MOV64mr %73:gr64, 1, $noreg, -24, $noreg, %6:gr64 :: (store (s64) into %ir..repack67)
  MOV64mi32 %73:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack69)
  %30:gr64 = SHL64ri %7:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %74:gr64 = MOV64ri @malloc
  $rdi = COPY %30:gr64
  CALL64r killed %74:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %75:gr64 = COPY $rax
  %31:gr64 = COPY %75:gr64
  TEST64rr %7:gr64, %7:gr64, implicit-def $eflags
  JCC_1 %bb.16, 14, implicit $eflags
  JMP_1 %bb.15

bb.15..lr.ph108.preheader:
; predecessors: %bb.14
  successors: %bb.16(0x80000000); %bb.16(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %76:gr64 = MOV64ri &__bzero
  $rdi = COPY %31:gr64
  $rsi = COPY %30:gr64
  CALL64r killed %76:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.16.._crit_edge109:
; predecessors: %bb.14, %bb.15
  successors: %bb.17(0x50000000), %bb.18(0x30000000); %bb.17(62.50%), %bb.18(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %77:gr64 = COPY $rsp
  %32:gr64 = ADD64ri8 %77:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %32:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %77:gr64, 1, $noreg, -48, $noreg, %31:gr64 :: (store (s64) into %ir.43)
  MOV64mr %77:gr64, 1, $noreg, -40, $noreg, %31:gr64 :: (store (s64) into %ir..repack72)
  MOV64mi32 %77:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack74)
  MOV64mr %77:gr64, 1, $noreg, -24, $noreg, %7:gr64 :: (store (s64) into %ir..repack76)
  MOV64mi32 %77:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack78)
  %33:gr64 = SHL64ri %8:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %78:gr64 = MOV64ri @malloc
  $rdi = COPY %33:gr64
  CALL64r killed %78:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %79:gr64 = COPY $rax
  %34:gr64 = COPY %79:gr64
  TEST64rr %8:gr64, %8:gr64, implicit-def $eflags
  JCC_1 %bb.18, 14, implicit $eflags
  JMP_1 %bb.17

bb.17..lr.ph111.preheader:
; predecessors: %bb.16
  successors: %bb.18(0x80000000); %bb.18(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %80:gr64 = MOV64ri &__bzero
  $rdi = COPY %34:gr64
  $rsi = COPY %33:gr64
  CALL64r killed %80:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.18.._crit_edge112:
; predecessors: %bb.16, %bb.17

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %81:gr64 = COPY $rsp
  %82:gr64 = ADD64ri8 %81:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %82:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %81:gr64, 1, $noreg, -48, $noreg, %34:gr64 :: (store (s64) into %ir.46)
  MOV64mr %81:gr64, 1, $noreg, -40, $noreg, %34:gr64 :: (store (s64) into %ir..repack81)
  MOV64mi32 %81:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack83)
  MOV64mr %81:gr64, 1, $noreg, -24, $noreg, %8:gr64 :: (store (s64) into %ir..repack85)
  MOV64mi32 %81:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack87)
  ADJCALLSTACKDOWN64 144, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %83:gr64 = COPY $rsp
  MOV64mr %83:gr64, 1, $noreg, 128, $noreg, %82:gr64 :: (store (s64) into stack + 128)
  MOV64mr %83:gr64, 1, $noreg, 112, $noreg, %32:gr64 :: (store (s64) into stack + 112)
  MOV64mr %83:gr64, 1, $noreg, 96, $noreg, %29:gr64 :: (store (s64) into stack + 96)
  MOV64mr %83:gr64, 1, $noreg, 80, $noreg, %26:gr64 :: (store (s64) into stack + 80)
  MOV64mr %83:gr64, 1, $noreg, 64, $noreg, %23:gr64 :: (store (s64) into stack + 64)
  MOV64mr %83:gr64, 1, $noreg, 48, $noreg, %20:gr64 :: (store (s64) into stack + 48)
  MOV64mr %83:gr64, 1, $noreg, 32, $noreg, %17:gr64 :: (store (s64) into stack + 32)
  MOV64mr %83:gr64, 1, $noreg, 16, $noreg, %14:gr64 :: (store (s64) into stack + 16)
  MOV64mr %83:gr64, 1, $noreg, 0, $noreg, %11:gr64 :: (store (s64) into stack)
  MOV32mi %83:gr64, 1, $noreg, 136, $noreg, 1 :: (store (s32) into stack + 136)
  MOV64mi32 %83:gr64, 1, $noreg, 120, $noreg, 1 :: (store (s64) into stack + 120)
  MOV64mi32 %83:gr64, 1, $noreg, 104, $noreg, 1 :: (store (s64) into stack + 104)
  MOV64mi32 %83:gr64, 1, $noreg, 88, $noreg, 1 :: (store (s64) into stack + 88)
  MOV64mi32 %83:gr64, 1, $noreg, 72, $noreg, 1 :: (store (s64) into stack + 72)
  MOV64mi32 %83:gr64, 1, $noreg, 56, $noreg, 1 :: (store (s64) into stack + 56)
  MOV64mi32 %83:gr64, 1, $noreg, 40, $noreg, 1 :: (store (s64) into stack + 40)
  MOV64mi32 %83:gr64, 1, $noreg, 24, $noreg, 1 :: (store (s64) into stack + 24)
  MOV64mi32 %83:gr64, 1, $noreg, 8, $noreg, 1 :: (store (s64) into stack + 8)
  %84:gr64 = MOV64ri @read_input_2D_f64
  %85:gr32 = MOV32r0 implicit-def dead $eflags
  %86:gr64 = SUBREG_TO_REG 0, killed %85:gr32, %subreg.sub_32bit
  %87:gr32 = MOV32ri 1
  %88:gr64 = MOV32ri64 3
  %89:gr64 = MOV64ri32 -1
  %90:gr64 = MOV32ri64 1
  $edi = COPY %87:gr32
  $rsi = COPY %86:gr64
  $rdx = COPY %88:gr64
  $rcx = COPY %86:gr64
  $r8 = COPY %89:gr64
  $r9 = COPY %90:gr64
  CALL64r killed %84:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 144, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %91:gr64 = MOV64ri @comet_print_memref_i64
  $rdi = COPY %90:gr64
  $rsi = COPY %11:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %90:gr64
  $rsi = COPY %14:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %90:gr64
  $rsi = COPY %17:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %90:gr64
  $rsi = COPY %20:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %90:gr64
  $rsi = COPY %23:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %90:gr64
  $rsi = COPY %26:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %90:gr64
  $rsi = COPY %29:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %90:gr64
  $rsi = COPY %32:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %92:gr64 = MOV64ri @comet_print_memref_f64
  $rdi = COPY %90:gr64
  $rsi = COPY %82:gr64
  CALL64r killed %92:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  RET 0

# End machine code for function main.

***** Machine Function before Domain Reassignment *****
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=40, align=8, at location [SP+8]
  fi#1: variable sized, align=1, at location [SP+8]
  fi#2: variable sized, align=1, at location [SP+8]
  fi#3: variable sized, align=1, at location [SP+8]
  fi#4: variable sized, align=1, at location [SP+8]
  fi#5: variable sized, align=1, at location [SP+8]
  fi#6: variable sized, align=1, at location [SP+8]
  fi#7: variable sized, align=1, at location [SP+8]
  fi#8: variable sized, align=1, at location [SP+8]
  fi#9: variable sized, align=1, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %35:gr64 = MOV64ri @malloc
  %36:gr64 = MOV32ri64 56
  $rdi = COPY %36:gr64
  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:gr64 = COPY $rax
  MOV64mr %stack.0, 1, $noreg, 0, $noreg, %37:gr64 :: (store (s64) into %ir.2)
  MOV64mr %stack.0, 1, $noreg, 8, $noreg, %37:gr64 :: (store (s64) into %ir..fca.1.gep)
  MOV64mi32 %stack.0, 1, $noreg, 16, $noreg, 0 :: (store (s64) into %ir..fca.2.gep)
  MOV64mi32 %stack.0, 1, $noreg, 24, $noreg, 7 :: (store (s64) into %ir..fca.3.0.gep)
  MOV64mi32 %stack.0, 1, $noreg, 32, $noreg, 1 :: (store (s64) into %ir..fca.4.0.gep)
  ADJCALLSTACKDOWN64 16, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %38:gr64 = COPY $rsp
  %39:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  MOV64mr %38:gr64, 1, $noreg, 0, $noreg, killed %39:gr64 :: (store (s64) into stack)
  MOV32mi %38:gr64, 1, $noreg, 8, $noreg, 1 :: (store (s32) into stack + 8)
  %40:gr64 = MOV64ri @read_input_sizes_2D_f64
  %41:gr32 = MOV32r0 implicit-def dead $eflags
  %42:gr64 = SUBREG_TO_REG 0, killed %41:gr32, %subreg.sub_32bit
  %43:gr32 = MOV32ri 1
  %44:gr64 = MOV32ri64 3
  %45:gr64 = MOV64ri32 -1
  %46:gr64 = MOV32ri64 1
  $edi = COPY %43:gr32
  $rsi = COPY %42:gr64
  $rdx = COPY %44:gr64
  $rcx = COPY %42:gr64
  $r8 = COPY %45:gr64
  $r9 = COPY %46:gr64
  CALL64r killed %40:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 16, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %0:gr64 = MOV64rm %37:gr64, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
  %1:gr64 = MOV64rm %37:gr64, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
  %2:gr64 = MOV64rm %37:gr64, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
  %3:gr64 = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
  %4:gr64 = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
  %5:gr64 = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
  %6:gr64 = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
  %7:gr64 = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
  %8:gr64 = MOV64rm %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
  %9:gr64 = SHL64ri %0:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %47:gr64 = COPY $rax
  %10:gr64 = COPY %47:gr64
  TEST64rr %0:gr64, %0:gr64, implicit-def $eflags
  JCC_1 %bb.2, 14, implicit $eflags
  JMP_1 %bb.1

bb.1..lr.ph.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %48:gr64 = MOV64ri &__bzero
  $rdi = COPY %10:gr64
  $rsi = COPY %9:gr64
  CALL64r killed %48:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.2.._crit_edge:
; predecessors: %bb.0, %bb.1
  successors: %bb.3(0x50000000), %bb.4(0x30000000); %bb.3(62.50%), %bb.4(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %49:gr64 = COPY $rsp
  %11:gr64 = ADD64ri8 %49:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %11:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %49:gr64, 1, $noreg, -48, $noreg, %10:gr64 :: (store (s64) into %ir.22)
  MOV64mr %49:gr64, 1, $noreg, -40, $noreg, %10:gr64 :: (store (s64) into %ir..repack9)
  MOV64mi32 %49:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack11)
  MOV64mr %49:gr64, 1, $noreg, -24, $noreg, %0:gr64 :: (store (s64) into %ir..repack13)
  MOV64mi32 %49:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack15)
  %12:gr64 = SHL64ri %1:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %50:gr64 = MOV64ri @malloc
  $rdi = COPY %12:gr64
  CALL64r killed %50:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %51:gr64 = COPY $rax
  %13:gr64 = COPY %51:gr64
  TEST64rr %1:gr64, %1:gr64, implicit-def $eflags
  JCC_1 %bb.4, 14, implicit $eflags
  JMP_1 %bb.3

bb.3..lr.ph90.preheader:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %52:gr64 = MOV64ri &__bzero
  $rdi = COPY %13:gr64
  $rsi = COPY %12:gr64
  CALL64r killed %52:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.4.._crit_edge91:
; predecessors: %bb.2, %bb.3
  successors: %bb.5(0x50000000), %bb.6(0x30000000); %bb.5(62.50%), %bb.6(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %53:gr64 = COPY $rsp
  %14:gr64 = ADD64ri8 %53:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %14:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %53:gr64, 1, $noreg, -48, $noreg, %13:gr64 :: (store (s64) into %ir.25)
  MOV64mr %53:gr64, 1, $noreg, -40, $noreg, %13:gr64 :: (store (s64) into %ir..repack18)
  MOV64mi32 %53:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack20)
  MOV64mr %53:gr64, 1, $noreg, -24, $noreg, %1:gr64 :: (store (s64) into %ir..repack22)
  MOV64mi32 %53:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack24)
  %15:gr64 = SHL64ri %2:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = MOV64ri @malloc
  $rdi = COPY %15:gr64
  CALL64r killed %54:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %55:gr64 = COPY $rax
  %16:gr64 = COPY %55:gr64
  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
  JCC_1 %bb.6, 14, implicit $eflags
  JMP_1 %bb.5

bb.5..lr.ph93.preheader:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %56:gr64 = MOV64ri &__bzero
  $rdi = COPY %16:gr64
  $rsi = COPY %15:gr64
  CALL64r killed %56:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.6.._crit_edge94:
; predecessors: %bb.4, %bb.5
  successors: %bb.7(0x50000000), %bb.8(0x30000000); %bb.7(62.50%), %bb.8(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr64 = COPY $rsp
  %17:gr64 = ADD64ri8 %57:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %17:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %57:gr64, 1, $noreg, -48, $noreg, %16:gr64 :: (store (s64) into %ir.28)
  MOV64mr %57:gr64, 1, $noreg, -40, $noreg, %16:gr64 :: (store (s64) into %ir..repack27)
  MOV64mi32 %57:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack29)
  MOV64mr %57:gr64, 1, $noreg, -24, $noreg, %2:gr64 :: (store (s64) into %ir..repack31)
  MOV64mi32 %57:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack33)
  %18:gr64 = SHL64ri %3:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %58:gr64 = MOV64ri @malloc
  $rdi = COPY %18:gr64
  CALL64r killed %58:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %59:gr64 = COPY $rax
  %19:gr64 = COPY %59:gr64
  TEST64rr %3:gr64, %3:gr64, implicit-def $eflags
  JCC_1 %bb.8, 14, implicit $eflags
  JMP_1 %bb.7

bb.7..lr.ph96.preheader:
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %60:gr64 = MOV64ri &__bzero
  $rdi = COPY %19:gr64
  $rsi = COPY %18:gr64
  CALL64r killed %60:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.8.._crit_edge97:
; predecessors: %bb.6, %bb.7
  successors: %bb.9(0x50000000), %bb.10(0x30000000); %bb.9(62.50%), %bb.10(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %61:gr64 = COPY $rsp
  %20:gr64 = ADD64ri8 %61:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %20:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %61:gr64, 1, $noreg, -48, $noreg, %19:gr64 :: (store (s64) into %ir.31)
  MOV64mr %61:gr64, 1, $noreg, -40, $noreg, %19:gr64 :: (store (s64) into %ir..repack36)
  MOV64mi32 %61:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack38)
  MOV64mr %61:gr64, 1, $noreg, -24, $noreg, %3:gr64 :: (store (s64) into %ir..repack40)
  MOV64mi32 %61:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack42)
  %21:gr64 = SHL64ri %4:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %62:gr64 = MOV64ri @malloc
  $rdi = COPY %21:gr64
  CALL64r killed %62:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %63:gr64 = COPY $rax
  %22:gr64 = COPY %63:gr64
  TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
  JCC_1 %bb.10, 14, implicit $eflags
  JMP_1 %bb.9

bb.9..lr.ph99.preheader:
; predecessors: %bb.8
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %64:gr64 = MOV64ri &__bzero
  $rdi = COPY %22:gr64
  $rsi = COPY %21:gr64
  CALL64r killed %64:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.10.._crit_edge100:
; predecessors: %bb.8, %bb.9
  successors: %bb.11(0x50000000), %bb.12(0x30000000); %bb.11(62.50%), %bb.12(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %65:gr64 = COPY $rsp
  %23:gr64 = ADD64ri8 %65:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %23:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %65:gr64, 1, $noreg, -48, $noreg, %22:gr64 :: (store (s64) into %ir.34)
  MOV64mr %65:gr64, 1, $noreg, -40, $noreg, %22:gr64 :: (store (s64) into %ir..repack45)
  MOV64mi32 %65:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack47)
  MOV64mr %65:gr64, 1, $noreg, -24, $noreg, %4:gr64 :: (store (s64) into %ir..repack49)
  MOV64mi32 %65:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack51)
  %24:gr64 = SHL64ri %5:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %66:gr64 = MOV64ri @malloc
  $rdi = COPY %24:gr64
  CALL64r killed %66:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %67:gr64 = COPY $rax
  %25:gr64 = COPY %67:gr64
  TEST64rr %5:gr64, %5:gr64, implicit-def $eflags
  JCC_1 %bb.12, 14, implicit $eflags
  JMP_1 %bb.11

bb.11..lr.ph102.preheader:
; predecessors: %bb.10
  successors: %bb.12(0x80000000); %bb.12(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %68:gr64 = MOV64ri &__bzero
  $rdi = COPY %25:gr64
  $rsi = COPY %24:gr64
  CALL64r killed %68:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.12.._crit_edge103:
; predecessors: %bb.10, %bb.11
  successors: %bb.13(0x50000000), %bb.14(0x30000000); %bb.13(62.50%), %bb.14(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %69:gr64 = COPY $rsp
  %26:gr64 = ADD64ri8 %69:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %26:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %69:gr64, 1, $noreg, -48, $noreg, %25:gr64 :: (store (s64) into %ir.37)
  MOV64mr %69:gr64, 1, $noreg, -40, $noreg, %25:gr64 :: (store (s64) into %ir..repack54)
  MOV64mi32 %69:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack56)
  MOV64mr %69:gr64, 1, $noreg, -24, $noreg, %5:gr64 :: (store (s64) into %ir..repack58)
  MOV64mi32 %69:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack60)
  %27:gr64 = SHL64ri %6:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %70:gr64 = MOV64ri @malloc
  $rdi = COPY %27:gr64
  CALL64r killed %70:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %71:gr64 = COPY $rax
  %28:gr64 = COPY %71:gr64
  TEST64rr %6:gr64, %6:gr64, implicit-def $eflags
  JCC_1 %bb.14, 14, implicit $eflags
  JMP_1 %bb.13

bb.13..lr.ph105.preheader:
; predecessors: %bb.12
  successors: %bb.14(0x80000000); %bb.14(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %72:gr64 = MOV64ri &__bzero
  $rdi = COPY %28:gr64
  $rsi = COPY %27:gr64
  CALL64r killed %72:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.14.._crit_edge106:
; predecessors: %bb.12, %bb.13
  successors: %bb.15(0x50000000), %bb.16(0x30000000); %bb.15(62.50%), %bb.16(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %73:gr64 = COPY $rsp
  %29:gr64 = ADD64ri8 %73:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %29:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %73:gr64, 1, $noreg, -48, $noreg, %28:gr64 :: (store (s64) into %ir.40)
  MOV64mr %73:gr64, 1, $noreg, -40, $noreg, %28:gr64 :: (store (s64) into %ir..repack63)
  MOV64mi32 %73:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack65)
  MOV64mr %73:gr64, 1, $noreg, -24, $noreg, %6:gr64 :: (store (s64) into %ir..repack67)
  MOV64mi32 %73:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack69)
  %30:gr64 = SHL64ri %7:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %74:gr64 = MOV64ri @malloc
  $rdi = COPY %30:gr64
  CALL64r killed %74:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %75:gr64 = COPY $rax
  %31:gr64 = COPY %75:gr64
  TEST64rr %7:gr64, %7:gr64, implicit-def $eflags
  JCC_1 %bb.16, 14, implicit $eflags
  JMP_1 %bb.15

bb.15..lr.ph108.preheader:
; predecessors: %bb.14
  successors: %bb.16(0x80000000); %bb.16(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %76:gr64 = MOV64ri &__bzero
  $rdi = COPY %31:gr64
  $rsi = COPY %30:gr64
  CALL64r killed %76:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.16.._crit_edge109:
; predecessors: %bb.14, %bb.15
  successors: %bb.17(0x50000000), %bb.18(0x30000000); %bb.17(62.50%), %bb.18(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %77:gr64 = COPY $rsp
  %32:gr64 = ADD64ri8 %77:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %32:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %77:gr64, 1, $noreg, -48, $noreg, %31:gr64 :: (store (s64) into %ir.43)
  MOV64mr %77:gr64, 1, $noreg, -40, $noreg, %31:gr64 :: (store (s64) into %ir..repack72)
  MOV64mi32 %77:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack74)
  MOV64mr %77:gr64, 1, $noreg, -24, $noreg, %7:gr64 :: (store (s64) into %ir..repack76)
  MOV64mi32 %77:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack78)
  %33:gr64 = SHL64ri %8:gr64(tied-def 0), 3, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %78:gr64 = MOV64ri @malloc
  $rdi = COPY %33:gr64
  CALL64r killed %78:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %79:gr64 = COPY $rax
  %34:gr64 = COPY %79:gr64
  TEST64rr %8:gr64, %8:gr64, implicit-def $eflags
  JCC_1 %bb.18, 14, implicit $eflags
  JMP_1 %bb.17

bb.17..lr.ph111.preheader:
; predecessors: %bb.16
  successors: %bb.18(0x80000000); %bb.18(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %80:gr64 = MOV64ri &__bzero
  $rdi = COPY %34:gr64
  $rsi = COPY %33:gr64
  CALL64r killed %80:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.18.._crit_edge112:
; predecessors: %bb.16, %bb.17

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %81:gr64 = COPY $rsp
  %82:gr64 = ADD64ri8 %81:gr64(tied-def 0), -48, implicit-def dead $eflags
  $rsp = COPY %82:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %81:gr64, 1, $noreg, -48, $noreg, %34:gr64 :: (store (s64) into %ir.46)
  MOV64mr %81:gr64, 1, $noreg, -40, $noreg, %34:gr64 :: (store (s64) into %ir..repack81)
  MOV64mi32 %81:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack83)
  MOV64mr %81:gr64, 1, $noreg, -24, $noreg, %8:gr64 :: (store (s64) into %ir..repack85)
  MOV64mi32 %81:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack87)
  ADJCALLSTACKDOWN64 144, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %83:gr64 = COPY $rsp
  MOV64mr %83:gr64, 1, $noreg, 128, $noreg, %82:gr64 :: (store (s64) into stack + 128)
  MOV64mr %83:gr64, 1, $noreg, 112, $noreg, %32:gr64 :: (store (s64) into stack + 112)
  MOV64mr %83:gr64, 1, $noreg, 96, $noreg, %29:gr64 :: (store (s64) into stack + 96)
  MOV64mr %83:gr64, 1, $noreg, 80, $noreg, %26:gr64 :: (store (s64) into stack + 80)
  MOV64mr %83:gr64, 1, $noreg, 64, $noreg, %23:gr64 :: (store (s64) into stack + 64)
  MOV64mr %83:gr64, 1, $noreg, 48, $noreg, %20:gr64 :: (store (s64) into stack + 48)
  MOV64mr %83:gr64, 1, $noreg, 32, $noreg, %17:gr64 :: (store (s64) into stack + 32)
  MOV64mr %83:gr64, 1, $noreg, 16, $noreg, %14:gr64 :: (store (s64) into stack + 16)
  MOV64mr %83:gr64, 1, $noreg, 0, $noreg, %11:gr64 :: (store (s64) into stack)
  MOV32mi %83:gr64, 1, $noreg, 136, $noreg, 1 :: (store (s32) into stack + 136)
  MOV64mi32 %83:gr64, 1, $noreg, 120, $noreg, 1 :: (store (s64) into stack + 120)
  MOV64mi32 %83:gr64, 1, $noreg, 104, $noreg, 1 :: (store (s64) into stack + 104)
  MOV64mi32 %83:gr64, 1, $noreg, 88, $noreg, 1 :: (store (s64) into stack + 88)
  MOV64mi32 %83:gr64, 1, $noreg, 72, $noreg, 1 :: (store (s64) into stack + 72)
  MOV64mi32 %83:gr64, 1, $noreg, 56, $noreg, 1 :: (store (s64) into stack + 56)
  MOV64mi32 %83:gr64, 1, $noreg, 40, $noreg, 1 :: (store (s64) into stack + 40)
  MOV64mi32 %83:gr64, 1, $noreg, 24, $noreg, 1 :: (store (s64) into stack + 24)
  MOV64mi32 %83:gr64, 1, $noreg, 8, $noreg, 1 :: (store (s64) into stack + 8)
  %84:gr64 = MOV64ri @read_input_2D_f64
  %85:gr32 = MOV32r0 implicit-def dead $eflags
  %86:gr64 = SUBREG_TO_REG 0, killed %85:gr32, %subreg.sub_32bit
  %87:gr32 = MOV32ri 1
  %88:gr64 = MOV32ri64 3
  %89:gr64 = MOV64ri32 -1
  %90:gr64 = MOV32ri64 1
  $edi = COPY %87:gr32
  $rsi = COPY %86:gr64
  $rdx = COPY %88:gr64
  $rcx = COPY %86:gr64
  $r8 = COPY %89:gr64
  $r9 = COPY %90:gr64
  CALL64r killed %84:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 144, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %91:gr64 = MOV64ri @comet_print_memref_i64
  $rdi = COPY %90:gr64
  $rsi = COPY %11:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %90:gr64
  $rsi = COPY %14:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %90:gr64
  $rsi = COPY %17:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %90:gr64
  $rsi = COPY %20:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %90:gr64
  $rsi = COPY %23:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %90:gr64
  $rsi = COPY %26:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %90:gr64
  $rsi = COPY %29:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %90:gr64
  $rsi = COPY %32:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %92:gr64 = MOV64ri @comet_print_memref_f64
  $rdi = COPY %90:gr64
  $rsi = COPY %82:gr64
  CALL64r killed %92:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  RET 0

# End machine code for function main.

# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=40, align=8, at location [SP+8]
  fi#1: variable sized, align=1, at location [SP+8]
  fi#2: variable sized, align=1, at location [SP+8]
  fi#3: variable sized, align=1, at location [SP+8]
  fi#4: variable sized, align=1, at location [SP+8]
  fi#5: variable sized, align=1, at location [SP+8]
  fi#6: variable sized, align=1, at location [SP+8]
  fi#7: variable sized, align=1, at location [SP+8]
  fi#8: variable sized, align=1, at location [SP+8]
  fi#9: variable sized, align=1, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %35:gr64 = MOV64ri @malloc
48B	  %36:gr64 = MOV32ri64 56
64B	  $rdi = COPY %36:gr64
80B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %37:gr64 = COPY $rax
128B	  MOV64mr %stack.0, 1, $noreg, 0, $noreg, %37:gr64 :: (store (s64) into %ir.2)
144B	  MOV64mr %stack.0, 1, $noreg, 8, $noreg, %37:gr64 :: (store (s64) into %ir..fca.1.gep)
160B	  MOV64mi32 %stack.0, 1, $noreg, 16, $noreg, 0 :: (store (s64) into %ir..fca.2.gep)
176B	  MOV64mi32 %stack.0, 1, $noreg, 24, $noreg, 7 :: (store (s64) into %ir..fca.3.0.gep)
192B	  MOV64mi32 %stack.0, 1, $noreg, 32, $noreg, 1 :: (store (s64) into %ir..fca.4.0.gep)
208B	  ADJCALLSTACKDOWN64 16, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
224B	  %38:gr64 = COPY $rsp
240B	  %39:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
256B	  MOV64mr %38:gr64, 1, $noreg, 0, $noreg, killed %39:gr64 :: (store (s64) into stack)
272B	  MOV32mi %38:gr64, 1, $noreg, 8, $noreg, 1 :: (store (s32) into stack + 8)
288B	  %40:gr64 = MOV64ri @read_input_sizes_2D_f64
304B	  %41:gr32 = MOV32r0 implicit-def dead $eflags
320B	  %42:gr64 = SUBREG_TO_REG 0, killed %41:gr32, %subreg.sub_32bit
336B	  %43:gr32 = MOV32ri 1
352B	  %44:gr64 = MOV32ri64 3
368B	  %45:gr64 = MOV64ri32 -1
384B	  %46:gr64 = MOV32ri64 1
400B	  $edi = COPY %43:gr32
416B	  $rsi = COPY %42:gr64
432B	  $rdx = COPY %44:gr64
448B	  $rcx = COPY %42:gr64
464B	  $r8 = COPY %45:gr64
480B	  $r9 = COPY %46:gr64
496B	  CALL64r killed %40:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
512B	  ADJCALLSTACKUP64 16, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
528B	  %0:gr64 = MOV64rm %37:gr64, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
544B	  %1:gr64 = MOV64rm %37:gr64, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
560B	  %2:gr64 = MOV64rm %37:gr64, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
576B	  %3:gr64 = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
592B	  %4:gr64 = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
608B	  %5:gr64 = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
624B	  %6:gr64 = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
640B	  %7:gr64 = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
656B	  %8:gr64 = MOV64rm %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
672B	  %9:gr64 = SHL64ri %0:gr64(tied-def 0), 3, implicit-def dead $eflags
688B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
704B	  $rdi = COPY %9:gr64
720B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
736B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
752B	  %47:gr64 = COPY $rax
768B	  %10:gr64 = COPY %47:gr64
784B	  TEST64rr %0:gr64, %0:gr64, implicit-def $eflags
800B	  JCC_1 %bb.2, 14, implicit $eflags
816B	  JMP_1 %bb.1

832B	bb.1..lr.ph.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
864B	  %48:gr64 = MOV64ri &__bzero
880B	  $rdi = COPY %10:gr64
896B	  $rsi = COPY %9:gr64
912B	  CALL64r killed %48:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
928B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

944B	bb.2.._crit_edge:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.3(0x50000000), %bb.4(0x30000000); %bb.3(62.50%), %bb.4(37.50%)

960B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
976B	  %49:gr64 = COPY $rsp
992B	  %11:gr64 = ADD64ri8 %49:gr64(tied-def 0), -48, implicit-def dead $eflags
1008B	  $rsp = COPY %11:gr64
1024B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1040B	  MOV64mr %49:gr64, 1, $noreg, -48, $noreg, %10:gr64 :: (store (s64) into %ir.22)
1056B	  MOV64mr %49:gr64, 1, $noreg, -40, $noreg, %10:gr64 :: (store (s64) into %ir..repack9)
1072B	  MOV64mi32 %49:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack11)
1088B	  MOV64mr %49:gr64, 1, $noreg, -24, $noreg, %0:gr64 :: (store (s64) into %ir..repack13)
1104B	  MOV64mi32 %49:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack15)
1120B	  %12:gr64 = SHL64ri %1:gr64(tied-def 0), 3, implicit-def dead $eflags
1136B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1152B	  %50:gr64 = MOV64ri @malloc
1168B	  $rdi = COPY %12:gr64
1184B	  CALL64r killed %50:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1200B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1216B	  %51:gr64 = COPY $rax
1232B	  %13:gr64 = COPY %51:gr64
1248B	  TEST64rr %1:gr64, %1:gr64, implicit-def $eflags
1264B	  JCC_1 %bb.4, 14, implicit $eflags
1280B	  JMP_1 %bb.3

1296B	bb.3..lr.ph90.preheader:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1312B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1328B	  %52:gr64 = MOV64ri &__bzero
1344B	  $rdi = COPY %13:gr64
1360B	  $rsi = COPY %12:gr64
1376B	  CALL64r killed %52:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
1392B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

1408B	bb.4.._crit_edge91:
	; predecessors: %bb.2, %bb.3
	  successors: %bb.5(0x50000000), %bb.6(0x30000000); %bb.5(62.50%), %bb.6(37.50%)

1424B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1440B	  %53:gr64 = COPY $rsp
1456B	  %14:gr64 = ADD64ri8 %53:gr64(tied-def 0), -48, implicit-def dead $eflags
1472B	  $rsp = COPY %14:gr64
1488B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1504B	  MOV64mr %53:gr64, 1, $noreg, -48, $noreg, %13:gr64 :: (store (s64) into %ir.25)
1520B	  MOV64mr %53:gr64, 1, $noreg, -40, $noreg, %13:gr64 :: (store (s64) into %ir..repack18)
1536B	  MOV64mi32 %53:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack20)
1552B	  MOV64mr %53:gr64, 1, $noreg, -24, $noreg, %1:gr64 :: (store (s64) into %ir..repack22)
1568B	  MOV64mi32 %53:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack24)
1584B	  %15:gr64 = SHL64ri %2:gr64(tied-def 0), 3, implicit-def dead $eflags
1600B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1616B	  %54:gr64 = MOV64ri @malloc
1632B	  $rdi = COPY %15:gr64
1648B	  CALL64r killed %54:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1664B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1680B	  %55:gr64 = COPY $rax
1696B	  %16:gr64 = COPY %55:gr64
1712B	  TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
1728B	  JCC_1 %bb.6, 14, implicit $eflags
1744B	  JMP_1 %bb.5

1760B	bb.5..lr.ph93.preheader:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

1776B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1792B	  %56:gr64 = MOV64ri &__bzero
1808B	  $rdi = COPY %16:gr64
1824B	  $rsi = COPY %15:gr64
1840B	  CALL64r killed %56:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
1856B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

1872B	bb.6.._crit_edge94:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.7(0x50000000), %bb.8(0x30000000); %bb.7(62.50%), %bb.8(37.50%)

1888B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1904B	  %57:gr64 = COPY $rsp
1920B	  %17:gr64 = ADD64ri8 %57:gr64(tied-def 0), -48, implicit-def dead $eflags
1936B	  $rsp = COPY %17:gr64
1952B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1968B	  MOV64mr %57:gr64, 1, $noreg, -48, $noreg, %16:gr64 :: (store (s64) into %ir.28)
1984B	  MOV64mr %57:gr64, 1, $noreg, -40, $noreg, %16:gr64 :: (store (s64) into %ir..repack27)
2000B	  MOV64mi32 %57:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack29)
2016B	  MOV64mr %57:gr64, 1, $noreg, -24, $noreg, %2:gr64 :: (store (s64) into %ir..repack31)
2032B	  MOV64mi32 %57:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack33)
2048B	  %18:gr64 = SHL64ri %3:gr64(tied-def 0), 3, implicit-def dead $eflags
2064B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2080B	  %58:gr64 = MOV64ri @malloc
2096B	  $rdi = COPY %18:gr64
2112B	  CALL64r killed %58:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2128B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2144B	  %59:gr64 = COPY $rax
2160B	  %19:gr64 = COPY %59:gr64
2176B	  TEST64rr %3:gr64, %3:gr64, implicit-def $eflags
2192B	  JCC_1 %bb.8, 14, implicit $eflags
2208B	  JMP_1 %bb.7

2224B	bb.7..lr.ph96.preheader:
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)

2240B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2256B	  %60:gr64 = MOV64ri &__bzero
2272B	  $rdi = COPY %19:gr64
2288B	  $rsi = COPY %18:gr64
2304B	  CALL64r killed %60:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
2320B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2336B	bb.8.._crit_edge97:
	; predecessors: %bb.6, %bb.7
	  successors: %bb.9(0x50000000), %bb.10(0x30000000); %bb.9(62.50%), %bb.10(37.50%)

2352B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2368B	  %61:gr64 = COPY $rsp
2384B	  %20:gr64 = ADD64ri8 %61:gr64(tied-def 0), -48, implicit-def dead $eflags
2400B	  $rsp = COPY %20:gr64
2416B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2432B	  MOV64mr %61:gr64, 1, $noreg, -48, $noreg, %19:gr64 :: (store (s64) into %ir.31)
2448B	  MOV64mr %61:gr64, 1, $noreg, -40, $noreg, %19:gr64 :: (store (s64) into %ir..repack36)
2464B	  MOV64mi32 %61:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack38)
2480B	  MOV64mr %61:gr64, 1, $noreg, -24, $noreg, %3:gr64 :: (store (s64) into %ir..repack40)
2496B	  MOV64mi32 %61:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack42)
2512B	  %21:gr64 = SHL64ri %4:gr64(tied-def 0), 3, implicit-def dead $eflags
2528B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2544B	  %62:gr64 = MOV64ri @malloc
2560B	  $rdi = COPY %21:gr64
2576B	  CALL64r killed %62:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2592B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2608B	  %63:gr64 = COPY $rax
2624B	  %22:gr64 = COPY %63:gr64
2640B	  TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
2656B	  JCC_1 %bb.10, 14, implicit $eflags
2672B	  JMP_1 %bb.9

2688B	bb.9..lr.ph99.preheader:
	; predecessors: %bb.8
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

2704B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2720B	  %64:gr64 = MOV64ri &__bzero
2736B	  $rdi = COPY %22:gr64
2752B	  $rsi = COPY %21:gr64
2768B	  CALL64r killed %64:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
2784B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2800B	bb.10.._crit_edge100:
	; predecessors: %bb.8, %bb.9
	  successors: %bb.11(0x50000000), %bb.12(0x30000000); %bb.11(62.50%), %bb.12(37.50%)

2816B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2832B	  %65:gr64 = COPY $rsp
2848B	  %23:gr64 = ADD64ri8 %65:gr64(tied-def 0), -48, implicit-def dead $eflags
2864B	  $rsp = COPY %23:gr64
2880B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2896B	  MOV64mr %65:gr64, 1, $noreg, -48, $noreg, %22:gr64 :: (store (s64) into %ir.34)
2912B	  MOV64mr %65:gr64, 1, $noreg, -40, $noreg, %22:gr64 :: (store (s64) into %ir..repack45)
2928B	  MOV64mi32 %65:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack47)
2944B	  MOV64mr %65:gr64, 1, $noreg, -24, $noreg, %4:gr64 :: (store (s64) into %ir..repack49)
2960B	  MOV64mi32 %65:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack51)
2976B	  %24:gr64 = SHL64ri %5:gr64(tied-def 0), 3, implicit-def dead $eflags
2992B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3008B	  %66:gr64 = MOV64ri @malloc
3024B	  $rdi = COPY %24:gr64
3040B	  CALL64r killed %66:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3056B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3072B	  %67:gr64 = COPY $rax
3088B	  %25:gr64 = COPY %67:gr64
3104B	  TEST64rr %5:gr64, %5:gr64, implicit-def $eflags
3120B	  JCC_1 %bb.12, 14, implicit $eflags
3136B	  JMP_1 %bb.11

3152B	bb.11..lr.ph102.preheader:
	; predecessors: %bb.10
	  successors: %bb.12(0x80000000); %bb.12(100.00%)

3168B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3184B	  %68:gr64 = MOV64ri &__bzero
3200B	  $rdi = COPY %25:gr64
3216B	  $rsi = COPY %24:gr64
3232B	  CALL64r killed %68:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
3248B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3264B	bb.12.._crit_edge103:
	; predecessors: %bb.10, %bb.11
	  successors: %bb.13(0x50000000), %bb.14(0x30000000); %bb.13(62.50%), %bb.14(37.50%)

3280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3296B	  %69:gr64 = COPY $rsp
3312B	  %26:gr64 = ADD64ri8 %69:gr64(tied-def 0), -48, implicit-def dead $eflags
3328B	  $rsp = COPY %26:gr64
3344B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3360B	  MOV64mr %69:gr64, 1, $noreg, -48, $noreg, %25:gr64 :: (store (s64) into %ir.37)
3376B	  MOV64mr %69:gr64, 1, $noreg, -40, $noreg, %25:gr64 :: (store (s64) into %ir..repack54)
3392B	  MOV64mi32 %69:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack56)
3408B	  MOV64mr %69:gr64, 1, $noreg, -24, $noreg, %5:gr64 :: (store (s64) into %ir..repack58)
3424B	  MOV64mi32 %69:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack60)
3440B	  %27:gr64 = SHL64ri %6:gr64(tied-def 0), 3, implicit-def dead $eflags
3456B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3472B	  %70:gr64 = MOV64ri @malloc
3488B	  $rdi = COPY %27:gr64
3504B	  CALL64r killed %70:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3520B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3536B	  %71:gr64 = COPY $rax
3552B	  %28:gr64 = COPY %71:gr64
3568B	  TEST64rr %6:gr64, %6:gr64, implicit-def $eflags
3584B	  JCC_1 %bb.14, 14, implicit $eflags
3600B	  JMP_1 %bb.13

3616B	bb.13..lr.ph105.preheader:
	; predecessors: %bb.12
	  successors: %bb.14(0x80000000); %bb.14(100.00%)

3632B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3648B	  %72:gr64 = MOV64ri &__bzero
3664B	  $rdi = COPY %28:gr64
3680B	  $rsi = COPY %27:gr64
3696B	  CALL64r killed %72:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
3712B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3728B	bb.14.._crit_edge106:
	; predecessors: %bb.12, %bb.13
	  successors: %bb.15(0x50000000), %bb.16(0x30000000); %bb.15(62.50%), %bb.16(37.50%)

3744B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3760B	  %73:gr64 = COPY $rsp
3776B	  %29:gr64 = ADD64ri8 %73:gr64(tied-def 0), -48, implicit-def dead $eflags
3792B	  $rsp = COPY %29:gr64
3808B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3824B	  MOV64mr %73:gr64, 1, $noreg, -48, $noreg, %28:gr64 :: (store (s64) into %ir.40)
3840B	  MOV64mr %73:gr64, 1, $noreg, -40, $noreg, %28:gr64 :: (store (s64) into %ir..repack63)
3856B	  MOV64mi32 %73:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack65)
3872B	  MOV64mr %73:gr64, 1, $noreg, -24, $noreg, %6:gr64 :: (store (s64) into %ir..repack67)
3888B	  MOV64mi32 %73:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack69)
3904B	  %30:gr64 = SHL64ri %7:gr64(tied-def 0), 3, implicit-def dead $eflags
3920B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3936B	  %74:gr64 = MOV64ri @malloc
3952B	  $rdi = COPY %30:gr64
3968B	  CALL64r killed %74:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3984B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4000B	  %75:gr64 = COPY $rax
4016B	  %31:gr64 = COPY %75:gr64
4032B	  TEST64rr %7:gr64, %7:gr64, implicit-def $eflags
4048B	  JCC_1 %bb.16, 14, implicit $eflags
4064B	  JMP_1 %bb.15

4080B	bb.15..lr.ph108.preheader:
	; predecessors: %bb.14
	  successors: %bb.16(0x80000000); %bb.16(100.00%)

4096B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4112B	  %76:gr64 = MOV64ri &__bzero
4128B	  $rdi = COPY %31:gr64
4144B	  $rsi = COPY %30:gr64
4160B	  CALL64r killed %76:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
4176B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

4192B	bb.16.._crit_edge109:
	; predecessors: %bb.14, %bb.15
	  successors: %bb.17(0x50000000), %bb.18(0x30000000); %bb.17(62.50%), %bb.18(37.50%)

4208B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4224B	  %77:gr64 = COPY $rsp
4240B	  %32:gr64 = ADD64ri8 %77:gr64(tied-def 0), -48, implicit-def dead $eflags
4256B	  $rsp = COPY %32:gr64
4272B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4288B	  MOV64mr %77:gr64, 1, $noreg, -48, $noreg, %31:gr64 :: (store (s64) into %ir.43)
4304B	  MOV64mr %77:gr64, 1, $noreg, -40, $noreg, %31:gr64 :: (store (s64) into %ir..repack72)
4320B	  MOV64mi32 %77:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack74)
4336B	  MOV64mr %77:gr64, 1, $noreg, -24, $noreg, %7:gr64 :: (store (s64) into %ir..repack76)
4352B	  MOV64mi32 %77:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack78)
4368B	  %33:gr64 = SHL64ri %8:gr64(tied-def 0), 3, implicit-def dead $eflags
4384B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4400B	  %78:gr64 = MOV64ri @malloc
4416B	  $rdi = COPY %33:gr64
4432B	  CALL64r killed %78:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
4448B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4464B	  %79:gr64 = COPY $rax
4480B	  %34:gr64 = COPY %79:gr64
4496B	  TEST64rr %8:gr64, %8:gr64, implicit-def $eflags
4512B	  JCC_1 %bb.18, 14, implicit $eflags
4528B	  JMP_1 %bb.17

4544B	bb.17..lr.ph111.preheader:
	; predecessors: %bb.16
	  successors: %bb.18(0x80000000); %bb.18(100.00%)

4560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4576B	  %80:gr64 = MOV64ri &__bzero
4592B	  $rdi = COPY %34:gr64
4608B	  $rsi = COPY %33:gr64
4624B	  CALL64r killed %80:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
4640B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

4656B	bb.18.._crit_edge112:
	; predecessors: %bb.16, %bb.17

4672B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4688B	  %81:gr64 = COPY $rsp
4704B	  %82:gr64 = ADD64ri8 %81:gr64(tied-def 0), -48, implicit-def dead $eflags
4720B	  $rsp = COPY %82:gr64
4736B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4752B	  MOV64mr %81:gr64, 1, $noreg, -48, $noreg, %34:gr64 :: (store (s64) into %ir.46)
4768B	  MOV64mr %81:gr64, 1, $noreg, -40, $noreg, %34:gr64 :: (store (s64) into %ir..repack81)
4784B	  MOV64mi32 %81:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack83)
4800B	  MOV64mr %81:gr64, 1, $noreg, -24, $noreg, %8:gr64 :: (store (s64) into %ir..repack85)
4816B	  MOV64mi32 %81:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack87)
4832B	  ADJCALLSTACKDOWN64 144, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4848B	  %83:gr64 = COPY $rsp
4864B	  MOV64mr %83:gr64, 1, $noreg, 128, $noreg, %82:gr64 :: (store (s64) into stack + 128)
4880B	  MOV64mr %83:gr64, 1, $noreg, 112, $noreg, %32:gr64 :: (store (s64) into stack + 112)
4896B	  MOV64mr %83:gr64, 1, $noreg, 96, $noreg, %29:gr64 :: (store (s64) into stack + 96)
4912B	  MOV64mr %83:gr64, 1, $noreg, 80, $noreg, %26:gr64 :: (store (s64) into stack + 80)
4928B	  MOV64mr %83:gr64, 1, $noreg, 64, $noreg, %23:gr64 :: (store (s64) into stack + 64)
4944B	  MOV64mr %83:gr64, 1, $noreg, 48, $noreg, %20:gr64 :: (store (s64) into stack + 48)
4960B	  MOV64mr %83:gr64, 1, $noreg, 32, $noreg, %17:gr64 :: (store (s64) into stack + 32)
4976B	  MOV64mr %83:gr64, 1, $noreg, 16, $noreg, %14:gr64 :: (store (s64) into stack + 16)
4992B	  MOV64mr %83:gr64, 1, $noreg, 0, $noreg, %11:gr64 :: (store (s64) into stack)
5008B	  MOV32mi %83:gr64, 1, $noreg, 136, $noreg, 1 :: (store (s32) into stack + 136)
5024B	  MOV64mi32 %83:gr64, 1, $noreg, 120, $noreg, 1 :: (store (s64) into stack + 120)
5040B	  MOV64mi32 %83:gr64, 1, $noreg, 104, $noreg, 1 :: (store (s64) into stack + 104)
5056B	  MOV64mi32 %83:gr64, 1, $noreg, 88, $noreg, 1 :: (store (s64) into stack + 88)
5072B	  MOV64mi32 %83:gr64, 1, $noreg, 72, $noreg, 1 :: (store (s64) into stack + 72)
5088B	  MOV64mi32 %83:gr64, 1, $noreg, 56, $noreg, 1 :: (store (s64) into stack + 56)
5104B	  MOV64mi32 %83:gr64, 1, $noreg, 40, $noreg, 1 :: (store (s64) into stack + 40)
5120B	  MOV64mi32 %83:gr64, 1, $noreg, 24, $noreg, 1 :: (store (s64) into stack + 24)
5136B	  MOV64mi32 %83:gr64, 1, $noreg, 8, $noreg, 1 :: (store (s64) into stack + 8)
5152B	  %84:gr64 = MOV64ri @read_input_2D_f64
5168B	  %85:gr32 = MOV32r0 implicit-def dead $eflags
5184B	  %86:gr64 = SUBREG_TO_REG 0, killed %85:gr32, %subreg.sub_32bit
5200B	  %87:gr32 = MOV32ri 1
5216B	  %88:gr64 = MOV32ri64 3
5232B	  %89:gr64 = MOV64ri32 -1
5248B	  %90:gr64 = MOV32ri64 1
5264B	  $edi = COPY %87:gr32
5280B	  $rsi = COPY %86:gr64
5296B	  $rdx = COPY %88:gr64
5312B	  $rcx = COPY %86:gr64
5328B	  $r8 = COPY %89:gr64
5344B	  $r9 = COPY %90:gr64
5360B	  CALL64r killed %84:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
5376B	  ADJCALLSTACKUP64 144, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5392B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5408B	  %91:gr64 = MOV64ri @comet_print_memref_i64
5424B	  $rdi = COPY %90:gr64
5440B	  $rsi = COPY %11:gr64
5456B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5472B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5488B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5504B	  $rdi = COPY %90:gr64
5520B	  $rsi = COPY %14:gr64
5536B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5552B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5568B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5584B	  $rdi = COPY %90:gr64
5600B	  $rsi = COPY %17:gr64
5616B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5632B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5648B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5664B	  $rdi = COPY %90:gr64
5680B	  $rsi = COPY %20:gr64
5696B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5712B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5728B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5744B	  $rdi = COPY %90:gr64
5760B	  $rsi = COPY %23:gr64
5776B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5792B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5808B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5824B	  $rdi = COPY %90:gr64
5840B	  $rsi = COPY %26:gr64
5856B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5872B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5888B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5904B	  $rdi = COPY %90:gr64
5920B	  $rsi = COPY %29:gr64
5936B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5952B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5968B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5984B	  $rdi = COPY %90:gr64
6000B	  $rsi = COPY %32:gr64
6016B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
6032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6048B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6064B	  %92:gr64 = MOV64ri @comet_print_memref_f64
6080B	  $rdi = COPY %90:gr64
6096B	  $rsi = COPY %82:gr64
6112B	  CALL64r killed %92:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
6128B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6144B	  RET 0

# End machine code for function main.

********** Stack Coloring **********
********** Function: main
Found 0 markers and 10 slots
Slot structure:
Slot #0 - 40 bytes.
Slot #1 - 0 bytes.
Slot #2 - 0 bytes.
Slot #3 - 0 bytes.
Slot #4 - 0 bytes.
Slot #5 - 0 bytes.
Slot #6 - 0 bytes.
Slot #7 - 0 bytes.
Slot #8 - 0 bytes.
Slot #9 - 0 bytes.
Total Stack size: 40 bytes

Will not try to merge slots.
Removed 0 markers.
********** EARLY IF-CONVERSION **********
********** Function: main
Machine InstCombiner: main
Combining MBB 
Combining MBB .lr.ph.preheader
Combining MBB ._crit_edge
Combining MBB .lr.ph90.preheader
Combining MBB ._crit_edge91
Combining MBB .lr.ph93.preheader
Combining MBB ._crit_edge94
Combining MBB .lr.ph96.preheader
Combining MBB ._crit_edge97
Combining MBB .lr.ph99.preheader
Combining MBB ._crit_edge100
Combining MBB .lr.ph102.preheader
Combining MBB ._crit_edge103
Combining MBB .lr.ph105.preheader
Combining MBB ._crit_edge106
Combining MBB .lr.ph108.preheader
Combining MBB ._crit_edge109
Combining MBB .lr.ph111.preheader
Combining MBB ._crit_edge112
********** X86 cmov Conversion : main**********

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[]
 - 1: BB1[.lr.ph.preheader]
 - 2: BB2[._crit_edge]
 - 3: BB3[.lr.ph90.preheader]
 - 4: BB4[._crit_edge91]
 - 5: BB5[.lr.ph93.preheader]
 - 6: BB6[._crit_edge94]
 - 7: BB7[.lr.ph96.preheader]
 - 8: BB8[._crit_edge97]
 - 9: BB9[.lr.ph99.preheader]
 - 10: BB10[._crit_edge100]
 - 11: BB11[.lr.ph102.preheader]
 - 12: BB12[._crit_edge103]
 - 13: BB13[.lr.ph105.preheader]
 - 14: BB14[._crit_edge106]
 - 15: BB15[.lr.ph108.preheader]
 - 16: BB16[._crit_edge109]
 - 17: BB17[.lr.ph111.preheader]
 - 18: BB18[._crit_edge112]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => [ local  ] weight = 1342177280, succ = BB1[.lr.ph.preheader]
  => [ local  ] weight = 805306368, succ = BB2[._crit_edge]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB1[.lr.ph.preheader]
  => assign 6000000000000000 (0000000000000000) to BB2[._crit_edge]
 - node: BB1[.lr.ph.preheader]
  => [ local  ] weight = 2147483648, succ = BB2[._crit_edge]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB2[._crit_edge]
 - node: BB2[._crit_edge]
  => [ local  ] weight = 1342177280, succ = BB3[.lr.ph90.preheader]
  => [ local  ] weight = 805306368, succ = BB4[._crit_edge91]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB3[.lr.ph90.preheader]
  => assign 6000000000000000 (0000000000000000) to BB4[._crit_edge91]
 - node: BB3[.lr.ph90.preheader]
  => [ local  ] weight = 2147483648, succ = BB4[._crit_edge91]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB4[._crit_edge91]
 - node: BB4[._crit_edge91]
  => [ local  ] weight = 1342177280, succ = BB5[.lr.ph93.preheader]
  => [ local  ] weight = 805306368, succ = BB6[._crit_edge94]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB5[.lr.ph93.preheader]
  => assign 6000000000000000 (0000000000000000) to BB6[._crit_edge94]
 - node: BB5[.lr.ph93.preheader]
  => [ local  ] weight = 2147483648, succ = BB6[._crit_edge94]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB6[._crit_edge94]
 - node: BB6[._crit_edge94]
  => [ local  ] weight = 1342177280, succ = BB7[.lr.ph96.preheader]
  => [ local  ] weight = 805306368, succ = BB8[._crit_edge97]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB7[.lr.ph96.preheader]
  => assign 6000000000000000 (0000000000000000) to BB8[._crit_edge97]
 - node: BB7[.lr.ph96.preheader]
  => [ local  ] weight = 2147483648, succ = BB8[._crit_edge97]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB8[._crit_edge97]
 - node: BB8[._crit_edge97]
  => [ local  ] weight = 1342177280, succ = BB9[.lr.ph99.preheader]
  => [ local  ] weight = 805306368, succ = BB10[._crit_edge100]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB9[.lr.ph99.preheader]
  => assign 6000000000000000 (0000000000000000) to BB10[._crit_edge100]
 - node: BB9[.lr.ph99.preheader]
  => [ local  ] weight = 2147483648, succ = BB10[._crit_edge100]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB10[._crit_edge100]
 - node: BB10[._crit_edge100]
  => [ local  ] weight = 1342177280, succ = BB11[.lr.ph102.preheader]
  => [ local  ] weight = 805306368, succ = BB12[._crit_edge103]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB11[.lr.ph102.preheader]
  => assign 6000000000000000 (0000000000000000) to BB12[._crit_edge103]
 - node: BB11[.lr.ph102.preheader]
  => [ local  ] weight = 2147483648, succ = BB12[._crit_edge103]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB12[._crit_edge103]
 - node: BB12[._crit_edge103]
  => [ local  ] weight = 1342177280, succ = BB13[.lr.ph105.preheader]
  => [ local  ] weight = 805306368, succ = BB14[._crit_edge106]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB13[.lr.ph105.preheader]
  => assign 6000000000000000 (0000000000000000) to BB14[._crit_edge106]
 - node: BB13[.lr.ph105.preheader]
  => [ local  ] weight = 2147483648, succ = BB14[._crit_edge106]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB14[._crit_edge106]
 - node: BB14[._crit_edge106]
  => [ local  ] weight = 1342177280, succ = BB15[.lr.ph108.preheader]
  => [ local  ] weight = 805306368, succ = BB16[._crit_edge109]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB15[.lr.ph108.preheader]
  => assign 6000000000000000 (0000000000000000) to BB16[._crit_edge109]
 - node: BB15[.lr.ph108.preheader]
  => [ local  ] weight = 2147483648, succ = BB16[._crit_edge109]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB16[._crit_edge109]
 - node: BB16[._crit_edge109]
  => [ local  ] weight = 1342177280, succ = BB17[.lr.ph111.preheader]
  => [ local  ] weight = 805306368, succ = BB18[._crit_edge112]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB17[.lr.ph111.preheader]
  => assign 6000000000000000 (0000000000000000) to BB18[._crit_edge112]
 - node: BB17[.lr.ph111.preheader]
  => [ local  ] weight = 2147483648, succ = BB18[._crit_edge112]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB18[._crit_edge112]
 - node: BB18[._crit_edge112]
  => mass:  ffffffffffffffff
float-to-int: min = 0.625, max = 1.0, factor = 12.8
 - BB0[]: float = 1.0, scaled = 12.8, int = 12
 - BB1[.lr.ph.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB2[._crit_edge]: float = 1.0, scaled = 12.8, int = 12
 - BB3[.lr.ph90.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB4[._crit_edge91]: float = 1.0, scaled = 12.8, int = 12
 - BB5[.lr.ph93.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB6[._crit_edge94]: float = 1.0, scaled = 12.8, int = 12
 - BB7[.lr.ph96.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB8[._crit_edge97]: float = 1.0, scaled = 12.8, int = 12
 - BB9[.lr.ph99.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB10[._crit_edge100]: float = 1.0, scaled = 12.8, int = 12
 - BB11[.lr.ph102.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB12[._crit_edge103]: float = 1.0, scaled = 12.8, int = 12
 - BB13[.lr.ph105.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB14[._crit_edge106]: float = 1.0, scaled = 12.8, int = 12
 - BB15[.lr.ph108.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB16[._crit_edge109]: float = 1.0, scaled = 12.8, int = 12
 - BB17[.lr.ph111.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB18[._crit_edge112]: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: main
 - BB0[]: float = 1.0, int = 12
 - BB1[.lr.ph.preheader]: float = 0.625, int = 8
 - BB2[._crit_edge]: float = 1.0, int = 12
 - BB3[.lr.ph90.preheader]: float = 0.625, int = 8
 - BB4[._crit_edge91]: float = 1.0, int = 12
 - BB5[.lr.ph93.preheader]: float = 0.625, int = 8
 - BB6[._crit_edge94]: float = 1.0, int = 12
 - BB7[.lr.ph96.preheader]: float = 0.625, int = 8
 - BB8[._crit_edge97]: float = 1.0, int = 12
 - BB9[.lr.ph99.preheader]: float = 0.625, int = 8
 - BB10[._crit_edge100]: float = 1.0, int = 12
 - BB11[.lr.ph102.preheader]: float = 0.625, int = 8
 - BB12[._crit_edge103]: float = 1.0, int = 12
 - BB13[.lr.ph105.preheader]: float = 0.625, int = 8
 - BB14[._crit_edge106]: float = 1.0, int = 12
 - BB15[.lr.ph108.preheader]: float = 0.625, int = 8
 - BB16[._crit_edge109]: float = 1.0, int = 12
 - BB17[.lr.ph111.preheader]: float = 0.625, int = 8
 - BB18[._crit_edge112]: float = 1.0, int = 12

******** Pre-regalloc Machine LICM: main ********

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[]
 - 1: BB1[.lr.ph.preheader]
 - 2: BB2[._crit_edge]
 - 3: BB3[.lr.ph90.preheader]
 - 4: BB4[._crit_edge91]
 - 5: BB5[.lr.ph93.preheader]
 - 6: BB6[._crit_edge94]
 - 7: BB7[.lr.ph96.preheader]
 - 8: BB8[._crit_edge97]
 - 9: BB9[.lr.ph99.preheader]
 - 10: BB10[._crit_edge100]
 - 11: BB11[.lr.ph102.preheader]
 - 12: BB12[._crit_edge103]
 - 13: BB13[.lr.ph105.preheader]
 - 14: BB14[._crit_edge106]
 - 15: BB15[.lr.ph108.preheader]
 - 16: BB16[._crit_edge109]
 - 17: BB17[.lr.ph111.preheader]
 - 18: BB18[._crit_edge112]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => [ local  ] weight = 1342177280, succ = BB1[.lr.ph.preheader]
  => [ local  ] weight = 805306368, succ = BB2[._crit_edge]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB1[.lr.ph.preheader]
  => assign 6000000000000000 (0000000000000000) to BB2[._crit_edge]
 - node: BB1[.lr.ph.preheader]
  => [ local  ] weight = 2147483648, succ = BB2[._crit_edge]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB2[._crit_edge]
 - node: BB2[._crit_edge]
  => [ local  ] weight = 1342177280, succ = BB3[.lr.ph90.preheader]
  => [ local  ] weight = 805306368, succ = BB4[._crit_edge91]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB3[.lr.ph90.preheader]
  => assign 6000000000000000 (0000000000000000) to BB4[._crit_edge91]
 - node: BB3[.lr.ph90.preheader]
  => [ local  ] weight = 2147483648, succ = BB4[._crit_edge91]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB4[._crit_edge91]
 - node: BB4[._crit_edge91]
  => [ local  ] weight = 1342177280, succ = BB5[.lr.ph93.preheader]
  => [ local  ] weight = 805306368, succ = BB6[._crit_edge94]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB5[.lr.ph93.preheader]
  => assign 6000000000000000 (0000000000000000) to BB6[._crit_edge94]
 - node: BB5[.lr.ph93.preheader]
  => [ local  ] weight = 2147483648, succ = BB6[._crit_edge94]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB6[._crit_edge94]
 - node: BB6[._crit_edge94]
  => [ local  ] weight = 1342177280, succ = BB7[.lr.ph96.preheader]
  => [ local  ] weight = 805306368, succ = BB8[._crit_edge97]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB7[.lr.ph96.preheader]
  => assign 6000000000000000 (0000000000000000) to BB8[._crit_edge97]
 - node: BB7[.lr.ph96.preheader]
  => [ local  ] weight = 2147483648, succ = BB8[._crit_edge97]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB8[._crit_edge97]
 - node: BB8[._crit_edge97]
  => [ local  ] weight = 1342177280, succ = BB9[.lr.ph99.preheader]
  => [ local  ] weight = 805306368, succ = BB10[._crit_edge100]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB9[.lr.ph99.preheader]
  => assign 6000000000000000 (0000000000000000) to BB10[._crit_edge100]
 - node: BB9[.lr.ph99.preheader]
  => [ local  ] weight = 2147483648, succ = BB10[._crit_edge100]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB10[._crit_edge100]
 - node: BB10[._crit_edge100]
  => [ local  ] weight = 1342177280, succ = BB11[.lr.ph102.preheader]
  => [ local  ] weight = 805306368, succ = BB12[._crit_edge103]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB11[.lr.ph102.preheader]
  => assign 6000000000000000 (0000000000000000) to BB12[._crit_edge103]
 - node: BB11[.lr.ph102.preheader]
  => [ local  ] weight = 2147483648, succ = BB12[._crit_edge103]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB12[._crit_edge103]
 - node: BB12[._crit_edge103]
  => [ local  ] weight = 1342177280, succ = BB13[.lr.ph105.preheader]
  => [ local  ] weight = 805306368, succ = BB14[._crit_edge106]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB13[.lr.ph105.preheader]
  => assign 6000000000000000 (0000000000000000) to BB14[._crit_edge106]
 - node: BB13[.lr.ph105.preheader]
  => [ local  ] weight = 2147483648, succ = BB14[._crit_edge106]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB14[._crit_edge106]
 - node: BB14[._crit_edge106]
  => [ local  ] weight = 1342177280, succ = BB15[.lr.ph108.preheader]
  => [ local  ] weight = 805306368, succ = BB16[._crit_edge109]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB15[.lr.ph108.preheader]
  => assign 6000000000000000 (0000000000000000) to BB16[._crit_edge109]
 - node: BB15[.lr.ph108.preheader]
  => [ local  ] weight = 2147483648, succ = BB16[._crit_edge109]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB16[._crit_edge109]
 - node: BB16[._crit_edge109]
  => [ local  ] weight = 1342177280, succ = BB17[.lr.ph111.preheader]
  => [ local  ] weight = 805306368, succ = BB18[._crit_edge112]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB17[.lr.ph111.preheader]
  => assign 6000000000000000 (0000000000000000) to BB18[._crit_edge112]
 - node: BB17[.lr.ph111.preheader]
  => [ local  ] weight = 2147483648, succ = BB18[._crit_edge112]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB18[._crit_edge112]
 - node: BB18[._crit_edge112]
  => mass:  ffffffffffffffff
float-to-int: min = 0.625, max = 1.0, factor = 12.8
 - BB0[]: float = 1.0, scaled = 12.8, int = 12
 - BB1[.lr.ph.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB2[._crit_edge]: float = 1.0, scaled = 12.8, int = 12
 - BB3[.lr.ph90.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB4[._crit_edge91]: float = 1.0, scaled = 12.8, int = 12
 - BB5[.lr.ph93.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB6[._crit_edge94]: float = 1.0, scaled = 12.8, int = 12
 - BB7[.lr.ph96.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB8[._crit_edge97]: float = 1.0, scaled = 12.8, int = 12
 - BB9[.lr.ph99.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB10[._crit_edge100]: float = 1.0, scaled = 12.8, int = 12
 - BB11[.lr.ph102.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB12[._crit_edge103]: float = 1.0, scaled = 12.8, int = 12
 - BB13[.lr.ph105.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB14[._crit_edge106]: float = 1.0, scaled = 12.8, int = 12
 - BB15[.lr.ph108.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB16[._crit_edge109]: float = 1.0, scaled = 12.8, int = 12
 - BB17[.lr.ph111.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB18[._crit_edge112]: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: main
 - BB0[]: float = 1.0, int = 12
 - BB1[.lr.ph.preheader]: float = 0.625, int = 8
 - BB2[._crit_edge]: float = 1.0, int = 12
 - BB3[.lr.ph90.preheader]: float = 0.625, int = 8
 - BB4[._crit_edge91]: float = 1.0, int = 12
 - BB5[.lr.ph93.preheader]: float = 0.625, int = 8
 - BB6[._crit_edge94]: float = 1.0, int = 12
 - BB7[.lr.ph96.preheader]: float = 0.625, int = 8
 - BB8[._crit_edge97]: float = 1.0, int = 12
 - BB9[.lr.ph99.preheader]: float = 0.625, int = 8
 - BB10[._crit_edge100]: float = 1.0, int = 12
 - BB11[.lr.ph102.preheader]: float = 0.625, int = 8
 - BB12[._crit_edge103]: float = 1.0, int = 12
 - BB13[.lr.ph105.preheader]: float = 0.625, int = 8
 - BB14[._crit_edge106]: float = 1.0, int = 12
 - BB15[.lr.ph108.preheader]: float = 0.625, int = 8
 - BB16[._crit_edge109]: float = 1.0, int = 12
 - BB17[.lr.ph111.preheader]: float = 0.625, int = 8
 - BB18[._crit_edge112]: float = 1.0, int = 12

Entering: 
Entering: ._crit_edge
Examining: %50:gr64 = MOV64ri @malloc
*** Found a common subexpression: %35:gr64 = MOV64ri @malloc
Examining: %99:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Entering: ._crit_edge91
Examining: %54:gr64 = MOV64ri @malloc
*** Found a common subexpression: %35:gr64 = MOV64ri @malloc
Examining: %98:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Entering: ._crit_edge94
Examining: %58:gr64 = MOV64ri @malloc
*** Found a common subexpression: %35:gr64 = MOV64ri @malloc
Examining: %97:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Entering: ._crit_edge97
Examining: %62:gr64 = MOV64ri @malloc
*** Found a common subexpression: %35:gr64 = MOV64ri @malloc
Examining: %96:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Entering: ._crit_edge100
Examining: %66:gr64 = MOV64ri @malloc
*** Found a common subexpression: %35:gr64 = MOV64ri @malloc
Examining: %95:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Entering: ._crit_edge103
Examining: %70:gr64 = MOV64ri @malloc
*** Found a common subexpression: %35:gr64 = MOV64ri @malloc
Examining: %94:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Entering: ._crit_edge106
Examining: %74:gr64 = MOV64ri @malloc
*** Found a common subexpression: %35:gr64 = MOV64ri @malloc
Examining: %93:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Entering: ._crit_edge109
Examining: %78:gr64 = MOV64ri @malloc
*** Found a common subexpression: %35:gr64 = MOV64ri @malloc
Entering: ._crit_edge112
Examining: %85:gr32 = MOV32r0 implicit-def dead $eflags
*** Found a common subexpression: %41:gr32 = MOV32r0 implicit-def dead $eflags
*** Not profitable, avoid CSE!
Examining: %87:gr32 = MOV32ri 1
*** Found a common subexpression: %43:gr32 = MOV32ri 1
*** Not profitable, avoid CSE!
Examining: %88:gr64 = MOV32ri64 3
*** Found a common subexpression: %44:gr64 = MOV32ri64 3
*** Not profitable, avoid CSE!
Examining: %89:gr64 = MOV64ri32 -1
*** Found a common subexpression: %45:gr64 = MOV64ri32 -1
*** Not profitable, avoid CSE!
Examining: %90:gr64 = MOV32ri64 1
*** Found a common subexpression: %46:gr64 = MOV32ri64 1
*** Not profitable, avoid CSE!
Exiting: ._crit_edge112
Entering: .lr.ph111.preheader
Examining: %80:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Exiting: .lr.ph111.preheader
Exiting: ._crit_edge109
Entering: .lr.ph108.preheader
Examining: %76:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Exiting: .lr.ph108.preheader
Exiting: ._crit_edge106
Entering: .lr.ph105.preheader
Examining: %72:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Exiting: .lr.ph105.preheader
Exiting: ._crit_edge103
Entering: .lr.ph102.preheader
Examining: %68:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Exiting: .lr.ph102.preheader
Exiting: ._crit_edge100
Entering: .lr.ph99.preheader
Examining: %64:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Exiting: .lr.ph99.preheader
Exiting: ._crit_edge97
Entering: .lr.ph96.preheader
Examining: %60:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Exiting: .lr.ph96.preheader
Exiting: ._crit_edge94
Entering: .lr.ph93.preheader
Examining: %56:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Exiting: .lr.ph93.preheader
Exiting: ._crit_edge91
Entering: .lr.ph90.preheader
Examining: %52:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Exiting: .lr.ph90.preheader
Exiting: ._crit_edge
Entering: .lr.ph.preheader
Examining: %48:gr64 = MOV64ri &__bzero
*** Found a common subexpression: %100:gr64 = MOV64ri &__bzero
Exiting: .lr.ph.preheader
Exiting: 
		Looking for trivial roots
Found a new trivial root: %bb.18
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 19, Num: 20
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.18
3: %bb.17
4: %bb.16
5: %bb.15
6: %bb.14
7: %bb.13
8: %bb.12
9: %bb.11
10: %bb.10
11: %bb.9
12: %bb.8
13: %bb.7
14: %bb.6
15: %bb.5
16: %bb.4
17: %bb.3
18: %bb.2
19: %bb.1
20: %bb.0
Found roots: %bb.18 
Computing cycles for function: main
Entry block: bb.0 (%ir-block.0)
DFS visiting block: bb.0 (%ir-block.0)
  first encountered at depth 1
  preorder number: 1
DFS visiting block: bb.2.._crit_edge
  first encountered at depth 3
  preorder number: 2
DFS visiting block: bb.4.._crit_edge91
  first encountered at depth 5
  preorder number: 3
DFS visiting block: bb.6.._crit_edge94
  first encountered at depth 7
  preorder number: 4
DFS visiting block: bb.8.._crit_edge97
  first encountered at depth 9
  preorder number: 5
DFS visiting block: bb.10.._crit_edge100
  first encountered at depth 11
  preorder number: 6
DFS visiting block: bb.12.._crit_edge103
  first encountered at depth 13
  preorder number: 7
DFS visiting block: bb.14.._crit_edge106
  first encountered at depth 15
  preorder number: 8
DFS visiting block: bb.16.._crit_edge109
  first encountered at depth 17
  preorder number: 9
DFS visiting block: bb.18.._crit_edge112
  first encountered at depth 19
  preorder number: 10
DFS visiting block: bb.18.._crit_edge112
  ended at 10
DFS visiting block: bb.17..lr.ph111.preheader
  first encountered at depth 18
  preorder number: 11
DFS visiting block: bb.18.._crit_edge112
  already done
DFS visiting block: bb.17..lr.ph111.preheader
  ended at 11
DFS visiting block: bb.16.._crit_edge109
  ended at 11
DFS visiting block: bb.15..lr.ph108.preheader
  first encountered at depth 16
  preorder number: 12
DFS visiting block: bb.16.._crit_edge109
  already done
DFS visiting block: bb.15..lr.ph108.preheader
  ended at 12
DFS visiting block: bb.14.._crit_edge106
  ended at 12
DFS visiting block: bb.13..lr.ph105.preheader
  first encountered at depth 14
  preorder number: 13
DFS visiting block: bb.14.._crit_edge106
  already done
DFS visiting block: bb.13..lr.ph105.preheader
  ended at 13
DFS visiting block: bb.12.._crit_edge103
  ended at 13
DFS visiting block: bb.11..lr.ph102.preheader
  first encountered at depth 12
  preorder number: 14
DFS visiting block: bb.12.._crit_edge103
  already done
DFS visiting block: bb.11..lr.ph102.preheader
  ended at 14
DFS visiting block: bb.10.._crit_edge100
  ended at 14
DFS visiting block: bb.9..lr.ph99.preheader
  first encountered at depth 10
  preorder number: 15
DFS visiting block: bb.10.._crit_edge100
  already done
DFS visiting block: bb.9..lr.ph99.preheader
  ended at 15
DFS visiting block: bb.8.._crit_edge97
  ended at 15
DFS visiting block: bb.7..lr.ph96.preheader
  first encountered at depth 8
  preorder number: 16
DFS visiting block: bb.8.._crit_edge97
  already done
DFS visiting block: bb.7..lr.ph96.preheader
  ended at 16
DFS visiting block: bb.6.._crit_edge94
  ended at 16
DFS visiting block: bb.5..lr.ph93.preheader
  first encountered at depth 6
  preorder number: 17
DFS visiting block: bb.6.._crit_edge94
  already done
DFS visiting block: bb.5..lr.ph93.preheader
  ended at 17
DFS visiting block: bb.4.._crit_edge91
  ended at 17
DFS visiting block: bb.3..lr.ph90.preheader
  first encountered at depth 4
  preorder number: 18
DFS visiting block: bb.4.._crit_edge91
  already done
DFS visiting block: bb.3..lr.ph90.preheader
  ended at 18
DFS visiting block: bb.2.._crit_edge
  ended at 18
DFS visiting block: bb.1..lr.ph.preheader
  first encountered at depth 2
  preorder number: 19
DFS visiting block: bb.2.._crit_edge
  already done
DFS visiting block: bb.1..lr.ph.preheader
  ended at 19
DFS visiting block: bb.0 (%ir-block.0)
  ended at 19
Preorder:
  bb.0 (%ir-block.0): 0
  bb.2.._crit_edge: 1
  bb.4.._crit_edge91: 2
  bb.6.._crit_edge94: 3
  bb.8.._crit_edge97: 4
  bb.10.._crit_edge100: 5
  bb.12.._crit_edge103: 6
  bb.14.._crit_edge106: 7
  bb.16.._crit_edge109: 8
  bb.18.._crit_edge112: 9
  bb.17..lr.ph111.preheader: 10
  bb.15..lr.ph108.preheader: 11
  bb.13..lr.ph105.preheader: 12
  bb.11..lr.ph102.preheader: 13
  bb.9..lr.ph99.preheader: 14
  bb.7..lr.ph96.preheader: 15
  bb.5..lr.ph93.preheader: 16
  bb.3..lr.ph90.preheader: 17
  bb.1..lr.ph.preheader: 18
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: main
Encountered load fold barrier on CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Encountered load fold barrier on MOV64mr %stack.0, 1, $noreg, 0, $noreg, %37:gr64 :: (store (s64) into %ir.2)
Encountered load fold barrier on MOV64mr %stack.0, 1, $noreg, 8, $noreg, %37:gr64 :: (store (s64) into %ir..fca.1.gep)
Encountered load fold barrier on MOV64mi32 %stack.0, 1, $noreg, 16, $noreg, 0 :: (store (s64) into %ir..fca.2.gep)
Encountered load fold barrier on MOV64mi32 %stack.0, 1, $noreg, 24, $noreg, 7 :: (store (s64) into %ir..fca.3.0.gep)
Encountered load fold barrier on MOV64mi32 %stack.0, 1, $noreg, 32, $noreg, 1 :: (store (s64) into %ir..fca.4.0.gep)
Encountered load fold barrier on MOV64mr %38:gr64, 1, $noreg, 0, $noreg, killed %39:gr64 :: (store (s64) into stack)
Encountered load fold barrier on MOV32mi %38:gr64, 1, $noreg, 8, $noreg, 1 :: (store (s32) into stack + 8)
NAPhysCopy: invalidating because of CALL64r killed %40:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
Encountered load fold barrier on CALL64r killed %40:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
Encountered load fold barrier on CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Attempting to optimize compare: TEST64rr %0:gr64, %0:gr64, implicit-def $eflags
Encountered load fold barrier on CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
NAPhysCopy: missed opportunity $rsp = COPY %11:gr64
Encountered load fold barrier on MOV64mr %49:gr64, 1, $noreg, -48, $noreg, %10:gr64 :: (store (s64) into %ir.22)
Encountered load fold barrier on MOV64mr %49:gr64, 1, $noreg, -40, $noreg, %10:gr64 :: (store (s64) into %ir..repack9)
Encountered load fold barrier on MOV64mi32 %49:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack11)
Encountered load fold barrier on MOV64mr %49:gr64, 1, $noreg, -24, $noreg, %0:gr64 :: (store (s64) into %ir..repack13)
Encountered load fold barrier on MOV64mi32 %49:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack15)
Encountered load fold barrier on CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Attempting to optimize compare: TEST64rr %1:gr64, %1:gr64, implicit-def $eflags
Encountered load fold barrier on CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
NAPhysCopy: missed opportunity $rsp = COPY %14:gr64
Encountered load fold barrier on MOV64mr %53:gr64, 1, $noreg, -48, $noreg, %13:gr64 :: (store (s64) into %ir.25)
Encountered load fold barrier on MOV64mr %53:gr64, 1, $noreg, -40, $noreg, %13:gr64 :: (store (s64) into %ir..repack18)
Encountered load fold barrier on MOV64mi32 %53:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack20)
Encountered load fold barrier on MOV64mr %53:gr64, 1, $noreg, -24, $noreg, %1:gr64 :: (store (s64) into %ir..repack22)
Encountered load fold barrier on MOV64mi32 %53:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack24)
Encountered load fold barrier on CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Attempting to optimize compare: TEST64rr %2:gr64, %2:gr64, implicit-def $eflags
Encountered load fold barrier on CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
NAPhysCopy: missed opportunity $rsp = COPY %17:gr64
Encountered load fold barrier on MOV64mr %57:gr64, 1, $noreg, -48, $noreg, %16:gr64 :: (store (s64) into %ir.28)
Encountered load fold barrier on MOV64mr %57:gr64, 1, $noreg, -40, $noreg, %16:gr64 :: (store (s64) into %ir..repack27)
Encountered load fold barrier on MOV64mi32 %57:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack29)
Encountered load fold barrier on MOV64mr %57:gr64, 1, $noreg, -24, $noreg, %2:gr64 :: (store (s64) into %ir..repack31)
Encountered load fold barrier on MOV64mi32 %57:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack33)
Encountered load fold barrier on CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Attempting to optimize compare: TEST64rr %3:gr64, %3:gr64, implicit-def $eflags
Encountered load fold barrier on CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
NAPhysCopy: missed opportunity $rsp = COPY %20:gr64
Encountered load fold barrier on MOV64mr %61:gr64, 1, $noreg, -48, $noreg, %19:gr64 :: (store (s64) into %ir.31)
Encountered load fold barrier on MOV64mr %61:gr64, 1, $noreg, -40, $noreg, %19:gr64 :: (store (s64) into %ir..repack36)
Encountered load fold barrier on MOV64mi32 %61:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack38)
Encountered load fold barrier on MOV64mr %61:gr64, 1, $noreg, -24, $noreg, %3:gr64 :: (store (s64) into %ir..repack40)
Encountered load fold barrier on MOV64mi32 %61:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack42)
Encountered load fold barrier on CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Attempting to optimize compare: TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
Encountered load fold barrier on CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
NAPhysCopy: missed opportunity $rsp = COPY %23:gr64
Encountered load fold barrier on MOV64mr %65:gr64, 1, $noreg, -48, $noreg, %22:gr64 :: (store (s64) into %ir.34)
Encountered load fold barrier on MOV64mr %65:gr64, 1, $noreg, -40, $noreg, %22:gr64 :: (store (s64) into %ir..repack45)
Encountered load fold barrier on MOV64mi32 %65:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack47)
Encountered load fold barrier on MOV64mr %65:gr64, 1, $noreg, -24, $noreg, %4:gr64 :: (store (s64) into %ir..repack49)
Encountered load fold barrier on MOV64mi32 %65:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack51)
Encountered load fold barrier on CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Attempting to optimize compare: TEST64rr %5:gr64, %5:gr64, implicit-def $eflags
Encountered load fold barrier on CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
NAPhysCopy: missed opportunity $rsp = COPY %26:gr64
Encountered load fold barrier on MOV64mr %69:gr64, 1, $noreg, -48, $noreg, %25:gr64 :: (store (s64) into %ir.37)
Encountered load fold barrier on MOV64mr %69:gr64, 1, $noreg, -40, $noreg, %25:gr64 :: (store (s64) into %ir..repack54)
Encountered load fold barrier on MOV64mi32 %69:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack56)
Encountered load fold barrier on MOV64mr %69:gr64, 1, $noreg, -24, $noreg, %5:gr64 :: (store (s64) into %ir..repack58)
Encountered load fold barrier on MOV64mi32 %69:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack60)
Encountered load fold barrier on CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Attempting to optimize compare: TEST64rr %6:gr64, %6:gr64, implicit-def $eflags
Encountered load fold barrier on CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
NAPhysCopy: missed opportunity $rsp = COPY %29:gr64
Encountered load fold barrier on MOV64mr %73:gr64, 1, $noreg, -48, $noreg, %28:gr64 :: (store (s64) into %ir.40)
Encountered load fold barrier on MOV64mr %73:gr64, 1, $noreg, -40, $noreg, %28:gr64 :: (store (s64) into %ir..repack63)
Encountered load fold barrier on MOV64mi32 %73:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack65)
Encountered load fold barrier on MOV64mr %73:gr64, 1, $noreg, -24, $noreg, %6:gr64 :: (store (s64) into %ir..repack67)
Encountered load fold barrier on MOV64mi32 %73:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack69)
Encountered load fold barrier on CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Attempting to optimize compare: TEST64rr %7:gr64, %7:gr64, implicit-def $eflags
Encountered load fold barrier on CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
NAPhysCopy: missed opportunity $rsp = COPY %32:gr64
Encountered load fold barrier on MOV64mr %77:gr64, 1, $noreg, -48, $noreg, %31:gr64 :: (store (s64) into %ir.43)
Encountered load fold barrier on MOV64mr %77:gr64, 1, $noreg, -40, $noreg, %31:gr64 :: (store (s64) into %ir..repack72)
Encountered load fold barrier on MOV64mi32 %77:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack74)
Encountered load fold barrier on MOV64mr %77:gr64, 1, $noreg, -24, $noreg, %7:gr64 :: (store (s64) into %ir..repack76)
Encountered load fold barrier on MOV64mi32 %77:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack78)
Encountered load fold barrier on CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Attempting to optimize compare: TEST64rr %8:gr64, %8:gr64, implicit-def $eflags
Encountered load fold barrier on CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
NAPhysCopy: missed opportunity $rsp = COPY %82:gr64
Encountered load fold barrier on MOV64mr %81:gr64, 1, $noreg, -48, $noreg, %34:gr64 :: (store (s64) into %ir.46)
Encountered load fold barrier on MOV64mr %81:gr64, 1, $noreg, -40, $noreg, %34:gr64 :: (store (s64) into %ir..repack81)
Encountered load fold barrier on MOV64mi32 %81:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack83)
Encountered load fold barrier on MOV64mr %81:gr64, 1, $noreg, -24, $noreg, %8:gr64 :: (store (s64) into %ir..repack85)
Encountered load fold barrier on MOV64mi32 %81:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack87)
Encountered load fold barrier on MOV64mr %83:gr64, 1, $noreg, 128, $noreg, %82:gr64 :: (store (s64) into stack + 128)
Encountered load fold barrier on MOV64mr %83:gr64, 1, $noreg, 112, $noreg, %32:gr64 :: (store (s64) into stack + 112)
Encountered load fold barrier on MOV64mr %83:gr64, 1, $noreg, 96, $noreg, %29:gr64 :: (store (s64) into stack + 96)
Encountered load fold barrier on MOV64mr %83:gr64, 1, $noreg, 80, $noreg, %26:gr64 :: (store (s64) into stack + 80)
Encountered load fold barrier on MOV64mr %83:gr64, 1, $noreg, 64, $noreg, %23:gr64 :: (store (s64) into stack + 64)
Encountered load fold barrier on MOV64mr %83:gr64, 1, $noreg, 48, $noreg, %20:gr64 :: (store (s64) into stack + 48)
Encountered load fold barrier on MOV64mr %83:gr64, 1, $noreg, 32, $noreg, %17:gr64 :: (store (s64) into stack + 32)
Encountered load fold barrier on MOV64mr %83:gr64, 1, $noreg, 16, $noreg, %14:gr64 :: (store (s64) into stack + 16)
Encountered load fold barrier on MOV64mr %83:gr64, 1, $noreg, 0, $noreg, %11:gr64 :: (store (s64) into stack)
Encountered load fold barrier on MOV32mi %83:gr64, 1, $noreg, 136, $noreg, 1 :: (store (s32) into stack + 136)
Encountered load fold barrier on MOV64mi32 %83:gr64, 1, $noreg, 120, $noreg, 1 :: (store (s64) into stack + 120)
Encountered load fold barrier on MOV64mi32 %83:gr64, 1, $noreg, 104, $noreg, 1 :: (store (s64) into stack + 104)
Encountered load fold barrier on MOV64mi32 %83:gr64, 1, $noreg, 88, $noreg, 1 :: (store (s64) into stack + 88)
Encountered load fold barrier on MOV64mi32 %83:gr64, 1, $noreg, 72, $noreg, 1 :: (store (s64) into stack + 72)
Encountered load fold barrier on MOV64mi32 %83:gr64, 1, $noreg, 56, $noreg, 1 :: (store (s64) into stack + 56)
Encountered load fold barrier on MOV64mi32 %83:gr64, 1, $noreg, 40, $noreg, 1 :: (store (s64) into stack + 40)
Encountered load fold barrier on MOV64mi32 %83:gr64, 1, $noreg, 24, $noreg, 1 :: (store (s64) into stack + 24)
Encountered load fold barrier on MOV64mi32 %83:gr64, 1, $noreg, 8, $noreg, 1 :: (store (s64) into stack + 8)
NAPhysCopy: invalidating because of CALL64r killed %84:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
Encountered load fold barrier on CALL64r killed %84:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
Encountered load fold barrier on CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
Encountered load fold barrier on CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
Encountered load fold barrier on CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
Encountered load fold barrier on CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
Encountered load fold barrier on CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
Encountered load fold barrier on CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
Encountered load fold barrier on CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
Encountered load fold barrier on CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
Encountered load fold barrier on CALL64r killed %92:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
**** Analysing main
Start X86AvoidStoreForwardBlocks
End X86AvoidStoreForwardBlocks
********** X86 speculative load hardening : main **********
********** X86 EFLAGS copy lowering : main **********
Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: main
********** REWRITING TWO-ADDR INSTRS **********
********** Function: main
	%9:gr64 = SHL64ri %0:gr64(tied-def 0), 3, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %9:gr64 = SHL64ri %0:gr64_nosp(tied-def 0), 3, implicit-def dead $eflags
2addr:         TO 3-ADDR: %9:gr64 = LEA64r $noreg, 8, %0:gr64_nosp, 0, $noreg
	%11:gr64 = ADD64ri8 %49:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %11:gr64 = ADD64ri8 %49:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr:         TO 3-ADDR: %11:gr64 = LEA64r %49:gr64, 1, $noreg, -48, $noreg
	%12:gr64 = SHL64ri %1:gr64(tied-def 0), 3, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %12:gr64 = SHL64ri %1:gr64_nosp(tied-def 0), 3, implicit-def dead $eflags
2addr:         TO 3-ADDR: %12:gr64 = LEA64r $noreg, 8, %1:gr64_nosp, 0, $noreg
	%14:gr64 = ADD64ri8 %53:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %14:gr64 = ADD64ri8 %53:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr:         TO 3-ADDR: %14:gr64 = LEA64r %53:gr64, 1, $noreg, -48, $noreg
	%15:gr64 = SHL64ri %2:gr64(tied-def 0), 3, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %15:gr64 = SHL64ri %2:gr64_nosp(tied-def 0), 3, implicit-def dead $eflags
2addr:         TO 3-ADDR: %15:gr64 = LEA64r $noreg, 8, %2:gr64_nosp, 0, $noreg
	%17:gr64 = ADD64ri8 %57:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %17:gr64 = ADD64ri8 %57:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr:         TO 3-ADDR: %17:gr64 = LEA64r %57:gr64, 1, $noreg, -48, $noreg
	%18:gr64 = SHL64ri %3:gr64(tied-def 0), 3, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %18:gr64 = SHL64ri %3:gr64_nosp(tied-def 0), 3, implicit-def dead $eflags
2addr:         TO 3-ADDR: %18:gr64 = LEA64r $noreg, 8, %3:gr64_nosp, 0, $noreg
	%20:gr64 = ADD64ri8 %61:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %20:gr64 = ADD64ri8 %61:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr:         TO 3-ADDR: %20:gr64 = LEA64r %61:gr64, 1, $noreg, -48, $noreg
	%21:gr64 = SHL64ri %4:gr64(tied-def 0), 3, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %21:gr64 = SHL64ri %4:gr64_nosp(tied-def 0), 3, implicit-def dead $eflags
2addr:         TO 3-ADDR: %21:gr64 = LEA64r $noreg, 8, %4:gr64_nosp, 0, $noreg
	%23:gr64 = ADD64ri8 %65:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %23:gr64 = ADD64ri8 %65:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr:         TO 3-ADDR: %23:gr64 = LEA64r %65:gr64, 1, $noreg, -48, $noreg
	%24:gr64 = SHL64ri %5:gr64(tied-def 0), 3, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %24:gr64 = SHL64ri %5:gr64_nosp(tied-def 0), 3, implicit-def dead $eflags
2addr:         TO 3-ADDR: %24:gr64 = LEA64r $noreg, 8, %5:gr64_nosp, 0, $noreg
	%26:gr64 = ADD64ri8 %69:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %26:gr64 = ADD64ri8 %69:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr:         TO 3-ADDR: %26:gr64 = LEA64r %69:gr64, 1, $noreg, -48, $noreg
	%27:gr64 = SHL64ri %6:gr64(tied-def 0), 3, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %27:gr64 = SHL64ri %6:gr64_nosp(tied-def 0), 3, implicit-def dead $eflags
2addr:         TO 3-ADDR: %27:gr64 = LEA64r $noreg, 8, %6:gr64_nosp, 0, $noreg
	%29:gr64 = ADD64ri8 %73:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %29:gr64 = ADD64ri8 %73:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr:         TO 3-ADDR: %29:gr64 = LEA64r %73:gr64, 1, $noreg, -48, $noreg
	%30:gr64 = SHL64ri %7:gr64(tied-def 0), 3, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %30:gr64 = SHL64ri %7:gr64_nosp(tied-def 0), 3, implicit-def dead $eflags
2addr:         TO 3-ADDR: %30:gr64 = LEA64r $noreg, 8, %7:gr64_nosp, 0, $noreg
	%32:gr64 = ADD64ri8 %77:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %32:gr64 = ADD64ri8 %77:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr:         TO 3-ADDR: %32:gr64 = LEA64r %77:gr64, 1, $noreg, -48, $noreg
	%33:gr64 = SHL64ri %8:gr64(tied-def 0), 3, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %33:gr64 = SHL64ri %8:gr64_nosp(tied-def 0), 3, implicit-def dead $eflags
2addr:         TO 3-ADDR: %33:gr64 = LEA64r $noreg, 8, %8:gr64_nosp, 0, $noreg
	%82:gr64 = ADD64ri8 %81:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %82:gr64 = ADD64ri8 %81:gr64(tied-def 0), -48, implicit-def dead $eflags
2addr:         TO 3-ADDR: %82:gr64 = LEA64r %81:gr64, 1, $noreg, -48, $noreg
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=40, align=8, at location [SP+8]
  fi#1: variable sized, align=1, at location [SP+8]
  fi#2: variable sized, align=1, at location [SP+8]
  fi#3: variable sized, align=1, at location [SP+8]
  fi#4: variable sized, align=1, at location [SP+8]
  fi#5: variable sized, align=1, at location [SP+8]
  fi#6: variable sized, align=1, at location [SP+8]
  fi#7: variable sized, align=1, at location [SP+8]
  fi#8: variable sized, align=1, at location [SP+8]
  fi#9: variable sized, align=1, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %35:gr64 = MOV64ri @malloc
48B	  %36:gr64 = MOV32ri64 56
64B	  $rdi = COPY killed %36:gr64
80B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %37:gr64 = COPY killed $rax
128B	  MOV64mr %stack.0, 1, $noreg, 0, $noreg, %37:gr64 :: (store (s64) into %ir.2)
144B	  MOV64mr %stack.0, 1, $noreg, 8, $noreg, %37:gr64 :: (store (s64) into %ir..fca.1.gep)
160B	  MOV64mi32 %stack.0, 1, $noreg, 16, $noreg, 0 :: (store (s64) into %ir..fca.2.gep)
176B	  MOV64mi32 %stack.0, 1, $noreg, 24, $noreg, 7 :: (store (s64) into %ir..fca.3.0.gep)
192B	  MOV64mi32 %stack.0, 1, $noreg, 32, $noreg, 1 :: (store (s64) into %ir..fca.4.0.gep)
208B	  ADJCALLSTACKDOWN64 16, 0, 16, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
224B	  %39:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
240B	  %40:gr64 = MOV64ri @read_input_sizes_2D_f64
256B	  %41:gr32 = MOV32r0 implicit-def dead $eflags
272B	  %42:gr64 = SUBREG_TO_REG 0, killed %41:gr32, %subreg.sub_32bit
288B	  %43:gr32 = MOV32ri 1
304B	  %44:gr64 = MOV32ri64 3
320B	  %45:gr64 = MOV64ri32 -1
336B	  %46:gr64 = MOV32ri64 1
352B	  $edi = COPY killed %43:gr32
368B	  $rsi = COPY %42:gr64
384B	  $rdx = COPY killed %44:gr64
400B	  $rcx = COPY killed %42:gr64
416B	  $r8 = COPY killed %45:gr64
432B	  $r9 = COPY killed %46:gr64
448B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 8)
464B	  PUSH64r killed %39:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
480B	  CALL64r killed %40:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit killed $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $r9, implicit-def $rsp, implicit-def $ssp
496B	  ADJCALLSTACKUP64 16, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
512B	  %0:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
528B	  %1:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
544B	  %2:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
560B	  %3:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
576B	  %4:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
592B	  %5:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
608B	  %6:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
624B	  %7:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
640B	  %8:gr64_nosp = MOV64rm killed %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
656B	  %9:gr64 = LEA64r $noreg, 8, %0:gr64_nosp, 0, $noreg
672B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
688B	  $rdi = COPY %9:gr64
704B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
720B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
736B	  %47:gr64 = COPY killed $rax
752B	  %10:gr64 = COPY killed %47:gr64
768B	  TEST64rr %0:gr64_nosp, %0:gr64_nosp, implicit-def $eflags
784B	  %100:gr64 = MOV64ri &__bzero
800B	  JCC_1 %bb.2, 14, implicit killed $eflags
816B	  JMP_1 %bb.1

832B	bb.1..lr.ph.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
864B	  $rdi = COPY %10:gr64
880B	  $rsi = COPY killed %9:gr64
896B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
912B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

928B	bb.2.._crit_edge:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.3(0x50000000), %bb.4(0x30000000); %bb.3(62.50%), %bb.4(37.50%)

944B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
960B	  %49:gr64 = COPY $rsp
976B	  %11:gr64 = LEA64r %49:gr64, 1, $noreg, -48, $noreg
992B	  $rsp = COPY %11:gr64
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1024B	  MOV64mr %49:gr64, 1, $noreg, -48, $noreg, %10:gr64 :: (store (s64) into %ir.22)
1040B	  MOV64mr %49:gr64, 1, $noreg, -40, $noreg, killed %10:gr64 :: (store (s64) into %ir..repack9)
1056B	  MOV64mi32 %49:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack11)
1072B	  MOV64mr %49:gr64, 1, $noreg, -24, $noreg, killed %0:gr64_nosp :: (store (s64) into %ir..repack13)
1088B	  MOV64mi32 killed %49:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack15)
1104B	  %12:gr64 = LEA64r $noreg, 8, %1:gr64_nosp, 0, $noreg
1120B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1136B	  $rdi = COPY %12:gr64
1152B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1184B	  %51:gr64 = COPY killed $rax
1200B	  %13:gr64 = COPY killed %51:gr64
1216B	  TEST64rr %1:gr64_nosp, %1:gr64_nosp, implicit-def $eflags
1232B	  JCC_1 %bb.4, 14, implicit killed $eflags
1248B	  JMP_1 %bb.3

1264B	bb.3..lr.ph90.preheader:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1296B	  $rdi = COPY %13:gr64
1312B	  $rsi = COPY killed %12:gr64
1328B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
1344B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

1360B	bb.4.._crit_edge91:
	; predecessors: %bb.2, %bb.3
	  successors: %bb.5(0x50000000), %bb.6(0x30000000); %bb.5(62.50%), %bb.6(37.50%)

1376B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1392B	  %53:gr64 = COPY $rsp
1408B	  %14:gr64 = LEA64r %53:gr64, 1, $noreg, -48, $noreg
1424B	  $rsp = COPY %14:gr64
1440B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1456B	  MOV64mr %53:gr64, 1, $noreg, -48, $noreg, %13:gr64 :: (store (s64) into %ir.25)
1472B	  MOV64mr %53:gr64, 1, $noreg, -40, $noreg, killed %13:gr64 :: (store (s64) into %ir..repack18)
1488B	  MOV64mi32 %53:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack20)
1504B	  MOV64mr %53:gr64, 1, $noreg, -24, $noreg, killed %1:gr64_nosp :: (store (s64) into %ir..repack22)
1520B	  MOV64mi32 killed %53:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack24)
1536B	  %15:gr64 = LEA64r $noreg, 8, %2:gr64_nosp, 0, $noreg
1552B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1568B	  $rdi = COPY %15:gr64
1584B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1600B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1616B	  %55:gr64 = COPY killed $rax
1632B	  %16:gr64 = COPY killed %55:gr64
1648B	  TEST64rr %2:gr64_nosp, %2:gr64_nosp, implicit-def $eflags
1664B	  JCC_1 %bb.6, 14, implicit killed $eflags
1680B	  JMP_1 %bb.5

1696B	bb.5..lr.ph93.preheader:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

1712B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1728B	  $rdi = COPY %16:gr64
1744B	  $rsi = COPY killed %15:gr64
1760B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
1776B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

1792B	bb.6.._crit_edge94:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.7(0x50000000), %bb.8(0x30000000); %bb.7(62.50%), %bb.8(37.50%)

1808B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1824B	  %57:gr64 = COPY $rsp
1840B	  %17:gr64 = LEA64r %57:gr64, 1, $noreg, -48, $noreg
1856B	  $rsp = COPY %17:gr64
1872B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1888B	  MOV64mr %57:gr64, 1, $noreg, -48, $noreg, %16:gr64 :: (store (s64) into %ir.28)
1904B	  MOV64mr %57:gr64, 1, $noreg, -40, $noreg, killed %16:gr64 :: (store (s64) into %ir..repack27)
1920B	  MOV64mi32 %57:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack29)
1936B	  MOV64mr %57:gr64, 1, $noreg, -24, $noreg, killed %2:gr64_nosp :: (store (s64) into %ir..repack31)
1952B	  MOV64mi32 killed %57:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack33)
1968B	  %18:gr64 = LEA64r $noreg, 8, %3:gr64_nosp, 0, $noreg
1984B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2000B	  $rdi = COPY %18:gr64
2016B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2048B	  %59:gr64 = COPY killed $rax
2064B	  %19:gr64 = COPY killed %59:gr64
2080B	  TEST64rr %3:gr64_nosp, %3:gr64_nosp, implicit-def $eflags
2096B	  JCC_1 %bb.8, 14, implicit killed $eflags
2112B	  JMP_1 %bb.7

2128B	bb.7..lr.ph96.preheader:
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)

2144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2160B	  $rdi = COPY %19:gr64
2176B	  $rsi = COPY killed %18:gr64
2192B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
2208B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2224B	bb.8.._crit_edge97:
	; predecessors: %bb.6, %bb.7
	  successors: %bb.9(0x50000000), %bb.10(0x30000000); %bb.9(62.50%), %bb.10(37.50%)

2240B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2256B	  %61:gr64 = COPY $rsp
2272B	  %20:gr64 = LEA64r %61:gr64, 1, $noreg, -48, $noreg
2288B	  $rsp = COPY %20:gr64
2304B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2320B	  MOV64mr %61:gr64, 1, $noreg, -48, $noreg, %19:gr64 :: (store (s64) into %ir.31)
2336B	  MOV64mr %61:gr64, 1, $noreg, -40, $noreg, killed %19:gr64 :: (store (s64) into %ir..repack36)
2352B	  MOV64mi32 %61:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack38)
2368B	  MOV64mr %61:gr64, 1, $noreg, -24, $noreg, killed %3:gr64_nosp :: (store (s64) into %ir..repack40)
2384B	  MOV64mi32 killed %61:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack42)
2400B	  %21:gr64 = LEA64r $noreg, 8, %4:gr64_nosp, 0, $noreg
2416B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2432B	  $rdi = COPY %21:gr64
2448B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2464B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2480B	  %63:gr64 = COPY killed $rax
2496B	  %22:gr64 = COPY killed %63:gr64
2512B	  TEST64rr %4:gr64_nosp, %4:gr64_nosp, implicit-def $eflags
2528B	  JCC_1 %bb.10, 14, implicit killed $eflags
2544B	  JMP_1 %bb.9

2560B	bb.9..lr.ph99.preheader:
	; predecessors: %bb.8
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

2576B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2592B	  $rdi = COPY %22:gr64
2608B	  $rsi = COPY killed %21:gr64
2624B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
2640B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2656B	bb.10.._crit_edge100:
	; predecessors: %bb.8, %bb.9
	  successors: %bb.11(0x50000000), %bb.12(0x30000000); %bb.11(62.50%), %bb.12(37.50%)

2672B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2688B	  %65:gr64 = COPY $rsp
2704B	  %23:gr64 = LEA64r %65:gr64, 1, $noreg, -48, $noreg
2720B	  $rsp = COPY %23:gr64
2736B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2752B	  MOV64mr %65:gr64, 1, $noreg, -48, $noreg, %22:gr64 :: (store (s64) into %ir.34)
2768B	  MOV64mr %65:gr64, 1, $noreg, -40, $noreg, killed %22:gr64 :: (store (s64) into %ir..repack45)
2784B	  MOV64mi32 %65:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack47)
2800B	  MOV64mr %65:gr64, 1, $noreg, -24, $noreg, killed %4:gr64_nosp :: (store (s64) into %ir..repack49)
2816B	  MOV64mi32 killed %65:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack51)
2832B	  %24:gr64 = LEA64r $noreg, 8, %5:gr64_nosp, 0, $noreg
2848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2864B	  $rdi = COPY %24:gr64
2880B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2912B	  %67:gr64 = COPY killed $rax
2928B	  %25:gr64 = COPY killed %67:gr64
2944B	  TEST64rr %5:gr64_nosp, %5:gr64_nosp, implicit-def $eflags
2960B	  JCC_1 %bb.12, 14, implicit killed $eflags
2976B	  JMP_1 %bb.11

2992B	bb.11..lr.ph102.preheader:
	; predecessors: %bb.10
	  successors: %bb.12(0x80000000); %bb.12(100.00%)

3008B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3024B	  $rdi = COPY %25:gr64
3040B	  $rsi = COPY killed %24:gr64
3056B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
3072B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3088B	bb.12.._crit_edge103:
	; predecessors: %bb.10, %bb.11
	  successors: %bb.13(0x50000000), %bb.14(0x30000000); %bb.13(62.50%), %bb.14(37.50%)

3104B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3120B	  %69:gr64 = COPY $rsp
3136B	  %26:gr64 = LEA64r %69:gr64, 1, $noreg, -48, $noreg
3152B	  $rsp = COPY %26:gr64
3168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3184B	  MOV64mr %69:gr64, 1, $noreg, -48, $noreg, %25:gr64 :: (store (s64) into %ir.37)
3200B	  MOV64mr %69:gr64, 1, $noreg, -40, $noreg, killed %25:gr64 :: (store (s64) into %ir..repack54)
3216B	  MOV64mi32 %69:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack56)
3232B	  MOV64mr %69:gr64, 1, $noreg, -24, $noreg, killed %5:gr64_nosp :: (store (s64) into %ir..repack58)
3248B	  MOV64mi32 killed %69:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack60)
3264B	  %27:gr64 = LEA64r $noreg, 8, %6:gr64_nosp, 0, $noreg
3280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3296B	  $rdi = COPY %27:gr64
3312B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3328B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3344B	  %71:gr64 = COPY killed $rax
3360B	  %28:gr64 = COPY killed %71:gr64
3376B	  TEST64rr %6:gr64_nosp, %6:gr64_nosp, implicit-def $eflags
3392B	  JCC_1 %bb.14, 14, implicit killed $eflags
3408B	  JMP_1 %bb.13

3424B	bb.13..lr.ph105.preheader:
	; predecessors: %bb.12
	  successors: %bb.14(0x80000000); %bb.14(100.00%)

3440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3456B	  $rdi = COPY %28:gr64
3472B	  $rsi = COPY killed %27:gr64
3488B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
3504B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3520B	bb.14.._crit_edge106:
	; predecessors: %bb.12, %bb.13
	  successors: %bb.15(0x50000000), %bb.16(0x30000000); %bb.15(62.50%), %bb.16(37.50%)

3536B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3552B	  %73:gr64 = COPY $rsp
3568B	  %29:gr64 = LEA64r %73:gr64, 1, $noreg, -48, $noreg
3584B	  $rsp = COPY %29:gr64
3600B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3616B	  MOV64mr %73:gr64, 1, $noreg, -48, $noreg, %28:gr64 :: (store (s64) into %ir.40)
3632B	  MOV64mr %73:gr64, 1, $noreg, -40, $noreg, killed %28:gr64 :: (store (s64) into %ir..repack63)
3648B	  MOV64mi32 %73:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack65)
3664B	  MOV64mr %73:gr64, 1, $noreg, -24, $noreg, killed %6:gr64_nosp :: (store (s64) into %ir..repack67)
3680B	  MOV64mi32 killed %73:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack69)
3696B	  %30:gr64 = LEA64r $noreg, 8, %7:gr64_nosp, 0, $noreg
3712B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3728B	  $rdi = COPY %30:gr64
3744B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3760B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3776B	  %75:gr64 = COPY killed $rax
3792B	  %31:gr64 = COPY killed %75:gr64
3808B	  TEST64rr %7:gr64_nosp, %7:gr64_nosp, implicit-def $eflags
3824B	  JCC_1 %bb.16, 14, implicit killed $eflags
3840B	  JMP_1 %bb.15

3856B	bb.15..lr.ph108.preheader:
	; predecessors: %bb.14
	  successors: %bb.16(0x80000000); %bb.16(100.00%)

3872B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3888B	  $rdi = COPY %31:gr64
3904B	  $rsi = COPY killed %30:gr64
3920B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
3936B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3952B	bb.16.._crit_edge109:
	; predecessors: %bb.14, %bb.15
	  successors: %bb.17(0x50000000), %bb.18(0x30000000); %bb.17(62.50%), %bb.18(37.50%)

3968B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3984B	  %77:gr64 = COPY $rsp
4000B	  %32:gr64 = LEA64r %77:gr64, 1, $noreg, -48, $noreg
4016B	  $rsp = COPY %32:gr64
4032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4048B	  MOV64mr %77:gr64, 1, $noreg, -48, $noreg, %31:gr64 :: (store (s64) into %ir.43)
4064B	  MOV64mr %77:gr64, 1, $noreg, -40, $noreg, killed %31:gr64 :: (store (s64) into %ir..repack72)
4080B	  MOV64mi32 %77:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack74)
4096B	  MOV64mr %77:gr64, 1, $noreg, -24, $noreg, killed %7:gr64_nosp :: (store (s64) into %ir..repack76)
4112B	  MOV64mi32 killed %77:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack78)
4128B	  %33:gr64 = LEA64r $noreg, 8, %8:gr64_nosp, 0, $noreg
4144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4160B	  $rdi = COPY %33:gr64
4176B	  CALL64r killed %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
4192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4208B	  %79:gr64 = COPY killed $rax
4224B	  %34:gr64 = COPY killed %79:gr64
4240B	  TEST64rr %8:gr64_nosp, %8:gr64_nosp, implicit-def $eflags
4256B	  JCC_1 %bb.18, 14, implicit killed $eflags
4272B	  JMP_1 %bb.17

4288B	bb.17..lr.ph111.preheader:
	; predecessors: %bb.16
	  successors: %bb.18(0x80000000); %bb.18(100.00%)

4304B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4320B	  $rdi = COPY %34:gr64
4336B	  $rsi = COPY killed %33:gr64
4352B	  CALL64r killed %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
4368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

4384B	bb.18.._crit_edge112:
	; predecessors: %bb.16, %bb.17

4400B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4416B	  %81:gr64 = COPY $rsp
4432B	  %82:gr64 = LEA64r %81:gr64, 1, $noreg, -48, $noreg
4448B	  $rsp = COPY %82:gr64
4464B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4480B	  MOV64mr %81:gr64, 1, $noreg, -48, $noreg, %34:gr64 :: (store (s64) into %ir.46)
4496B	  MOV64mr %81:gr64, 1, $noreg, -40, $noreg, killed %34:gr64 :: (store (s64) into %ir..repack81)
4512B	  MOV64mi32 %81:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack83)
4528B	  MOV64mr %81:gr64, 1, $noreg, -24, $noreg, killed %8:gr64_nosp :: (store (s64) into %ir..repack85)
4544B	  MOV64mi32 killed %81:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack87)
4560B	  ADJCALLSTACKDOWN64 144, 0, 144, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4576B	  %84:gr64 = MOV64ri @read_input_2D_f64
4592B	  %85:gr32 = MOV32r0 implicit-def dead $eflags
4608B	  %86:gr64 = SUBREG_TO_REG 0, killed %85:gr32, %subreg.sub_32bit
4624B	  %87:gr32 = MOV32ri 1
4640B	  %88:gr64 = MOV32ri64 3
4656B	  %89:gr64 = MOV64ri32 -1
4672B	  %90:gr64 = MOV32ri64 1
4688B	  $edi = COPY killed %87:gr32
4704B	  $rsi = COPY %86:gr64
4720B	  $rdx = COPY killed %88:gr64
4736B	  $rcx = COPY killed %86:gr64
4752B	  $r8 = COPY killed %89:gr64
4768B	  $r9 = COPY %90:gr64
4784B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 136)
4800B	  PUSH64r %82:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 128)
4816B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 120)
4832B	  PUSH64r %32:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 112)
4848B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 104)
4864B	  PUSH64r %29:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 96)
4880B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 88)
4896B	  PUSH64r %26:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 80)
4912B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 72)
4928B	  PUSH64r %23:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 64)
4944B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 56)
4960B	  PUSH64r %20:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 48)
4976B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 40)
4992B	  PUSH64r %17:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 32)
5008B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 24)
5024B	  PUSH64r %14:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 16)
5040B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 8)
5056B	  PUSH64r %11:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
5072B	  CALL64r killed %84:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit killed $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $r9, implicit-def $rsp, implicit-def $ssp
5088B	  ADJCALLSTACKUP64 144, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5104B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5120B	  %91:gr64 = MOV64ri @comet_print_memref_i64
5136B	  $rdi = COPY %90:gr64
5152B	  $rsi = COPY killed %11:gr64
5168B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5184B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5200B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5216B	  $rdi = COPY %90:gr64
5232B	  $rsi = COPY killed %14:gr64
5248B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5264B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5296B	  $rdi = COPY %90:gr64
5312B	  $rsi = COPY killed %17:gr64
5328B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5344B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5360B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5376B	  $rdi = COPY %90:gr64
5392B	  $rsi = COPY killed %20:gr64
5408B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5424B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5456B	  $rdi = COPY %90:gr64
5472B	  $rsi = COPY killed %23:gr64
5488B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5504B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5520B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5536B	  $rdi = COPY %90:gr64
5552B	  $rsi = COPY killed %26:gr64
5568B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5584B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5600B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5616B	  $rdi = COPY %90:gr64
5632B	  $rsi = COPY killed %29:gr64
5648B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5664B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5680B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5696B	  $rdi = COPY %90:gr64
5712B	  $rsi = COPY killed %32:gr64
5728B	  CALL64r killed %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5744B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5760B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5776B	  %92:gr64 = MOV64ri @comet_print_memref_f64
5792B	  $rdi = COPY killed %90:gr64
5808B	  $rsi = COPY killed %82:gr64
5824B	  CALL64r killed %92:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5840B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5856B	  RET 0

# End machine code for function main.

Computing live-in reg-units in ABI blocks.
Created 0 new intervals.
********** INTERVALS **********
%0 [512r,1072r:0) 0@512r  weight:0.000000e+00
%1 [528r,1504r:0) 0@528r  weight:0.000000e+00
%2 [544r,1936r:0) 0@544r  weight:0.000000e+00
%3 [560r,2368r:0) 0@560r  weight:0.000000e+00
%4 [576r,2800r:0) 0@576r  weight:0.000000e+00
%5 [592r,3232r:0) 0@592r  weight:0.000000e+00
%6 [608r,3664r:0) 0@608r  weight:0.000000e+00
%7 [624r,4096r:0) 0@624r  weight:0.000000e+00
%8 [640r,4528r:0) 0@640r  weight:0.000000e+00
%9 [656r,880r:0) 0@656r  weight:0.000000e+00
%10 [752r,1040r:0) 0@752r  weight:0.000000e+00
%11 [976r,5152r:0) 0@976r  weight:0.000000e+00
%12 [1104r,1312r:0) 0@1104r  weight:0.000000e+00
%13 [1200r,1472r:0) 0@1200r  weight:0.000000e+00
%14 [1408r,5232r:0) 0@1408r  weight:0.000000e+00
%15 [1536r,1744r:0) 0@1536r  weight:0.000000e+00
%16 [1632r,1904r:0) 0@1632r  weight:0.000000e+00
%17 [1840r,5312r:0) 0@1840r  weight:0.000000e+00
%18 [1968r,2176r:0) 0@1968r  weight:0.000000e+00
%19 [2064r,2336r:0) 0@2064r  weight:0.000000e+00
%20 [2272r,5392r:0) 0@2272r  weight:0.000000e+00
%21 [2400r,2608r:0) 0@2400r  weight:0.000000e+00
%22 [2496r,2768r:0) 0@2496r  weight:0.000000e+00
%23 [2704r,5472r:0) 0@2704r  weight:0.000000e+00
%24 [2832r,3040r:0) 0@2832r  weight:0.000000e+00
%25 [2928r,3200r:0) 0@2928r  weight:0.000000e+00
%26 [3136r,5552r:0) 0@3136r  weight:0.000000e+00
%27 [3264r,3472r:0) 0@3264r  weight:0.000000e+00
%28 [3360r,3632r:0) 0@3360r  weight:0.000000e+00
%29 [3568r,5632r:0) 0@3568r  weight:0.000000e+00
%30 [3696r,3904r:0) 0@3696r  weight:0.000000e+00
%31 [3792r,4064r:0) 0@3792r  weight:0.000000e+00
%32 [4000r,5712r:0) 0@4000r  weight:0.000000e+00
%33 [4128r,4336r:0) 0@4128r  weight:0.000000e+00
%34 [4224r,4496r:0) 0@4224r  weight:0.000000e+00
%35 [32r,4176r:0) 0@32r  weight:0.000000e+00
%36 [48r,64r:0) 0@48r  weight:0.000000e+00
%37 [112r,640r:0) 0@112r  weight:0.000000e+00
%39 [224r,464r:0) 0@224r  weight:0.000000e+00
%40 [240r,480r:0) 0@240r  weight:0.000000e+00
%41 [256r,272r:0) 0@256r  weight:0.000000e+00
%42 [272r,400r:0) 0@272r  weight:0.000000e+00
%43 [288r,352r:0) 0@288r  weight:0.000000e+00
%44 [304r,384r:0) 0@304r  weight:0.000000e+00
%45 [320r,416r:0) 0@320r  weight:0.000000e+00
%46 [336r,432r:0) 0@336r  weight:0.000000e+00
%47 [736r,752r:0) 0@736r  weight:0.000000e+00
%49 [960r,1088r:0) 0@960r  weight:0.000000e+00
%51 [1184r,1200r:0) 0@1184r  weight:0.000000e+00
%53 [1392r,1520r:0) 0@1392r  weight:0.000000e+00
%55 [1616r,1632r:0) 0@1616r  weight:0.000000e+00
%57 [1824r,1952r:0) 0@1824r  weight:0.000000e+00
%59 [2048r,2064r:0) 0@2048r  weight:0.000000e+00
%61 [2256r,2384r:0) 0@2256r  weight:0.000000e+00
%63 [2480r,2496r:0) 0@2480r  weight:0.000000e+00
%65 [2688r,2816r:0) 0@2688r  weight:0.000000e+00
%67 [2912r,2928r:0) 0@2912r  weight:0.000000e+00
%69 [3120r,3248r:0) 0@3120r  weight:0.000000e+00
%71 [3344r,3360r:0) 0@3344r  weight:0.000000e+00
%73 [3552r,3680r:0) 0@3552r  weight:0.000000e+00
%75 [3776r,3792r:0) 0@3776r  weight:0.000000e+00
%77 [3984r,4112r:0) 0@3984r  weight:0.000000e+00
%79 [4208r,4224r:0) 0@4208r  weight:0.000000e+00
%81 [4416r,4544r:0) 0@4416r  weight:0.000000e+00
%82 [4432r,5808r:0) 0@4432r  weight:0.000000e+00
%84 [4576r,5072r:0) 0@4576r  weight:0.000000e+00
%85 [4592r,4608r:0) 0@4592r  weight:0.000000e+00
%86 [4608r,4736r:0) 0@4608r  weight:0.000000e+00
%87 [4624r,4688r:0) 0@4624r  weight:0.000000e+00
%88 [4640r,4720r:0) 0@4640r  weight:0.000000e+00
%89 [4656r,4752r:0) 0@4656r  weight:0.000000e+00
%90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
%91 [5120r,5728r:0) 0@5120r  weight:0.000000e+00
%92 [5776r,5824r:0) 0@5776r  weight:0.000000e+00
%100 [784r,4352r:0) 0@784r  weight:0.000000e+00
RegMasks: 80r 480r 704r 896r 1152r 1328r 1584r 1760r 2016r 2192r 2448r 2624r 2880r 3056r 3312r 3488r 3744r 3920r 4176r 4352r 5072r 5168r 5248r 5328r 5408r 5488r 5568r 5648r 5728r 5824r
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=40, align=8, at location [SP+8]
  fi#1: variable sized, align=1, at location [SP+8]
  fi#2: variable sized, align=1, at location [SP+8]
  fi#3: variable sized, align=1, at location [SP+8]
  fi#4: variable sized, align=1, at location [SP+8]
  fi#5: variable sized, align=1, at location [SP+8]
  fi#6: variable sized, align=1, at location [SP+8]
  fi#7: variable sized, align=1, at location [SP+8]
  fi#8: variable sized, align=1, at location [SP+8]
  fi#9: variable sized, align=1, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %35:gr64 = MOV64ri @malloc
48B	  %36:gr64 = MOV32ri64 56
64B	  $rdi = COPY %36:gr64
80B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %37:gr64 = COPY killed $rax
128B	  MOV64mr %stack.0, 1, $noreg, 0, $noreg, %37:gr64 :: (store (s64) into %ir.2)
144B	  MOV64mr %stack.0, 1, $noreg, 8, $noreg, %37:gr64 :: (store (s64) into %ir..fca.1.gep)
160B	  MOV64mi32 %stack.0, 1, $noreg, 16, $noreg, 0 :: (store (s64) into %ir..fca.2.gep)
176B	  MOV64mi32 %stack.0, 1, $noreg, 24, $noreg, 7 :: (store (s64) into %ir..fca.3.0.gep)
192B	  MOV64mi32 %stack.0, 1, $noreg, 32, $noreg, 1 :: (store (s64) into %ir..fca.4.0.gep)
208B	  ADJCALLSTACKDOWN64 16, 0, 16, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
224B	  %39:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
240B	  %40:gr64 = MOV64ri @read_input_sizes_2D_f64
256B	  %41:gr32 = MOV32r0 implicit-def dead $eflags
272B	  %42:gr64 = SUBREG_TO_REG 0, %41:gr32, %subreg.sub_32bit
288B	  %43:gr32 = MOV32ri 1
304B	  %44:gr64 = MOV32ri64 3
320B	  %45:gr64 = MOV64ri32 -1
336B	  %46:gr64 = MOV32ri64 1
352B	  $edi = COPY %43:gr32
368B	  $rsi = COPY %42:gr64
384B	  $rdx = COPY %44:gr64
400B	  $rcx = COPY %42:gr64
416B	  $r8 = COPY %45:gr64
432B	  $r9 = COPY %46:gr64
448B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 8)
464B	  PUSH64r %39:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
480B	  CALL64r %40:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit killed $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $r9, implicit-def $rsp, implicit-def $ssp
496B	  ADJCALLSTACKUP64 16, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
512B	  %0:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
528B	  %1:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
544B	  %2:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
560B	  %3:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
576B	  %4:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
592B	  %5:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
608B	  %6:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
624B	  %7:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
640B	  %8:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
656B	  %9:gr64 = LEA64r $noreg, 8, %0:gr64_nosp, 0, $noreg
672B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
688B	  $rdi = COPY %9:gr64
704B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
720B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
736B	  %47:gr64 = COPY killed $rax
752B	  %10:gr64 = COPY %47:gr64
768B	  TEST64rr %0:gr64_nosp, %0:gr64_nosp, implicit-def $eflags
784B	  %100:gr64 = MOV64ri &__bzero
800B	  JCC_1 %bb.2, 14, implicit killed $eflags
816B	  JMP_1 %bb.1

832B	bb.1..lr.ph.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
864B	  $rdi = COPY %10:gr64
880B	  $rsi = COPY %9:gr64
896B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
912B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

928B	bb.2.._crit_edge:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.3(0x50000000), %bb.4(0x30000000); %bb.3(62.50%), %bb.4(37.50%)

944B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
960B	  %49:gr64 = COPY $rsp
976B	  %11:gr64 = LEA64r %49:gr64, 1, $noreg, -48, $noreg
992B	  $rsp = COPY %11:gr64
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1024B	  MOV64mr %49:gr64, 1, $noreg, -48, $noreg, %10:gr64 :: (store (s64) into %ir.22)
1040B	  MOV64mr %49:gr64, 1, $noreg, -40, $noreg, %10:gr64 :: (store (s64) into %ir..repack9)
1056B	  MOV64mi32 %49:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack11)
1072B	  MOV64mr %49:gr64, 1, $noreg, -24, $noreg, %0:gr64_nosp :: (store (s64) into %ir..repack13)
1088B	  MOV64mi32 %49:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack15)
1104B	  %12:gr64 = LEA64r $noreg, 8, %1:gr64_nosp, 0, $noreg
1120B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1136B	  $rdi = COPY %12:gr64
1152B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1184B	  %51:gr64 = COPY killed $rax
1200B	  %13:gr64 = COPY %51:gr64
1216B	  TEST64rr %1:gr64_nosp, %1:gr64_nosp, implicit-def $eflags
1232B	  JCC_1 %bb.4, 14, implicit killed $eflags
1248B	  JMP_1 %bb.3

1264B	bb.3..lr.ph90.preheader:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1296B	  $rdi = COPY %13:gr64
1312B	  $rsi = COPY %12:gr64
1328B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
1344B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

1360B	bb.4.._crit_edge91:
	; predecessors: %bb.2, %bb.3
	  successors: %bb.5(0x50000000), %bb.6(0x30000000); %bb.5(62.50%), %bb.6(37.50%)

1376B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1392B	  %53:gr64 = COPY $rsp
1408B	  %14:gr64 = LEA64r %53:gr64, 1, $noreg, -48, $noreg
1424B	  $rsp = COPY %14:gr64
1440B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1456B	  MOV64mr %53:gr64, 1, $noreg, -48, $noreg, %13:gr64 :: (store (s64) into %ir.25)
1472B	  MOV64mr %53:gr64, 1, $noreg, -40, $noreg, %13:gr64 :: (store (s64) into %ir..repack18)
1488B	  MOV64mi32 %53:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack20)
1504B	  MOV64mr %53:gr64, 1, $noreg, -24, $noreg, %1:gr64_nosp :: (store (s64) into %ir..repack22)
1520B	  MOV64mi32 %53:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack24)
1536B	  %15:gr64 = LEA64r $noreg, 8, %2:gr64_nosp, 0, $noreg
1552B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1568B	  $rdi = COPY %15:gr64
1584B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1600B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1616B	  %55:gr64 = COPY killed $rax
1632B	  %16:gr64 = COPY %55:gr64
1648B	  TEST64rr %2:gr64_nosp, %2:gr64_nosp, implicit-def $eflags
1664B	  JCC_1 %bb.6, 14, implicit killed $eflags
1680B	  JMP_1 %bb.5

1696B	bb.5..lr.ph93.preheader:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

1712B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1728B	  $rdi = COPY %16:gr64
1744B	  $rsi = COPY %15:gr64
1760B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
1776B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

1792B	bb.6.._crit_edge94:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.7(0x50000000), %bb.8(0x30000000); %bb.7(62.50%), %bb.8(37.50%)

1808B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1824B	  %57:gr64 = COPY $rsp
1840B	  %17:gr64 = LEA64r %57:gr64, 1, $noreg, -48, $noreg
1856B	  $rsp = COPY %17:gr64
1872B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1888B	  MOV64mr %57:gr64, 1, $noreg, -48, $noreg, %16:gr64 :: (store (s64) into %ir.28)
1904B	  MOV64mr %57:gr64, 1, $noreg, -40, $noreg, %16:gr64 :: (store (s64) into %ir..repack27)
1920B	  MOV64mi32 %57:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack29)
1936B	  MOV64mr %57:gr64, 1, $noreg, -24, $noreg, %2:gr64_nosp :: (store (s64) into %ir..repack31)
1952B	  MOV64mi32 %57:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack33)
1968B	  %18:gr64 = LEA64r $noreg, 8, %3:gr64_nosp, 0, $noreg
1984B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2000B	  $rdi = COPY %18:gr64
2016B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2048B	  %59:gr64 = COPY killed $rax
2064B	  %19:gr64 = COPY %59:gr64
2080B	  TEST64rr %3:gr64_nosp, %3:gr64_nosp, implicit-def $eflags
2096B	  JCC_1 %bb.8, 14, implicit killed $eflags
2112B	  JMP_1 %bb.7

2128B	bb.7..lr.ph96.preheader:
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)

2144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2160B	  $rdi = COPY %19:gr64
2176B	  $rsi = COPY %18:gr64
2192B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
2208B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2224B	bb.8.._crit_edge97:
	; predecessors: %bb.6, %bb.7
	  successors: %bb.9(0x50000000), %bb.10(0x30000000); %bb.9(62.50%), %bb.10(37.50%)

2240B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2256B	  %61:gr64 = COPY $rsp
2272B	  %20:gr64 = LEA64r %61:gr64, 1, $noreg, -48, $noreg
2288B	  $rsp = COPY %20:gr64
2304B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2320B	  MOV64mr %61:gr64, 1, $noreg, -48, $noreg, %19:gr64 :: (store (s64) into %ir.31)
2336B	  MOV64mr %61:gr64, 1, $noreg, -40, $noreg, %19:gr64 :: (store (s64) into %ir..repack36)
2352B	  MOV64mi32 %61:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack38)
2368B	  MOV64mr %61:gr64, 1, $noreg, -24, $noreg, %3:gr64_nosp :: (store (s64) into %ir..repack40)
2384B	  MOV64mi32 %61:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack42)
2400B	  %21:gr64 = LEA64r $noreg, 8, %4:gr64_nosp, 0, $noreg
2416B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2432B	  $rdi = COPY %21:gr64
2448B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2464B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2480B	  %63:gr64 = COPY killed $rax
2496B	  %22:gr64 = COPY %63:gr64
2512B	  TEST64rr %4:gr64_nosp, %4:gr64_nosp, implicit-def $eflags
2528B	  JCC_1 %bb.10, 14, implicit killed $eflags
2544B	  JMP_1 %bb.9

2560B	bb.9..lr.ph99.preheader:
	; predecessors: %bb.8
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

2576B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2592B	  $rdi = COPY %22:gr64
2608B	  $rsi = COPY %21:gr64
2624B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
2640B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2656B	bb.10.._crit_edge100:
	; predecessors: %bb.8, %bb.9
	  successors: %bb.11(0x50000000), %bb.12(0x30000000); %bb.11(62.50%), %bb.12(37.50%)

2672B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2688B	  %65:gr64 = COPY $rsp
2704B	  %23:gr64 = LEA64r %65:gr64, 1, $noreg, -48, $noreg
2720B	  $rsp = COPY %23:gr64
2736B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2752B	  MOV64mr %65:gr64, 1, $noreg, -48, $noreg, %22:gr64 :: (store (s64) into %ir.34)
2768B	  MOV64mr %65:gr64, 1, $noreg, -40, $noreg, %22:gr64 :: (store (s64) into %ir..repack45)
2784B	  MOV64mi32 %65:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack47)
2800B	  MOV64mr %65:gr64, 1, $noreg, -24, $noreg, %4:gr64_nosp :: (store (s64) into %ir..repack49)
2816B	  MOV64mi32 %65:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack51)
2832B	  %24:gr64 = LEA64r $noreg, 8, %5:gr64_nosp, 0, $noreg
2848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2864B	  $rdi = COPY %24:gr64
2880B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2912B	  %67:gr64 = COPY killed $rax
2928B	  %25:gr64 = COPY %67:gr64
2944B	  TEST64rr %5:gr64_nosp, %5:gr64_nosp, implicit-def $eflags
2960B	  JCC_1 %bb.12, 14, implicit killed $eflags
2976B	  JMP_1 %bb.11

2992B	bb.11..lr.ph102.preheader:
	; predecessors: %bb.10
	  successors: %bb.12(0x80000000); %bb.12(100.00%)

3008B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3024B	  $rdi = COPY %25:gr64
3040B	  $rsi = COPY %24:gr64
3056B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
3072B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3088B	bb.12.._crit_edge103:
	; predecessors: %bb.10, %bb.11
	  successors: %bb.13(0x50000000), %bb.14(0x30000000); %bb.13(62.50%), %bb.14(37.50%)

3104B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3120B	  %69:gr64 = COPY $rsp
3136B	  %26:gr64 = LEA64r %69:gr64, 1, $noreg, -48, $noreg
3152B	  $rsp = COPY %26:gr64
3168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3184B	  MOV64mr %69:gr64, 1, $noreg, -48, $noreg, %25:gr64 :: (store (s64) into %ir.37)
3200B	  MOV64mr %69:gr64, 1, $noreg, -40, $noreg, %25:gr64 :: (store (s64) into %ir..repack54)
3216B	  MOV64mi32 %69:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack56)
3232B	  MOV64mr %69:gr64, 1, $noreg, -24, $noreg, %5:gr64_nosp :: (store (s64) into %ir..repack58)
3248B	  MOV64mi32 %69:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack60)
3264B	  %27:gr64 = LEA64r $noreg, 8, %6:gr64_nosp, 0, $noreg
3280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3296B	  $rdi = COPY %27:gr64
3312B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3328B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3344B	  %71:gr64 = COPY killed $rax
3360B	  %28:gr64 = COPY %71:gr64
3376B	  TEST64rr %6:gr64_nosp, %6:gr64_nosp, implicit-def $eflags
3392B	  JCC_1 %bb.14, 14, implicit killed $eflags
3408B	  JMP_1 %bb.13

3424B	bb.13..lr.ph105.preheader:
	; predecessors: %bb.12
	  successors: %bb.14(0x80000000); %bb.14(100.00%)

3440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3456B	  $rdi = COPY %28:gr64
3472B	  $rsi = COPY %27:gr64
3488B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
3504B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3520B	bb.14.._crit_edge106:
	; predecessors: %bb.12, %bb.13
	  successors: %bb.15(0x50000000), %bb.16(0x30000000); %bb.15(62.50%), %bb.16(37.50%)

3536B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3552B	  %73:gr64 = COPY $rsp
3568B	  %29:gr64 = LEA64r %73:gr64, 1, $noreg, -48, $noreg
3584B	  $rsp = COPY %29:gr64
3600B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3616B	  MOV64mr %73:gr64, 1, $noreg, -48, $noreg, %28:gr64 :: (store (s64) into %ir.40)
3632B	  MOV64mr %73:gr64, 1, $noreg, -40, $noreg, %28:gr64 :: (store (s64) into %ir..repack63)
3648B	  MOV64mi32 %73:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack65)
3664B	  MOV64mr %73:gr64, 1, $noreg, -24, $noreg, %6:gr64_nosp :: (store (s64) into %ir..repack67)
3680B	  MOV64mi32 %73:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack69)
3696B	  %30:gr64 = LEA64r $noreg, 8, %7:gr64_nosp, 0, $noreg
3712B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3728B	  $rdi = COPY %30:gr64
3744B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3760B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3776B	  %75:gr64 = COPY killed $rax
3792B	  %31:gr64 = COPY %75:gr64
3808B	  TEST64rr %7:gr64_nosp, %7:gr64_nosp, implicit-def $eflags
3824B	  JCC_1 %bb.16, 14, implicit killed $eflags
3840B	  JMP_1 %bb.15

3856B	bb.15..lr.ph108.preheader:
	; predecessors: %bb.14
	  successors: %bb.16(0x80000000); %bb.16(100.00%)

3872B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3888B	  $rdi = COPY %31:gr64
3904B	  $rsi = COPY %30:gr64
3920B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
3936B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3952B	bb.16.._crit_edge109:
	; predecessors: %bb.14, %bb.15
	  successors: %bb.17(0x50000000), %bb.18(0x30000000); %bb.17(62.50%), %bb.18(37.50%)

3968B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3984B	  %77:gr64 = COPY $rsp
4000B	  %32:gr64 = LEA64r %77:gr64, 1, $noreg, -48, $noreg
4016B	  $rsp = COPY %32:gr64
4032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4048B	  MOV64mr %77:gr64, 1, $noreg, -48, $noreg, %31:gr64 :: (store (s64) into %ir.43)
4064B	  MOV64mr %77:gr64, 1, $noreg, -40, $noreg, %31:gr64 :: (store (s64) into %ir..repack72)
4080B	  MOV64mi32 %77:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack74)
4096B	  MOV64mr %77:gr64, 1, $noreg, -24, $noreg, %7:gr64_nosp :: (store (s64) into %ir..repack76)
4112B	  MOV64mi32 %77:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack78)
4128B	  %33:gr64 = LEA64r $noreg, 8, %8:gr64_nosp, 0, $noreg
4144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4160B	  $rdi = COPY %33:gr64
4176B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
4192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4208B	  %79:gr64 = COPY killed $rax
4224B	  %34:gr64 = COPY %79:gr64
4240B	  TEST64rr %8:gr64_nosp, %8:gr64_nosp, implicit-def $eflags
4256B	  JCC_1 %bb.18, 14, implicit killed $eflags
4272B	  JMP_1 %bb.17

4288B	bb.17..lr.ph111.preheader:
	; predecessors: %bb.16
	  successors: %bb.18(0x80000000); %bb.18(100.00%)

4304B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4320B	  $rdi = COPY %34:gr64
4336B	  $rsi = COPY %33:gr64
4352B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
4368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

4384B	bb.18.._crit_edge112:
	; predecessors: %bb.16, %bb.17

4400B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4416B	  %81:gr64 = COPY $rsp
4432B	  %82:gr64 = LEA64r %81:gr64, 1, $noreg, -48, $noreg
4448B	  $rsp = COPY %82:gr64
4464B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4480B	  MOV64mr %81:gr64, 1, $noreg, -48, $noreg, %34:gr64 :: (store (s64) into %ir.46)
4496B	  MOV64mr %81:gr64, 1, $noreg, -40, $noreg, %34:gr64 :: (store (s64) into %ir..repack81)
4512B	  MOV64mi32 %81:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack83)
4528B	  MOV64mr %81:gr64, 1, $noreg, -24, $noreg, %8:gr64_nosp :: (store (s64) into %ir..repack85)
4544B	  MOV64mi32 %81:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack87)
4560B	  ADJCALLSTACKDOWN64 144, 0, 144, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4576B	  %84:gr64 = MOV64ri @read_input_2D_f64
4592B	  %85:gr32 = MOV32r0 implicit-def dead $eflags
4608B	  %86:gr64 = SUBREG_TO_REG 0, %85:gr32, %subreg.sub_32bit
4624B	  %87:gr32 = MOV32ri 1
4640B	  %88:gr64 = MOV32ri64 3
4656B	  %89:gr64 = MOV64ri32 -1
4672B	  %90:gr64 = MOV32ri64 1
4688B	  $edi = COPY %87:gr32
4704B	  $rsi = COPY %86:gr64
4720B	  $rdx = COPY %88:gr64
4736B	  $rcx = COPY %86:gr64
4752B	  $r8 = COPY %89:gr64
4768B	  $r9 = COPY %90:gr64
4784B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 136)
4800B	  PUSH64r %82:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 128)
4816B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 120)
4832B	  PUSH64r %32:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 112)
4848B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 104)
4864B	  PUSH64r %29:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 96)
4880B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 88)
4896B	  PUSH64r %26:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 80)
4912B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 72)
4928B	  PUSH64r %23:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 64)
4944B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 56)
4960B	  PUSH64r %20:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 48)
4976B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 40)
4992B	  PUSH64r %17:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 32)
5008B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 24)
5024B	  PUSH64r %14:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 16)
5040B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 8)
5056B	  PUSH64r %11:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
5072B	  CALL64r %84:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit killed $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $r9, implicit-def $rsp, implicit-def $ssp
5088B	  ADJCALLSTACKUP64 144, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5104B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5120B	  %91:gr64 = MOV64ri @comet_print_memref_i64
5136B	  $rdi = COPY %90:gr64
5152B	  $rsi = COPY %11:gr64
5168B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5184B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5200B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5216B	  $rdi = COPY %90:gr64
5232B	  $rsi = COPY %14:gr64
5248B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5264B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5296B	  $rdi = COPY %90:gr64
5312B	  $rsi = COPY %17:gr64
5328B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5344B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5360B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5376B	  $rdi = COPY %90:gr64
5392B	  $rsi = COPY %20:gr64
5408B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5424B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5456B	  $rdi = COPY %90:gr64
5472B	  $rsi = COPY %23:gr64
5488B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5504B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5520B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5536B	  $rdi = COPY %90:gr64
5552B	  $rsi = COPY %26:gr64
5568B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5584B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5600B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5616B	  $rdi = COPY %90:gr64
5632B	  $rsi = COPY %29:gr64
5648B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5664B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5680B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5696B	  $rdi = COPY %90:gr64
5712B	  $rsi = COPY %32:gr64
5728B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5744B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5760B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5776B	  %92:gr64 = MOV64ri @comet_print_memref_f64
5792B	  $rdi = COPY %90:gr64
5808B	  $rsi = COPY %82:gr64
5824B	  CALL64r %92:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5840B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5856B	  RET 0

# End machine code for function main.

********** SIMPLE REGISTER COALESCING **********
********** Function: main
********** JOINING INTERVALS ***********
._crit_edge:
960B	%49:gr64 = COPY $rsp
	Considering merging %49 with $rsp
		RHS = %49 [960r,1088r:0) 0@960r  weight:0.000000e+00
		Interference: SPL
	Interference!
992B	$rsp = COPY %11:gr64
	Considering merging %11 with $rsp
		RHS = %11 [976r,5152r:0) 0@976r  weight:0.000000e+00
		Interference: SPL
	Interference!
1136B	$rdi = COPY %12:gr64
	Considering merging %12 with $rdi
	Can only merge into reserved registers.
1184B	%51:gr64 = COPY killed $rax
	Considering merging %51 with $rax
	Can only merge into reserved registers.
._crit_edge91:
1392B	%53:gr64 = COPY $rsp
	Considering merging %53 with $rsp
		RHS = %53 [1392r,1520r:0) 0@1392r  weight:0.000000e+00
		Interference: SPL
	Interference!
1424B	$rsp = COPY %14:gr64
	Considering merging %14 with $rsp
		RHS = %14 [1408r,5232r:0) 0@1408r  weight:0.000000e+00
		Interference: SPL
	Interference!
1568B	$rdi = COPY %15:gr64
	Considering merging %15 with $rdi
	Can only merge into reserved registers.
1616B	%55:gr64 = COPY killed $rax
	Considering merging %55 with $rax
	Can only merge into reserved registers.
._crit_edge94:
1824B	%57:gr64 = COPY $rsp
	Considering merging %57 with $rsp
		RHS = %57 [1824r,1952r:0) 0@1824r  weight:0.000000e+00
		Interference: SPL
	Interference!
1856B	$rsp = COPY %17:gr64
	Considering merging %17 with $rsp
		RHS = %17 [1840r,5312r:0) 0@1840r  weight:0.000000e+00
		Interference: SPL
	Interference!
2000B	$rdi = COPY %18:gr64
	Considering merging %18 with $rdi
	Can only merge into reserved registers.
2048B	%59:gr64 = COPY killed $rax
	Considering merging %59 with $rax
	Can only merge into reserved registers.
._crit_edge97:
2256B	%61:gr64 = COPY $rsp
	Considering merging %61 with $rsp
		RHS = %61 [2256r,2384r:0) 0@2256r  weight:0.000000e+00
		Interference: SPL
	Interference!
2288B	$rsp = COPY %20:gr64
	Considering merging %20 with $rsp
		RHS = %20 [2272r,5392r:0) 0@2272r  weight:0.000000e+00
		Interference: SPL
	Interference!
2432B	$rdi = COPY %21:gr64
	Considering merging %21 with $rdi
	Can only merge into reserved registers.
2480B	%63:gr64 = COPY killed $rax
	Considering merging %63 with $rax
	Can only merge into reserved registers.
._crit_edge100:
2688B	%65:gr64 = COPY $rsp
	Considering merging %65 with $rsp
		RHS = %65 [2688r,2816r:0) 0@2688r  weight:0.000000e+00
		Interference: SPL
	Interference!
2720B	$rsp = COPY %23:gr64
	Considering merging %23 with $rsp
		RHS = %23 [2704r,5472r:0) 0@2704r  weight:0.000000e+00
		Interference: SPL
	Interference!
2864B	$rdi = COPY %24:gr64
	Considering merging %24 with $rdi
	Can only merge into reserved registers.
2912B	%67:gr64 = COPY killed $rax
	Considering merging %67 with $rax
	Can only merge into reserved registers.
._crit_edge103:
3120B	%69:gr64 = COPY $rsp
	Considering merging %69 with $rsp
		RHS = %69 [3120r,3248r:0) 0@3120r  weight:0.000000e+00
		Interference: SPL
	Interference!
3152B	$rsp = COPY %26:gr64
	Considering merging %26 with $rsp
		RHS = %26 [3136r,5552r:0) 0@3136r  weight:0.000000e+00
		Interference: SPL
	Interference!
3296B	$rdi = COPY %27:gr64
	Considering merging %27 with $rdi
	Can only merge into reserved registers.
3344B	%71:gr64 = COPY killed $rax
	Considering merging %71 with $rax
	Can only merge into reserved registers.
._crit_edge106:
3552B	%73:gr64 = COPY $rsp
	Considering merging %73 with $rsp
		RHS = %73 [3552r,3680r:0) 0@3552r  weight:0.000000e+00
		Interference: SPL
	Interference!
3584B	$rsp = COPY %29:gr64
	Considering merging %29 with $rsp
		RHS = %29 [3568r,5632r:0) 0@3568r  weight:0.000000e+00
		Interference: SPL
	Interference!
3728B	$rdi = COPY %30:gr64
	Considering merging %30 with $rdi
	Can only merge into reserved registers.
3776B	%75:gr64 = COPY killed $rax
	Considering merging %75 with $rax
	Can only merge into reserved registers.
._crit_edge109:
3984B	%77:gr64 = COPY $rsp
	Considering merging %77 with $rsp
		RHS = %77 [3984r,4112r:0) 0@3984r  weight:0.000000e+00
		Interference: SPL
	Interference!
4016B	$rsp = COPY %32:gr64
	Considering merging %32 with $rsp
		RHS = %32 [4000r,5712r:0) 0@4000r  weight:0.000000e+00
		Interference: SPL
	Interference!
4160B	$rdi = COPY %33:gr64
	Considering merging %33 with $rdi
	Can only merge into reserved registers.
4208B	%79:gr64 = COPY killed $rax
	Considering merging %79 with $rax
	Can only merge into reserved registers.
:
64B	$rdi = COPY %36:gr64
	Considering merging %36 with $rdi
	Can only merge into reserved registers.
Remat: $rdi = MOV32ri64 56
Shrink: %36 [48r,64r:0) 0@48r  weight:0.000000e+00
All defs dead: 48r	dead %36:gr64 = MOV32ri64 56
Shrunk: %36 [48r,48d:0) 0@48r  weight:0.000000e+00
Deleting dead def 48r	dead %36:gr64 = MOV32ri64 56
112B	%37:gr64 = COPY killed $rax
	Considering merging %37 with $rax
	Can only merge into reserved registers.
272B	%42:gr64 = SUBREG_TO_REG 0, %41:gr32, %subreg.sub_32bit
	Considering merging to GR64_with_sub_8bit with %41 in %42:sub_32bit
		RHS = %41 [256r,272r:0) 0@256r  weight:0.000000e+00
		LHS = %42 [272r,400r:0) 0@272r  weight:0.000000e+00
		merge %42:0@272r into %41:0@256r --> @256r
		erased:	272r	%42:gr64 = SUBREG_TO_REG 0, %41:gr32, %subreg.sub_32bit
AllocationOrder(GR64) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 ]
AllocationOrder(GR64_with_sub_8bit) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 ]
		updated: 256B	undef %42.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
	Success: %41:sub_32bit -> %42
	Result = %42 [256r,400r:0) 0@256r  weight:0.000000e+00
352B	$edi = COPY %43:gr32
	Considering merging %43 with $edi
	Can only merge into reserved registers.
Remat: $edi = MOV32ri 1
Shrink: %43 [288r,352r:0) 0@288r  weight:0.000000e+00
All defs dead: 288r	dead %43:gr32 = MOV32ri 1
Shrunk: %43 [288r,288d:0) 0@288r  weight:0.000000e+00
Deleting dead def 288r	dead %43:gr32 = MOV32ri 1
368B	$rsi = COPY %42:gr64_with_sub_8bit
	Considering merging %42 with $rsi
	Can only merge into reserved registers.
Remat: dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
Shrink: %42 [256r,400r:0) 0@256r  weight:0.000000e+00
Shrunk: %42 [256r,400r:0) 0@256r  weight:0.000000e+00
384B	$rdx = COPY %44:gr64
	Considering merging %44 with $rdx
	Can only merge into reserved registers.
Remat: $rdx = MOV32ri64 3
Shrink: %44 [304r,384r:0) 0@304r  weight:0.000000e+00
All defs dead: 304r	dead %44:gr64 = MOV32ri64 3
Shrunk: %44 [304r,304d:0) 0@304r  weight:0.000000e+00
Deleting dead def 304r	dead %44:gr64 = MOV32ri64 3
400B	$rcx = COPY %42:gr64_with_sub_8bit
	Considering merging %42 with $rcx
	Can only merge into reserved registers.
Remat: dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
Shrink: %42 [256r,400r:0) 0@256r  weight:0.000000e+00
All defs dead: 256r	dead undef %42.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
Shrunk: %42 [256r,256d:0) 0@256r  weight:0.000000e+00
Deleting dead def 256r	dead undef %42.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
416B	$r8 = COPY %45:gr64
	Considering merging %45 with $r8
	Can only merge into reserved registers.
Remat: $r8 = MOV64ri32 -1
Shrink: %45 [320r,416r:0) 0@320r  weight:0.000000e+00
All defs dead: 320r	dead %45:gr64 = MOV64ri32 -1
Shrunk: %45 [320r,320d:0) 0@320r  weight:0.000000e+00
Deleting dead def 320r	dead %45:gr64 = MOV64ri32 -1
432B	$r9 = COPY %46:gr64
	Considering merging %46 with $r9
	Can only merge into reserved registers.
Remat: $r9 = MOV32ri64 1
Shrink: %46 [336r,432r:0) 0@336r  weight:0.000000e+00
All defs dead: 336r	dead %46:gr64 = MOV32ri64 1
Shrunk: %46 [336r,336d:0) 0@336r  weight:0.000000e+00
Deleting dead def 336r	dead %46:gr64 = MOV32ri64 1
688B	$rdi = COPY %9:gr64
	Considering merging %9 with $rdi
	Can only merge into reserved registers.
736B	%47:gr64 = COPY killed $rax
	Considering merging %47 with $rax
	Can only merge into reserved registers.
.lr.ph.preheader:
864B	$rdi = COPY %10:gr64
	Considering merging %10 with $rdi
	Can only merge into reserved registers.
880B	$rsi = COPY %9:gr64
	Considering merging %9 with $rsi
	Can only merge into reserved registers.
.lr.ph90.preheader:
1296B	$rdi = COPY %13:gr64
	Considering merging %13 with $rdi
	Can only merge into reserved registers.
1312B	$rsi = COPY %12:gr64
	Considering merging %12 with $rsi
	Can only merge into reserved registers.
.lr.ph93.preheader:
1728B	$rdi = COPY %16:gr64
	Considering merging %16 with $rdi
	Can only merge into reserved registers.
1744B	$rsi = COPY %15:gr64
	Considering merging %15 with $rsi
	Can only merge into reserved registers.
.lr.ph96.preheader:
2160B	$rdi = COPY %19:gr64
	Considering merging %19 with $rdi
	Can only merge into reserved registers.
2176B	$rsi = COPY %18:gr64
	Considering merging %18 with $rsi
	Can only merge into reserved registers.
.lr.ph99.preheader:
2592B	$rdi = COPY %22:gr64
	Considering merging %22 with $rdi
	Can only merge into reserved registers.
2608B	$rsi = COPY %21:gr64
	Considering merging %21 with $rsi
	Can only merge into reserved registers.
.lr.ph102.preheader:
3024B	$rdi = COPY %25:gr64
	Considering merging %25 with $rdi
	Can only merge into reserved registers.
3040B	$rsi = COPY %24:gr64
	Considering merging %24 with $rsi
	Can only merge into reserved registers.
.lr.ph105.preheader:
3456B	$rdi = COPY %28:gr64
	Considering merging %28 with $rdi
	Can only merge into reserved registers.
3472B	$rsi = COPY %27:gr64
	Considering merging %27 with $rsi
	Can only merge into reserved registers.
.lr.ph108.preheader:
3888B	$rdi = COPY %31:gr64
	Considering merging %31 with $rdi
	Can only merge into reserved registers.
3904B	$rsi = COPY %30:gr64
	Considering merging %30 with $rsi
	Can only merge into reserved registers.
.lr.ph111.preheader:
4320B	$rdi = COPY %34:gr64
	Considering merging %34 with $rdi
	Can only merge into reserved registers.
4336B	$rsi = COPY %33:gr64
	Considering merging %33 with $rsi
	Can only merge into reserved registers.
._crit_edge112:
4416B	%81:gr64 = COPY $rsp
	Considering merging %81 with $rsp
		RHS = %81 [4416r,4544r:0) 0@4416r  weight:0.000000e+00
		Interference: SPL
	Interference!
4448B	$rsp = COPY %82:gr64
	Considering merging %82 with $rsp
		RHS = %82 [4432r,5808r:0) 0@4432r  weight:0.000000e+00
		Interference: SPL
	Interference!
4608B	%86:gr64 = SUBREG_TO_REG 0, %85:gr32, %subreg.sub_32bit
	Considering merging to GR64_with_sub_8bit with %85 in %86:sub_32bit
		RHS = %85 [4592r,4608r:0) 0@4592r  weight:0.000000e+00
		LHS = %86 [4608r,4736r:0) 0@4608r  weight:0.000000e+00
		merge %86:0@4608r into %85:0@4592r --> @4592r
		erased:	4608r	%86:gr64 = SUBREG_TO_REG 0, %85:gr32, %subreg.sub_32bit
		updated: 4592B	undef %86.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
	Success: %85:sub_32bit -> %86
	Result = %86 [4592r,4736r:0) 0@4592r  weight:0.000000e+00
4688B	$edi = COPY %87:gr32
	Considering merging %87 with $edi
	Can only merge into reserved registers.
Remat: $edi = MOV32ri 1
Shrink: %87 [4624r,4688r:0) 0@4624r  weight:0.000000e+00
All defs dead: 4624r	dead %87:gr32 = MOV32ri 1
Shrunk: %87 [4624r,4624d:0) 0@4624r  weight:0.000000e+00
Deleting dead def 4624r	dead %87:gr32 = MOV32ri 1
4704B	$rsi = COPY %86:gr64_with_sub_8bit
	Considering merging %86 with $rsi
	Can only merge into reserved registers.
Remat: dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
Shrink: %86 [4592r,4736r:0) 0@4592r  weight:0.000000e+00
Shrunk: %86 [4592r,4736r:0) 0@4592r  weight:0.000000e+00
4720B	$rdx = COPY %88:gr64
	Considering merging %88 with $rdx
	Can only merge into reserved registers.
Remat: $rdx = MOV32ri64 3
Shrink: %88 [4640r,4720r:0) 0@4640r  weight:0.000000e+00
All defs dead: 4640r	dead %88:gr64 = MOV32ri64 3
Shrunk: %88 [4640r,4640d:0) 0@4640r  weight:0.000000e+00
Deleting dead def 4640r	dead %88:gr64 = MOV32ri64 3
4736B	$rcx = COPY %86:gr64_with_sub_8bit
	Considering merging %86 with $rcx
	Can only merge into reserved registers.
Remat: dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
Shrink: %86 [4592r,4736r:0) 0@4592r  weight:0.000000e+00
All defs dead: 4592r	dead undef %86.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
Shrunk: %86 [4592r,4592d:0) 0@4592r  weight:0.000000e+00
Deleting dead def 4592r	dead undef %86.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
4752B	$r8 = COPY %89:gr64
	Considering merging %89 with $r8
	Can only merge into reserved registers.
Remat: $r8 = MOV64ri32 -1
Shrink: %89 [4656r,4752r:0) 0@4656r  weight:0.000000e+00
All defs dead: 4656r	dead %89:gr64 = MOV64ri32 -1
Shrunk: %89 [4656r,4656d:0) 0@4656r  weight:0.000000e+00
Deleting dead def 4656r	dead %89:gr64 = MOV64ri32 -1
4768B	$r9 = COPY %90:gr64
	Considering merging %90 with $r9
	Can only merge into reserved registers.
Remat: $r9 = MOV32ri64 1
Shrink: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
Shrunk: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
5136B	$rdi = COPY %90:gr64
	Considering merging %90 with $rdi
	Can only merge into reserved registers.
Remat: $rdi = MOV32ri64 1
Shrink: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
Shrunk: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
5152B	$rsi = COPY %11:gr64
	Considering merging %11 with $rsi
	Can only merge into reserved registers.
5216B	$rdi = COPY %90:gr64
	Considering merging %90 with $rdi
	Can only merge into reserved registers.
Remat: $rdi = MOV32ri64 1
Shrink: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
Shrunk: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
5232B	$rsi = COPY %14:gr64
	Considering merging %14 with $rsi
	Can only merge into reserved registers.
5296B	$rdi = COPY %90:gr64
	Considering merging %90 with $rdi
	Can only merge into reserved registers.
Remat: $rdi = MOV32ri64 1
Shrink: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
Shrunk: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
5312B	$rsi = COPY %17:gr64
	Considering merging %17 with $rsi
	Can only merge into reserved registers.
5376B	$rdi = COPY %90:gr64
	Considering merging %90 with $rdi
	Can only merge into reserved registers.
Remat: $rdi = MOV32ri64 1
Shrink: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
Shrunk: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
5392B	$rsi = COPY %20:gr64
	Considering merging %20 with $rsi
	Can only merge into reserved registers.
5456B	$rdi = COPY %90:gr64
	Considering merging %90 with $rdi
	Can only merge into reserved registers.
Remat: $rdi = MOV32ri64 1
Shrink: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
Shrunk: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
5472B	$rsi = COPY %23:gr64
	Considering merging %23 with $rsi
	Can only merge into reserved registers.
5536B	$rdi = COPY %90:gr64
	Considering merging %90 with $rdi
	Can only merge into reserved registers.
Remat: $rdi = MOV32ri64 1
Shrink: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
Shrunk: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
5552B	$rsi = COPY %26:gr64
	Considering merging %26 with $rsi
	Can only merge into reserved registers.
5616B	$rdi = COPY %90:gr64
	Considering merging %90 with $rdi
	Can only merge into reserved registers.
Remat: $rdi = MOV32ri64 1
Shrink: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
Shrunk: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
5632B	$rsi = COPY %29:gr64
	Considering merging %29 with $rsi
	Can only merge into reserved registers.
5696B	$rdi = COPY %90:gr64
	Considering merging %90 with $rdi
	Can only merge into reserved registers.
Remat: $rdi = MOV32ri64 1
Shrink: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
Shrunk: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
5712B	$rsi = COPY %32:gr64
	Considering merging %32 with $rsi
	Can only merge into reserved registers.
5792B	$rdi = COPY %90:gr64
	Considering merging %90 with $rdi
	Can only merge into reserved registers.
Remat: $rdi = MOV32ri64 1
Shrink: %90 [4672r,5792r:0) 0@4672r  weight:0.000000e+00
All defs dead: 4672r	dead %90:gr64 = MOV32ri64 1
Shrunk: %90 [4672r,4672d:0) 0@4672r  weight:0.000000e+00
Deleting dead def 4672r	dead %90:gr64 = MOV32ri64 1
5808B	$rsi = COPY %82:gr64
	Considering merging %82 with $rsi
	Can only merge into reserved registers.
1200B	%13:gr64 = COPY %51:gr64
	Considering merging to GR64 with %51 in %13
		RHS = %51 [1184r,1200r:0) 0@1184r  weight:0.000000e+00
		LHS = %13 [1200r,1472r:0) 0@1200r  weight:0.000000e+00
		merge %13:0@1200r into %51:0@1184r --> @1184r
		erased:	1200r	%13:gr64 = COPY %51:gr64
		updated: 1184B	%13:gr64 = COPY killed $rax
	Success: %51 -> %13
	Result = %13 [1184r,1472r:0) 0@1184r  weight:0.000000e+00
1632B	%16:gr64 = COPY %55:gr64
	Considering merging to GR64 with %55 in %16
		RHS = %55 [1616r,1632r:0) 0@1616r  weight:0.000000e+00
		LHS = %16 [1632r,1904r:0) 0@1632r  weight:0.000000e+00
		merge %16:0@1632r into %55:0@1616r --> @1616r
		erased:	1632r	%16:gr64 = COPY %55:gr64
		updated: 1616B	%16:gr64 = COPY killed $rax
	Success: %55 -> %16
	Result = %16 [1616r,1904r:0) 0@1616r  weight:0.000000e+00
2064B	%19:gr64 = COPY %59:gr64
	Considering merging to GR64 with %59 in %19
		RHS = %59 [2048r,2064r:0) 0@2048r  weight:0.000000e+00
		LHS = %19 [2064r,2336r:0) 0@2064r  weight:0.000000e+00
		merge %19:0@2064r into %59:0@2048r --> @2048r
		erased:	2064r	%19:gr64 = COPY %59:gr64
		updated: 2048B	%19:gr64 = COPY killed $rax
	Success: %59 -> %19
	Result = %19 [2048r,2336r:0) 0@2048r  weight:0.000000e+00
2496B	%22:gr64 = COPY %63:gr64
	Considering merging to GR64 with %63 in %22
		RHS = %63 [2480r,2496r:0) 0@2480r  weight:0.000000e+00
		LHS = %22 [2496r,2768r:0) 0@2496r  weight:0.000000e+00
		merge %22:0@2496r into %63:0@2480r --> @2480r
		erased:	2496r	%22:gr64 = COPY %63:gr64
		updated: 2480B	%22:gr64 = COPY killed $rax
	Success: %63 -> %22
	Result = %22 [2480r,2768r:0) 0@2480r  weight:0.000000e+00
2928B	%25:gr64 = COPY %67:gr64
	Considering merging to GR64 with %67 in %25
		RHS = %67 [2912r,2928r:0) 0@2912r  weight:0.000000e+00
		LHS = %25 [2928r,3200r:0) 0@2928r  weight:0.000000e+00
		merge %25:0@2928r into %67:0@2912r --> @2912r
		erased:	2928r	%25:gr64 = COPY %67:gr64
		updated: 2912B	%25:gr64 = COPY killed $rax
	Success: %67 -> %25
	Result = %25 [2912r,3200r:0) 0@2912r  weight:0.000000e+00
3360B	%28:gr64 = COPY %71:gr64
	Considering merging to GR64 with %71 in %28
		RHS = %71 [3344r,3360r:0) 0@3344r  weight:0.000000e+00
		LHS = %28 [3360r,3632r:0) 0@3360r  weight:0.000000e+00
		merge %28:0@3360r into %71:0@3344r --> @3344r
		erased:	3360r	%28:gr64 = COPY %71:gr64
		updated: 3344B	%28:gr64 = COPY killed $rax
	Success: %71 -> %28
	Result = %28 [3344r,3632r:0) 0@3344r  weight:0.000000e+00
3792B	%31:gr64 = COPY %75:gr64
	Considering merging to GR64 with %75 in %31
		RHS = %75 [3776r,3792r:0) 0@3776r  weight:0.000000e+00
		LHS = %31 [3792r,4064r:0) 0@3792r  weight:0.000000e+00
		merge %31:0@3792r into %75:0@3776r --> @3776r
		erased:	3792r	%31:gr64 = COPY %75:gr64
		updated: 3776B	%31:gr64 = COPY killed $rax
	Success: %75 -> %31
	Result = %31 [3776r,4064r:0) 0@3776r  weight:0.000000e+00
4224B	%34:gr64 = COPY %79:gr64
	Considering merging to GR64 with %79 in %34
		RHS = %79 [4208r,4224r:0) 0@4208r  weight:0.000000e+00
		LHS = %34 [4224r,4496r:0) 0@4224r  weight:0.000000e+00
		merge %34:0@4224r into %79:0@4208r --> @4208r
		erased:	4224r	%34:gr64 = COPY %79:gr64
		updated: 4208B	%34:gr64 = COPY killed $rax
	Success: %79 -> %34
	Result = %34 [4208r,4496r:0) 0@4208r  weight:0.000000e+00
752B	%10:gr64 = COPY %47:gr64
	Considering merging to GR64 with %47 in %10
		RHS = %47 [736r,752r:0) 0@736r  weight:0.000000e+00
		LHS = %10 [752r,1040r:0) 0@752r  weight:0.000000e+00
		merge %10:0@752r into %47:0@736r --> @736r
		erased:	752r	%10:gr64 = COPY %47:gr64
		updated: 736B	%10:gr64 = COPY killed $rax
	Success: %47 -> %10
	Result = %10 [736r,1040r:0) 0@736r  weight:0.000000e+00
960B	%49:gr64 = COPY $rsp
	Considering merging %49 with $rsp
		RHS = %49 [960r,1088r:0) 0@960r  weight:0.000000e+00
		Interference: SPL
	Interference!
992B	$rsp = COPY %11:gr64
	Considering merging %11 with $rsp
		RHS = %11 [976r,5152r:0) 0@976r  weight:0.000000e+00
		Interference: SPL
	Interference!
1392B	%53:gr64 = COPY $rsp
	Considering merging %53 with $rsp
		RHS = %53 [1392r,1520r:0) 0@1392r  weight:0.000000e+00
		Interference: SPL
	Interference!
1424B	$rsp = COPY %14:gr64
	Considering merging %14 with $rsp
		RHS = %14 [1408r,5232r:0) 0@1408r  weight:0.000000e+00
		Interference: SPL
	Interference!
1824B	%57:gr64 = COPY $rsp
	Considering merging %57 with $rsp
		RHS = %57 [1824r,1952r:0) 0@1824r  weight:0.000000e+00
		Interference: SPL
	Interference!
1856B	$rsp = COPY %17:gr64
	Considering merging %17 with $rsp
		RHS = %17 [1840r,5312r:0) 0@1840r  weight:0.000000e+00
		Interference: SPL
	Interference!
2256B	%61:gr64 = COPY $rsp
	Considering merging %61 with $rsp
		RHS = %61 [2256r,2384r:0) 0@2256r  weight:0.000000e+00
		Interference: SPL
	Interference!
2288B	$rsp = COPY %20:gr64
	Considering merging %20 with $rsp
		RHS = %20 [2272r,5392r:0) 0@2272r  weight:0.000000e+00
		Interference: SPL
	Interference!
2688B	%65:gr64 = COPY $rsp
	Considering merging %65 with $rsp
		RHS = %65 [2688r,2816r:0) 0@2688r  weight:0.000000e+00
		Interference: SPL
	Interference!
2720B	$rsp = COPY %23:gr64
	Considering merging %23 with $rsp
		RHS = %23 [2704r,5472r:0) 0@2704r  weight:0.000000e+00
		Interference: SPL
	Interference!
3120B	%69:gr64 = COPY $rsp
	Considering merging %69 with $rsp
		RHS = %69 [3120r,3248r:0) 0@3120r  weight:0.000000e+00
		Interference: SPL
	Interference!
3152B	$rsp = COPY %26:gr64
	Considering merging %26 with $rsp
		RHS = %26 [3136r,5552r:0) 0@3136r  weight:0.000000e+00
		Interference: SPL
	Interference!
3552B	%73:gr64 = COPY $rsp
	Considering merging %73 with $rsp
		RHS = %73 [3552r,3680r:0) 0@3552r  weight:0.000000e+00
		Interference: SPL
	Interference!
3584B	$rsp = COPY %29:gr64
	Considering merging %29 with $rsp
		RHS = %29 [3568r,5632r:0) 0@3568r  weight:0.000000e+00
		Interference: SPL
	Interference!
3984B	%77:gr64 = COPY $rsp
	Considering merging %77 with $rsp
		RHS = %77 [3984r,4112r:0) 0@3984r  weight:0.000000e+00
		Interference: SPL
	Interference!
4016B	$rsp = COPY %32:gr64
	Considering merging %32 with $rsp
		RHS = %32 [4000r,5712r:0) 0@4000r  weight:0.000000e+00
		Interference: SPL
	Interference!
864B	$rdi = COPY %10:gr64
	Considering merging %10 with $rdi
	Can only merge into reserved registers.
1296B	$rdi = COPY %13:gr64
	Considering merging %13 with $rdi
	Can only merge into reserved registers.
1728B	$rdi = COPY %16:gr64
	Considering merging %16 with $rdi
	Can only merge into reserved registers.
2160B	$rdi = COPY %19:gr64
	Considering merging %19 with $rdi
	Can only merge into reserved registers.
2592B	$rdi = COPY %22:gr64
	Considering merging %22 with $rdi
	Can only merge into reserved registers.
3024B	$rdi = COPY %25:gr64
	Considering merging %25 with $rdi
	Can only merge into reserved registers.
3456B	$rdi = COPY %28:gr64
	Considering merging %28 with $rdi
	Can only merge into reserved registers.
3888B	$rdi = COPY %31:gr64
	Considering merging %31 with $rdi
	Can only merge into reserved registers.
4320B	$rdi = COPY %34:gr64
	Considering merging %34 with $rdi
	Can only merge into reserved registers.
4416B	%81:gr64 = COPY $rsp
	Considering merging %81 with $rsp
		RHS = %81 [4416r,4544r:0) 0@4416r  weight:0.000000e+00
		Interference: SPL
	Interference!
4448B	$rsp = COPY %82:gr64
	Considering merging %82 with $rsp
		RHS = %82 [4432r,5808r:0) 0@4432r  weight:0.000000e+00
		Interference: SPL
	Interference!
Trying to inflate 0 regs.
********** INTERVALS **********
SPL [16r,16d:136)[80r,80d:135)[96r,96d:134)[208r,208d:133)[448r,448d:19)[464r,464d:18)[480r,480d:132)[496r,496d:131)[672r,672d:130)[704r,704d:129)[720r,720d:128)[848r,848d:127)[896r,896d:126)[912r,912d:125)[944r,944d:124)[992r,992d:123)[1008r,1008d:122)[1120r,1120d:121)[1152r,1152d:120)[1168r,1168d:119)[1280r,1280d:118)[1328r,1328d:117)[1344r,1344d:116)[1376r,1376d:115)[1424r,1424d:114)[1440r,1440d:113)[1552r,1552d:112)[1584r,1584d:111)[1600r,1600d:110)[1712r,1712d:109)[1760r,1760d:108)[1776r,1776d:107)[1808r,1808d:106)[1856r,1856d:105)[1872r,1872d:104)[1984r,1984d:103)[2016r,2016d:102)[2032r,2032d:101)[2144r,2144d:100)[2192r,2192d:99)[2208r,2208d:98)[2240r,2240d:97)[2288r,2288d:96)[2304r,2304d:95)[2416r,2416d:94)[2448r,2448d:93)[2464r,2464d:92)[2576r,2576d:91)[2624r,2624d:90)[2640r,2640d:89)[2672r,2672d:88)[2720r,2720d:87)[2736r,2736d:86)[2848r,2848d:85)[2880r,2880d:84)[2896r,2896d:83)[3008r,3008d:82)[3056r,3056d:81)[3072r,3072d:80)[3104r,3104d:79)[3152r,3152d:78)[3168r,3168d:77)[3280r,3280d:76)[3312r,3312d:75)[3328r,3328d:74)[3440r,3440d:73)[3488r,3488d:72)[3504r,3504d:71)[3536r,3536d:70)[3584r,3584d:69)[3600r,3600d:68)[3712r,3712d:67)[3744r,3744d:66)[3760r,3760d:65)[3872r,3872d:64)[3920r,3920d:63)[3936r,3936d:62)[3968r,3968d:61)[4016r,4016d:60)[4032r,4032d:59)[4144r,4144d:58)[4176r,4176d:57)[4192r,4192d:56)[4304r,4304d:55)[4352r,4352d:54)[4368r,4368d:53)[4400r,4400d:52)[4448r,4448d:51)[4464r,4464d:50)[4560r,4560d:49)[4784r,4784d:17)[4800r,4800d:16)[4816r,4816d:15)[4832r,4832d:14)[4848r,4848d:13)[4864r,4864d:12)[4880r,4880d:11)[4896r,4896d:10)[4912r,4912d:9)[4928r,4928d:8)[4944r,4944d:7)[4960r,4960d:6)[4976r,4976d:5)[4992r,4992d:4)[5008r,5008d:3)[5024r,5024d:2)[5040r,5040d:1)[5056r,5056d:0)[5072r,5072d:48)[5088r,5088d:47)[5104r,5104d:46)[5168r,5168d:45)[5184r,5184d:44)[5200r,5200d:43)[5248r,5248d:42)[5264r,5264d:41)[5280r,5280d:40)[5328r,5328d:39)[5344r,5344d:38)[5360r,5360d:37)[5408r,5408d:36)[5424r,5424d:35)[5440r,5440d:34)[5488r,5488d:33)[5504r,5504d:32)[5520r,5520d:31)[5568r,5568d:30)[5584r,5584d:29)[5600r,5600d:28)[5648r,5648d:27)[5664r,5664d:26)[5680r,5680d:25)[5728r,5728d:24)[5744r,5744d:23)[5760r,5760d:22)[5824r,5824d:21)[5840r,5840d:20) 0@5056r 1@5040r 2@5024r 3@5008r 4@4992r 5@4976r 6@4960r 7@4944r 8@4928r 9@4912r 10@4896r 11@4880r 12@4864r 13@4848r 14@4832r 15@4816r 16@4800r 17@4784r 18@464r 19@448r 20@5840r 21@5824r 22@5760r 23@5744r 24@5728r 25@5680r 26@5664r 27@5648r 28@5600r 29@5584r 30@5568r 31@5520r 32@5504r 33@5488r 34@5440r 35@5424r 36@5408r 37@5360r 38@5344r 39@5328r 40@5280r 41@5264r 42@5248r 43@5200r 44@5184r 45@5168r 46@5104r 47@5088r 48@5072r 49@4560r 50@4464r 51@4448r 52@4400r 53@4368r 54@4352r 55@4304r 56@4192r 57@4176r 58@4144r 59@4032r 60@4016r 61@3968r 62@3936r 63@3920r 64@3872r 65@3760r 66@3744r 67@3712r 68@3600r 69@3584r 70@3536r 71@3504r 72@3488r 73@3440r 74@3328r 75@3312r 76@3280r 77@3168r 78@3152r 79@3104r 80@3072r 81@3056r 82@3008r 83@2896r 84@2880r 85@2848r 86@2736r 87@2720r 88@2672r 89@2640r 90@2624r 91@2576r 92@2464r 93@2448r 94@2416r 95@2304r 96@2288r 97@2240r 98@2208r 99@2192r 100@2144r 101@2032r 102@2016r 103@1984r 104@1872r 105@1856r 106@1808r 107@1776r 108@1760r 109@1712r 110@1600r 111@1584r 112@1552r 113@1440r 114@1424r 115@1376r 116@1344r 117@1328r 118@1280r 119@1168r 120@1152r 121@1120r 122@1008r 123@992r 124@944r 125@912r 126@896r 127@848r 128@720r 129@704r 130@672r 131@496r 132@480r 133@208r 134@96r 135@80r 136@16r
%0 [512r,1072r:0) 0@512r  weight:0.000000e+00
%1 [528r,1504r:0) 0@528r  weight:0.000000e+00
%2 [544r,1936r:0) 0@544r  weight:0.000000e+00
%3 [560r,2368r:0) 0@560r  weight:0.000000e+00
%4 [576r,2800r:0) 0@576r  weight:0.000000e+00
%5 [592r,3232r:0) 0@592r  weight:0.000000e+00
%6 [608r,3664r:0) 0@608r  weight:0.000000e+00
%7 [624r,4096r:0) 0@624r  weight:0.000000e+00
%8 [640r,4528r:0) 0@640r  weight:0.000000e+00
%9 [656r,880r:0) 0@656r  weight:0.000000e+00
%10 [736r,1040r:0) 0@736r  weight:0.000000e+00
%11 [976r,5152r:0) 0@976r  weight:0.000000e+00
%12 [1104r,1312r:0) 0@1104r  weight:0.000000e+00
%13 [1184r,1472r:0) 0@1184r  weight:0.000000e+00
%14 [1408r,5232r:0) 0@1408r  weight:0.000000e+00
%15 [1536r,1744r:0) 0@1536r  weight:0.000000e+00
%16 [1616r,1904r:0) 0@1616r  weight:0.000000e+00
%17 [1840r,5312r:0) 0@1840r  weight:0.000000e+00
%18 [1968r,2176r:0) 0@1968r  weight:0.000000e+00
%19 [2048r,2336r:0) 0@2048r  weight:0.000000e+00
%20 [2272r,5392r:0) 0@2272r  weight:0.000000e+00
%21 [2400r,2608r:0) 0@2400r  weight:0.000000e+00
%22 [2480r,2768r:0) 0@2480r  weight:0.000000e+00
%23 [2704r,5472r:0) 0@2704r  weight:0.000000e+00
%24 [2832r,3040r:0) 0@2832r  weight:0.000000e+00
%25 [2912r,3200r:0) 0@2912r  weight:0.000000e+00
%26 [3136r,5552r:0) 0@3136r  weight:0.000000e+00
%27 [3264r,3472r:0) 0@3264r  weight:0.000000e+00
%28 [3344r,3632r:0) 0@3344r  weight:0.000000e+00
%29 [3568r,5632r:0) 0@3568r  weight:0.000000e+00
%30 [3696r,3904r:0) 0@3696r  weight:0.000000e+00
%31 [3776r,4064r:0) 0@3776r  weight:0.000000e+00
%32 [4000r,5712r:0) 0@4000r  weight:0.000000e+00
%33 [4128r,4336r:0) 0@4128r  weight:0.000000e+00
%34 [4208r,4496r:0) 0@4208r  weight:0.000000e+00
%35 [32r,4176r:0) 0@32r  weight:0.000000e+00
%37 [112r,640r:0) 0@112r  weight:0.000000e+00
%39 [224r,464r:0) 0@224r  weight:0.000000e+00
%40 [240r,480r:0) 0@240r  weight:0.000000e+00
%49 [960r,1088r:0) 0@960r  weight:0.000000e+00
%53 [1392r,1520r:0) 0@1392r  weight:0.000000e+00
%57 [1824r,1952r:0) 0@1824r  weight:0.000000e+00
%61 [2256r,2384r:0) 0@2256r  weight:0.000000e+00
%65 [2688r,2816r:0) 0@2688r  weight:0.000000e+00
%69 [3120r,3248r:0) 0@3120r  weight:0.000000e+00
%73 [3552r,3680r:0) 0@3552r  weight:0.000000e+00
%77 [3984r,4112r:0) 0@3984r  weight:0.000000e+00
%81 [4416r,4544r:0) 0@4416r  weight:0.000000e+00
%82 [4432r,5808r:0) 0@4432r  weight:0.000000e+00
%84 [4576r,5072r:0) 0@4576r  weight:0.000000e+00
%91 [5120r,5728r:0) 0@5120r  weight:0.000000e+00
%92 [5776r,5824r:0) 0@5776r  weight:0.000000e+00
%100 [784r,4352r:0) 0@784r  weight:0.000000e+00
RegMasks: 80r 480r 704r 896r 1152r 1328r 1584r 1760r 2016r 2192r 2448r 2624r 2880r 3056r 3312r 3488r 3744r 3920r 4176r 4352r 5072r 5168r 5248r 5328r 5408r 5488r 5568r 5648r 5728r 5824r
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=40, align=8, at location [SP+8]
  fi#1: variable sized, align=1, at location [SP+8]
  fi#2: variable sized, align=1, at location [SP+8]
  fi#3: variable sized, align=1, at location [SP+8]
  fi#4: variable sized, align=1, at location [SP+8]
  fi#5: variable sized, align=1, at location [SP+8]
  fi#6: variable sized, align=1, at location [SP+8]
  fi#7: variable sized, align=1, at location [SP+8]
  fi#8: variable sized, align=1, at location [SP+8]
  fi#9: variable sized, align=1, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %35:gr64 = MOV64ri @malloc
64B	  $rdi = MOV32ri64 56
80B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %37:gr64 = COPY killed $rax
128B	  MOV64mr %stack.0, 1, $noreg, 0, $noreg, %37:gr64 :: (store (s64) into %ir.2)
144B	  MOV64mr %stack.0, 1, $noreg, 8, $noreg, %37:gr64 :: (store (s64) into %ir..fca.1.gep)
160B	  MOV64mi32 %stack.0, 1, $noreg, 16, $noreg, 0 :: (store (s64) into %ir..fca.2.gep)
176B	  MOV64mi32 %stack.0, 1, $noreg, 24, $noreg, 7 :: (store (s64) into %ir..fca.3.0.gep)
192B	  MOV64mi32 %stack.0, 1, $noreg, 32, $noreg, 1 :: (store (s64) into %ir..fca.4.0.gep)
208B	  ADJCALLSTACKDOWN64 16, 0, 16, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
224B	  %39:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
240B	  %40:gr64 = MOV64ri @read_input_sizes_2D_f64
352B	  $edi = MOV32ri 1
368B	  dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
384B	  $rdx = MOV32ri64 3
400B	  dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
416B	  $r8 = MOV64ri32 -1
432B	  $r9 = MOV32ri64 1
448B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 8)
464B	  PUSH64r %39:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
480B	  CALL64r %40:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit killed $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $r9, implicit-def $rsp, implicit-def $ssp
496B	  ADJCALLSTACKUP64 16, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
512B	  %0:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
528B	  %1:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
544B	  %2:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
560B	  %3:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
576B	  %4:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
592B	  %5:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
608B	  %6:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
624B	  %7:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
640B	  %8:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
656B	  %9:gr64 = LEA64r $noreg, 8, %0:gr64_nosp, 0, $noreg
672B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
688B	  $rdi = COPY %9:gr64
704B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
720B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
736B	  %10:gr64 = COPY killed $rax
768B	  TEST64rr %0:gr64_nosp, %0:gr64_nosp, implicit-def $eflags
784B	  %100:gr64 = MOV64ri &__bzero
800B	  JCC_1 %bb.2, 14, implicit killed $eflags
816B	  JMP_1 %bb.1

832B	bb.1..lr.ph.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
864B	  $rdi = COPY %10:gr64
880B	  $rsi = COPY %9:gr64
896B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
912B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

928B	bb.2.._crit_edge:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.3(0x50000000), %bb.4(0x30000000); %bb.3(62.50%), %bb.4(37.50%)

944B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
960B	  %49:gr64 = COPY $rsp
976B	  %11:gr64 = LEA64r %49:gr64, 1, $noreg, -48, $noreg
992B	  $rsp = COPY %11:gr64
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1024B	  MOV64mr %49:gr64, 1, $noreg, -48, $noreg, %10:gr64 :: (store (s64) into %ir.22)
1040B	  MOV64mr %49:gr64, 1, $noreg, -40, $noreg, %10:gr64 :: (store (s64) into %ir..repack9)
1056B	  MOV64mi32 %49:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack11)
1072B	  MOV64mr %49:gr64, 1, $noreg, -24, $noreg, %0:gr64_nosp :: (store (s64) into %ir..repack13)
1088B	  MOV64mi32 %49:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack15)
1104B	  %12:gr64 = LEA64r $noreg, 8, %1:gr64_nosp, 0, $noreg
1120B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1136B	  $rdi = COPY %12:gr64
1152B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1184B	  %13:gr64 = COPY killed $rax
1216B	  TEST64rr %1:gr64_nosp, %1:gr64_nosp, implicit-def $eflags
1232B	  JCC_1 %bb.4, 14, implicit killed $eflags
1248B	  JMP_1 %bb.3

1264B	bb.3..lr.ph90.preheader:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1296B	  $rdi = COPY %13:gr64
1312B	  $rsi = COPY %12:gr64
1328B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
1344B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

1360B	bb.4.._crit_edge91:
	; predecessors: %bb.2, %bb.3
	  successors: %bb.5(0x50000000), %bb.6(0x30000000); %bb.5(62.50%), %bb.6(37.50%)

1376B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1392B	  %53:gr64 = COPY $rsp
1408B	  %14:gr64 = LEA64r %53:gr64, 1, $noreg, -48, $noreg
1424B	  $rsp = COPY %14:gr64
1440B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1456B	  MOV64mr %53:gr64, 1, $noreg, -48, $noreg, %13:gr64 :: (store (s64) into %ir.25)
1472B	  MOV64mr %53:gr64, 1, $noreg, -40, $noreg, %13:gr64 :: (store (s64) into %ir..repack18)
1488B	  MOV64mi32 %53:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack20)
1504B	  MOV64mr %53:gr64, 1, $noreg, -24, $noreg, %1:gr64_nosp :: (store (s64) into %ir..repack22)
1520B	  MOV64mi32 %53:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack24)
1536B	  %15:gr64 = LEA64r $noreg, 8, %2:gr64_nosp, 0, $noreg
1552B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1568B	  $rdi = COPY %15:gr64
1584B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1600B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1616B	  %16:gr64 = COPY killed $rax
1648B	  TEST64rr %2:gr64_nosp, %2:gr64_nosp, implicit-def $eflags
1664B	  JCC_1 %bb.6, 14, implicit killed $eflags
1680B	  JMP_1 %bb.5

1696B	bb.5..lr.ph93.preheader:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

1712B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1728B	  $rdi = COPY %16:gr64
1744B	  $rsi = COPY %15:gr64
1760B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
1776B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

1792B	bb.6.._crit_edge94:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.7(0x50000000), %bb.8(0x30000000); %bb.7(62.50%), %bb.8(37.50%)

1808B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1824B	  %57:gr64 = COPY $rsp
1840B	  %17:gr64 = LEA64r %57:gr64, 1, $noreg, -48, $noreg
1856B	  $rsp = COPY %17:gr64
1872B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1888B	  MOV64mr %57:gr64, 1, $noreg, -48, $noreg, %16:gr64 :: (store (s64) into %ir.28)
1904B	  MOV64mr %57:gr64, 1, $noreg, -40, $noreg, %16:gr64 :: (store (s64) into %ir..repack27)
1920B	  MOV64mi32 %57:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack29)
1936B	  MOV64mr %57:gr64, 1, $noreg, -24, $noreg, %2:gr64_nosp :: (store (s64) into %ir..repack31)
1952B	  MOV64mi32 %57:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack33)
1968B	  %18:gr64 = LEA64r $noreg, 8, %3:gr64_nosp, 0, $noreg
1984B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2000B	  $rdi = COPY %18:gr64
2016B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2048B	  %19:gr64 = COPY killed $rax
2080B	  TEST64rr %3:gr64_nosp, %3:gr64_nosp, implicit-def $eflags
2096B	  JCC_1 %bb.8, 14, implicit killed $eflags
2112B	  JMP_1 %bb.7

2128B	bb.7..lr.ph96.preheader:
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)

2144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2160B	  $rdi = COPY %19:gr64
2176B	  $rsi = COPY %18:gr64
2192B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
2208B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2224B	bb.8.._crit_edge97:
	; predecessors: %bb.6, %bb.7
	  successors: %bb.9(0x50000000), %bb.10(0x30000000); %bb.9(62.50%), %bb.10(37.50%)

2240B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2256B	  %61:gr64 = COPY $rsp
2272B	  %20:gr64 = LEA64r %61:gr64, 1, $noreg, -48, $noreg
2288B	  $rsp = COPY %20:gr64
2304B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2320B	  MOV64mr %61:gr64, 1, $noreg, -48, $noreg, %19:gr64 :: (store (s64) into %ir.31)
2336B	  MOV64mr %61:gr64, 1, $noreg, -40, $noreg, %19:gr64 :: (store (s64) into %ir..repack36)
2352B	  MOV64mi32 %61:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack38)
2368B	  MOV64mr %61:gr64, 1, $noreg, -24, $noreg, %3:gr64_nosp :: (store (s64) into %ir..repack40)
2384B	  MOV64mi32 %61:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack42)
2400B	  %21:gr64 = LEA64r $noreg, 8, %4:gr64_nosp, 0, $noreg
2416B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2432B	  $rdi = COPY %21:gr64
2448B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2464B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2480B	  %22:gr64 = COPY killed $rax
2512B	  TEST64rr %4:gr64_nosp, %4:gr64_nosp, implicit-def $eflags
2528B	  JCC_1 %bb.10, 14, implicit killed $eflags
2544B	  JMP_1 %bb.9

2560B	bb.9..lr.ph99.preheader:
	; predecessors: %bb.8
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

2576B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2592B	  $rdi = COPY %22:gr64
2608B	  $rsi = COPY %21:gr64
2624B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
2640B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2656B	bb.10.._crit_edge100:
	; predecessors: %bb.8, %bb.9
	  successors: %bb.11(0x50000000), %bb.12(0x30000000); %bb.11(62.50%), %bb.12(37.50%)

2672B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2688B	  %65:gr64 = COPY $rsp
2704B	  %23:gr64 = LEA64r %65:gr64, 1, $noreg, -48, $noreg
2720B	  $rsp = COPY %23:gr64
2736B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2752B	  MOV64mr %65:gr64, 1, $noreg, -48, $noreg, %22:gr64 :: (store (s64) into %ir.34)
2768B	  MOV64mr %65:gr64, 1, $noreg, -40, $noreg, %22:gr64 :: (store (s64) into %ir..repack45)
2784B	  MOV64mi32 %65:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack47)
2800B	  MOV64mr %65:gr64, 1, $noreg, -24, $noreg, %4:gr64_nosp :: (store (s64) into %ir..repack49)
2816B	  MOV64mi32 %65:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack51)
2832B	  %24:gr64 = LEA64r $noreg, 8, %5:gr64_nosp, 0, $noreg
2848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2864B	  $rdi = COPY %24:gr64
2880B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2912B	  %25:gr64 = COPY killed $rax
2944B	  TEST64rr %5:gr64_nosp, %5:gr64_nosp, implicit-def $eflags
2960B	  JCC_1 %bb.12, 14, implicit killed $eflags
2976B	  JMP_1 %bb.11

2992B	bb.11..lr.ph102.preheader:
	; predecessors: %bb.10
	  successors: %bb.12(0x80000000); %bb.12(100.00%)

3008B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3024B	  $rdi = COPY %25:gr64
3040B	  $rsi = COPY %24:gr64
3056B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
3072B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3088B	bb.12.._crit_edge103:
	; predecessors: %bb.10, %bb.11
	  successors: %bb.13(0x50000000), %bb.14(0x30000000); %bb.13(62.50%), %bb.14(37.50%)

3104B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3120B	  %69:gr64 = COPY $rsp
3136B	  %26:gr64 = LEA64r %69:gr64, 1, $noreg, -48, $noreg
3152B	  $rsp = COPY %26:gr64
3168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3184B	  MOV64mr %69:gr64, 1, $noreg, -48, $noreg, %25:gr64 :: (store (s64) into %ir.37)
3200B	  MOV64mr %69:gr64, 1, $noreg, -40, $noreg, %25:gr64 :: (store (s64) into %ir..repack54)
3216B	  MOV64mi32 %69:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack56)
3232B	  MOV64mr %69:gr64, 1, $noreg, -24, $noreg, %5:gr64_nosp :: (store (s64) into %ir..repack58)
3248B	  MOV64mi32 %69:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack60)
3264B	  %27:gr64 = LEA64r $noreg, 8, %6:gr64_nosp, 0, $noreg
3280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3296B	  $rdi = COPY %27:gr64
3312B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3328B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3344B	  %28:gr64 = COPY killed $rax
3376B	  TEST64rr %6:gr64_nosp, %6:gr64_nosp, implicit-def $eflags
3392B	  JCC_1 %bb.14, 14, implicit killed $eflags
3408B	  JMP_1 %bb.13

3424B	bb.13..lr.ph105.preheader:
	; predecessors: %bb.12
	  successors: %bb.14(0x80000000); %bb.14(100.00%)

3440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3456B	  $rdi = COPY %28:gr64
3472B	  $rsi = COPY %27:gr64
3488B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
3504B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3520B	bb.14.._crit_edge106:
	; predecessors: %bb.12, %bb.13
	  successors: %bb.15(0x50000000), %bb.16(0x30000000); %bb.15(62.50%), %bb.16(37.50%)

3536B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3552B	  %73:gr64 = COPY $rsp
3568B	  %29:gr64 = LEA64r %73:gr64, 1, $noreg, -48, $noreg
3584B	  $rsp = COPY %29:gr64
3600B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3616B	  MOV64mr %73:gr64, 1, $noreg, -48, $noreg, %28:gr64 :: (store (s64) into %ir.40)
3632B	  MOV64mr %73:gr64, 1, $noreg, -40, $noreg, %28:gr64 :: (store (s64) into %ir..repack63)
3648B	  MOV64mi32 %73:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack65)
3664B	  MOV64mr %73:gr64, 1, $noreg, -24, $noreg, %6:gr64_nosp :: (store (s64) into %ir..repack67)
3680B	  MOV64mi32 %73:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack69)
3696B	  %30:gr64 = LEA64r $noreg, 8, %7:gr64_nosp, 0, $noreg
3712B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3728B	  $rdi = COPY %30:gr64
3744B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3760B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3776B	  %31:gr64 = COPY killed $rax
3808B	  TEST64rr %7:gr64_nosp, %7:gr64_nosp, implicit-def $eflags
3824B	  JCC_1 %bb.16, 14, implicit killed $eflags
3840B	  JMP_1 %bb.15

3856B	bb.15..lr.ph108.preheader:
	; predecessors: %bb.14
	  successors: %bb.16(0x80000000); %bb.16(100.00%)

3872B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3888B	  $rdi = COPY %31:gr64
3904B	  $rsi = COPY %30:gr64
3920B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
3936B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3952B	bb.16.._crit_edge109:
	; predecessors: %bb.14, %bb.15
	  successors: %bb.17(0x50000000), %bb.18(0x30000000); %bb.17(62.50%), %bb.18(37.50%)

3968B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3984B	  %77:gr64 = COPY $rsp
4000B	  %32:gr64 = LEA64r %77:gr64, 1, $noreg, -48, $noreg
4016B	  $rsp = COPY %32:gr64
4032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4048B	  MOV64mr %77:gr64, 1, $noreg, -48, $noreg, %31:gr64 :: (store (s64) into %ir.43)
4064B	  MOV64mr %77:gr64, 1, $noreg, -40, $noreg, %31:gr64 :: (store (s64) into %ir..repack72)
4080B	  MOV64mi32 %77:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack74)
4096B	  MOV64mr %77:gr64, 1, $noreg, -24, $noreg, %7:gr64_nosp :: (store (s64) into %ir..repack76)
4112B	  MOV64mi32 %77:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack78)
4128B	  %33:gr64 = LEA64r $noreg, 8, %8:gr64_nosp, 0, $noreg
4144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4160B	  $rdi = COPY %33:gr64
4176B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
4192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4208B	  %34:gr64 = COPY killed $rax
4240B	  TEST64rr %8:gr64_nosp, %8:gr64_nosp, implicit-def $eflags
4256B	  JCC_1 %bb.18, 14, implicit killed $eflags
4272B	  JMP_1 %bb.17

4288B	bb.17..lr.ph111.preheader:
	; predecessors: %bb.16
	  successors: %bb.18(0x80000000); %bb.18(100.00%)

4304B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4320B	  $rdi = COPY %34:gr64
4336B	  $rsi = COPY %33:gr64
4352B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
4368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

4384B	bb.18.._crit_edge112:
	; predecessors: %bb.16, %bb.17

4400B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4416B	  %81:gr64 = COPY $rsp
4432B	  %82:gr64 = LEA64r %81:gr64, 1, $noreg, -48, $noreg
4448B	  $rsp = COPY %82:gr64
4464B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4480B	  MOV64mr %81:gr64, 1, $noreg, -48, $noreg, %34:gr64 :: (store (s64) into %ir.46)
4496B	  MOV64mr %81:gr64, 1, $noreg, -40, $noreg, %34:gr64 :: (store (s64) into %ir..repack81)
4512B	  MOV64mi32 %81:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack83)
4528B	  MOV64mr %81:gr64, 1, $noreg, -24, $noreg, %8:gr64_nosp :: (store (s64) into %ir..repack85)
4544B	  MOV64mi32 %81:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack87)
4560B	  ADJCALLSTACKDOWN64 144, 0, 144, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4576B	  %84:gr64 = MOV64ri @read_input_2D_f64
4688B	  $edi = MOV32ri 1
4704B	  dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
4720B	  $rdx = MOV32ri64 3
4736B	  dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
4752B	  $r8 = MOV64ri32 -1
4768B	  $r9 = MOV32ri64 1
4784B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 136)
4800B	  PUSH64r %82:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 128)
4816B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 120)
4832B	  PUSH64r %32:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 112)
4848B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 104)
4864B	  PUSH64r %29:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 96)
4880B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 88)
4896B	  PUSH64r %26:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 80)
4912B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 72)
4928B	  PUSH64r %23:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 64)
4944B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 56)
4960B	  PUSH64r %20:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 48)
4976B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 40)
4992B	  PUSH64r %17:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 32)
5008B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 24)
5024B	  PUSH64r %14:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 16)
5040B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 8)
5056B	  PUSH64r %11:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
5072B	  CALL64r %84:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit killed $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $r9, implicit-def $rsp, implicit-def $ssp
5088B	  ADJCALLSTACKUP64 144, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5104B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5120B	  %91:gr64 = MOV64ri @comet_print_memref_i64
5136B	  $rdi = MOV32ri64 1
5152B	  $rsi = COPY %11:gr64
5168B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5184B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5200B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5216B	  $rdi = MOV32ri64 1
5232B	  $rsi = COPY %14:gr64
5248B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5264B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5296B	  $rdi = MOV32ri64 1
5312B	  $rsi = COPY %17:gr64
5328B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5344B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5360B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5376B	  $rdi = MOV32ri64 1
5392B	  $rsi = COPY %20:gr64
5408B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5424B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5456B	  $rdi = MOV32ri64 1
5472B	  $rsi = COPY %23:gr64
5488B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5504B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5520B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5536B	  $rdi = MOV32ri64 1
5552B	  $rsi = COPY %26:gr64
5568B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5584B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5600B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5616B	  $rdi = MOV32ri64 1
5632B	  $rsi = COPY %29:gr64
5648B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5664B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5680B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5696B	  $rdi = MOV32ri64 1
5712B	  $rsi = COPY %32:gr64
5728B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5744B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5760B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5776B	  %92:gr64 = MOV64ri @comet_print_memref_f64
5792B	  $rdi = MOV32ri64 1
5808B	  $rsi = COPY %82:gr64
5824B	  CALL64r %92:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
5840B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5856B	  RET 0

# End machine code for function main.

Before MISched:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=40, align=8, at location [SP+8]
  fi#1: variable sized, align=1, at location [SP+8]
  fi#2: variable sized, align=1, at location [SP+8]
  fi#3: variable sized, align=1, at location [SP+8]
  fi#4: variable sized, align=1, at location [SP+8]
  fi#5: variable sized, align=1, at location [SP+8]
  fi#6: variable sized, align=1, at location [SP+8]
  fi#7: variable sized, align=1, at location [SP+8]
  fi#8: variable sized, align=1, at location [SP+8]
  fi#9: variable sized, align=1, at location [SP+8]

bb.0 (%ir-block.0):
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %35:gr64 = MOV64ri @malloc
  $rdi = MOV32ri64 56
  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:gr64 = COPY killed $rax
  MOV64mr %stack.0, 1, $noreg, 0, $noreg, %37:gr64 :: (store (s64) into %ir.2)
  MOV64mr %stack.0, 1, $noreg, 8, $noreg, %37:gr64 :: (store (s64) into %ir..fca.1.gep)
  MOV64mi32 %stack.0, 1, $noreg, 16, $noreg, 0 :: (store (s64) into %ir..fca.2.gep)
  MOV64mi32 %stack.0, 1, $noreg, 24, $noreg, 7 :: (store (s64) into %ir..fca.3.0.gep)
  MOV64mi32 %stack.0, 1, $noreg, 32, $noreg, 1 :: (store (s64) into %ir..fca.4.0.gep)
  ADJCALLSTACKDOWN64 16, 0, 16, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %39:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  %40:gr64 = MOV64ri @read_input_sizes_2D_f64
  $edi = MOV32ri 1
  dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
  $rdx = MOV32ri64 3
  dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
  $r8 = MOV64ri32 -1
  $r9 = MOV32ri64 1
  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 8)
  PUSH64r %39:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
  CALL64r %40:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit killed $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $r9, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 16, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %0:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
  %1:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
  %2:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
  %3:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
  %4:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
  %5:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
  %6:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
  %7:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
  %8:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
  %9:gr64 = LEA64r $noreg, 8, %0:gr64_nosp, 0, $noreg
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = COPY killed $rax
  TEST64rr %0:gr64_nosp, %0:gr64_nosp, implicit-def $eflags
  %100:gr64 = MOV64ri &__bzero
  JCC_1 %bb.2, 14, implicit killed $eflags
  JMP_1 %bb.1

bb.1..lr.ph.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  $rsi = COPY %9:gr64
  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.2.._crit_edge:
; predecessors: %bb.0, %bb.1
  successors: %bb.3(0x50000000), %bb.4(0x30000000); %bb.3(62.50%), %bb.4(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %49:gr64 = COPY $rsp
  %11:gr64 = LEA64r %49:gr64, 1, $noreg, -48, $noreg
  $rsp = COPY %11:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %49:gr64, 1, $noreg, -48, $noreg, %10:gr64 :: (store (s64) into %ir.22)
  MOV64mr %49:gr64, 1, $noreg, -40, $noreg, %10:gr64 :: (store (s64) into %ir..repack9)
  MOV64mi32 %49:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack11)
  MOV64mr %49:gr64, 1, $noreg, -24, $noreg, %0:gr64_nosp :: (store (s64) into %ir..repack13)
  MOV64mi32 %49:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack15)
  %12:gr64 = LEA64r $noreg, 8, %1:gr64_nosp, 0, $noreg
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %12:gr64
  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %13:gr64 = COPY killed $rax
  TEST64rr %1:gr64_nosp, %1:gr64_nosp, implicit-def $eflags
  JCC_1 %bb.4, 14, implicit killed $eflags
  JMP_1 %bb.3

bb.3..lr.ph90.preheader:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %13:gr64
  $rsi = COPY %12:gr64
  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.4.._crit_edge91:
; predecessors: %bb.2, %bb.3
  successors: %bb.5(0x50000000), %bb.6(0x30000000); %bb.5(62.50%), %bb.6(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %53:gr64 = COPY $rsp
  %14:gr64 = LEA64r %53:gr64, 1, $noreg, -48, $noreg
  $rsp = COPY %14:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %53:gr64, 1, $noreg, -48, $noreg, %13:gr64 :: (store (s64) into %ir.25)
  MOV64mr %53:gr64, 1, $noreg, -40, $noreg, %13:gr64 :: (store (s64) into %ir..repack18)
  MOV64mi32 %53:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack20)
  MOV64mr %53:gr64, 1, $noreg, -24, $noreg, %1:gr64_nosp :: (store (s64) into %ir..repack22)
  MOV64mi32 %53:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack24)
  %15:gr64 = LEA64r $noreg, 8, %2:gr64_nosp, 0, $noreg
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %15:gr64
  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %16:gr64 = COPY killed $rax
  TEST64rr %2:gr64_nosp, %2:gr64_nosp, implicit-def $eflags
  JCC_1 %bb.6, 14, implicit killed $eflags
  JMP_1 %bb.5

bb.5..lr.ph93.preheader:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %16:gr64
  $rsi = COPY %15:gr64
  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.6.._crit_edge94:
; predecessors: %bb.4, %bb.5
  successors: %bb.7(0x50000000), %bb.8(0x30000000); %bb.7(62.50%), %bb.8(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr64 = COPY $rsp
  %17:gr64 = LEA64r %57:gr64, 1, $noreg, -48, $noreg
  $rsp = COPY %17:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %57:gr64, 1, $noreg, -48, $noreg, %16:gr64 :: (store (s64) into %ir.28)
  MOV64mr %57:gr64, 1, $noreg, -40, $noreg, %16:gr64 :: (store (s64) into %ir..repack27)
  MOV64mi32 %57:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack29)
  MOV64mr %57:gr64, 1, $noreg, -24, $noreg, %2:gr64_nosp :: (store (s64) into %ir..repack31)
  MOV64mi32 %57:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack33)
  %18:gr64 = LEA64r $noreg, 8, %3:gr64_nosp, 0, $noreg
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %18:gr64
  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %19:gr64 = COPY killed $rax
  TEST64rr %3:gr64_nosp, %3:gr64_nosp, implicit-def $eflags
  JCC_1 %bb.8, 14, implicit killed $eflags
  JMP_1 %bb.7

bb.7..lr.ph96.preheader:
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %19:gr64
  $rsi = COPY %18:gr64
  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.8.._crit_edge97:
; predecessors: %bb.6, %bb.7
  successors: %bb.9(0x50000000), %bb.10(0x30000000); %bb.9(62.50%), %bb.10(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %61:gr64 = COPY $rsp
  %20:gr64 = LEA64r %61:gr64, 1, $noreg, -48, $noreg
  $rsp = COPY %20:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %61:gr64, 1, $noreg, -48, $noreg, %19:gr64 :: (store (s64) into %ir.31)
  MOV64mr %61:gr64, 1, $noreg, -40, $noreg, %19:gr64 :: (store (s64) into %ir..repack36)
  MOV64mi32 %61:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack38)
  MOV64mr %61:gr64, 1, $noreg, -24, $noreg, %3:gr64_nosp :: (store (s64) into %ir..repack40)
  MOV64mi32 %61:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack42)
  %21:gr64 = LEA64r $noreg, 8, %4:gr64_nosp, 0, $noreg
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %21:gr64
  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %22:gr64 = COPY killed $rax
  TEST64rr %4:gr64_nosp, %4:gr64_nosp, implicit-def $eflags
  JCC_1 %bb.10, 14, implicit killed $eflags
  JMP_1 %bb.9

bb.9..lr.ph99.preheader:
; predecessors: %bb.8
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %22:gr64
  $rsi = COPY %21:gr64
  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.10.._crit_edge100:
; predecessors: %bb.8, %bb.9
  successors: %bb.11(0x50000000), %bb.12(0x30000000); %bb.11(62.50%), %bb.12(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %65:gr64 = COPY $rsp
  %23:gr64 = LEA64r %65:gr64, 1, $noreg, -48, $noreg
  $rsp = COPY %23:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %65:gr64, 1, $noreg, -48, $noreg, %22:gr64 :: (store (s64) into %ir.34)
  MOV64mr %65:gr64, 1, $noreg, -40, $noreg, %22:gr64 :: (store (s64) into %ir..repack45)
  MOV64mi32 %65:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack47)
  MOV64mr %65:gr64, 1, $noreg, -24, $noreg, %4:gr64_nosp :: (store (s64) into %ir..repack49)
  MOV64mi32 %65:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack51)
  %24:gr64 = LEA64r $noreg, 8, %5:gr64_nosp, 0, $noreg
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %24:gr64
  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr64 = COPY killed $rax
  TEST64rr %5:gr64_nosp, %5:gr64_nosp, implicit-def $eflags
  JCC_1 %bb.12, 14, implicit killed $eflags
  JMP_1 %bb.11

bb.11..lr.ph102.preheader:
; predecessors: %bb.10
  successors: %bb.12(0x80000000); %bb.12(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %25:gr64
  $rsi = COPY %24:gr64
  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.12.._crit_edge103:
; predecessors: %bb.10, %bb.11
  successors: %bb.13(0x50000000), %bb.14(0x30000000); %bb.13(62.50%), %bb.14(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %69:gr64 = COPY $rsp
  %26:gr64 = LEA64r %69:gr64, 1, $noreg, -48, $noreg
  $rsp = COPY %26:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %69:gr64, 1, $noreg, -48, $noreg, %25:gr64 :: (store (s64) into %ir.37)
  MOV64mr %69:gr64, 1, $noreg, -40, $noreg, %25:gr64 :: (store (s64) into %ir..repack54)
  MOV64mi32 %69:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack56)
  MOV64mr %69:gr64, 1, $noreg, -24, $noreg, %5:gr64_nosp :: (store (s64) into %ir..repack58)
  MOV64mi32 %69:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack60)
  %27:gr64 = LEA64r $noreg, 8, %6:gr64_nosp, 0, $noreg
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %27:gr64
  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %28:gr64 = COPY killed $rax
  TEST64rr %6:gr64_nosp, %6:gr64_nosp, implicit-def $eflags
  JCC_1 %bb.14, 14, implicit killed $eflags
  JMP_1 %bb.13

bb.13..lr.ph105.preheader:
; predecessors: %bb.12
  successors: %bb.14(0x80000000); %bb.14(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %28:gr64
  $rsi = COPY %27:gr64
  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.14.._crit_edge106:
; predecessors: %bb.12, %bb.13
  successors: %bb.15(0x50000000), %bb.16(0x30000000); %bb.15(62.50%), %bb.16(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %73:gr64 = COPY $rsp
  %29:gr64 = LEA64r %73:gr64, 1, $noreg, -48, $noreg
  $rsp = COPY %29:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %73:gr64, 1, $noreg, -48, $noreg, %28:gr64 :: (store (s64) into %ir.40)
  MOV64mr %73:gr64, 1, $noreg, -40, $noreg, %28:gr64 :: (store (s64) into %ir..repack63)
  MOV64mi32 %73:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack65)
  MOV64mr %73:gr64, 1, $noreg, -24, $noreg, %6:gr64_nosp :: (store (s64) into %ir..repack67)
  MOV64mi32 %73:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack69)
  %30:gr64 = LEA64r $noreg, 8, %7:gr64_nosp, 0, $noreg
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %30:gr64
  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %31:gr64 = COPY killed $rax
  TEST64rr %7:gr64_nosp, %7:gr64_nosp, implicit-def $eflags
  JCC_1 %bb.16, 14, implicit killed $eflags
  JMP_1 %bb.15

bb.15..lr.ph108.preheader:
; predecessors: %bb.14
  successors: %bb.16(0x80000000); %bb.16(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %31:gr64
  $rsi = COPY %30:gr64
  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.16.._crit_edge109:
; predecessors: %bb.14, %bb.15
  successors: %bb.17(0x50000000), %bb.18(0x30000000); %bb.17(62.50%), %bb.18(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %77:gr64 = COPY $rsp
  %32:gr64 = LEA64r %77:gr64, 1, $noreg, -48, $noreg
  $rsp = COPY %32:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %77:gr64, 1, $noreg, -48, $noreg, %31:gr64 :: (store (s64) into %ir.43)
  MOV64mr %77:gr64, 1, $noreg, -40, $noreg, %31:gr64 :: (store (s64) into %ir..repack72)
  MOV64mi32 %77:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack74)
  MOV64mr %77:gr64, 1, $noreg, -24, $noreg, %7:gr64_nosp :: (store (s64) into %ir..repack76)
  MOV64mi32 %77:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack78)
  %33:gr64 = LEA64r $noreg, 8, %8:gr64_nosp, 0, $noreg
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %33:gr64
  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %34:gr64 = COPY killed $rax
  TEST64rr %8:gr64_nosp, %8:gr64_nosp, implicit-def $eflags
  JCC_1 %bb.18, 14, implicit killed $eflags
  JMP_1 %bb.17

bb.17..lr.ph111.preheader:
; predecessors: %bb.16
  successors: %bb.18(0x80000000); %bb.18(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %34:gr64
  $rsi = COPY %33:gr64
  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.18.._crit_edge112:
; predecessors: %bb.16, %bb.17

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %81:gr64 = COPY $rsp
  %82:gr64 = LEA64r %81:gr64, 1, $noreg, -48, $noreg
  $rsp = COPY %82:gr64
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %81:gr64, 1, $noreg, -48, $noreg, %34:gr64 :: (store (s64) into %ir.46)
  MOV64mr %81:gr64, 1, $noreg, -40, $noreg, %34:gr64 :: (store (s64) into %ir..repack81)
  MOV64mi32 %81:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack83)
  MOV64mr %81:gr64, 1, $noreg, -24, $noreg, %8:gr64_nosp :: (store (s64) into %ir..repack85)
  MOV64mi32 %81:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack87)
  ADJCALLSTACKDOWN64 144, 0, 144, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %84:gr64 = MOV64ri @read_input_2D_f64
  $edi = MOV32ri 1
  dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
  $rdx = MOV32ri64 3
  dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
  $r8 = MOV64ri32 -1
  $r9 = MOV32ri64 1
  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 136)
  PUSH64r %82:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 128)
  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 120)
  PUSH64r %32:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 112)
  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 104)
  PUSH64r %29:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 96)
  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 88)
  PUSH64r %26:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 80)
  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 72)
  PUSH64r %23:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 64)
  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 56)
  PUSH64r %20:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 48)
  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 40)
  PUSH64r %17:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 32)
  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 24)
  PUSH64r %14:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 16)
  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 8)
  PUSH64r %11:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
  CALL64r %84:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit killed $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $r9, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 144, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %91:gr64 = MOV64ri @comet_print_memref_i64
  $rdi = MOV32ri64 1
  $rsi = COPY %11:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 1
  $rsi = COPY %14:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 1
  $rsi = COPY %17:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 1
  $rsi = COPY %20:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 1
  $rsi = COPY %23:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 1
  $rsi = COPY %26:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 1
  $rsi = COPY %29:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 1
  $rsi = COPY %32:gr64
  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %92:gr64 = MOV64ri @comet_print_memref_f64
  $rdi = MOV32ri64 1
  $rsi = COPY %82:gr64
  CALL64r %92:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  RET 0

# End machine code for function main.

AllocationOrder(GR32) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $r14d $r15d $r12d $r13d ]
AllocationOrder(GR16) = [ $ax $cx $dx $si $di $r8w $r9w $r10w $r11w $bx $r14w $r15w $r12w $r13w ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $r14b $r15b $r12b $r13b ]
********** MI Scheduling **********
main:%bb.0 
  From: %10:gr64 = COPY killed $rax
    To: JCC_1 %bb.2, 14, implicit killed $eflags
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Macro fuse: SU(1) - ExitSU /  TEST64rr - JCC_1
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %10:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   TEST64rr %0:gr64_nosp, %0:gr64_nosp, implicit-def $eflags
  # preds left       : 2
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Single Issue       : false;
SU(2):   %100:gr64 = MOV64ri &__bzero
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.2, 14, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) TEST64rr %0:gr64_nosp, %0:gr64_nosp, implicit-def $eflags
handleMove 768B -> 792B: TEST64rr %0:gr64_nosp, %0:gr64_nosp, implicit-def $eflags
     %0:	[512r,1072r:0) 0@512r
        -->	[512r,1072r:0) 0@512r
     EFLAGS:	[16r,16d:90)[96r,96d:89)[208r,208d:88)[368r,368d:3)[400r,400d:2)[496r,496d:87)[672r,672d:86)[720r,720d:85)[792r,800r:84)[848r,848d:83)[912r,912d:82)[944r,944d:81)[1008r,1008d:80)[1120r,1120d:79)[1168r,1168d:78)[1216r,1232r:77)[1280r,1280d:76)[1344r,1344d:75)[1376r,1376d:74)[1440r,1440d:73)[1552r,1552d:72)[1600r,1600d:71)[1648r,1664r:70)[1712r,1712d:69)[1776r,1776d:68)[1808r,1808d:67)[1872r,1872d:66)[1984r,1984d:65)[2032r,2032d:64)[2080r,2096r:63)[2144r,2144d:62)[2208r,2208d:61)[2240r,2240d:60)[2304r,2304d:59)[2416r,2416d:58)[2464r,2464d:57)[2512r,2528r:56)[2576r,2576d:55)[2640r,2640d:54)[2672r,2672d:53)[2736r,2736d:52)[2848r,2848d:51)[2896r,2896d:50)[2944r,2960r:49)[3008r,3008d:48)[3072r,3072d:47)[3104r,3104d:46)[3168r,3168d:45)[3280r,3280d:44)[3328r,3328d:43)[3376r,3392r:42)[3440r,3440d:41)[3504r,3504d:40)[3536r,3536d:39)[3600r,3600d:38)[3712r,3712d:37)[3760r,3760d:36)[3808r,3824r:35)[3872r,3872d:34)[3936r,3936d:33)[3968r,3968d:32)[4032r,4032d:31)[4144r,4144d:30)[4192r,4192d:29)[4240r,4256r:28)[4304r,4304d:27)[4368r,4368d:26)[4400r,4400d:25)[4464r,4464d:24)[4560r,4560d:23)[4704r,4704d:1)[4736r,4736d:0)[5088r,5088d:22)[5104r,5104d:21)[5184r,5184d:20)[5200r,5200d:19)[5264r,5264d:18)[5280r,5280d:17)[5344r,5344d:16)[5360r,5360d:15)[5424r,5424d:14)[5440r,5440d:13)[5504r,5504d:12)[5520r,5520d:11)[5584r,5584d:10)[5600r,5600d:9)[5664r,5664d:8)[5680r,5680d:7)[5744r,5744d:6)[5760r,5760d:5)[5840r,5840d:4) 0@4736r 1@4704r 2@400r 3@368r 4@5840r 5@5760r 6@5744r 7@5680r 8@5664r 9@5600r 10@5584r 11@5520r 12@5504r 13@5440r 14@5424r 15@5360r 16@5344r 17@5280r 18@5264r 19@5200r 20@5184r 21@5104r 22@5088r 23@4560r 24@4464r 25@4400r 26@4368r 27@4304r 28@4240r 29@4192r 30@4144r 31@4032r 32@3968r 33@3936r 34@3872r 35@3808r 36@3760r 37@3712r 38@3600r 39@3536r 40@3504r 41@3440r 42@3376r 43@3328r 44@3280r 45@3168r 46@3104r 47@3072r 48@3008r 49@2944r 50@2896r 51@2848r 52@2736r 53@2672r 54@2640r 55@2576r 56@2512r 57@2464r 58@2416r 59@2304r 60@2240r 61@2208r 62@2144r 63@2080r 64@2032r 65@1984r 66@1872r 67@1808r 68@1776r 69@1712r 70@1648r 71@1600r 72@1552r 73@1440r 74@1376r 75@1344r 76@1280r 77@1216r 78@1168r 79@1120r 80@1008r 81@944r 82@912r 83@848r 84@792r 85@720r 86@672r 87@496r 88@208r 89@96r 90@16r
        -->	[16r,16d:90)[96r,96d:89)[208r,208d:88)[368r,368d:3)[400r,400d:2)[496r,496d:87)[672r,672d:86)[720r,720d:85)[792r,800r:84)[848r,848d:83)[912r,912d:82)[944r,944d:81)[1008r,1008d:80)[1120r,1120d:79)[1168r,1168d:78)[1216r,1232r:77)[1280r,1280d:76)[1344r,1344d:75)[1376r,1376d:74)[1440r,1440d:73)[1552r,1552d:72)[1600r,1600d:71)[1648r,1664r:70)[1712r,1712d:69)[1776r,1776d:68)[1808r,1808d:67)[1872r,1872d:66)[1984r,1984d:65)[2032r,2032d:64)[2080r,2096r:63)[2144r,2144d:62)[2208r,2208d:61)[2240r,2240d:60)[2304r,2304d:59)[2416r,2416d:58)[2464r,2464d:57)[2512r,2528r:56)[2576r,2576d:55)[2640r,2640d:54)[2672r,2672d:53)[2736r,2736d:52)[2848r,2848d:51)[2896r,2896d:50)[2944r,2960r:49)[3008r,3008d:48)[3072r,3072d:47)[3104r,3104d:46)[3168r,3168d:45)[3280r,3280d:44)[3328r,3328d:43)[3376r,3392r:42)[3440r,3440d:41)[3504r,3504d:40)[3536r,3536d:39)[3600r,3600d:38)[3712r,3712d:37)[3760r,3760d:36)[3808r,3824r:35)[3872r,3872d:34)[3936r,3936d:33)[3968r,3968d:32)[4032r,4032d:31)[4144r,4144d:30)[4192r,4192d:29)[4240r,4256r:28)[4304r,4304d:27)[4368r,4368d:26)[4400r,4400d:25)[4464r,4464d:24)[4560r,4560d:23)[4704r,4704d:1)[4736r,4736d:0)[5088r,5088d:22)[5104r,5104d:21)[5184r,5184d:20)[5200r,5200d:19)[5264r,5264d:18)[5280r,5280d:17)[5344r,5344d:16)[5360r,5360d:15)[5424r,5424d:14)[5440r,5440d:13)[5504r,5504d:12)[5520r,5520d:11)[5584r,5584d:10)[5600r,5600d:9)[5664r,5664d:8)[5680r,5680d:7)[5744r,5744d:6)[5760r,5760d:5)[5840r,5840d:4) 0@4736r 1@4704r 2@400r 3@368r 4@5840r 5@5760r 6@5744r 7@5680r 8@5664r 9@5600r 10@5584r 11@5520r 12@5504r 13@5440r 14@5424r 15@5360r 16@5344r 17@5280r 18@5264r 19@5200r 20@5184r 21@5104r 22@5088r 23@4560r 24@4464r 25@4400r 26@4368r 27@4304r 28@4240r 29@4192r 30@4144r 31@4032r 32@3968r 33@3936r 34@3872r 35@3808r 36@3760r 37@3712r 38@3600r 39@3536r 40@3504r 41@3440r 42@3376r 43@3328r 44@3280r 45@3168r 46@3104r 47@3072r 48@3008r 49@2944r 50@2896r 51@2848r 52@2736r 53@2672r 54@2640r 55@2576r 56@2512r 57@2464r 58@2416r 59@2304r 60@2240r 61@2208r 62@2144r 63@2080r 64@2032r 65@1984r 66@1872r 67@1808r 68@1776r 69@1712r 70@1648r 71@1600r 72@1552r 73@1440r 74@1376r 75@1344r 76@1280r 77@1216r 78@1168r 79@1120r 80@1008r 81@944r 82@912r 83@848r 84@792r 85@720r 86@672r 87@496r 88@208r 89@96r 90@16r
  Ready @0c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 
  Cand SU(0) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) %100:gr64 = MOV64ri &__bzero
  Ready @0c
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %10:gr64 = COPY killed $rax
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %10:gr64 = COPY killed $rax
SU(2):   %100:gr64 = MOV64ri &__bzero
SU(1):   TEST64rr %0:gr64_nosp, %0:gr64_nosp, implicit-def $eflags

********** MI Scheduling **********
main:%bb.0 
  From: %0:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 10
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GR16=20
Live In: %37 
Live Out: %9 %0 %8 %7 %6 %5 %4 %3 %2 %1 
Live Thru: 
  LiveReg: %9
  LiveReg: %0
  UpdateRegP: SU(9) %9:gr64 = LEA64r $noreg, 8, %0:gr64_nosp, 0, $noreg
              to GR16 -2
  LiveReg: %8
  LiveReg: %7
  LiveReg: %6
  LiveReg: %5
  LiveReg: %4
  LiveReg: %3
  LiveReg: %2
  LiveReg: %1
Top Pressure:
GR16=2
Bottom Pressure:
GR16=20
AllocationOrder(SEGMENT_REG) = [ ]
AllocationOrder(GR32_BPSP) = [ ] (sub-class)
AllocationOrder(GR32_BPSP) = [ ] (sub-class)
AllocationOrder(GR32_BSI) = [ $esi $ebx ] (sub-class)
AllocationOrder(GR32_BSI) = [ $esi $ebx ] (sub-class)
AllocationOrder(GR32_DIBP) = [ $edi ] (sub-class)
AllocationOrder(GR32_DIBP) = [ $edi ] (sub-class)
AllocationOrder(RFP32) = [ $fp0 $fp1 $fp2 $fp3 $fp4 $fp5 $fp6 ]
AllocationOrder(GR8_ABCD_H) = [ $ah $ch $dh $bh ] (sub-class)
AllocationOrder(GR8_ABCD_L) = [ $al $cl $dl $bl ] (sub-class)
AllocationOrder(VK1) = [ $k0 $k1 $k2 $k3 $k4 $k5 $k6 $k7 ]
AllocationOrder(VR64) = [ $mm0 $mm1 $mm2 $mm3 $mm4 $mm5 $mm6 $mm7 ]
AllocationOrder(TILE) = [ $tmm0 $tmm1 $tmm2 $tmm3 $tmm4 $tmm5 $tmm6 $tmm7 ]
AllocationOrder(GR8_NOREX) = [ $al $cl $dl $bl ]
AllocationOrder(GR64) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 ]
AllocationOrder(GR64_NOREX_and_GR64_TCW64) = [ $rax $rcx $rdx ] (sub-class)
AllocationOrder(GR64_NOREX_and_GR64_TCW64) = [ $rax $rcx $rdx ] (sub-class)
AllocationOrder(FR16) = [ $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 ]
AllocationOrder(DEBUG_REG) = [ $dr0 $dr1 $dr2 $dr3 $dr4 $dr5 $dr6 $dr7 $dr8 $dr9 $dr10 $dr11 $dr12 $dr13 $dr14 $dr15 ]
AllocationOrder(CONTROL_REG) = [ $cr0 $cr1 $cr2 $cr3 $cr4 $cr5 $cr6 $cr7 $cr8 $cr9 $cr10 $cr11 $cr12 $cr13 $cr14 $cr15 ]
AllocationOrder(GR64_NOREX) = [ $rax $rcx $rdx $rsi $rdi $rbx ] (sub-class)
AllocationOrder(GR64_TCW64) = [ $rax $rcx $rdx $r8 $r9 $r10 $r11 ] (sub-class)
AllocationOrder(GR64_TCW64) = [ $rax $rcx $rdx $r8 $r9 $r10 $r11 ] (sub-class)
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR64_TC) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r11 ] (sub-class)
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR64_TC) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r11 ] (sub-class)
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR64PLTSafe) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $rbx $r14 $r15 $r12 $r13 ] (sub-class)
AllocationOrder(FR16X) = [ $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 ]
AllocationOrder(LOW32_ADDR_ACCESS_RBP) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $r14d $r15d $r12d $r13d ]
Excess PSets: 
SU(0):   %0:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 5
  Successors:
    SU(9): Data Latency=5 Reg=%0
  Pressure Diff      : 
  Single Issue       : false;
SU(1):   %1:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 4
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Pressure Diff      : 
  Single Issue       : false;
SU(2):   %2:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 4
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Pressure Diff      : 
  Single Issue       : false;
SU(3):   %3:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 4
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Pressure Diff      : 
  Single Issue       : false;
SU(4):   %4:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 4
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Pressure Diff      : 
  Single Issue       : false;
SU(5):   %5:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 4
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Pressure Diff      : 
  Single Issue       : false;
SU(6):   %6:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 4
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   %7:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 4
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Pressure Diff      : 
  Single Issue       : false;
SU(8):   %8:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 4
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Pressure Diff      : 
  Single Issue       : false;
SU(9):   %9:gr64 = LEA64r $noreg, 8, %0:gr64_nosp, 0, $noreg
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(0): Data Latency=5 Reg=%0
  Pressure Diff      : GR16 -2
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 8
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(8): Ord  Latency=4 Artificial
    SU(7): Ord  Latency=4 Artificial
    SU(6): Ord  Latency=4 Artificial
    SU(5): Ord  Latency=4 Artificial
    SU(4): Ord  Latency=4 Artificial
    SU(3): Ord  Latency=4 Artificial
    SU(2): Ord  Latency=4 Artificial
    SU(1): Ord  Latency=4 Artificial
Critical Path(GS-RR ): 5
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 9 8 7 6 5 4 3 2 1 
  Cand SU(9) ORDER                              
Pick Bot ORDER     
Scheduling SU(9) %9:gr64 = LEA64r $noreg, 8, %0:gr64_nosp, 0, $noreg
Bottom Pressure:
GR16=18
  Ready @0c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
  BotQ.A TopLatency SU(9) 5c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 8 7 6 5 4 3 2 0 
  Cand SU(1) ORDER                              
  Cand SU(8) ORDER                              
Pick Bot ORDER     
Scheduling SU(8) %8:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
Bottom Pressure:
GR16=18
  LiveReg: %37
  UpdateRegP: SU(0) %0:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
              to GR16 -2
  UpdateRegP: SU(1) %1:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
              to GR16 -2
  UpdateRegP: SU(2) %2:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
              to GR16 -2
  UpdateRegP: SU(3) %3:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
              to GR16 -2
  UpdateRegP: SU(4) %4:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
              to GR16 -2
  UpdateRegP: SU(5) %5:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
              to GR16 -2
  UpdateRegP: SU(6) %6:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
              to GR16 -2
  UpdateRegP: SU(7) %7:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
              to GR16 -2
  UpdateRegP: SU(8) %8:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
              to GR16 -2
  Ready @4c
  SKLPort23 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(8) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 7 6 5 4 3 2 
  Cand SU(1) ORDER                              
  Cand SU(7) ORDER                              
Pick Bot ORDER     
Scheduling SU(7) %7:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
Bottom Pressure:
GR16=16
  Ready @4c
  SKLPort23 +1x12u
  *** Critical resource SKLPort23: 1c
  SKLPort237 +1x8u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 2 SKLPort23
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 2 6 5 4 3 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) %6:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
Bottom Pressure:
GR16=14
  Ready @4c
  SKLPort23 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 4
  Executed: 1c
  Critical: 1c, 3 SKLPort23
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 2 3 5 4 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %5:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
Bottom Pressure:
GR16=12
  Ready @4c
  SKLPort23 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 5
  Executed: 2c
  Critical: 2c, 4 SKLPort23
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 2 3 4 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %4:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
Bottom Pressure:
GR16=10
  Ready @4c
  SKLPort23 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +1x3u
  *** Max MOps 6 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 6
  Executed: 2c
  Critical: 2c, 5 SKLPort23
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 2 3 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %3:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
Bottom Pressure:
GR16=8
  Ready @4c
  SKLPort23 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +1x3u
BotQ.A @1c
  Retired: 7
  Executed: 3c
  Critical: 3c, 6 SKLPort23
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %2:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
Bottom Pressure:
GR16=6
  Ready @4c
  SKLPort23 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +1x3u
BotQ.A @1c
  Retired: 8
  Executed: 3c
  Critical: 3c, 7 SKLPort23
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %1:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
Bottom Pressure:
GR16=4
  Ready @4c
  SKLPort23 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +1x3u
BotQ.A @1c
  Retired: 9
  Executed: 4c
  Critical: 4c, 8 SKLPort23
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %0:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
Bottom Pressure:
GR16=2
  Ready @5c
  SKLPort23 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(0) 5c
BotQ.A @1c
  Retired: 10
  Executed: 4c
  Critical: 4c, 9 SKLPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %0:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
SU(1):   %1:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
SU(2):   %2:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
SU(3):   %3:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
SU(4):   %4:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
SU(5):   %5:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
SU(6):   %6:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
SU(7):   %7:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
SU(8):   %8:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
SU(9):   %9:gr64 = LEA64r $noreg, 8, %0:gr64_nosp, 0, $noreg

********** MI Scheduling **********
main:%bb.0 
  From: %39:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
    To: PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 8)
 RegionInstrs: 8
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP_with_GR32_SIDI=2
GR32_DIBP_with_LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H_with_GR32_BSI=3
GR8_ABCD_L_with_GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP_with_GR32_TC=4
GR64_NOREX=6
GR64_TCW64=6
GR32_BPSP_with_GR64_TCW64=6
GR8=8
GR8_with_GR32_DIBP=8
GR8_with_GR32_BSI=8
GR64_TC_with_GR64_TCW64=8
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=8
GR8_with_GR64_NOREX=8
GR64_TC=8
GR8_with_GR64_TCW64=8
GR8_with_GR64_TC=8
GR8_with_GR64PLTSafe=8
GR16=12
Live In: 
Live Out: R9B R9BH R9WH R8B R8BH R8WH CH CL HCX DH DL HDX SIL SIH HSI DIL DIH HDI %40 %39 
Live Thru: 
  LiveReg: %40
  LiveReg: %39
Top Pressure:

Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP_with_GR32_SIDI=2
GR32_DIBP_with_LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H_with_GR32_BSI=3
GR8_ABCD_L_with_GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP_with_GR32_TC=4
GR64_NOREX=6
GR64_TCW64=6
GR32_BPSP_with_GR64_TCW64=6
GR8=8
GR8_with_GR32_DIBP=8
GR8_with_GR32_BSI=8
GR64_TC_with_GR64_TCW64=8
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=8
GR8_with_GR64_NOREX=8
GR64_TC=8
GR8_with_GR64_TCW64=8
GR8_with_GR64_TC=8
GR8_with_GR64PLTSafe=8
GR16=12
Excess PSets: 
SU(0):   %39:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(1):   %40:gr64 = MOV64ri @read_input_sizes_2D_f64
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(2):   $edi = MOV32ri 1
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR32_BPSP -1    GR32_SIDI -1    GR32_DIBP_with_GR32_SIDI -1    GR32_DIBP_with_LOW32_ADDR_ACCESS_with_sub_32bit -1    GR64_NOREX -1    GR8 -1    GR8_with_GR32_DIBP -1    GR8_with_GR32_BSI -1    GR64_TC_with_GR64_TCW64 -1    GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8_with_GR64_NOREX -1    GR64_TC -1    GR8_with_GR64_TCW64 -1    GR8_with_GR64_TC -1    GR8_with_GR64PLTSafe -1    GR16 -1
  Single Issue       : false;
SU(3):   dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR32_BSI -1    GR32_SIDI -1    GR32_DIBP_with_GR32_SIDI -1    GR8_ABCD_H_with_GR32_BSI -1    GR8_ABCD_L_with_GR32_BSI -1    GR8_NOREX -1    GR64_NOREX -1    GR8 -1    GR8_with_GR32_DIBP -1    GR8_with_GR32_BSI -1    GR64_TC_with_GR64_TCW64 -1    GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8_with_GR64_NOREX -1    GR64_TC -1    GR8_with_GR64_TCW64 -1    GR8_with_GR64_TC -1
  Single Issue       : false;
SU(4):   $rdx = MOV32ri64 3
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR8_ABCD_H_with_GR32_BSI -1    GR8_ABCD_L_with_GR32_BSI -1    GR8_NOREX -2    GR32_TC -2    GR32_BPSP_with_GR32_TC -2    GR64_NOREX -2    GR64_TCW64 -2    GR32_BPSP_with_GR64_TCW64 -2    GR8 -2    GR8_with_GR32_DIBP -2    GR8_with_GR32_BSI -2    GR64_TC_with_GR64_TCW64 -2    GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit -2    GR8_with_GR64_NOREX -2    GR64_TC -2    GR8_with_GR64_TCW64 -2
  Single Issue       : false;
SU(5):   dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR32_BSI -2    GR8_ABCD_H_with_GR32_BSI -1    GR8_ABCD_L_with_GR32_BSI -1    GR8_NOREX -2    GR32_TC -2    GR32_BPSP_with_GR32_TC -2    GR64_NOREX -2    GR64_TCW64 -2    GR32_BPSP_with_GR64_TCW64 -2    GR8 -2    GR8_with_GR32_DIBP -2    GR8_with_GR32_BSI -2    GR64_TC_with_GR64_TCW64 -2    GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit -2    GR8_with_GR64_NOREX -2    GR64_TC -2
  Single Issue       : false;
SU(6):   $r8 = MOV64ri32 -1
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR64_TCW64 -1    GR32_BPSP_with_GR64_TCW64 -1    GR8 -1    GR8_with_GR32_DIBP -1    GR8_with_GR32_BSI -1    GR64_TC_with_GR64_TCW64 -1    GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8_with_GR64_NOREX -1    GR64_TC -1    GR8_with_GR64_TCW64 -1    GR8_with_GR64_TC -1    GR8_with_GR64PLTSafe -1    GR16 -1
  Single Issue       : false;
SU(7):   $r9 = MOV32ri64 1
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR64_TCW64 -1    GR32_BPSP_with_GR64_TCW64 -1    GR8 -1    GR8_with_GR32_DIBP -1    GR8_with_GR32_BSI -1    GR64_TC_with_GR64_TCW64 -1    GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8_with_GR64_NOREX -1    GR64_TC -1    GR8_with_GR64_TCW64 -1    GR8_with_GR64_TC -1    GR8_with_GR64PLTSafe -1    GR16 -1
  Single Issue       : false;
ExitSU:   PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 8)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 6 5 4 3 2 1 0 
  Cand SU(7) ORDER                              
  Cand SU(6) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(6) $r8 = MOV64ri32 -1
handleMove 416B -> 440B: $r8 = MOV64ri32 -1
     R8B:	[440r,480r:1)[4752r,5072r:0) 0@4752r 1@440r
        -->	[440r,480r:1)[4752r,5072r:0) 0@4752r 1@440r
     R8BH:	[440r,480r:1)[4752r,5072r:0) 0@4752r 1@440r
        -->	[440r,480r:1)[4752r,5072r:0) 0@4752r 1@440r
     R8WH:	[440r,480r:1)[4752r,5072r:0) 0@4752r 1@440r
        -->	[440r,480r:1)[4752r,5072r:0) 0@4752r 1@440r
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP_with_GR32_SIDI=2
GR32_DIBP_with_LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H_with_GR32_BSI=3
GR8_ABCD_L_with_GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP_with_GR32_TC=4
GR64_NOREX=6
GR64_TCW64=5
GR32_BPSP_with_GR64_TCW64=5
GR8=7
GR8_with_GR32_DIBP=7
GR8_with_GR32_BSI=7
GR64_TC_with_GR64_TCW64=7
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=7
GR8_with_GR64_NOREX=7
GR64_TC=7
GR8_with_GR64_TCW64=7
GR8_with_GR64_TC=7
GR8_with_GR64PLTSafe=7
GR16=11
  Ready @0c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 0 5 4 3 2 1 
  Cand SU(7) ORDER                              
  Cand SU(5) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(5) dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
handleMove 400B -> 436B: dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
     CH:	[436r,480r:1)[4736r,5072r:0) 0@4736r 1@436r
        -->	[436r,480r:1)[4736r,5072r:0) 0@4736r 1@436r
     CL:	[436r,480r:1)[4736r,5072r:0) 0@4736r 1@436r
        -->	[436r,480r:1)[4736r,5072r:0) 0@4736r 1@436r
     HCX:	[436r,480r:1)[4736r,5072r:0) 0@4736r 1@436r
        -->	[436r,480r:1)[4736r,5072r:0) 0@4736r 1@436r
     EFLAGS:	[16r,16d:90)[96r,96d:89)[208r,208d:88)[368r,368d:3)[400r,400d:2)[496r,496d:87)[672r,672d:86)[720r,720d:85)[792r,800r:84)[848r,848d:83)[912r,912d:82)[944r,944d:81)[1008r,1008d:80)[1120r,1120d:79)[1168r,1168d:78)[1216r,1232r:77)[1280r,1280d:76)[1344r,1344d:75)[1376r,1376d:74)[1440r,1440d:73)[1552r,1552d:72)[1600r,1600d:71)[1648r,1664r:70)[1712r,1712d:69)[1776r,1776d:68)[1808r,1808d:67)[1872r,1872d:66)[1984r,1984d:65)[2032r,2032d:64)[2080r,2096r:63)[2144r,2144d:62)[2208r,2208d:61)[2240r,2240d:60)[2304r,2304d:59)[2416r,2416d:58)[2464r,2464d:57)[2512r,2528r:56)[2576r,2576d:55)[2640r,2640d:54)[2672r,2672d:53)[2736r,2736d:52)[2848r,2848d:51)[2896r,2896d:50)[2944r,2960r:49)[3008r,3008d:48)[3072r,3072d:47)[3104r,3104d:46)[3168r,3168d:45)[3280r,3280d:44)[3328r,3328d:43)[3376r,3392r:42)[3440r,3440d:41)[3504r,3504d:40)[3536r,3536d:39)[3600r,3600d:38)[3712r,3712d:37)[3760r,3760d:36)[3808r,3824r:35)[3872r,3872d:34)[3936r,3936d:33)[3968r,3968d:32)[4032r,4032d:31)[4144r,4144d:30)[4192r,4192d:29)[4240r,4256r:28)[4304r,4304d:27)[4368r,4368d:26)[4400r,4400d:25)[4464r,4464d:24)[4560r,4560d:23)[4704r,4704d:1)[4736r,4736d:0)[5088r,5088d:22)[5104r,5104d:21)[5184r,5184d:20)[5200r,5200d:19)[5264r,5264d:18)[5280r,5280d:17)[5344r,5344d:16)[5360r,5360d:15)[5424r,5424d:14)[5440r,5440d:13)[5504r,5504d:12)[5520r,5520d:11)[5584r,5584d:10)[5600r,5600d:9)[5664r,5664d:8)[5680r,5680d:7)[5744r,5744d:6)[5760r,5760d:5)[5840r,5840d:4) 0@4736r 1@4704r 2@400r 3@368r 4@5840r 5@5760r 6@5744r 7@5680r 8@5664r 9@5600r 10@5584r 11@5520r 12@5504r 13@5440r 14@5424r 15@5360r 16@5344r 17@5280r 18@5264r 19@5200r 20@5184r 21@5104r 22@5088r 23@4560r 24@4464r 25@4400r 26@4368r 27@4304r 28@4240r 29@4192r 30@4144r 31@4032r 32@3968r 33@3936r 34@3872r 35@3808r 36@3760r 37@3712r 38@3600r 39@3536r 40@3504r 41@3440r 42@3376r 43@3328r 44@3280r 45@3168r 46@3104r 47@3072r 48@3008r 49@2944r 50@2896r 51@2848r 52@2736r 53@2672r 54@2640r 55@2576r 56@2512r 57@2464r 58@2416r 59@2304r 60@2240r 61@2208r 62@2144r 63@2080r 64@2032r 65@1984r 66@1872r 67@1808r 68@1776r 69@1712r 70@1648r 71@1600r 72@1552r 73@1440r 74@1376r 75@1344r 76@1280r 77@1216r 78@1168r 79@1120r 80@1008r 81@944r 82@912r 83@848r 84@792r 85@720r 86@672r 87@496r 88@208r 89@96r 90@16r
        -->	[16r,16d:90)[96r,96d:89)[208r,208d:88)[368r,368d:3)[436r,436d:2)[496r,496d:87)[672r,672d:86)[720r,720d:85)[792r,800r:84)[848r,848d:83)[912r,912d:82)[944r,944d:81)[1008r,1008d:80)[1120r,1120d:79)[1168r,1168d:78)[1216r,1232r:77)[1280r,1280d:76)[1344r,1344d:75)[1376r,1376d:74)[1440r,1440d:73)[1552r,1552d:72)[1600r,1600d:71)[1648r,1664r:70)[1712r,1712d:69)[1776r,1776d:68)[1808r,1808d:67)[1872r,1872d:66)[1984r,1984d:65)[2032r,2032d:64)[2080r,2096r:63)[2144r,2144d:62)[2208r,2208d:61)[2240r,2240d:60)[2304r,2304d:59)[2416r,2416d:58)[2464r,2464d:57)[2512r,2528r:56)[2576r,2576d:55)[2640r,2640d:54)[2672r,2672d:53)[2736r,2736d:52)[2848r,2848d:51)[2896r,2896d:50)[2944r,2960r:49)[3008r,3008d:48)[3072r,3072d:47)[3104r,3104d:46)[3168r,3168d:45)[3280r,3280d:44)[3328r,3328d:43)[3376r,3392r:42)[3440r,3440d:41)[3504r,3504d:40)[3536r,3536d:39)[3600r,3600d:38)[3712r,3712d:37)[3760r,3760d:36)[3808r,3824r:35)[3872r,3872d:34)[3936r,3936d:33)[3968r,3968d:32)[4032r,4032d:31)[4144r,4144d:30)[4192r,4192d:29)[4240r,4256r:28)[4304r,4304d:27)[4368r,4368d:26)[4400r,4400d:25)[4464r,4464d:24)[4560r,4560d:23)[4704r,4704d:1)[4736r,4736d:0)[5088r,5088d:22)[5104r,5104d:21)[5184r,5184d:20)[5200r,5200d:19)[5264r,5264d:18)[5280r,5280d:17)[5344r,5344d:16)[5360r,5360d:15)[5424r,5424d:14)[5440r,5440d:13)[5504r,5504d:12)[5520r,5520d:11)[5584r,5584d:10)[5600r,5600d:9)[5664r,5664d:8)[5680r,5680d:7)[5744r,5744d:6)[5760r,5760d:5)[5840r,5840d:4) 0@4736r 1@4704r 2@436r 3@368r 4@5840r 5@5760r 6@5744r 7@5680r 8@5664r 9@5600r 10@5584r 11@5520r 12@5504r 13@5440r 14@5424r 15@5360r 16@5344r 17@5280r 18@5264r 19@5200r 20@5184r 21@5104r 22@5088r 23@4560r 24@4464r 25@4400r 26@4368r 27@4304r 28@4240r 29@4192r 30@4144r 31@4032r 32@3968r 33@3936r 34@3872r 35@3808r 36@3760r 37@3712r 38@3600r 39@3536r 40@3504r 41@3440r 42@3376r 43@3328r 44@3280r 45@3168r 46@3104r 47@3072r 48@3008r 49@2944r 50@2896r 51@2848r 52@2736r 53@2672r 54@2640r 55@2576r 56@2512r 57@2464r 58@2416r 59@2304r 60@2240r 61@2208r 62@2144r 63@2080r 64@2032r 65@1984r 66@1872r 67@1808r 68@1776r 69@1712r 70@1648r 71@1600r 72@1552r 73@1440r 74@1376r 75@1344r 76@1280r 77@1216r 78@1168r 79@1120r 80@1008r 81@944r 82@912r 83@848r 84@792r 85@720r 86@672r 87@496r 88@208r 89@96r 90@16r
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=1
GR32_SIDI=2
GR32_DIBP_with_GR32_SIDI=2
GR32_DIBP_with_LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H_with_GR32_BSI=2
GR8_ABCD_L_with_GR32_BSI=2
GR8_NOREX=3
GR32_TC=2
GR32_BPSP_with_GR32_TC=2
GR64_NOREX=4
GR64_TCW64=3
GR32_BPSP_with_GR64_TCW64=3
GR8=5
GR8_with_GR32_DIBP=5
GR8_with_GR32_BSI=5
GR64_TC_with_GR64_TCW64=5
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=5
GR8_with_GR64_NOREX=5
GR64_TC=5
GR8_with_GR64_TCW64=5
GR8_with_GR64_TC=5
GR8_with_GR64PLTSafe=5
GR16=9
  GR8_NOREX: 5 <= 6(+ 0 livethru)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 0 1 4 3 2 
  Cand SU(7) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi

*** Renumbered SlotIndexes 432-472 ***
handleMove 368B -> 440B: dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
     SIL:	[440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4704r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4704r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
        -->	[440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4704r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4704r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
     SIH:	[440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4704r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4704r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
        -->	[440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4704r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4704r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
     HSI:	[440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4704r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4704r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
        -->	[440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4704r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4704r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
     EFLAGS:	[16r,16d:90)[96r,96d:89)[208r,208d:88)[368r,368d:3)[448r,448d:2)[496r,496d:87)[672r,672d:86)[720r,720d:85)[792r,800r:84)[848r,848d:83)[912r,912d:82)[944r,944d:81)[1008r,1008d:80)[1120r,1120d:79)[1168r,1168d:78)[1216r,1232r:77)[1280r,1280d:76)[1344r,1344d:75)[1376r,1376d:74)[1440r,1440d:73)[1552r,1552d:72)[1600r,1600d:71)[1648r,1664r:70)[1712r,1712d:69)[1776r,1776d:68)[1808r,1808d:67)[1872r,1872d:66)[1984r,1984d:65)[2032r,2032d:64)[2080r,2096r:63)[2144r,2144d:62)[2208r,2208d:61)[2240r,2240d:60)[2304r,2304d:59)[2416r,2416d:58)[2464r,2464d:57)[2512r,2528r:56)[2576r,2576d:55)[2640r,2640d:54)[2672r,2672d:53)[2736r,2736d:52)[2848r,2848d:51)[2896r,2896d:50)[2944r,2960r:49)[3008r,3008d:48)[3072r,3072d:47)[3104r,3104d:46)[3168r,3168d:45)[3280r,3280d:44)[3328r,3328d:43)[3376r,3392r:42)[3440r,3440d:41)[3504r,3504d:40)[3536r,3536d:39)[3600r,3600d:38)[3712r,3712d:37)[3760r,3760d:36)[3808r,3824r:35)[3872r,3872d:34)[3936r,3936d:33)[3968r,3968d:32)[4032r,4032d:31)[4144r,4144d:30)[4192r,4192d:29)[4240r,4256r:28)[4304r,4304d:27)[4368r,4368d:26)[4400r,4400d:25)[4464r,4464d:24)[4560r,4560d:23)[4704r,4704d:1)[4736r,4736d:0)[5088r,5088d:22)[5104r,5104d:21)[5184r,5184d:20)[5200r,5200d:19)[5264r,5264d:18)[5280r,5280d:17)[5344r,5344d:16)[5360r,5360d:15)[5424r,5424d:14)[5440r,5440d:13)[5504r,5504d:12)[5520r,5520d:11)[5584r,5584d:10)[5600r,5600d:9)[5664r,5664d:8)[5680r,5680d:7)[5744r,5744d:6)[5760r,5760d:5)[5840r,5840d:4) 0@4736r 1@4704r 2@448r 3@368r 4@5840r 5@5760r 6@5744r 7@5680r 8@5664r 9@5600r 10@5584r 11@5520r 12@5504r 13@5440r 14@5424r 15@5360r 16@5344r 17@5280r 18@5264r 19@5200r 20@5184r 21@5104r 22@5088r 23@4560r 24@4464r 25@4400r 26@4368r 27@4304r 28@4240r 29@4192r 30@4144r 31@4032r 32@3968r 33@3936r 34@3872r 35@3808r 36@3760r 37@3712r 38@3600r 39@3536r 40@3504r 41@3440r 42@3376r 43@3328r 44@3280r 45@3168r 46@3104r 47@3072r 48@3008r 49@2944r 50@2896r 51@2848r 52@2736r 53@2672r 54@2640r 55@2576r 56@2512r 57@2464r 58@2416r 59@2304r 60@2240r 61@2208r 62@2144r 63@2080r 64@2032r 65@1984r 66@1872r 67@1808r 68@1776r 69@1712r 70@1648r 71@1600r 72@1552r 73@1440r 74@1376r 75@1344r 76@1280r 77@1216r 78@1168r 79@1120r 80@1008r 81@944r 82@912r 83@848r 84@792r 85@720r 86@672r 87@496r 88@208r 89@96r 90@16r
        -->	[16r,16d:90)[96r,96d:89)[208r,208d:88)[440r,440d:3)[448r,448d:2)[496r,496d:87)[672r,672d:86)[720r,720d:85)[792r,800r:84)[848r,848d:83)[912r,912d:82)[944r,944d:81)[1008r,1008d:80)[1120r,1120d:79)[1168r,1168d:78)[1216r,1232r:77)[1280r,1280d:76)[1344r,1344d:75)[1376r,1376d:74)[1440r,1440d:73)[1552r,1552d:72)[1600r,1600d:71)[1648r,1664r:70)[1712r,1712d:69)[1776r,1776d:68)[1808r,1808d:67)[1872r,1872d:66)[1984r,1984d:65)[2032r,2032d:64)[2080r,2096r:63)[2144r,2144d:62)[2208r,2208d:61)[2240r,2240d:60)[2304r,2304d:59)[2416r,2416d:58)[2464r,2464d:57)[2512r,2528r:56)[2576r,2576d:55)[2640r,2640d:54)[2672r,2672d:53)[2736r,2736d:52)[2848r,2848d:51)[2896r,2896d:50)[2944r,2960r:49)[3008r,3008d:48)[3072r,3072d:47)[3104r,3104d:46)[3168r,3168d:45)[3280r,3280d:44)[3328r,3328d:43)[3376r,3392r:42)[3440r,3440d:41)[3504r,3504d:40)[3536r,3536d:39)[3600r,3600d:38)[3712r,3712d:37)[3760r,3760d:36)[3808r,3824r:35)[3872r,3872d:34)[3936r,3936d:33)[3968r,3968d:32)[4032r,4032d:31)[4144r,4144d:30)[4192r,4192d:29)[4240r,4256r:28)[4304r,4304d:27)[4368r,4368d:26)[4400r,4400d:25)[4464r,4464d:24)[4560r,4560d:23)[4704r,4704d:1)[4736r,4736d:0)[5088r,5088d:22)[5104r,5104d:21)[5184r,5184d:20)[5200r,5200d:19)[5264r,5264d:18)[5280r,5280d:17)[5344r,5344d:16)[5360r,5360d:15)[5424r,5424d:14)[5440r,5440d:13)[5504r,5504d:12)[5520r,5520d:11)[5584r,5584d:10)[5600r,5600d:9)[5664r,5664d:8)[5680r,5680d:7)[5744r,5744d:6)[5760r,5760d:5)[5840r,5840d:4) 0@4736r 1@4704r 2@448r 3@440r 4@5840r 5@5760r 6@5744r 7@5680r 8@5664r 9@5600r 10@5584r 11@5520r 12@5504r 13@5440r 14@5424r 15@5360r 16@5344r 17@5280r 18@5264r 19@5200r 20@5184r 21@5104r 22@5088r 23@4560r 24@4464r 25@4400r 26@4368r 27@4304r 28@4240r 29@4192r 30@4144r 31@4032r 32@3968r 33@3936r 34@3872r 35@3808r 36@3760r 37@3712r 38@3600r 39@3536r 40@3504r 41@3440r 42@3376r 43@3328r 44@3280r 45@3168r 46@3104r 47@3072r 48@3008r 49@2944r 50@2896r 51@2848r 52@2736r 53@2672r 54@2640r 55@2576r 56@2512r 57@2464r 58@2416r 59@2304r 60@2240r 61@2208r 62@2144r 63@2080r 64@2032r 65@1984r 66@1872r 67@1808r 68@1776r 69@1712r 70@1648r 71@1600r 72@1552r 73@1440r 74@1376r 75@1344r 76@1280r 77@1216r 78@1168r 79@1120r 80@1008r 81@944r 82@912r 83@848r 84@792r 85@720r 86@672r 87@496r 88@208r 89@96r 90@16r
Bottom Pressure:
GR32_BPSP=1
GR32_SIDI=1
GR32_DIBP_with_GR32_SIDI=1
GR32_DIBP_with_LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H_with_GR32_BSI=1
GR8_ABCD_L_with_GR32_BSI=1
GR8_NOREX=2
GR32_TC=2
GR32_BPSP_with_GR32_TC=2
GR64_NOREX=3
GR64_TCW64=3
GR32_BPSP_with_GR64_TCW64=3
GR8=4
GR8_with_GR32_DIBP=4
GR8_with_GR32_BSI=4
GR64_TC_with_GR64_TCW64=4
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=4
GR8_with_GR64_NOREX=4
GR64_TC=4
GR8_with_GR64_TCW64=4
GR8_with_GR64_TC=4
GR8_with_GR64PLTSafe=4
GR16=8
  GR32_DIBP_with_GR32_SIDI: 2 <= 4(+ 0 livethru)
  GR8_NOREX: 5 <= 6(+ 0 livethru)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 0 1 4 2 
  Cand SU(7) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) $edi = MOV32ri 1
handleMove 352B -> 436B: $edi = MOV32ri 1
     DIL:	[64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4688r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4688r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
        -->	[64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4688r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4688r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
     DIH:	[64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4688r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4688r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
        -->	[64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4688r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4688r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
     HDI:	[64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4688r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4688r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
        -->	[64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4688r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4688r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
Bottom Pressure:
GR8_ABCD_H_with_GR32_BSI=1
GR8_ABCD_L_with_GR32_BSI=1
GR8_NOREX=2
GR32_TC=2
GR32_BPSP_with_GR32_TC=2
GR64_NOREX=2
GR64_TCW64=3
GR32_BPSP_with_GR64_TCW64=3
GR8=3
GR8_with_GR32_DIBP=3
GR8_with_GR32_BSI=3
GR64_TC_with_GR64_TCW64=3
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=3
GR8_with_GR64_NOREX=3
GR64_TC=3
GR8_with_GR64_TCW64=3
GR8_with_GR64_TC=3
GR8_with_GR64PLTSafe=3
GR16=7
  GR32_DIBP_with_GR32_SIDI: 2 <= 4(+ 0 livethru)
  Ready @0c
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 4
  Executed: 0c
  Critical: 0c, 2 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 0 1 4 
  Cand SU(7) ORDER                              
Pick Bot ORDER     
Scheduling SU(7) $r9 = MOV32ri64 1
Bottom Pressure:
GR8_ABCD_H_with_GR32_BSI=1
GR8_ABCD_L_with_GR32_BSI=1
GR8_NOREX=2
GR32_TC=2
GR32_BPSP_with_GR32_TC=2
GR64_NOREX=2
GR64_TCW64=2
GR32_BPSP_with_GR64_TCW64=2
GR8=2
GR8_with_GR32_DIBP=2
GR8_with_GR32_BSI=2
GR64_TC_with_GR64_TCW64=2
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=2
GR8_with_GR64_NOREX=2
GR64_TC=2
GR8_with_GR64_TCW64=2
GR8_with_GR64_TC=2
GR8_with_GR64PLTSafe=2
GR16=6
  Ready @0c
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 5
  Executed: 0c
  Critical: 0c, 3 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 0 1 
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) $rdx = MOV32ri64 3
Bottom Pressure:
GR16=4
  GR8_NOREX: 5 <= 6(+ 0 livethru)
  Ready @0c
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
  *** Max MOps 6 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 4 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %40:gr64 = MOV64ri @read_input_sizes_2D_f64
Bottom Pressure:
GR16=2
  Ready @1c
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @1c
  Retired: 7
  Executed: 1c
  Critical: 1c, 5 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %39:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
Bottom Pressure:

  Ready @1c
  SKLPort15 +1x12u
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @1c
  Retired: 8
  Executed: 1c
  Critical: 1c, 6 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %39:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
SU(1):   %40:gr64 = MOV64ri @read_input_sizes_2D_f64
SU(4):   $rdx = MOV32ri64 3
SU(7):   $r9 = MOV32ri64 1
SU(2):   $edi = MOV32ri 1
SU(3):   dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
SU(5):   dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
SU(6):   $r8 = MOV64ri32 -1

********** MI Scheduling **********
main:%bb.0 
  From: %37:gr64 = COPY killed $rax
    To: ADJCALLSTACKDOWN64 16, 0, 16, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %37:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(2): Data Latency=0 Reg=%37
    SU(1): Data Latency=0 Reg=%37
  Single Issue       : false;
SU(1):   MOV64mr %stack.0, 1, $noreg, 0, $noreg, %37:gr64 :: (store (s64) into %ir.2)
  # preds left       : 1
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%37
  Successors:
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOV64mr %stack.0, 1, $noreg, 8, $noreg, %37:gr64 :: (store (s64) into %ir..fca.1.gep)
  # preds left       : 2
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Memory
    SU(0): Data Latency=0 Reg=%37
  Successors:
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
  Single Issue       : false;
SU(3):   MOV64mi32 %stack.0, 1, $noreg, 16, $noreg, 0 :: (store (s64) into %ir..fca.2.gep)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
  Single Issue       : false;
SU(4):   MOV64mi32 %stack.0, 1, $noreg, 24, $noreg, 7 :: (store (s64) into %ir..fca.3.0.gep)
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(5): Ord  Latency=0 Memory
  Single Issue       : false;
SU(5):   MOV64mi32 %stack.0, 1, $noreg, 32, $noreg, 1 :: (store (s64) into %ir..fca.4.0.gep)
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 16, 0, 16, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 
Scheduling SU(5) MOV64mi32 %stack.0, 1, $noreg, 32, $noreg, 1 :: (store (s64) into %ir..fca.4.0.gep)
  Ready @0c
  SKLPort4 +1x24u
  *** Critical resource SKLPort4: 1c
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) MOV64mi32 %stack.0, 1, $noreg, 24, $noreg, 7 :: (store (s64) into %ir..fca.3.0.gep)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 2
  Executed: 2c
  Critical: 2c, 2 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOV64mi32 %stack.0, 1, $noreg, 16, $noreg, 0 :: (store (s64) into %ir..fca.2.gep)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 3
  Executed: 3c
  Critical: 3c, 3 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOV64mr %stack.0, 1, $noreg, 8, $noreg, %37:gr64 :: (store (s64) into %ir..fca.1.gep)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 4
  Executed: 4c
  Critical: 4c, 4 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %stack.0, 1, $noreg, 0, $noreg, %37:gr64 :: (store (s64) into %ir.2)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 5
  Executed: 5c
  Critical: 5c, 5 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %37:gr64 = COPY killed $rax
  Ready @0c
BotQ.A @0c
  Retired: 5
  Executed: 5c
  Critical: 5c, 5 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %37:gr64 = COPY killed $rax
SU(1):   MOV64mr %stack.0, 1, $noreg, 0, $noreg, %37:gr64 :: (store (s64) into %ir.2)
SU(2):   MOV64mr %stack.0, 1, $noreg, 8, $noreg, %37:gr64 :: (store (s64) into %ir..fca.1.gep)
SU(3):   MOV64mi32 %stack.0, 1, $noreg, 16, $noreg, 0 :: (store (s64) into %ir..fca.2.gep)
SU(4):   MOV64mi32 %stack.0, 1, $noreg, 24, $noreg, 7 :: (store (s64) into %ir..fca.3.0.gep)
SU(5):   MOV64mi32 %stack.0, 1, $noreg, 32, $noreg, 1 :: (store (s64) into %ir..fca.4.0.gep)

********** MI Scheduling **********
main:%bb.0 
  From: %35:gr64 = MOV64ri @malloc
    To: CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %35:gr64 = MOV64ri @malloc
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Data Latency=1 Reg=%35
  Single Issue       : false;
SU(1):   $rdi = MOV32ri64 56
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Data Latency=1 Reg=%35
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rdi = MOV32ri64 56
  Ready @1c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %35:gr64 = MOV64ri @malloc
  Ready @1c
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SKLPort0156
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %35:gr64 = MOV64ri @malloc
SU(1):   $rdi = MOV32ri64 56

********** MI Scheduling **********
main:%bb.1 .lr.ph.preheader
  From: $rdi = COPY %10:gr64
    To: CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %10:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %9:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = COPY %9:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = COPY %10:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.1 ***
SU(0):   $rdi = COPY %10:gr64
SU(1):   $rsi = COPY %9:gr64

********** MI Scheduling **********
main:%bb.2 ._crit_edge
  From: %13:gr64 = COPY killed $rax
    To: JCC_1 %bb.4, 14, implicit $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Macro fuse: SU(1) - ExitSU /  TEST64rr - JCC_1
SU(0):   %13:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   TEST64rr %1:gr64_nosp, %1:gr64_nosp, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Artificial
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Single Issue       : false;
ExitSU:   JCC_1 %bb.4, 14, implicit $eflags
  # preds left       : 1
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) TEST64rr %1:gr64_nosp, %1:gr64_nosp, implicit-def $eflags
  Ready @0c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %13:gr64 = COPY killed $rax
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.2 ***
SU(0):   %13:gr64 = COPY killed $rax
SU(1):   TEST64rr %1:gr64_nosp, %1:gr64_nosp, implicit-def $eflags

********** MI Scheduling **********
main:%bb.2 ._crit_edge
  From: MOV64mr %49:gr64, 1, $noreg, -48, $noreg, %10:gr64 :: (store (s64) into %ir.22)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV64mr %49:gr64, 1, $noreg, -48, $noreg, %10:gr64 :: (store (s64) into %ir.22)
  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Single Issue       : false;
SU(1):   MOV64mr %49:gr64, 1, $noreg, -40, $noreg, %10:gr64 :: (store (s64) into %ir..repack9)
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOV64mi32 %49:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack11)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
  Single Issue       : false;
SU(3):   MOV64mr %49:gr64, 1, $noreg, -24, $noreg, %0:gr64_nosp :: (store (s64) into %ir..repack13)
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
  Single Issue       : false;
SU(4):   MOV64mi32 %49:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack15)
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Single Issue       : false;
SU(5):   %12:gr64 = LEA64r $noreg, 8, %1:gr64_nosp, 0, $noreg
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 4 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %12:gr64 = LEA64r $noreg, 8, %1:gr64_nosp, 0, $noreg
  Ready @0c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) MOV64mi32 %49:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack15)
  Ready @0c
  SKLPort4 +1x24u
  *** Critical resource SKLPort4: 1c
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOV64mr %49:gr64, 1, $noreg, -24, $noreg, %0:gr64_nosp :: (store (s64) into %ir..repack13)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 3
  Executed: 2c
  Critical: 2c, 2 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOV64mi32 %49:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack11)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 4
  Executed: 3c
  Critical: 3c, 3 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %49:gr64, 1, $noreg, -40, $noreg, %10:gr64 :: (store (s64) into %ir..repack9)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 5
  Executed: 4c
  Critical: 4c, 4 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV64mr %49:gr64, 1, $noreg, -48, $noreg, %10:gr64 :: (store (s64) into %ir.22)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
  *** Max MOps 6 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 6
  Executed: 5c
  Critical: 5c, 5 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.2 ***
SU(0):   MOV64mr %49:gr64, 1, $noreg, -48, $noreg, %10:gr64 :: (store (s64) into %ir.22)
SU(1):   MOV64mr %49:gr64, 1, $noreg, -40, $noreg, %10:gr64 :: (store (s64) into %ir..repack9)
SU(2):   MOV64mi32 %49:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack11)
SU(3):   MOV64mr %49:gr64, 1, $noreg, -24, $noreg, %0:gr64_nosp :: (store (s64) into %ir..repack13)
SU(4):   MOV64mi32 %49:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack15)
SU(5):   %12:gr64 = LEA64r $noreg, 8, %1:gr64_nosp, 0, $noreg

********** MI Scheduling **********
main:%bb.2 ._crit_edge
  From: %49:gr64 = COPY $rsp
    To: $rsp = COPY %11:gr64
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %49:gr64 = COPY $rsp
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%49
  Single Issue       : false;
SU(1):   %11:gr64 = LEA64r %49:gr64, 1, $noreg, -48, $noreg
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%49
  Successors:
    ExitSU: Data Latency=1 Reg=%11
  Single Issue       : false;
ExitSU:   $rsp = COPY %11:gr64
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%11
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %11:gr64 = LEA64r %49:gr64, 1, $noreg, -48, $noreg
  Ready @1c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %49:gr64 = COPY $rsp
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.2 ***
SU(0):   %49:gr64 = COPY $rsp
SU(1):   %11:gr64 = LEA64r %49:gr64, 1, $noreg, -48, $noreg

********** MI Scheduling **********
main:%bb.3 .lr.ph90.preheader
  From: $rdi = COPY %13:gr64
    To: CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %13:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %12:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = COPY %12:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = COPY %13:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.3 ***
SU(0):   $rdi = COPY %13:gr64
SU(1):   $rsi = COPY %12:gr64

********** MI Scheduling **********
main:%bb.4 ._crit_edge91
  From: %16:gr64 = COPY killed $rax
    To: JCC_1 %bb.6, 14, implicit $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Macro fuse: SU(1) - ExitSU /  TEST64rr - JCC_1
SU(0):   %16:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   TEST64rr %2:gr64_nosp, %2:gr64_nosp, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Artificial
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Single Issue       : false;
ExitSU:   JCC_1 %bb.6, 14, implicit $eflags
  # preds left       : 1
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) TEST64rr %2:gr64_nosp, %2:gr64_nosp, implicit-def $eflags
  Ready @0c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %16:gr64 = COPY killed $rax
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   %16:gr64 = COPY killed $rax
SU(1):   TEST64rr %2:gr64_nosp, %2:gr64_nosp, implicit-def $eflags

********** MI Scheduling **********
main:%bb.4 ._crit_edge91
  From: MOV64mr %53:gr64, 1, $noreg, -48, $noreg, %13:gr64 :: (store (s64) into %ir.25)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV64mr %53:gr64, 1, $noreg, -48, $noreg, %13:gr64 :: (store (s64) into %ir.25)
  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Single Issue       : false;
SU(1):   MOV64mr %53:gr64, 1, $noreg, -40, $noreg, %13:gr64 :: (store (s64) into %ir..repack18)
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOV64mi32 %53:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack20)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
  Single Issue       : false;
SU(3):   MOV64mr %53:gr64, 1, $noreg, -24, $noreg, %1:gr64_nosp :: (store (s64) into %ir..repack22)
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
  Single Issue       : false;
SU(4):   MOV64mi32 %53:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack24)
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Single Issue       : false;
SU(5):   %15:gr64 = LEA64r $noreg, 8, %2:gr64_nosp, 0, $noreg
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 4 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %15:gr64 = LEA64r $noreg, 8, %2:gr64_nosp, 0, $noreg
  Ready @0c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) MOV64mi32 %53:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack24)
  Ready @0c
  SKLPort4 +1x24u
  *** Critical resource SKLPort4: 1c
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOV64mr %53:gr64, 1, $noreg, -24, $noreg, %1:gr64_nosp :: (store (s64) into %ir..repack22)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 3
  Executed: 2c
  Critical: 2c, 2 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOV64mi32 %53:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack20)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 4
  Executed: 3c
  Critical: 3c, 3 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %53:gr64, 1, $noreg, -40, $noreg, %13:gr64 :: (store (s64) into %ir..repack18)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 5
  Executed: 4c
  Critical: 4c, 4 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV64mr %53:gr64, 1, $noreg, -48, $noreg, %13:gr64 :: (store (s64) into %ir.25)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
  *** Max MOps 6 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 6
  Executed: 5c
  Critical: 5c, 5 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   MOV64mr %53:gr64, 1, $noreg, -48, $noreg, %13:gr64 :: (store (s64) into %ir.25)
SU(1):   MOV64mr %53:gr64, 1, $noreg, -40, $noreg, %13:gr64 :: (store (s64) into %ir..repack18)
SU(2):   MOV64mi32 %53:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack20)
SU(3):   MOV64mr %53:gr64, 1, $noreg, -24, $noreg, %1:gr64_nosp :: (store (s64) into %ir..repack22)
SU(4):   MOV64mi32 %53:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack24)
SU(5):   %15:gr64 = LEA64r $noreg, 8, %2:gr64_nosp, 0, $noreg

********** MI Scheduling **********
main:%bb.4 ._crit_edge91
  From: %53:gr64 = COPY $rsp
    To: $rsp = COPY %14:gr64
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %53:gr64 = COPY $rsp
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%53
  Single Issue       : false;
SU(1):   %14:gr64 = LEA64r %53:gr64, 1, $noreg, -48, $noreg
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%53
  Successors:
    ExitSU: Data Latency=1 Reg=%14
  Single Issue       : false;
ExitSU:   $rsp = COPY %14:gr64
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%14
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %14:gr64 = LEA64r %53:gr64, 1, $noreg, -48, $noreg
  Ready @1c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %53:gr64 = COPY $rsp
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   %53:gr64 = COPY $rsp
SU(1):   %14:gr64 = LEA64r %53:gr64, 1, $noreg, -48, $noreg

********** MI Scheduling **********
main:%bb.5 .lr.ph93.preheader
  From: $rdi = COPY %16:gr64
    To: CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %16:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %15:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = COPY %15:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = COPY %16:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.5 ***
SU(0):   $rdi = COPY %16:gr64
SU(1):   $rsi = COPY %15:gr64

********** MI Scheduling **********
main:%bb.6 ._crit_edge94
  From: %19:gr64 = COPY killed $rax
    To: JCC_1 %bb.8, 14, implicit $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Macro fuse: SU(1) - ExitSU /  TEST64rr - JCC_1
SU(0):   %19:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   TEST64rr %3:gr64_nosp, %3:gr64_nosp, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Artificial
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Single Issue       : false;
ExitSU:   JCC_1 %bb.8, 14, implicit $eflags
  # preds left       : 1
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) TEST64rr %3:gr64_nosp, %3:gr64_nosp, implicit-def $eflags
  Ready @0c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %19:gr64 = COPY killed $rax
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(0):   %19:gr64 = COPY killed $rax
SU(1):   TEST64rr %3:gr64_nosp, %3:gr64_nosp, implicit-def $eflags

********** MI Scheduling **********
main:%bb.6 ._crit_edge94
  From: MOV64mr %57:gr64, 1, $noreg, -48, $noreg, %16:gr64 :: (store (s64) into %ir.28)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV64mr %57:gr64, 1, $noreg, -48, $noreg, %16:gr64 :: (store (s64) into %ir.28)
  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Single Issue       : false;
SU(1):   MOV64mr %57:gr64, 1, $noreg, -40, $noreg, %16:gr64 :: (store (s64) into %ir..repack27)
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOV64mi32 %57:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack29)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
  Single Issue       : false;
SU(3):   MOV64mr %57:gr64, 1, $noreg, -24, $noreg, %2:gr64_nosp :: (store (s64) into %ir..repack31)
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
  Single Issue       : false;
SU(4):   MOV64mi32 %57:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack33)
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Single Issue       : false;
SU(5):   %18:gr64 = LEA64r $noreg, 8, %3:gr64_nosp, 0, $noreg
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 4 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %18:gr64 = LEA64r $noreg, 8, %3:gr64_nosp, 0, $noreg
  Ready @0c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) MOV64mi32 %57:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack33)
  Ready @0c
  SKLPort4 +1x24u
  *** Critical resource SKLPort4: 1c
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOV64mr %57:gr64, 1, $noreg, -24, $noreg, %2:gr64_nosp :: (store (s64) into %ir..repack31)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 3
  Executed: 2c
  Critical: 2c, 2 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOV64mi32 %57:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack29)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 4
  Executed: 3c
  Critical: 3c, 3 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %57:gr64, 1, $noreg, -40, $noreg, %16:gr64 :: (store (s64) into %ir..repack27)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 5
  Executed: 4c
  Critical: 4c, 4 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV64mr %57:gr64, 1, $noreg, -48, $noreg, %16:gr64 :: (store (s64) into %ir.28)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
  *** Max MOps 6 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 6
  Executed: 5c
  Critical: 5c, 5 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(0):   MOV64mr %57:gr64, 1, $noreg, -48, $noreg, %16:gr64 :: (store (s64) into %ir.28)
SU(1):   MOV64mr %57:gr64, 1, $noreg, -40, $noreg, %16:gr64 :: (store (s64) into %ir..repack27)
SU(2):   MOV64mi32 %57:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack29)
SU(3):   MOV64mr %57:gr64, 1, $noreg, -24, $noreg, %2:gr64_nosp :: (store (s64) into %ir..repack31)
SU(4):   MOV64mi32 %57:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack33)
SU(5):   %18:gr64 = LEA64r $noreg, 8, %3:gr64_nosp, 0, $noreg

********** MI Scheduling **********
main:%bb.6 ._crit_edge94
  From: %57:gr64 = COPY $rsp
    To: $rsp = COPY %17:gr64
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %57:gr64 = COPY $rsp
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%57
  Single Issue       : false;
SU(1):   %17:gr64 = LEA64r %57:gr64, 1, $noreg, -48, $noreg
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%57
  Successors:
    ExitSU: Data Latency=1 Reg=%17
  Single Issue       : false;
ExitSU:   $rsp = COPY %17:gr64
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%17
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %17:gr64 = LEA64r %57:gr64, 1, $noreg, -48, $noreg
  Ready @1c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %57:gr64 = COPY $rsp
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(0):   %57:gr64 = COPY $rsp
SU(1):   %17:gr64 = LEA64r %57:gr64, 1, $noreg, -48, $noreg

********** MI Scheduling **********
main:%bb.7 .lr.ph96.preheader
  From: $rdi = COPY %19:gr64
    To: CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %19:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %18:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = COPY %18:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = COPY %19:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.7 ***
SU(0):   $rdi = COPY %19:gr64
SU(1):   $rsi = COPY %18:gr64

********** MI Scheduling **********
main:%bb.8 ._crit_edge97
  From: %22:gr64 = COPY killed $rax
    To: JCC_1 %bb.10, 14, implicit $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Macro fuse: SU(1) - ExitSU /  TEST64rr - JCC_1
SU(0):   %22:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   TEST64rr %4:gr64_nosp, %4:gr64_nosp, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Artificial
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Single Issue       : false;
ExitSU:   JCC_1 %bb.10, 14, implicit $eflags
  # preds left       : 1
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) TEST64rr %4:gr64_nosp, %4:gr64_nosp, implicit-def $eflags
  Ready @0c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %22:gr64 = COPY killed $rax
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.8 ***
SU(0):   %22:gr64 = COPY killed $rax
SU(1):   TEST64rr %4:gr64_nosp, %4:gr64_nosp, implicit-def $eflags

********** MI Scheduling **********
main:%bb.8 ._crit_edge97
  From: MOV64mr %61:gr64, 1, $noreg, -48, $noreg, %19:gr64 :: (store (s64) into %ir.31)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV64mr %61:gr64, 1, $noreg, -48, $noreg, %19:gr64 :: (store (s64) into %ir.31)
  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Single Issue       : false;
SU(1):   MOV64mr %61:gr64, 1, $noreg, -40, $noreg, %19:gr64 :: (store (s64) into %ir..repack36)
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOV64mi32 %61:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack38)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
  Single Issue       : false;
SU(3):   MOV64mr %61:gr64, 1, $noreg, -24, $noreg, %3:gr64_nosp :: (store (s64) into %ir..repack40)
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
  Single Issue       : false;
SU(4):   MOV64mi32 %61:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack42)
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Single Issue       : false;
SU(5):   %21:gr64 = LEA64r $noreg, 8, %4:gr64_nosp, 0, $noreg
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 4 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %21:gr64 = LEA64r $noreg, 8, %4:gr64_nosp, 0, $noreg
  Ready @0c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) MOV64mi32 %61:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack42)
  Ready @0c
  SKLPort4 +1x24u
  *** Critical resource SKLPort4: 1c
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOV64mr %61:gr64, 1, $noreg, -24, $noreg, %3:gr64_nosp :: (store (s64) into %ir..repack40)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 3
  Executed: 2c
  Critical: 2c, 2 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOV64mi32 %61:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack38)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 4
  Executed: 3c
  Critical: 3c, 3 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %61:gr64, 1, $noreg, -40, $noreg, %19:gr64 :: (store (s64) into %ir..repack36)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 5
  Executed: 4c
  Critical: 4c, 4 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV64mr %61:gr64, 1, $noreg, -48, $noreg, %19:gr64 :: (store (s64) into %ir.31)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
  *** Max MOps 6 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 6
  Executed: 5c
  Critical: 5c, 5 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.8 ***
SU(0):   MOV64mr %61:gr64, 1, $noreg, -48, $noreg, %19:gr64 :: (store (s64) into %ir.31)
SU(1):   MOV64mr %61:gr64, 1, $noreg, -40, $noreg, %19:gr64 :: (store (s64) into %ir..repack36)
SU(2):   MOV64mi32 %61:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack38)
SU(3):   MOV64mr %61:gr64, 1, $noreg, -24, $noreg, %3:gr64_nosp :: (store (s64) into %ir..repack40)
SU(4):   MOV64mi32 %61:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack42)
SU(5):   %21:gr64 = LEA64r $noreg, 8, %4:gr64_nosp, 0, $noreg

********** MI Scheduling **********
main:%bb.8 ._crit_edge97
  From: %61:gr64 = COPY $rsp
    To: $rsp = COPY %20:gr64
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %61:gr64 = COPY $rsp
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%61
  Single Issue       : false;
SU(1):   %20:gr64 = LEA64r %61:gr64, 1, $noreg, -48, $noreg
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%61
  Successors:
    ExitSU: Data Latency=1 Reg=%20
  Single Issue       : false;
ExitSU:   $rsp = COPY %20:gr64
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%20
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %20:gr64 = LEA64r %61:gr64, 1, $noreg, -48, $noreg
  Ready @1c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %61:gr64 = COPY $rsp
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.8 ***
SU(0):   %61:gr64 = COPY $rsp
SU(1):   %20:gr64 = LEA64r %61:gr64, 1, $noreg, -48, $noreg

********** MI Scheduling **********
main:%bb.9 .lr.ph99.preheader
  From: $rdi = COPY %22:gr64
    To: CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %22:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %21:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = COPY %21:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = COPY %22:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.9 ***
SU(0):   $rdi = COPY %22:gr64
SU(1):   $rsi = COPY %21:gr64

********** MI Scheduling **********
main:%bb.10 ._crit_edge100
  From: %25:gr64 = COPY killed $rax
    To: JCC_1 %bb.12, 14, implicit $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Macro fuse: SU(1) - ExitSU /  TEST64rr - JCC_1
SU(0):   %25:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   TEST64rr %5:gr64_nosp, %5:gr64_nosp, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Artificial
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Single Issue       : false;
ExitSU:   JCC_1 %bb.12, 14, implicit $eflags
  # preds left       : 1
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) TEST64rr %5:gr64_nosp, %5:gr64_nosp, implicit-def $eflags
  Ready @0c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %25:gr64 = COPY killed $rax
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(0):   %25:gr64 = COPY killed $rax
SU(1):   TEST64rr %5:gr64_nosp, %5:gr64_nosp, implicit-def $eflags

********** MI Scheduling **********
main:%bb.10 ._crit_edge100
  From: MOV64mr %65:gr64, 1, $noreg, -48, $noreg, %22:gr64 :: (store (s64) into %ir.34)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV64mr %65:gr64, 1, $noreg, -48, $noreg, %22:gr64 :: (store (s64) into %ir.34)
  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Single Issue       : false;
SU(1):   MOV64mr %65:gr64, 1, $noreg, -40, $noreg, %22:gr64 :: (store (s64) into %ir..repack45)
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOV64mi32 %65:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack47)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
  Single Issue       : false;
SU(3):   MOV64mr %65:gr64, 1, $noreg, -24, $noreg, %4:gr64_nosp :: (store (s64) into %ir..repack49)
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
  Single Issue       : false;
SU(4):   MOV64mi32 %65:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack51)
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Single Issue       : false;
SU(5):   %24:gr64 = LEA64r $noreg, 8, %5:gr64_nosp, 0, $noreg
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 4 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %24:gr64 = LEA64r $noreg, 8, %5:gr64_nosp, 0, $noreg
  Ready @0c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) MOV64mi32 %65:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack51)
  Ready @0c
  SKLPort4 +1x24u
  *** Critical resource SKLPort4: 1c
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOV64mr %65:gr64, 1, $noreg, -24, $noreg, %4:gr64_nosp :: (store (s64) into %ir..repack49)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 3
  Executed: 2c
  Critical: 2c, 2 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOV64mi32 %65:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack47)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 4
  Executed: 3c
  Critical: 3c, 3 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %65:gr64, 1, $noreg, -40, $noreg, %22:gr64 :: (store (s64) into %ir..repack45)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 5
  Executed: 4c
  Critical: 4c, 4 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV64mr %65:gr64, 1, $noreg, -48, $noreg, %22:gr64 :: (store (s64) into %ir.34)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
  *** Max MOps 6 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 6
  Executed: 5c
  Critical: 5c, 5 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(0):   MOV64mr %65:gr64, 1, $noreg, -48, $noreg, %22:gr64 :: (store (s64) into %ir.34)
SU(1):   MOV64mr %65:gr64, 1, $noreg, -40, $noreg, %22:gr64 :: (store (s64) into %ir..repack45)
SU(2):   MOV64mi32 %65:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack47)
SU(3):   MOV64mr %65:gr64, 1, $noreg, -24, $noreg, %4:gr64_nosp :: (store (s64) into %ir..repack49)
SU(4):   MOV64mi32 %65:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack51)
SU(5):   %24:gr64 = LEA64r $noreg, 8, %5:gr64_nosp, 0, $noreg

********** MI Scheduling **********
main:%bb.10 ._crit_edge100
  From: %65:gr64 = COPY $rsp
    To: $rsp = COPY %23:gr64
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %65:gr64 = COPY $rsp
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%65
  Single Issue       : false;
SU(1):   %23:gr64 = LEA64r %65:gr64, 1, $noreg, -48, $noreg
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%65
  Successors:
    ExitSU: Data Latency=1 Reg=%23
  Single Issue       : false;
ExitSU:   $rsp = COPY %23:gr64
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%23
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %23:gr64 = LEA64r %65:gr64, 1, $noreg, -48, $noreg
  Ready @1c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %65:gr64 = COPY $rsp
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(0):   %65:gr64 = COPY $rsp
SU(1):   %23:gr64 = LEA64r %65:gr64, 1, $noreg, -48, $noreg

********** MI Scheduling **********
main:%bb.11 .lr.ph102.preheader
  From: $rdi = COPY %25:gr64
    To: CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %25:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %24:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = COPY %24:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = COPY %25:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.11 ***
SU(0):   $rdi = COPY %25:gr64
SU(1):   $rsi = COPY %24:gr64

********** MI Scheduling **********
main:%bb.12 ._crit_edge103
  From: %28:gr64 = COPY killed $rax
    To: JCC_1 %bb.14, 14, implicit $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Macro fuse: SU(1) - ExitSU /  TEST64rr - JCC_1
SU(0):   %28:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   TEST64rr %6:gr64_nosp, %6:gr64_nosp, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Artificial
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Single Issue       : false;
ExitSU:   JCC_1 %bb.14, 14, implicit $eflags
  # preds left       : 1
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) TEST64rr %6:gr64_nosp, %6:gr64_nosp, implicit-def $eflags
  Ready @0c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %28:gr64 = COPY killed $rax
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.12 ***
SU(0):   %28:gr64 = COPY killed $rax
SU(1):   TEST64rr %6:gr64_nosp, %6:gr64_nosp, implicit-def $eflags

********** MI Scheduling **********
main:%bb.12 ._crit_edge103
  From: MOV64mr %69:gr64, 1, $noreg, -48, $noreg, %25:gr64 :: (store (s64) into %ir.37)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV64mr %69:gr64, 1, $noreg, -48, $noreg, %25:gr64 :: (store (s64) into %ir.37)
  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Single Issue       : false;
SU(1):   MOV64mr %69:gr64, 1, $noreg, -40, $noreg, %25:gr64 :: (store (s64) into %ir..repack54)
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOV64mi32 %69:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack56)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
  Single Issue       : false;
SU(3):   MOV64mr %69:gr64, 1, $noreg, -24, $noreg, %5:gr64_nosp :: (store (s64) into %ir..repack58)
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
  Single Issue       : false;
SU(4):   MOV64mi32 %69:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack60)
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Single Issue       : false;
SU(5):   %27:gr64 = LEA64r $noreg, 8, %6:gr64_nosp, 0, $noreg
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 4 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %27:gr64 = LEA64r $noreg, 8, %6:gr64_nosp, 0, $noreg
  Ready @0c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) MOV64mi32 %69:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack60)
  Ready @0c
  SKLPort4 +1x24u
  *** Critical resource SKLPort4: 1c
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOV64mr %69:gr64, 1, $noreg, -24, $noreg, %5:gr64_nosp :: (store (s64) into %ir..repack58)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 3
  Executed: 2c
  Critical: 2c, 2 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOV64mi32 %69:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack56)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 4
  Executed: 3c
  Critical: 3c, 3 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %69:gr64, 1, $noreg, -40, $noreg, %25:gr64 :: (store (s64) into %ir..repack54)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 5
  Executed: 4c
  Critical: 4c, 4 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV64mr %69:gr64, 1, $noreg, -48, $noreg, %25:gr64 :: (store (s64) into %ir.37)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
  *** Max MOps 6 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 6
  Executed: 5c
  Critical: 5c, 5 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.12 ***
SU(0):   MOV64mr %69:gr64, 1, $noreg, -48, $noreg, %25:gr64 :: (store (s64) into %ir.37)
SU(1):   MOV64mr %69:gr64, 1, $noreg, -40, $noreg, %25:gr64 :: (store (s64) into %ir..repack54)
SU(2):   MOV64mi32 %69:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack56)
SU(3):   MOV64mr %69:gr64, 1, $noreg, -24, $noreg, %5:gr64_nosp :: (store (s64) into %ir..repack58)
SU(4):   MOV64mi32 %69:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack60)
SU(5):   %27:gr64 = LEA64r $noreg, 8, %6:gr64_nosp, 0, $noreg

********** MI Scheduling **********
main:%bb.12 ._crit_edge103
  From: %69:gr64 = COPY $rsp
    To: $rsp = COPY %26:gr64
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %69:gr64 = COPY $rsp
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%69
  Single Issue       : false;
SU(1):   %26:gr64 = LEA64r %69:gr64, 1, $noreg, -48, $noreg
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%69
  Successors:
    ExitSU: Data Latency=1 Reg=%26
  Single Issue       : false;
ExitSU:   $rsp = COPY %26:gr64
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%26
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %26:gr64 = LEA64r %69:gr64, 1, $noreg, -48, $noreg
  Ready @1c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %69:gr64 = COPY $rsp
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.12 ***
SU(0):   %69:gr64 = COPY $rsp
SU(1):   %26:gr64 = LEA64r %69:gr64, 1, $noreg, -48, $noreg

********** MI Scheduling **********
main:%bb.13 .lr.ph105.preheader
  From: $rdi = COPY %28:gr64
    To: CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %28:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %27:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = COPY %27:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = COPY %28:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.13 ***
SU(0):   $rdi = COPY %28:gr64
SU(1):   $rsi = COPY %27:gr64

********** MI Scheduling **********
main:%bb.14 ._crit_edge106
  From: %31:gr64 = COPY killed $rax
    To: JCC_1 %bb.16, 14, implicit $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Macro fuse: SU(1) - ExitSU /  TEST64rr - JCC_1
SU(0):   %31:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   TEST64rr %7:gr64_nosp, %7:gr64_nosp, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Artificial
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Single Issue       : false;
ExitSU:   JCC_1 %bb.16, 14, implicit $eflags
  # preds left       : 1
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) TEST64rr %7:gr64_nosp, %7:gr64_nosp, implicit-def $eflags
  Ready @0c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %31:gr64 = COPY killed $rax
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.14 ***
SU(0):   %31:gr64 = COPY killed $rax
SU(1):   TEST64rr %7:gr64_nosp, %7:gr64_nosp, implicit-def $eflags

********** MI Scheduling **********
main:%bb.14 ._crit_edge106
  From: MOV64mr %73:gr64, 1, $noreg, -48, $noreg, %28:gr64 :: (store (s64) into %ir.40)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV64mr %73:gr64, 1, $noreg, -48, $noreg, %28:gr64 :: (store (s64) into %ir.40)
  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Single Issue       : false;
SU(1):   MOV64mr %73:gr64, 1, $noreg, -40, $noreg, %28:gr64 :: (store (s64) into %ir..repack63)
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOV64mi32 %73:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack65)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
  Single Issue       : false;
SU(3):   MOV64mr %73:gr64, 1, $noreg, -24, $noreg, %6:gr64_nosp :: (store (s64) into %ir..repack67)
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
  Single Issue       : false;
SU(4):   MOV64mi32 %73:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack69)
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Single Issue       : false;
SU(5):   %30:gr64 = LEA64r $noreg, 8, %7:gr64_nosp, 0, $noreg
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 4 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %30:gr64 = LEA64r $noreg, 8, %7:gr64_nosp, 0, $noreg
  Ready @0c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) MOV64mi32 %73:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack69)
  Ready @0c
  SKLPort4 +1x24u
  *** Critical resource SKLPort4: 1c
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOV64mr %73:gr64, 1, $noreg, -24, $noreg, %6:gr64_nosp :: (store (s64) into %ir..repack67)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 3
  Executed: 2c
  Critical: 2c, 2 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOV64mi32 %73:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack65)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 4
  Executed: 3c
  Critical: 3c, 3 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %73:gr64, 1, $noreg, -40, $noreg, %28:gr64 :: (store (s64) into %ir..repack63)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 5
  Executed: 4c
  Critical: 4c, 4 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV64mr %73:gr64, 1, $noreg, -48, $noreg, %28:gr64 :: (store (s64) into %ir.40)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
  *** Max MOps 6 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 6
  Executed: 5c
  Critical: 5c, 5 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.14 ***
SU(0):   MOV64mr %73:gr64, 1, $noreg, -48, $noreg, %28:gr64 :: (store (s64) into %ir.40)
SU(1):   MOV64mr %73:gr64, 1, $noreg, -40, $noreg, %28:gr64 :: (store (s64) into %ir..repack63)
SU(2):   MOV64mi32 %73:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack65)
SU(3):   MOV64mr %73:gr64, 1, $noreg, -24, $noreg, %6:gr64_nosp :: (store (s64) into %ir..repack67)
SU(4):   MOV64mi32 %73:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack69)
SU(5):   %30:gr64 = LEA64r $noreg, 8, %7:gr64_nosp, 0, $noreg

********** MI Scheduling **********
main:%bb.14 ._crit_edge106
  From: %73:gr64 = COPY $rsp
    To: $rsp = COPY %29:gr64
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %73:gr64 = COPY $rsp
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%73
  Single Issue       : false;
SU(1):   %29:gr64 = LEA64r %73:gr64, 1, $noreg, -48, $noreg
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%73
  Successors:
    ExitSU: Data Latency=1 Reg=%29
  Single Issue       : false;
ExitSU:   $rsp = COPY %29:gr64
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%29
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %29:gr64 = LEA64r %73:gr64, 1, $noreg, -48, $noreg
  Ready @1c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %73:gr64 = COPY $rsp
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.14 ***
SU(0):   %73:gr64 = COPY $rsp
SU(1):   %29:gr64 = LEA64r %73:gr64, 1, $noreg, -48, $noreg

********** MI Scheduling **********
main:%bb.15 .lr.ph108.preheader
  From: $rdi = COPY %31:gr64
    To: CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %31:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %30:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = COPY %30:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = COPY %31:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.15 ***
SU(0):   $rdi = COPY %31:gr64
SU(1):   $rsi = COPY %30:gr64

********** MI Scheduling **********
main:%bb.16 ._crit_edge109
  From: %34:gr64 = COPY killed $rax
    To: JCC_1 %bb.18, 14, implicit $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Macro fuse: SU(1) - ExitSU /  TEST64rr - JCC_1
SU(0):   %34:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   TEST64rr %8:gr64_nosp, %8:gr64_nosp, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Artificial
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Single Issue       : false;
ExitSU:   JCC_1 %bb.18, 14, implicit $eflags
  # preds left       : 1
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) TEST64rr %8:gr64_nosp, %8:gr64_nosp, implicit-def $eflags
  Ready @0c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %34:gr64 = COPY killed $rax
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.16 ***
SU(0):   %34:gr64 = COPY killed $rax
SU(1):   TEST64rr %8:gr64_nosp, %8:gr64_nosp, implicit-def $eflags

********** MI Scheduling **********
main:%bb.16 ._crit_edge109
  From: MOV64mr %77:gr64, 1, $noreg, -48, $noreg, %31:gr64 :: (store (s64) into %ir.43)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV64mr %77:gr64, 1, $noreg, -48, $noreg, %31:gr64 :: (store (s64) into %ir.43)
  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Single Issue       : false;
SU(1):   MOV64mr %77:gr64, 1, $noreg, -40, $noreg, %31:gr64 :: (store (s64) into %ir..repack72)
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOV64mi32 %77:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack74)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
  Single Issue       : false;
SU(3):   MOV64mr %77:gr64, 1, $noreg, -24, $noreg, %7:gr64_nosp :: (store (s64) into %ir..repack76)
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
  Single Issue       : false;
SU(4):   MOV64mi32 %77:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack78)
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Single Issue       : false;
SU(5):   %33:gr64 = LEA64r $noreg, 8, %8:gr64_nosp, 0, $noreg
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 4 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %33:gr64 = LEA64r $noreg, 8, %8:gr64_nosp, 0, $noreg
  Ready @0c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) MOV64mi32 %77:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack78)
  Ready @0c
  SKLPort4 +1x24u
  *** Critical resource SKLPort4: 1c
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOV64mr %77:gr64, 1, $noreg, -24, $noreg, %7:gr64_nosp :: (store (s64) into %ir..repack76)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 3
  Executed: 2c
  Critical: 2c, 2 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOV64mi32 %77:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack74)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 4
  Executed: 3c
  Critical: 3c, 3 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %77:gr64, 1, $noreg, -40, $noreg, %31:gr64 :: (store (s64) into %ir..repack72)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 5
  Executed: 4c
  Critical: 4c, 4 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV64mr %77:gr64, 1, $noreg, -48, $noreg, %31:gr64 :: (store (s64) into %ir.43)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
  *** Max MOps 6 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 6
  Executed: 5c
  Critical: 5c, 5 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.16 ***
SU(0):   MOV64mr %77:gr64, 1, $noreg, -48, $noreg, %31:gr64 :: (store (s64) into %ir.43)
SU(1):   MOV64mr %77:gr64, 1, $noreg, -40, $noreg, %31:gr64 :: (store (s64) into %ir..repack72)
SU(2):   MOV64mi32 %77:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack74)
SU(3):   MOV64mr %77:gr64, 1, $noreg, -24, $noreg, %7:gr64_nosp :: (store (s64) into %ir..repack76)
SU(4):   MOV64mi32 %77:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack78)
SU(5):   %33:gr64 = LEA64r $noreg, 8, %8:gr64_nosp, 0, $noreg

********** MI Scheduling **********
main:%bb.16 ._crit_edge109
  From: %77:gr64 = COPY $rsp
    To: $rsp = COPY %32:gr64
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %77:gr64 = COPY $rsp
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%77
  Single Issue       : false;
SU(1):   %32:gr64 = LEA64r %77:gr64, 1, $noreg, -48, $noreg
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%77
  Successors:
    ExitSU: Data Latency=1 Reg=%32
  Single Issue       : false;
ExitSU:   $rsp = COPY %32:gr64
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%32
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %32:gr64 = LEA64r %77:gr64, 1, $noreg, -48, $noreg
  Ready @1c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %77:gr64 = COPY $rsp
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.16 ***
SU(0):   %77:gr64 = COPY $rsp
SU(1):   %32:gr64 = LEA64r %77:gr64, 1, $noreg, -48, $noreg

********** MI Scheduling **********
main:%bb.17 .lr.ph111.preheader
  From: $rdi = COPY %34:gr64
    To: CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %34:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %33:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = COPY %33:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = COPY %34:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.17 ***
SU(0):   $rdi = COPY %34:gr64
SU(1):   $rsi = COPY %33:gr64

********** MI Scheduling **********
main:%bb.18 ._crit_edge112
  From: %92:gr64 = MOV64ri @comet_print_memref_f64
    To: CALL64r %92:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %92:gr64 = MOV64ri @comet_print_memref_f64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Data Latency=1 Reg=%92
  Single Issue       : false;
SU(1):   $rdi = MOV32ri64 1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $rsi = COPY %82:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %92:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Data Latency=1 Reg=%92
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) $rsi = COPY %82:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rdi = MOV32ri64 1
  Ready @1c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %92:gr64 = MOV64ri @comet_print_memref_f64
  Ready @1c
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SKLPort0156
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.18 ***
SU(0):   %92:gr64 = MOV64ri @comet_print_memref_f64
SU(1):   $rdi = MOV32ri64 1
SU(2):   $rsi = COPY %82:gr64

********** MI Scheduling **********
main:%bb.18 ._crit_edge112
  From: $rdi = MOV32ri64 1
    To: CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %32:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) $rsi = COPY %32:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 1
  Ready @1c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(0) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.18 ***
SU(0):   $rdi = MOV32ri64 1
SU(1):   $rsi = COPY %32:gr64

********** MI Scheduling **********
main:%bb.18 ._crit_edge112
  From: $rdi = MOV32ri64 1
    To: CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %29:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) $rsi = COPY %29:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 1
  Ready @1c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(0) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.18 ***
SU(0):   $rdi = MOV32ri64 1
SU(1):   $rsi = COPY %29:gr64

********** MI Scheduling **********
main:%bb.18 ._crit_edge112
  From: $rdi = MOV32ri64 1
    To: CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %26:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) $rsi = COPY %26:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 1
  Ready @1c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(0) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.18 ***
SU(0):   $rdi = MOV32ri64 1
SU(1):   $rsi = COPY %26:gr64

********** MI Scheduling **********
main:%bb.18 ._crit_edge112
  From: $rdi = MOV32ri64 1
    To: CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %23:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) $rsi = COPY %23:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 1
  Ready @1c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(0) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.18 ***
SU(0):   $rdi = MOV32ri64 1
SU(1):   $rsi = COPY %23:gr64

********** MI Scheduling **********
main:%bb.18 ._crit_edge112
  From: $rdi = MOV32ri64 1
    To: CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %20:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) $rsi = COPY %20:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 1
  Ready @1c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(0) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.18 ***
SU(0):   $rdi = MOV32ri64 1
SU(1):   $rsi = COPY %20:gr64

********** MI Scheduling **********
main:%bb.18 ._crit_edge112
  From: $rdi = MOV32ri64 1
    To: CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %17:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) $rsi = COPY %17:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 1
  Ready @1c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(0) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.18 ***
SU(0):   $rdi = MOV32ri64 1
SU(1):   $rsi = COPY %17:gr64

********** MI Scheduling **********
main:%bb.18 ._crit_edge112
  From: $rdi = MOV32ri64 1
    To: CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %14:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) $rsi = COPY %14:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 1
  Ready @1c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(0) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.18 ***
SU(0):   $rdi = MOV32ri64 1
SU(1):   $rsi = COPY %14:gr64

********** MI Scheduling **********
main:%bb.18 ._crit_edge112
  From: %91:gr64 = MOV64ri @comet_print_memref_i64
    To: CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %91:gr64 = MOV64ri @comet_print_memref_i64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Data Latency=1 Reg=%91
  Single Issue       : false;
SU(1):   $rdi = MOV32ri64 1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $rsi = COPY %11:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Data Latency=1 Reg=%91
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) $rsi = COPY %11:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rdi = MOV32ri64 1
  Ready @1c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %91:gr64 = MOV64ri @comet_print_memref_i64
  Ready @1c
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SKLPort0156
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.18 ***
SU(0):   %91:gr64 = MOV64ri @comet_print_memref_i64
SU(1):   $rdi = MOV32ri64 1
SU(2):   $rsi = COPY %11:gr64

********** MI Scheduling **********
main:%bb.18 ._crit_edge112
  From: %84:gr64 = MOV64ri @read_input_2D_f64
    To: PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 136)
 RegionInstrs: 7
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %84:gr64 = MOV64ri @read_input_2D_f64
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   $edi = MOV32ri 1
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(2):   dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(3):   $rdx = MOV32ri64 3
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(4):   dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(5):   $r8 = MOV64ri32 -1
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(6):   $r9 = MOV32ri64 1
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
ExitSU:   PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 136)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 5 4 3 2 1 0 
  Cand SU(6) ORDER                              
  Cand SU(5) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(5) $r8 = MOV64ri32 -1
handleMove 4752B -> 4776B: $r8 = MOV64ri32 -1
     R8B:	[456r,480r:1)[4752r,5072r:0) 0@4752r 1@456r
        -->	[456r,480r:1)[4776r,5072r:0) 0@4776r 1@456r
     R8BH:	[456r,480r:1)[4752r,5072r:0) 0@4752r 1@456r
        -->	[456r,480r:1)[4776r,5072r:0) 0@4776r 1@456r
     R8WH:	[456r,480r:1)[4752r,5072r:0) 0@4752r 1@456r
        -->	[456r,480r:1)[4776r,5072r:0) 0@4776r 1@456r
  Ready @0c
  SKLPort0156 +1x6u
  *** Critical resource SKLPort0156: 0c
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 0 4 3 2 1 
  Cand SU(6) ORDER                              
  Cand SU(4) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(4) dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
handleMove 4736B -> 4772B: dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
     CH:	[448r,480r:1)[4736r,5072r:0) 0@4736r 1@448r
        -->	[448r,480r:1)[4772r,5072r:0) 0@4772r 1@448r
     CL:	[448r,480r:1)[4736r,5072r:0) 0@4736r 1@448r
        -->	[448r,480r:1)[4772r,5072r:0) 0@4772r 1@448r
     HCX:	[448r,480r:1)[4736r,5072r:0) 0@4736r 1@448r
        -->	[448r,480r:1)[4772r,5072r:0) 0@4772r 1@448r
     EFLAGS:	[16r,16d:90)[96r,96d:89)[208r,208d:88)[440r,440d:3)[448r,448d:2)[496r,496d:87)[672r,672d:86)[720r,720d:85)[792r,800r:84)[848r,848d:83)[912r,912d:82)[944r,944d:81)[1008r,1008d:80)[1120r,1120d:79)[1168r,1168d:78)[1216r,1232r:77)[1280r,1280d:76)[1344r,1344d:75)[1376r,1376d:74)[1440r,1440d:73)[1552r,1552d:72)[1600r,1600d:71)[1648r,1664r:70)[1712r,1712d:69)[1776r,1776d:68)[1808r,1808d:67)[1872r,1872d:66)[1984r,1984d:65)[2032r,2032d:64)[2080r,2096r:63)[2144r,2144d:62)[2208r,2208d:61)[2240r,2240d:60)[2304r,2304d:59)[2416r,2416d:58)[2464r,2464d:57)[2512r,2528r:56)[2576r,2576d:55)[2640r,2640d:54)[2672r,2672d:53)[2736r,2736d:52)[2848r,2848d:51)[2896r,2896d:50)[2944r,2960r:49)[3008r,3008d:48)[3072r,3072d:47)[3104r,3104d:46)[3168r,3168d:45)[3280r,3280d:44)[3328r,3328d:43)[3376r,3392r:42)[3440r,3440d:41)[3504r,3504d:40)[3536r,3536d:39)[3600r,3600d:38)[3712r,3712d:37)[3760r,3760d:36)[3808r,3824r:35)[3872r,3872d:34)[3936r,3936d:33)[3968r,3968d:32)[4032r,4032d:31)[4144r,4144d:30)[4192r,4192d:29)[4240r,4256r:28)[4304r,4304d:27)[4368r,4368d:26)[4400r,4400d:25)[4464r,4464d:24)[4560r,4560d:23)[4704r,4704d:1)[4736r,4736d:0)[5088r,5088d:22)[5104r,5104d:21)[5184r,5184d:20)[5200r,5200d:19)[5264r,5264d:18)[5280r,5280d:17)[5344r,5344d:16)[5360r,5360d:15)[5424r,5424d:14)[5440r,5440d:13)[5504r,5504d:12)[5520r,5520d:11)[5584r,5584d:10)[5600r,5600d:9)[5664r,5664d:8)[5680r,5680d:7)[5744r,5744d:6)[5760r,5760d:5)[5840r,5840d:4) 0@4736r 1@4704r 2@448r 3@440r 4@5840r 5@5760r 6@5744r 7@5680r 8@5664r 9@5600r 10@5584r 11@5520r 12@5504r 13@5440r 14@5424r 15@5360r 16@5344r 17@5280r 18@5264r 19@5200r 20@5184r 21@5104r 22@5088r 23@4560r 24@4464r 25@4400r 26@4368r 27@4304r 28@4240r 29@4192r 30@4144r 31@4032r 32@3968r 33@3936r 34@3872r 35@3808r 36@3760r 37@3712r 38@3600r 39@3536r 40@3504r 41@3440r 42@3376r 43@3328r 44@3280r 45@3168r 46@3104r 47@3072r 48@3008r 49@2944r 50@2896r 51@2848r 52@2736r 53@2672r 54@2640r 55@2576r 56@2512r 57@2464r 58@2416r 59@2304r 60@2240r 61@2208r 62@2144r 63@2080r 64@2032r 65@1984r 66@1872r 67@1808r 68@1776r 69@1712r 70@1648r 71@1600r 72@1552r 73@1440r 74@1376r 75@1344r 76@1280r 77@1216r 78@1168r 79@1120r 80@1008r 81@944r 82@912r 83@848r 84@792r 85@720r 86@672r 87@496r 88@208r 89@96r 90@16r
        -->	[16r,16d:90)[96r,96d:89)[208r,208d:88)[440r,440d:3)[448r,448d:2)[496r,496d:87)[672r,672d:86)[720r,720d:85)[792r,800r:84)[848r,848d:83)[912r,912d:82)[944r,944d:81)[1008r,1008d:80)[1120r,1120d:79)[1168r,1168d:78)[1216r,1232r:77)[1280r,1280d:76)[1344r,1344d:75)[1376r,1376d:74)[1440r,1440d:73)[1552r,1552d:72)[1600r,1600d:71)[1648r,1664r:70)[1712r,1712d:69)[1776r,1776d:68)[1808r,1808d:67)[1872r,1872d:66)[1984r,1984d:65)[2032r,2032d:64)[2080r,2096r:63)[2144r,2144d:62)[2208r,2208d:61)[2240r,2240d:60)[2304r,2304d:59)[2416r,2416d:58)[2464r,2464d:57)[2512r,2528r:56)[2576r,2576d:55)[2640r,2640d:54)[2672r,2672d:53)[2736r,2736d:52)[2848r,2848d:51)[2896r,2896d:50)[2944r,2960r:49)[3008r,3008d:48)[3072r,3072d:47)[3104r,3104d:46)[3168r,3168d:45)[3280r,3280d:44)[3328r,3328d:43)[3376r,3392r:42)[3440r,3440d:41)[3504r,3504d:40)[3536r,3536d:39)[3600r,3600d:38)[3712r,3712d:37)[3760r,3760d:36)[3808r,3824r:35)[3872r,3872d:34)[3936r,3936d:33)[3968r,3968d:32)[4032r,4032d:31)[4144r,4144d:30)[4192r,4192d:29)[4240r,4256r:28)[4304r,4304d:27)[4368r,4368d:26)[4400r,4400d:25)[4464r,4464d:24)[4560r,4560d:23)[4704r,4704d:1)[4772r,4772d:0)[5088r,5088d:22)[5104r,5104d:21)[5184r,5184d:20)[5200r,5200d:19)[5264r,5264d:18)[5280r,5280d:17)[5344r,5344d:16)[5360r,5360d:15)[5424r,5424d:14)[5440r,5440d:13)[5504r,5504d:12)[5520r,5520d:11)[5584r,5584d:10)[5600r,5600d:9)[5664r,5664d:8)[5680r,5680d:7)[5744r,5744d:6)[5760r,5760d:5)[5840r,5840d:4) 0@4772r 1@4704r 2@448r 3@440r 4@5840r 5@5760r 6@5744r 7@5680r 8@5664r 9@5600r 10@5584r 11@5520r 12@5504r 13@5440r 14@5424r 15@5360r 16@5344r 17@5280r 18@5264r 19@5200r 20@5184r 21@5104r 22@5088r 23@4560r 24@4464r 25@4400r 26@4368r 27@4304r 28@4240r 29@4192r 30@4144r 31@4032r 32@3968r 33@3936r 34@3872r 35@3808r 36@3760r 37@3712r 38@3600r 39@3536r 40@3504r 41@3440r 42@3376r 43@3328r 44@3280r 45@3168r 46@3104r 47@3072r 48@3008r 49@2944r 50@2896r 51@2848r 52@2736r 53@2672r 54@2640r 55@2576r 56@2512r 57@2464r 58@2416r 59@2304r 60@2240r 61@2208r 62@2144r 63@2080r 64@2032r 65@1984r 66@1872r 67@1808r 68@1776r 69@1712r 70@1648r 71@1600r 72@1552r 73@1440r 74@1376r 75@1344r 76@1280r 77@1216r 78@1168r 79@1120r 80@1008r 81@944r 82@912r 83@848r 84@792r 85@720r 86@672r 87@496r 88@208r 89@96r 90@16r
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 0 1 3 2 
  Cand SU(6) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi

*** Renumbered SlotIndexes 4768-4808 ***
handleMove 4704B -> 4776B: dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
     SIL:	[440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4704r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4704r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
        -->	[440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4776r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4776r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
     SIH:	[440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4704r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4704r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
        -->	[440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4776r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4776r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
     HSI:	[440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4704r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4704r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
        -->	[440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4776r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4776r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
     EFLAGS:	[16r,16d:90)[96r,96d:89)[208r,208d:88)[440r,440d:3)[448r,448d:2)[496r,496d:87)[672r,672d:86)[720r,720d:85)[792r,800r:84)[848r,848d:83)[912r,912d:82)[944r,944d:81)[1008r,1008d:80)[1120r,1120d:79)[1168r,1168d:78)[1216r,1232r:77)[1280r,1280d:76)[1344r,1344d:75)[1376r,1376d:74)[1440r,1440d:73)[1552r,1552d:72)[1600r,1600d:71)[1648r,1664r:70)[1712r,1712d:69)[1776r,1776d:68)[1808r,1808d:67)[1872r,1872d:66)[1984r,1984d:65)[2032r,2032d:64)[2080r,2096r:63)[2144r,2144d:62)[2208r,2208d:61)[2240r,2240d:60)[2304r,2304d:59)[2416r,2416d:58)[2464r,2464d:57)[2512r,2528r:56)[2576r,2576d:55)[2640r,2640d:54)[2672r,2672d:53)[2736r,2736d:52)[2848r,2848d:51)[2896r,2896d:50)[2944r,2960r:49)[3008r,3008d:48)[3072r,3072d:47)[3104r,3104d:46)[3168r,3168d:45)[3280r,3280d:44)[3328r,3328d:43)[3376r,3392r:42)[3440r,3440d:41)[3504r,3504d:40)[3536r,3536d:39)[3600r,3600d:38)[3712r,3712d:37)[3760r,3760d:36)[3808r,3824r:35)[3872r,3872d:34)[3936r,3936d:33)[3968r,3968d:32)[4032r,4032d:31)[4144r,4144d:30)[4192r,4192d:29)[4240r,4256r:28)[4304r,4304d:27)[4368r,4368d:26)[4400r,4400d:25)[4464r,4464d:24)[4560r,4560d:23)[4704r,4704d:1)[4784r,4784d:0)[5088r,5088d:22)[5104r,5104d:21)[5184r,5184d:20)[5200r,5200d:19)[5264r,5264d:18)[5280r,5280d:17)[5344r,5344d:16)[5360r,5360d:15)[5424r,5424d:14)[5440r,5440d:13)[5504r,5504d:12)[5520r,5520d:11)[5584r,5584d:10)[5600r,5600d:9)[5664r,5664d:8)[5680r,5680d:7)[5744r,5744d:6)[5760r,5760d:5)[5840r,5840d:4) 0@4784r 1@4704r 2@448r 3@440r 4@5840r 5@5760r 6@5744r 7@5680r 8@5664r 9@5600r 10@5584r 11@5520r 12@5504r 13@5440r 14@5424r 15@5360r 16@5344r 17@5280r 18@5264r 19@5200r 20@5184r 21@5104r 22@5088r 23@4560r 24@4464r 25@4400r 26@4368r 27@4304r 28@4240r 29@4192r 30@4144r 31@4032r 32@3968r 33@3936r 34@3872r 35@3808r 36@3760r 37@3712r 38@3600r 39@3536r 40@3504r 41@3440r 42@3376r 43@3328r 44@3280r 45@3168r 46@3104r 47@3072r 48@3008r 49@2944r 50@2896r 51@2848r 52@2736r 53@2672r 54@2640r 55@2576r 56@2512r 57@2464r 58@2416r 59@2304r 60@2240r 61@2208r 62@2144r 63@2080r 64@2032r 65@1984r 66@1872r 67@1808r 68@1776r 69@1712r 70@1648r 71@1600r 72@1552r 73@1440r 74@1376r 75@1344r 76@1280r 77@1216r 78@1168r 79@1120r 80@1008r 81@944r 82@912r 83@848r 84@792r 85@720r 86@672r 87@496r 88@208r 89@96r 90@16r
        -->	[16r,16d:90)[96r,96d:89)[208r,208d:88)[440r,440d:3)[448r,448d:2)[496r,496d:87)[672r,672d:86)[720r,720d:85)[792r,800r:84)[848r,848d:83)[912r,912d:82)[944r,944d:81)[1008r,1008d:80)[1120r,1120d:79)[1168r,1168d:78)[1216r,1232r:77)[1280r,1280d:76)[1344r,1344d:75)[1376r,1376d:74)[1440r,1440d:73)[1552r,1552d:72)[1600r,1600d:71)[1648r,1664r:70)[1712r,1712d:69)[1776r,1776d:68)[1808r,1808d:67)[1872r,1872d:66)[1984r,1984d:65)[2032r,2032d:64)[2080r,2096r:63)[2144r,2144d:62)[2208r,2208d:61)[2240r,2240d:60)[2304r,2304d:59)[2416r,2416d:58)[2464r,2464d:57)[2512r,2528r:56)[2576r,2576d:55)[2640r,2640d:54)[2672r,2672d:53)[2736r,2736d:52)[2848r,2848d:51)[2896r,2896d:50)[2944r,2960r:49)[3008r,3008d:48)[3072r,3072d:47)[3104r,3104d:46)[3168r,3168d:45)[3280r,3280d:44)[3328r,3328d:43)[3376r,3392r:42)[3440r,3440d:41)[3504r,3504d:40)[3536r,3536d:39)[3600r,3600d:38)[3712r,3712d:37)[3760r,3760d:36)[3808r,3824r:35)[3872r,3872d:34)[3936r,3936d:33)[3968r,3968d:32)[4032r,4032d:31)[4144r,4144d:30)[4192r,4192d:29)[4240r,4256r:28)[4304r,4304d:27)[4368r,4368d:26)[4400r,4400d:25)[4464r,4464d:24)[4560r,4560d:23)[4776r,4776d:1)[4784r,4784d:0)[5088r,5088d:22)[5104r,5104d:21)[5184r,5184d:20)[5200r,5200d:19)[5264r,5264d:18)[5280r,5280d:17)[5344r,5344d:16)[5360r,5360d:15)[5424r,5424d:14)[5440r,5440d:13)[5504r,5504d:12)[5520r,5520d:11)[5584r,5584d:10)[5600r,5600d:9)[5664r,5664d:8)[5680r,5680d:7)[5744r,5744d:6)[5760r,5760d:5)[5840r,5840d:4) 0@4784r 1@4776r 2@448r 3@440r 4@5840r 5@5760r 6@5744r 7@5680r 8@5664r 9@5600r 10@5584r 11@5520r 12@5504r 13@5440r 14@5424r 15@5360r 16@5344r 17@5280r 18@5264r 19@5200r 20@5184r 21@5104r 22@5088r 23@4560r 24@4464r 25@4400r 26@4368r 27@4304r 28@4240r 29@4192r 30@4144r 31@4032r 32@3968r 33@3936r 34@3872r 35@3808r 36@3760r 37@3712r 38@3600r 39@3536r 40@3504r 41@3440r 42@3376r 43@3328r 44@3280r 45@3168r 46@3104r 47@3072r 48@3008r 49@2944r 50@2896r 51@2848r 52@2736r 53@2672r 54@2640r 55@2576r 56@2512r 57@2464r 58@2416r 59@2304r 60@2240r 61@2208r 62@2144r 63@2080r 64@2032r 65@1984r 66@1872r 67@1808r 68@1776r 69@1712r 70@1648r 71@1600r 72@1552r 73@1440r 74@1376r 75@1344r 76@1280r 77@1216r 78@1168r 79@1120r 80@1008r 81@944r 82@912r 83@848r 84@792r 85@720r 86@672r 87@496r 88@208r 89@96r 90@16r
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 1 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 0 1 3 
  Cand SU(6) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $edi = MOV32ri 1
handleMove 4688B -> 4772B: $edi = MOV32ri 1
     DIL:	[64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4688r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4688r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
        -->	[64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4772r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4772r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
     DIH:	[64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4688r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4688r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
        -->	[64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4772r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4772r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
     HDI:	[64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4688r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4688r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
        -->	[64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4772r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4772r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
  Ready @0c
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 4
  Executed: 0c
  Critical: 0c, 2 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 0 3 
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) $r9 = MOV32ri64 1
  Ready @0c
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @0c
  Retired: 5
  Executed: 0c
  Critical: 0c, 3 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 0 
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) $rdx = MOV32ri64 3
  Ready @0c
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
  *** Max MOps 6 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 4 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %84:gr64 = MOV64ri @read_input_2D_f64
  Ready @1c
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
BotQ.A @1c
  Retired: 7
  Executed: 1c
  Critical: 1c, 5 SKLPort0156
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.18 ***
SU(0):   %84:gr64 = MOV64ri @read_input_2D_f64
SU(3):   $rdx = MOV32ri64 3
SU(6):   $r9 = MOV32ri64 1
SU(1):   $edi = MOV32ri 1
SU(2):   dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
SU(4):   dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
SU(5):   $r8 = MOV64ri32 -1

********** MI Scheduling **********
main:%bb.18 ._crit_edge112
  From: MOV64mr %81:gr64, 1, $noreg, -48, $noreg, %34:gr64 :: (store (s64) into %ir.46)
    To: ADJCALLSTACKDOWN64 144, 0, 144, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV64mr %81:gr64, 1, $noreg, -48, $noreg, %34:gr64 :: (store (s64) into %ir.46)
  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Single Issue       : false;
SU(1):   MOV64mr %81:gr64, 1, $noreg, -40, $noreg, %34:gr64 :: (store (s64) into %ir..repack81)
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOV64mi32 %81:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack83)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
  Single Issue       : false;
SU(3):   MOV64mr %81:gr64, 1, $noreg, -24, $noreg, %8:gr64_nosp :: (store (s64) into %ir..repack85)
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(4): Ord  Latency=0 Memory
  Single Issue       : false;
SU(4):   MOV64mi32 %81:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack87)
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 144, 0, 144, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) MOV64mi32 %81:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack87)
  Ready @0c
  SKLPort4 +1x24u
  *** Critical resource SKLPort4: 1c
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOV64mr %81:gr64, 1, $noreg, -24, $noreg, %8:gr64_nosp :: (store (s64) into %ir..repack85)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 2
  Executed: 2c
  Critical: 2c, 2 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOV64mi32 %81:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack83)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 3
  Executed: 3c
  Critical: 3c, 3 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %81:gr64, 1, $noreg, -40, $noreg, %34:gr64 :: (store (s64) into %ir..repack81)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 4
  Executed: 4c
  Critical: 4c, 4 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV64mr %81:gr64, 1, $noreg, -48, $noreg, %34:gr64 :: (store (s64) into %ir.46)
  Ready @0c
  SKLPort4 +1x24u
  SKLPort04 +1x12u
  SKLPort237 +1x8u
  SKLPortAny +2x3u
BotQ.A @0c
  Retired: 5
  Executed: 5c
  Critical: 5c, 5 SKLPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.18 ***
SU(0):   MOV64mr %81:gr64, 1, $noreg, -48, $noreg, %34:gr64 :: (store (s64) into %ir.46)
SU(1):   MOV64mr %81:gr64, 1, $noreg, -40, $noreg, %34:gr64 :: (store (s64) into %ir..repack81)
SU(2):   MOV64mi32 %81:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack83)
SU(3):   MOV64mr %81:gr64, 1, $noreg, -24, $noreg, %8:gr64_nosp :: (store (s64) into %ir..repack85)
SU(4):   MOV64mi32 %81:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack87)

********** MI Scheduling **********
main:%bb.18 ._crit_edge112
  From: %81:gr64 = COPY $rsp
    To: $rsp = COPY %82:gr64
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %81:gr64 = COPY $rsp
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%81
  Single Issue       : false;
SU(1):   %82:gr64 = LEA64r %81:gr64, 1, $noreg, -48, $noreg
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%81
  Successors:
    ExitSU: Data Latency=1 Reg=%82
  Single Issue       : false;
ExitSU:   $rsp = COPY %82:gr64
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%82
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %82:gr64 = LEA64r %81:gr64, 1, $noreg, -48, $noreg
  Ready @1c
  SKLPort15 +1x12u
  *** Critical resource SKLPort15: 0c
  SKLPort015 +1x8u
  SKLPort0156 +1x6u
  SKLPortAny +1x3u
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %81:gr64 = COPY $rsp
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SKLPort15
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.18 ***
SU(0):   %81:gr64 = COPY $rsp
SU(1):   %82:gr64 = LEA64r %81:gr64, 1, $noreg, -48, $noreg

********** INTERVALS **********
CH [448r,480r:1)[4784r,5072r:0) 0@4784r 1@448r
CL [448r,480r:1)[4784r,5072r:0) 0@4784r 1@448r
DIL [64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4772r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4772r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
DIH [64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4772r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4772r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
HCX [448r,480r:1)[4784r,5072r:0) 0@4784r 1@448r
HDI [64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4772r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4772r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
EFLAGS [16r,16d:90)[96r,96d:89)[208r,208d:88)[440r,440d:3)[448r,448d:2)[496r,496d:87)[672r,672d:86)[720r,720d:85)[792r,800r:84)[848r,848d:83)[912r,912d:82)[944r,944d:81)[1008r,1008d:80)[1120r,1120d:79)[1168r,1168d:78)[1216r,1232r:77)[1280r,1280d:76)[1344r,1344d:75)[1376r,1376d:74)[1440r,1440d:73)[1552r,1552d:72)[1600r,1600d:71)[1648r,1664r:70)[1712r,1712d:69)[1776r,1776d:68)[1808r,1808d:67)[1872r,1872d:66)[1984r,1984d:65)[2032r,2032d:64)[2080r,2096r:63)[2144r,2144d:62)[2208r,2208d:61)[2240r,2240d:60)[2304r,2304d:59)[2416r,2416d:58)[2464r,2464d:57)[2512r,2528r:56)[2576r,2576d:55)[2640r,2640d:54)[2672r,2672d:53)[2736r,2736d:52)[2848r,2848d:51)[2896r,2896d:50)[2944r,2960r:49)[3008r,3008d:48)[3072r,3072d:47)[3104r,3104d:46)[3168r,3168d:45)[3280r,3280d:44)[3328r,3328d:43)[3376r,3392r:42)[3440r,3440d:41)[3504r,3504d:40)[3536r,3536d:39)[3600r,3600d:38)[3712r,3712d:37)[3760r,3760d:36)[3808r,3824r:35)[3872r,3872d:34)[3936r,3936d:33)[3968r,3968d:32)[4032r,4032d:31)[4144r,4144d:30)[4192r,4192d:29)[4240r,4256r:28)[4304r,4304d:27)[4368r,4368d:26)[4400r,4400d:25)[4464r,4464d:24)[4560r,4560d:23)[4776r,4776d:1)[4784r,4784d:0)[5088r,5088d:22)[5104r,5104d:21)[5184r,5184d:20)[5200r,5200d:19)[5264r,5264d:18)[5280r,5280d:17)[5344r,5344d:16)[5360r,5360d:15)[5424r,5424d:14)[5440r,5440d:13)[5504r,5504d:12)[5520r,5520d:11)[5584r,5584d:10)[5600r,5600d:9)[5664r,5664d:8)[5680r,5680d:7)[5744r,5744d:6)[5760r,5760d:5)[5840r,5840d:4) 0@4784r 1@4776r 2@448r 3@440r 4@5840r 5@5760r 6@5744r 7@5680r 8@5664r 9@5600r 10@5584r 11@5520r 12@5504r 13@5440r 14@5424r 15@5360r 16@5344r 17@5280r 18@5264r 19@5200r 20@5184r 21@5104r 22@5088r 23@4560r 24@4464r 25@4400r 26@4368r 27@4304r 28@4240r 29@4192r 30@4144r 31@4032r 32@3968r 33@3936r 34@3872r 35@3808r 36@3760r 37@3712r 38@3600r 39@3536r 40@3504r 41@3440r 42@3376r 43@3328r 44@3280r 45@3168r 46@3104r 47@3072r 48@3008r 49@2944r 50@2896r 51@2848r 52@2736r 53@2672r 54@2640r 55@2576r 56@2512r 57@2464r 58@2416r 59@2304r 60@2240r 61@2208r 62@2144r 63@2080r 64@2032r 65@1984r 66@1872r 67@1808r 68@1776r 69@1712r 70@1648r 71@1600r 72@1552r 73@1440r 74@1376r 75@1344r 76@1280r 77@1216r 78@1168r 79@1120r 80@1008r 81@944r 82@912r 83@848r 84@792r 85@720r 86@672r 87@496r 88@208r 89@96r 90@16r
SIL [440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4776r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4776r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
SIH [440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4776r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4776r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
HSI [440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4776r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4776r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
SPL [16r,16d:136)[80r,80d:135)[96r,96d:134)[208r,208d:133)[464r,464d:19)[472r,472d:18)[480r,480d:132)[496r,496d:131)[672r,672d:130)[704r,704d:129)[720r,720d:128)[848r,848d:127)[896r,896d:126)[912r,912d:125)[944r,944d:124)[992r,992d:123)[1008r,1008d:122)[1120r,1120d:121)[1152r,1152d:120)[1168r,1168d:119)[1280r,1280d:118)[1328r,1328d:117)[1344r,1344d:116)[1376r,1376d:115)[1424r,1424d:114)[1440r,1440d:113)[1552r,1552d:112)[1584r,1584d:111)[1600r,1600d:110)[1712r,1712d:109)[1760r,1760d:108)[1776r,1776d:107)[1808r,1808d:106)[1856r,1856d:105)[1872r,1872d:104)[1984r,1984d:103)[2016r,2016d:102)[2032r,2032d:101)[2144r,2144d:100)[2192r,2192d:99)[2208r,2208d:98)[2240r,2240d:97)[2288r,2288d:96)[2304r,2304d:95)[2416r,2416d:94)[2448r,2448d:93)[2464r,2464d:92)[2576r,2576d:91)[2624r,2624d:90)[2640r,2640d:89)[2672r,2672d:88)[2720r,2720d:87)[2736r,2736d:86)[2848r,2848d:85)[2880r,2880d:84)[2896r,2896d:83)[3008r,3008d:82)[3056r,3056d:81)[3072r,3072d:80)[3104r,3104d:79)[3152r,3152d:78)[3168r,3168d:77)[3280r,3280d:76)[3312r,3312d:75)[3328r,3328d:74)[3440r,3440d:73)[3488r,3488d:72)[3504r,3504d:71)[3536r,3536d:70)[3584r,3584d:69)[3600r,3600d:68)[3712r,3712d:67)[3744r,3744d:66)[3760r,3760d:65)[3872r,3872d:64)[3920r,3920d:63)[3936r,3936d:62)[3968r,3968d:61)[4016r,4016d:60)[4032r,4032d:59)[4144r,4144d:58)[4176r,4176d:57)[4192r,4192d:56)[4304r,4304d:55)[4352r,4352d:54)[4368r,4368d:53)[4400r,4400d:52)[4448r,4448d:51)[4464r,4464d:50)[4560r,4560d:49)[4800r,4800d:17)[4808r,4808d:16)[4816r,4816d:15)[4832r,4832d:14)[4848r,4848d:13)[4864r,4864d:12)[4880r,4880d:11)[4896r,4896d:10)[4912r,4912d:9)[4928r,4928d:8)[4944r,4944d:7)[4960r,4960d:6)[4976r,4976d:5)[4992r,4992d:4)[5008r,5008d:3)[5024r,5024d:2)[5040r,5040d:1)[5056r,5056d:0)[5072r,5072d:48)[5088r,5088d:47)[5104r,5104d:46)[5168r,5168d:45)[5184r,5184d:44)[5200r,5200d:43)[5248r,5248d:42)[5264r,5264d:41)[5280r,5280d:40)[5328r,5328d:39)[5344r,5344d:38)[5360r,5360d:37)[5408r,5408d:36)[5424r,5424d:35)[5440r,5440d:34)[5488r,5488d:33)[5504r,5504d:32)[5520r,5520d:31)[5568r,5568d:30)[5584r,5584d:29)[5600r,5600d:28)[5648r,5648d:27)[5664r,5664d:26)[5680r,5680d:25)[5728r,5728d:24)[5744r,5744d:23)[5760r,5760d:22)[5824r,5824d:21)[5840r,5840d:20) 0@5056r 1@5040r 2@5024r 3@5008r 4@4992r 5@4976r 6@4960r 7@4944r 8@4928r 9@4912r 10@4896r 11@4880r 12@4864r 13@4848r 14@4832r 15@4816r 16@4808r 17@4800r 18@472r 19@464r 20@5840r 21@5824r 22@5760r 23@5744r 24@5728r 25@5680r 26@5664r 27@5648r 28@5600r 29@5584r 30@5568r 31@5520r 32@5504r 33@5488r 34@5440r 35@5424r 36@5408r 37@5360r 38@5344r 39@5328r 40@5280r 41@5264r 42@5248r 43@5200r 44@5184r 45@5168r 46@5104r 47@5088r 48@5072r 49@4560r 50@4464r 51@4448r 52@4400r 53@4368r 54@4352r 55@4304r 56@4192r 57@4176r 58@4144r 59@4032r 60@4016r 61@3968r 62@3936r 63@3920r 64@3872r 65@3760r 66@3744r 67@3712r 68@3600r 69@3584r 70@3536r 71@3504r 72@3488r 73@3440r 74@3328r 75@3312r 76@3280r 77@3168r 78@3152r 79@3104r 80@3072r 81@3056r 82@3008r 83@2896r 84@2880r 85@2848r 86@2736r 87@2720r 88@2672r 89@2640r 90@2624r 91@2576r 92@2464r 93@2448r 94@2416r 95@2304r 96@2288r 97@2240r 98@2208r 99@2192r 100@2144r 101@2032r 102@2016r 103@1984r 104@1872r 105@1856r 106@1808r 107@1776r 108@1760r 109@1712r 110@1600r 111@1584r 112@1552r 113@1440r 114@1424r 115@1376r 116@1344r 117@1328r 118@1280r 119@1168r 120@1152r 121@1120r 122@1008r 123@992r 124@944r 125@912r 126@896r 127@848r 128@720r 129@704r 130@672r 131@496r 132@480r 133@208r 134@96r 135@80r 136@16r
R8B [456r,480r:1)[4792r,5072r:0) 0@4792r 1@456r
R8BH [456r,480r:1)[4792r,5072r:0) 0@4792r 1@456r
R8WH [456r,480r:1)[4792r,5072r:0) 0@4792r 1@456r
%0 [512r,1072r:0) 0@512r  weight:0.000000e+00
%1 [528r,1504r:0) 0@528r  weight:0.000000e+00
%2 [544r,1936r:0) 0@544r  weight:0.000000e+00
%3 [560r,2368r:0) 0@560r  weight:0.000000e+00
%4 [576r,2800r:0) 0@576r  weight:0.000000e+00
%5 [592r,3232r:0) 0@592r  weight:0.000000e+00
%6 [608r,3664r:0) 0@608r  weight:0.000000e+00
%7 [624r,4096r:0) 0@624r  weight:0.000000e+00
%8 [640r,4528r:0) 0@640r  weight:0.000000e+00
%9 [656r,880r:0) 0@656r  weight:0.000000e+00
%10 [736r,1040r:0) 0@736r  weight:0.000000e+00
%11 [976r,5152r:0) 0@976r  weight:0.000000e+00
%12 [1104r,1312r:0) 0@1104r  weight:0.000000e+00
%13 [1184r,1472r:0) 0@1184r  weight:0.000000e+00
%14 [1408r,5232r:0) 0@1408r  weight:0.000000e+00
%15 [1536r,1744r:0) 0@1536r  weight:0.000000e+00
%16 [1616r,1904r:0) 0@1616r  weight:0.000000e+00
%17 [1840r,5312r:0) 0@1840r  weight:0.000000e+00
%18 [1968r,2176r:0) 0@1968r  weight:0.000000e+00
%19 [2048r,2336r:0) 0@2048r  weight:0.000000e+00
%20 [2272r,5392r:0) 0@2272r  weight:0.000000e+00
%21 [2400r,2608r:0) 0@2400r  weight:0.000000e+00
%22 [2480r,2768r:0) 0@2480r  weight:0.000000e+00
%23 [2704r,5472r:0) 0@2704r  weight:0.000000e+00
%24 [2832r,3040r:0) 0@2832r  weight:0.000000e+00
%25 [2912r,3200r:0) 0@2912r  weight:0.000000e+00
%26 [3136r,5552r:0) 0@3136r  weight:0.000000e+00
%27 [3264r,3472r:0) 0@3264r  weight:0.000000e+00
%28 [3344r,3632r:0) 0@3344r  weight:0.000000e+00
%29 [3568r,5632r:0) 0@3568r  weight:0.000000e+00
%30 [3696r,3904r:0) 0@3696r  weight:0.000000e+00
%31 [3776r,4064r:0) 0@3776r  weight:0.000000e+00
%32 [4000r,5712r:0) 0@4000r  weight:0.000000e+00
%33 [4128r,4336r:0) 0@4128r  weight:0.000000e+00
%34 [4208r,4496r:0) 0@4208r  weight:0.000000e+00
%35 [32r,4176r:0) 0@32r  weight:0.000000e+00
%37 [112r,640r:0) 0@112r  weight:0.000000e+00
%39 [224r,472r:0) 0@224r  weight:0.000000e+00
%40 [240r,480r:0) 0@240r  weight:0.000000e+00
%49 [960r,1088r:0) 0@960r  weight:0.000000e+00
%53 [1392r,1520r:0) 0@1392r  weight:0.000000e+00
%57 [1824r,1952r:0) 0@1824r  weight:0.000000e+00
%61 [2256r,2384r:0) 0@2256r  weight:0.000000e+00
%65 [2688r,2816r:0) 0@2688r  weight:0.000000e+00
%69 [3120r,3248r:0) 0@3120r  weight:0.000000e+00
%73 [3552r,3680r:0) 0@3552r  weight:0.000000e+00
%77 [3984r,4112r:0) 0@3984r  weight:0.000000e+00
%81 [4416r,4544r:0) 0@4416r  weight:0.000000e+00
%82 [4432r,5808r:0) 0@4432r  weight:0.000000e+00
%84 [4576r,5072r:0) 0@4576r  weight:0.000000e+00
%91 [5120r,5728r:0) 0@5120r  weight:0.000000e+00
%92 [5776r,5824r:0) 0@5776r  weight:0.000000e+00
%100 [784r,4352r:0) 0@784r  weight:0.000000e+00
RegMasks: 80r 480r 704r 896r 1152r 1328r 1584r 1760r 2016r 2192r 2448r 2624r 2880r 3056r 3312r 3488r 3744r 3920r 4176r 4352r 5072r 5168r 5248r 5328r 5408r 5488r 5568r 5648r 5728r 5824r
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=40, align=8, at location [SP+8]
  fi#1: variable sized, align=1, at location [SP+8]
  fi#2: variable sized, align=1, at location [SP+8]
  fi#3: variable sized, align=1, at location [SP+8]
  fi#4: variable sized, align=1, at location [SP+8]
  fi#5: variable sized, align=1, at location [SP+8]
  fi#6: variable sized, align=1, at location [SP+8]
  fi#7: variable sized, align=1, at location [SP+8]
  fi#8: variable sized, align=1, at location [SP+8]
  fi#9: variable sized, align=1, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %35:gr64 = MOV64ri @malloc
64B	  $rdi = MOV32ri64 56
80B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %37:gr64 = COPY killed $rax
128B	  MOV64mr %stack.0, 1, $noreg, 0, $noreg, %37:gr64 :: (store (s64) into %ir.2)
144B	  MOV64mr %stack.0, 1, $noreg, 8, $noreg, %37:gr64 :: (store (s64) into %ir..fca.1.gep)
160B	  MOV64mi32 %stack.0, 1, $noreg, 16, $noreg, 0 :: (store (s64) into %ir..fca.2.gep)
176B	  MOV64mi32 %stack.0, 1, $noreg, 24, $noreg, 7 :: (store (s64) into %ir..fca.3.0.gep)
192B	  MOV64mi32 %stack.0, 1, $noreg, 32, $noreg, 1 :: (store (s64) into %ir..fca.4.0.gep)
208B	  ADJCALLSTACKDOWN64 16, 0, 16, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
224B	  %39:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
240B	  %40:gr64 = MOV64ri @read_input_sizes_2D_f64
384B	  $rdx = MOV32ri64 3
432B	  $r9 = MOV32ri64 1
436B	  $edi = MOV32ri 1
440B	  dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
448B	  dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
456B	  $r8 = MOV64ri32 -1
464B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 8)
472B	  PUSH64r %39:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
480B	  CALL64r %40:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit killed $rdx, implicit $rcx, implicit $r8, implicit killed $r9, implicit-def $rsp, implicit-def $ssp
496B	  ADJCALLSTACKUP64 16, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
512B	  %0:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
528B	  %1:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
544B	  %2:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
560B	  %3:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
576B	  %4:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
592B	  %5:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
608B	  %6:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
624B	  %7:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
640B	  %8:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
656B	  %9:gr64 = LEA64r $noreg, 8, %0:gr64_nosp, 0, $noreg
672B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
688B	  $rdi = COPY %9:gr64
704B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
720B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
736B	  %10:gr64 = COPY killed $rax
784B	  %100:gr64 = MOV64ri &__bzero
792B	  TEST64rr %0:gr64_nosp, %0:gr64_nosp, implicit-def $eflags
800B	  JCC_1 %bb.2, 14, implicit $eflags
816B	  JMP_1 %bb.1

832B	bb.1..lr.ph.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
864B	  $rdi = COPY %10:gr64
880B	  $rsi = COPY %9:gr64
896B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
912B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

928B	bb.2.._crit_edge:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.3(0x50000000), %bb.4(0x30000000); %bb.3(62.50%), %bb.4(37.50%)

944B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
960B	  %49:gr64 = COPY $rsp
976B	  %11:gr64 = LEA64r %49:gr64, 1, $noreg, -48, $noreg
992B	  $rsp = COPY %11:gr64
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1024B	  MOV64mr %49:gr64, 1, $noreg, -48, $noreg, %10:gr64 :: (store (s64) into %ir.22)
1040B	  MOV64mr %49:gr64, 1, $noreg, -40, $noreg, %10:gr64 :: (store (s64) into %ir..repack9)
1056B	  MOV64mi32 %49:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack11)
1072B	  MOV64mr %49:gr64, 1, $noreg, -24, $noreg, %0:gr64_nosp :: (store (s64) into %ir..repack13)
1088B	  MOV64mi32 %49:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack15)
1104B	  %12:gr64 = LEA64r $noreg, 8, %1:gr64_nosp, 0, $noreg
1120B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1136B	  $rdi = COPY %12:gr64
1152B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1184B	  %13:gr64 = COPY killed $rax
1216B	  TEST64rr %1:gr64_nosp, %1:gr64_nosp, implicit-def $eflags
1232B	  JCC_1 %bb.4, 14, implicit $eflags
1248B	  JMP_1 %bb.3

1264B	bb.3..lr.ph90.preheader:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1296B	  $rdi = COPY %13:gr64
1312B	  $rsi = COPY %12:gr64
1328B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
1344B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

1360B	bb.4.._crit_edge91:
	; predecessors: %bb.2, %bb.3
	  successors: %bb.5(0x50000000), %bb.6(0x30000000); %bb.5(62.50%), %bb.6(37.50%)

1376B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1392B	  %53:gr64 = COPY $rsp
1408B	  %14:gr64 = LEA64r %53:gr64, 1, $noreg, -48, $noreg
1424B	  $rsp = COPY %14:gr64
1440B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1456B	  MOV64mr %53:gr64, 1, $noreg, -48, $noreg, %13:gr64 :: (store (s64) into %ir.25)
1472B	  MOV64mr %53:gr64, 1, $noreg, -40, $noreg, %13:gr64 :: (store (s64) into %ir..repack18)
1488B	  MOV64mi32 %53:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack20)
1504B	  MOV64mr %53:gr64, 1, $noreg, -24, $noreg, %1:gr64_nosp :: (store (s64) into %ir..repack22)
1520B	  MOV64mi32 %53:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack24)
1536B	  %15:gr64 = LEA64r $noreg, 8, %2:gr64_nosp, 0, $noreg
1552B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1568B	  $rdi = COPY %15:gr64
1584B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1600B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1616B	  %16:gr64 = COPY killed $rax
1648B	  TEST64rr %2:gr64_nosp, %2:gr64_nosp, implicit-def $eflags
1664B	  JCC_1 %bb.6, 14, implicit $eflags
1680B	  JMP_1 %bb.5

1696B	bb.5..lr.ph93.preheader:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

1712B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1728B	  $rdi = COPY %16:gr64
1744B	  $rsi = COPY %15:gr64
1760B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
1776B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

1792B	bb.6.._crit_edge94:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.7(0x50000000), %bb.8(0x30000000); %bb.7(62.50%), %bb.8(37.50%)

1808B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1824B	  %57:gr64 = COPY $rsp
1840B	  %17:gr64 = LEA64r %57:gr64, 1, $noreg, -48, $noreg
1856B	  $rsp = COPY %17:gr64
1872B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1888B	  MOV64mr %57:gr64, 1, $noreg, -48, $noreg, %16:gr64 :: (store (s64) into %ir.28)
1904B	  MOV64mr %57:gr64, 1, $noreg, -40, $noreg, %16:gr64 :: (store (s64) into %ir..repack27)
1920B	  MOV64mi32 %57:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack29)
1936B	  MOV64mr %57:gr64, 1, $noreg, -24, $noreg, %2:gr64_nosp :: (store (s64) into %ir..repack31)
1952B	  MOV64mi32 %57:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack33)
1968B	  %18:gr64 = LEA64r $noreg, 8, %3:gr64_nosp, 0, $noreg
1984B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2000B	  $rdi = COPY %18:gr64
2016B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2048B	  %19:gr64 = COPY killed $rax
2080B	  TEST64rr %3:gr64_nosp, %3:gr64_nosp, implicit-def $eflags
2096B	  JCC_1 %bb.8, 14, implicit $eflags
2112B	  JMP_1 %bb.7

2128B	bb.7..lr.ph96.preheader:
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)

2144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2160B	  $rdi = COPY %19:gr64
2176B	  $rsi = COPY %18:gr64
2192B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
2208B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2224B	bb.8.._crit_edge97:
	; predecessors: %bb.6, %bb.7
	  successors: %bb.9(0x50000000), %bb.10(0x30000000); %bb.9(62.50%), %bb.10(37.50%)

2240B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2256B	  %61:gr64 = COPY $rsp
2272B	  %20:gr64 = LEA64r %61:gr64, 1, $noreg, -48, $noreg
2288B	  $rsp = COPY %20:gr64
2304B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2320B	  MOV64mr %61:gr64, 1, $noreg, -48, $noreg, %19:gr64 :: (store (s64) into %ir.31)
2336B	  MOV64mr %61:gr64, 1, $noreg, -40, $noreg, %19:gr64 :: (store (s64) into %ir..repack36)
2352B	  MOV64mi32 %61:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack38)
2368B	  MOV64mr %61:gr64, 1, $noreg, -24, $noreg, %3:gr64_nosp :: (store (s64) into %ir..repack40)
2384B	  MOV64mi32 %61:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack42)
2400B	  %21:gr64 = LEA64r $noreg, 8, %4:gr64_nosp, 0, $noreg
2416B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2432B	  $rdi = COPY %21:gr64
2448B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2464B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2480B	  %22:gr64 = COPY killed $rax
2512B	  TEST64rr %4:gr64_nosp, %4:gr64_nosp, implicit-def $eflags
2528B	  JCC_1 %bb.10, 14, implicit $eflags
2544B	  JMP_1 %bb.9

2560B	bb.9..lr.ph99.preheader:
	; predecessors: %bb.8
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

2576B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2592B	  $rdi = COPY %22:gr64
2608B	  $rsi = COPY %21:gr64
2624B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
2640B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2656B	bb.10.._crit_edge100:
	; predecessors: %bb.8, %bb.9
	  successors: %bb.11(0x50000000), %bb.12(0x30000000); %bb.11(62.50%), %bb.12(37.50%)

2672B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2688B	  %65:gr64 = COPY $rsp
2704B	  %23:gr64 = LEA64r %65:gr64, 1, $noreg, -48, $noreg
2720B	  $rsp = COPY %23:gr64
2736B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2752B	  MOV64mr %65:gr64, 1, $noreg, -48, $noreg, %22:gr64 :: (store (s64) into %ir.34)
2768B	  MOV64mr %65:gr64, 1, $noreg, -40, $noreg, %22:gr64 :: (store (s64) into %ir..repack45)
2784B	  MOV64mi32 %65:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack47)
2800B	  MOV64mr %65:gr64, 1, $noreg, -24, $noreg, %4:gr64_nosp :: (store (s64) into %ir..repack49)
2816B	  MOV64mi32 %65:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack51)
2832B	  %24:gr64 = LEA64r $noreg, 8, %5:gr64_nosp, 0, $noreg
2848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2864B	  $rdi = COPY %24:gr64
2880B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2912B	  %25:gr64 = COPY killed $rax
2944B	  TEST64rr %5:gr64_nosp, %5:gr64_nosp, implicit-def $eflags
2960B	  JCC_1 %bb.12, 14, implicit $eflags
2976B	  JMP_1 %bb.11

2992B	bb.11..lr.ph102.preheader:
	; predecessors: %bb.10
	  successors: %bb.12(0x80000000); %bb.12(100.00%)

3008B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3024B	  $rdi = COPY %25:gr64
3040B	  $rsi = COPY %24:gr64
3056B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
3072B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3088B	bb.12.._crit_edge103:
	; predecessors: %bb.10, %bb.11
	  successors: %bb.13(0x50000000), %bb.14(0x30000000); %bb.13(62.50%), %bb.14(37.50%)

3104B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3120B	  %69:gr64 = COPY $rsp
3136B	  %26:gr64 = LEA64r %69:gr64, 1, $noreg, -48, $noreg
3152B	  $rsp = COPY %26:gr64
3168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3184B	  MOV64mr %69:gr64, 1, $noreg, -48, $noreg, %25:gr64 :: (store (s64) into %ir.37)
3200B	  MOV64mr %69:gr64, 1, $noreg, -40, $noreg, %25:gr64 :: (store (s64) into %ir..repack54)
3216B	  MOV64mi32 %69:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack56)
3232B	  MOV64mr %69:gr64, 1, $noreg, -24, $noreg, %5:gr64_nosp :: (store (s64) into %ir..repack58)
3248B	  MOV64mi32 %69:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack60)
3264B	  %27:gr64 = LEA64r $noreg, 8, %6:gr64_nosp, 0, $noreg
3280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3296B	  $rdi = COPY %27:gr64
3312B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3328B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3344B	  %28:gr64 = COPY killed $rax
3376B	  TEST64rr %6:gr64_nosp, %6:gr64_nosp, implicit-def $eflags
3392B	  JCC_1 %bb.14, 14, implicit $eflags
3408B	  JMP_1 %bb.13

3424B	bb.13..lr.ph105.preheader:
	; predecessors: %bb.12
	  successors: %bb.14(0x80000000); %bb.14(100.00%)

3440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3456B	  $rdi = COPY %28:gr64
3472B	  $rsi = COPY %27:gr64
3488B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
3504B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3520B	bb.14.._crit_edge106:
	; predecessors: %bb.12, %bb.13
	  successors: %bb.15(0x50000000), %bb.16(0x30000000); %bb.15(62.50%), %bb.16(37.50%)

3536B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3552B	  %73:gr64 = COPY $rsp
3568B	  %29:gr64 = LEA64r %73:gr64, 1, $noreg, -48, $noreg
3584B	  $rsp = COPY %29:gr64
3600B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3616B	  MOV64mr %73:gr64, 1, $noreg, -48, $noreg, %28:gr64 :: (store (s64) into %ir.40)
3632B	  MOV64mr %73:gr64, 1, $noreg, -40, $noreg, %28:gr64 :: (store (s64) into %ir..repack63)
3648B	  MOV64mi32 %73:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack65)
3664B	  MOV64mr %73:gr64, 1, $noreg, -24, $noreg, %6:gr64_nosp :: (store (s64) into %ir..repack67)
3680B	  MOV64mi32 %73:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack69)
3696B	  %30:gr64 = LEA64r $noreg, 8, %7:gr64_nosp, 0, $noreg
3712B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3728B	  $rdi = COPY %30:gr64
3744B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3760B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3776B	  %31:gr64 = COPY killed $rax
3808B	  TEST64rr %7:gr64_nosp, %7:gr64_nosp, implicit-def $eflags
3824B	  JCC_1 %bb.16, 14, implicit $eflags
3840B	  JMP_1 %bb.15

3856B	bb.15..lr.ph108.preheader:
	; predecessors: %bb.14
	  successors: %bb.16(0x80000000); %bb.16(100.00%)

3872B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3888B	  $rdi = COPY %31:gr64
3904B	  $rsi = COPY %30:gr64
3920B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
3936B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3952B	bb.16.._crit_edge109:
	; predecessors: %bb.14, %bb.15
	  successors: %bb.17(0x50000000), %bb.18(0x30000000); %bb.17(62.50%), %bb.18(37.50%)

3968B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3984B	  %77:gr64 = COPY $rsp
4000B	  %32:gr64 = LEA64r %77:gr64, 1, $noreg, -48, $noreg
4016B	  $rsp = COPY %32:gr64
4032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4048B	  MOV64mr %77:gr64, 1, $noreg, -48, $noreg, %31:gr64 :: (store (s64) into %ir.43)
4064B	  MOV64mr %77:gr64, 1, $noreg, -40, $noreg, %31:gr64 :: (store (s64) into %ir..repack72)
4080B	  MOV64mi32 %77:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack74)
4096B	  MOV64mr %77:gr64, 1, $noreg, -24, $noreg, %7:gr64_nosp :: (store (s64) into %ir..repack76)
4112B	  MOV64mi32 %77:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack78)
4128B	  %33:gr64 = LEA64r $noreg, 8, %8:gr64_nosp, 0, $noreg
4144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4160B	  $rdi = COPY %33:gr64
4176B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
4192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4208B	  %34:gr64 = COPY killed $rax
4240B	  TEST64rr %8:gr64_nosp, %8:gr64_nosp, implicit-def $eflags
4256B	  JCC_1 %bb.18, 14, implicit $eflags
4272B	  JMP_1 %bb.17

4288B	bb.17..lr.ph111.preheader:
	; predecessors: %bb.16
	  successors: %bb.18(0x80000000); %bb.18(100.00%)

4304B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4320B	  $rdi = COPY %34:gr64
4336B	  $rsi = COPY %33:gr64
4352B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
4368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

4384B	bb.18.._crit_edge112:
	; predecessors: %bb.16, %bb.17

4400B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4416B	  %81:gr64 = COPY $rsp
4432B	  %82:gr64 = LEA64r %81:gr64, 1, $noreg, -48, $noreg
4448B	  $rsp = COPY %82:gr64
4464B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4480B	  MOV64mr %81:gr64, 1, $noreg, -48, $noreg, %34:gr64 :: (store (s64) into %ir.46)
4496B	  MOV64mr %81:gr64, 1, $noreg, -40, $noreg, %34:gr64 :: (store (s64) into %ir..repack81)
4512B	  MOV64mi32 %81:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack83)
4528B	  MOV64mr %81:gr64, 1, $noreg, -24, $noreg, %8:gr64_nosp :: (store (s64) into %ir..repack85)
4544B	  MOV64mi32 %81:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack87)
4560B	  ADJCALLSTACKDOWN64 144, 0, 144, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4576B	  %84:gr64 = MOV64ri @read_input_2D_f64
4720B	  $rdx = MOV32ri64 3
4768B	  $r9 = MOV32ri64 1
4772B	  $edi = MOV32ri 1
4776B	  dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
4784B	  dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
4792B	  $r8 = MOV64ri32 -1
4800B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 136)
4808B	  PUSH64r %82:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 128)
4816B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 120)
4832B	  PUSH64r %32:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 112)
4848B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 104)
4864B	  PUSH64r %29:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 96)
4880B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 88)
4896B	  PUSH64r %26:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 80)
4912B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 72)
4928B	  PUSH64r %23:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 64)
4944B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 56)
4960B	  PUSH64r %20:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 48)
4976B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 40)
4992B	  PUSH64r %17:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 32)
5008B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 24)
5024B	  PUSH64r %14:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 16)
5040B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 8)
5056B	  PUSH64r %11:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
5072B	  CALL64r %84:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit killed $rdx, implicit $rcx, implicit $r8, implicit killed $r9, implicit-def $rsp, implicit-def $ssp
5088B	  ADJCALLSTACKUP64 144, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5104B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5120B	  %91:gr64 = MOV64ri @comet_print_memref_i64
5136B	  $rdi = MOV32ri64 1
5152B	  $rsi = COPY %11:gr64
5168B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5184B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5200B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5216B	  $rdi = MOV32ri64 1
5232B	  $rsi = COPY %14:gr64
5248B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5264B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5296B	  $rdi = MOV32ri64 1
5312B	  $rsi = COPY %17:gr64
5328B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5344B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5360B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5376B	  $rdi = MOV32ri64 1
5392B	  $rsi = COPY %20:gr64
5408B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5424B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5456B	  $rdi = MOV32ri64 1
5472B	  $rsi = COPY %23:gr64
5488B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5504B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5520B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5536B	  $rdi = MOV32ri64 1
5552B	  $rsi = COPY %26:gr64
5568B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5584B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5600B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5616B	  $rdi = MOV32ri64 1
5632B	  $rsi = COPY %29:gr64
5648B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5664B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5680B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5696B	  $rdi = MOV32ri64 1
5712B	  $rsi = COPY %32:gr64
5728B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5744B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5760B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5776B	  %92:gr64 = MOV64ri @comet_print_memref_f64
5792B	  $rdi = MOV32ri64 1
5808B	  $rsi = COPY %82:gr64
5824B	  CALL64r %92:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5840B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5856B	  RET 0

# End machine code for function main.


block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[]
 - 1: BB1[.lr.ph.preheader]
 - 2: BB2[._crit_edge]
 - 3: BB3[.lr.ph90.preheader]
 - 4: BB4[._crit_edge91]
 - 5: BB5[.lr.ph93.preheader]
 - 6: BB6[._crit_edge94]
 - 7: BB7[.lr.ph96.preheader]
 - 8: BB8[._crit_edge97]
 - 9: BB9[.lr.ph99.preheader]
 - 10: BB10[._crit_edge100]
 - 11: BB11[.lr.ph102.preheader]
 - 12: BB12[._crit_edge103]
 - 13: BB13[.lr.ph105.preheader]
 - 14: BB14[._crit_edge106]
 - 15: BB15[.lr.ph108.preheader]
 - 16: BB16[._crit_edge109]
 - 17: BB17[.lr.ph111.preheader]
 - 18: BB18[._crit_edge112]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => [ local  ] weight = 1342177280, succ = BB1[.lr.ph.preheader]
  => [ local  ] weight = 805306368, succ = BB2[._crit_edge]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB1[.lr.ph.preheader]
  => assign 6000000000000000 (0000000000000000) to BB2[._crit_edge]
 - node: BB1[.lr.ph.preheader]
  => [ local  ] weight = 2147483648, succ = BB2[._crit_edge]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB2[._crit_edge]
 - node: BB2[._crit_edge]
  => [ local  ] weight = 1342177280, succ = BB3[.lr.ph90.preheader]
  => [ local  ] weight = 805306368, succ = BB4[._crit_edge91]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB3[.lr.ph90.preheader]
  => assign 6000000000000000 (0000000000000000) to BB4[._crit_edge91]
 - node: BB3[.lr.ph90.preheader]
  => [ local  ] weight = 2147483648, succ = BB4[._crit_edge91]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB4[._crit_edge91]
 - node: BB4[._crit_edge91]
  => [ local  ] weight = 1342177280, succ = BB5[.lr.ph93.preheader]
  => [ local  ] weight = 805306368, succ = BB6[._crit_edge94]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB5[.lr.ph93.preheader]
  => assign 6000000000000000 (0000000000000000) to BB6[._crit_edge94]
 - node: BB5[.lr.ph93.preheader]
  => [ local  ] weight = 2147483648, succ = BB6[._crit_edge94]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB6[._crit_edge94]
 - node: BB6[._crit_edge94]
  => [ local  ] weight = 1342177280, succ = BB7[.lr.ph96.preheader]
  => [ local  ] weight = 805306368, succ = BB8[._crit_edge97]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB7[.lr.ph96.preheader]
  => assign 6000000000000000 (0000000000000000) to BB8[._crit_edge97]
 - node: BB7[.lr.ph96.preheader]
  => [ local  ] weight = 2147483648, succ = BB8[._crit_edge97]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB8[._crit_edge97]
 - node: BB8[._crit_edge97]
  => [ local  ] weight = 1342177280, succ = BB9[.lr.ph99.preheader]
  => [ local  ] weight = 805306368, succ = BB10[._crit_edge100]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB9[.lr.ph99.preheader]
  => assign 6000000000000000 (0000000000000000) to BB10[._crit_edge100]
 - node: BB9[.lr.ph99.preheader]
  => [ local  ] weight = 2147483648, succ = BB10[._crit_edge100]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB10[._crit_edge100]
 - node: BB10[._crit_edge100]
  => [ local  ] weight = 1342177280, succ = BB11[.lr.ph102.preheader]
  => [ local  ] weight = 805306368, succ = BB12[._crit_edge103]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB11[.lr.ph102.preheader]
  => assign 6000000000000000 (0000000000000000) to BB12[._crit_edge103]
 - node: BB11[.lr.ph102.preheader]
  => [ local  ] weight = 2147483648, succ = BB12[._crit_edge103]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB12[._crit_edge103]
 - node: BB12[._crit_edge103]
  => [ local  ] weight = 1342177280, succ = BB13[.lr.ph105.preheader]
  => [ local  ] weight = 805306368, succ = BB14[._crit_edge106]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB13[.lr.ph105.preheader]
  => assign 6000000000000000 (0000000000000000) to BB14[._crit_edge106]
 - node: BB13[.lr.ph105.preheader]
  => [ local  ] weight = 2147483648, succ = BB14[._crit_edge106]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB14[._crit_edge106]
 - node: BB14[._crit_edge106]
  => [ local  ] weight = 1342177280, succ = BB15[.lr.ph108.preheader]
  => [ local  ] weight = 805306368, succ = BB16[._crit_edge109]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB15[.lr.ph108.preheader]
  => assign 6000000000000000 (0000000000000000) to BB16[._crit_edge109]
 - node: BB15[.lr.ph108.preheader]
  => [ local  ] weight = 2147483648, succ = BB16[._crit_edge109]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB16[._crit_edge109]
 - node: BB16[._crit_edge109]
  => [ local  ] weight = 1342177280, succ = BB17[.lr.ph111.preheader]
  => [ local  ] weight = 805306368, succ = BB18[._crit_edge112]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB17[.lr.ph111.preheader]
  => assign 6000000000000000 (0000000000000000) to BB18[._crit_edge112]
 - node: BB17[.lr.ph111.preheader]
  => [ local  ] weight = 2147483648, succ = BB18[._crit_edge112]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB18[._crit_edge112]
 - node: BB18[._crit_edge112]
  => mass:  ffffffffffffffff
float-to-int: min = 0.625, max = 1.0, factor = 12.8
 - BB0[]: float = 1.0, scaled = 12.8, int = 12
 - BB1[.lr.ph.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB2[._crit_edge]: float = 1.0, scaled = 12.8, int = 12
 - BB3[.lr.ph90.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB4[._crit_edge91]: float = 1.0, scaled = 12.8, int = 12
 - BB5[.lr.ph93.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB6[._crit_edge94]: float = 1.0, scaled = 12.8, int = 12
 - BB7[.lr.ph96.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB8[._crit_edge97]: float = 1.0, scaled = 12.8, int = 12
 - BB9[.lr.ph99.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB10[._crit_edge100]: float = 1.0, scaled = 12.8, int = 12
 - BB11[.lr.ph102.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB12[._crit_edge103]: float = 1.0, scaled = 12.8, int = 12
 - BB13[.lr.ph105.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB14[._crit_edge106]: float = 1.0, scaled = 12.8, int = 12
 - BB15[.lr.ph108.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB16[._crit_edge109]: float = 1.0, scaled = 12.8, int = 12
 - BB17[.lr.ph111.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB18[._crit_edge112]: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: main
 - BB0[]: float = 1.0, int = 12
 - BB1[.lr.ph.preheader]: float = 0.625, int = 8
 - BB2[._crit_edge]: float = 1.0, int = 12
 - BB3[.lr.ph90.preheader]: float = 0.625, int = 8
 - BB4[._crit_edge91]: float = 1.0, int = 12
 - BB5[.lr.ph93.preheader]: float = 0.625, int = 8
 - BB6[._crit_edge94]: float = 1.0, int = 12
 - BB7[.lr.ph96.preheader]: float = 0.625, int = 8
 - BB8[._crit_edge97]: float = 1.0, int = 12
 - BB9[.lr.ph99.preheader]: float = 0.625, int = 8
 - BB10[._crit_edge100]: float = 1.0, int = 12
 - BB11[.lr.ph102.preheader]: float = 0.625, int = 8
 - BB12[._crit_edge103]: float = 1.0, int = 12
 - BB13[.lr.ph105.preheader]: float = 0.625, int = 8
 - BB14[._crit_edge106]: float = 1.0, int = 12
 - BB15[.lr.ph108.preheader]: float = 0.625, int = 8
 - BB16[._crit_edge109]: float = 1.0, int = 12
 - BB17[.lr.ph111.preheader]: float = 0.625, int = 8
 - BB18[._crit_edge112]: float = 1.0, int = 12

********** GREEDY REGISTER ALLOCATION **********
********** Function: main
********** GREEDY REGISTER ALLOCATION **********
********** Function: main
********** Compute Spill Weights **********
********** Function: main
********** INTERVALS **********
CH [448r,480r:1)[4784r,5072r:0) 0@4784r 1@448r
CL [448r,480r:1)[4784r,5072r:0) 0@4784r 1@448r
DIL [64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4772r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4772r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
DIH [64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4772r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4772r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
HCX [448r,480r:1)[4784r,5072r:0) 0@4784r 1@448r
HDI [64r,80r:11)[436r,480r:1)[688r,704r:29)[864r,896r:28)[1136r,1152r:27)[1296r,1328r:26)[1568r,1584r:25)[1728r,1760r:24)[2000r,2016r:23)[2160r,2192r:22)[2432r,2448r:21)[2592r,2624r:20)[2864r,2880r:19)[3024r,3056r:18)[3296r,3312r:17)[3456r,3488r:16)[3728r,3744r:15)[3888r,3920r:14)[4160r,4176r:13)[4320r,4352r:12)[4772r,5072r:0)[5136r,5168r:10)[5216r,5248r:9)[5296r,5328r:8)[5376r,5408r:7)[5456r,5488r:6)[5536r,5568r:5)[5616r,5648r:4)[5696r,5728r:3)[5792r,5824r:2) 0@4772r 1@436r 2@5792r 3@5696r 4@5616r 5@5536r 6@5456r 7@5376r 8@5296r 9@5216r 10@5136r 11@64r 12@4320r 13@4160r 14@3888r 15@3728r 16@3456r 17@3296r 18@3024r 19@2864r 20@2592r 21@2432r 22@2160r 23@2000r 24@1728r 25@1568r 26@1296r 27@1136r 28@864r 29@688r
EFLAGS [16r,16d:90)[96r,96d:89)[208r,208d:88)[440r,440d:3)[448r,448d:2)[496r,496d:87)[672r,672d:86)[720r,720d:85)[792r,800r:84)[848r,848d:83)[912r,912d:82)[944r,944d:81)[1008r,1008d:80)[1120r,1120d:79)[1168r,1168d:78)[1216r,1232r:77)[1280r,1280d:76)[1344r,1344d:75)[1376r,1376d:74)[1440r,1440d:73)[1552r,1552d:72)[1600r,1600d:71)[1648r,1664r:70)[1712r,1712d:69)[1776r,1776d:68)[1808r,1808d:67)[1872r,1872d:66)[1984r,1984d:65)[2032r,2032d:64)[2080r,2096r:63)[2144r,2144d:62)[2208r,2208d:61)[2240r,2240d:60)[2304r,2304d:59)[2416r,2416d:58)[2464r,2464d:57)[2512r,2528r:56)[2576r,2576d:55)[2640r,2640d:54)[2672r,2672d:53)[2736r,2736d:52)[2848r,2848d:51)[2896r,2896d:50)[2944r,2960r:49)[3008r,3008d:48)[3072r,3072d:47)[3104r,3104d:46)[3168r,3168d:45)[3280r,3280d:44)[3328r,3328d:43)[3376r,3392r:42)[3440r,3440d:41)[3504r,3504d:40)[3536r,3536d:39)[3600r,3600d:38)[3712r,3712d:37)[3760r,3760d:36)[3808r,3824r:35)[3872r,3872d:34)[3936r,3936d:33)[3968r,3968d:32)[4032r,4032d:31)[4144r,4144d:30)[4192r,4192d:29)[4240r,4256r:28)[4304r,4304d:27)[4368r,4368d:26)[4400r,4400d:25)[4464r,4464d:24)[4560r,4560d:23)[4776r,4776d:1)[4784r,4784d:0)[5088r,5088d:22)[5104r,5104d:21)[5184r,5184d:20)[5200r,5200d:19)[5264r,5264d:18)[5280r,5280d:17)[5344r,5344d:16)[5360r,5360d:15)[5424r,5424d:14)[5440r,5440d:13)[5504r,5504d:12)[5520r,5520d:11)[5584r,5584d:10)[5600r,5600d:9)[5664r,5664d:8)[5680r,5680d:7)[5744r,5744d:6)[5760r,5760d:5)[5840r,5840d:4) 0@4784r 1@4776r 2@448r 3@440r 4@5840r 5@5760r 6@5744r 7@5680r 8@5664r 9@5600r 10@5584r 11@5520r 12@5504r 13@5440r 14@5424r 15@5360r 16@5344r 17@5280r 18@5264r 19@5200r 20@5184r 21@5104r 22@5088r 23@4560r 24@4464r 25@4400r 26@4368r 27@4304r 28@4240r 29@4192r 30@4144r 31@4032r 32@3968r 33@3936r 34@3872r 35@3808r 36@3760r 37@3712r 38@3600r 39@3536r 40@3504r 41@3440r 42@3376r 43@3328r 44@3280r 45@3168r 46@3104r 47@3072r 48@3008r 49@2944r 50@2896r 51@2848r 52@2736r 53@2672r 54@2640r 55@2576r 56@2512r 57@2464r 58@2416r 59@2304r 60@2240r 61@2208r 62@2144r 63@2080r 64@2032r 65@1984r 66@1872r 67@1808r 68@1776r 69@1712r 70@1648r 71@1600r 72@1552r 73@1440r 74@1376r 75@1344r 76@1280r 77@1216r 78@1168r 79@1120r 80@1008r 81@944r 82@912r 83@848r 84@792r 85@720r 86@672r 87@496r 88@208r 89@96r 90@16r
SIL [440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4776r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4776r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
SIH [440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4776r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4776r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
HSI [440r,480r:1)[880r,896r:19)[1312r,1328r:18)[1744r,1760r:17)[2176r,2192r:16)[2608r,2624r:15)[3040r,3056r:14)[3472r,3488r:13)[3904r,3920r:12)[4336r,4352r:11)[4776r,5072r:0)[5152r,5168r:10)[5232r,5248r:9)[5312r,5328r:8)[5392r,5408r:7)[5472r,5488r:6)[5552r,5568r:5)[5632r,5648r:4)[5712r,5728r:3)[5808r,5824r:2) 0@4776r 1@440r 2@5808r 3@5712r 4@5632r 5@5552r 6@5472r 7@5392r 8@5312r 9@5232r 10@5152r 11@4336r 12@3904r 13@3472r 14@3040r 15@2608r 16@2176r 17@1744r 18@1312r 19@880r
SPL [16r,16d:136)[80r,80d:135)[96r,96d:134)[208r,208d:133)[464r,464d:19)[472r,472d:18)[480r,480d:132)[496r,496d:131)[672r,672d:130)[704r,704d:129)[720r,720d:128)[848r,848d:127)[896r,896d:126)[912r,912d:125)[944r,944d:124)[992r,992d:123)[1008r,1008d:122)[1120r,1120d:121)[1152r,1152d:120)[1168r,1168d:119)[1280r,1280d:118)[1328r,1328d:117)[1344r,1344d:116)[1376r,1376d:115)[1424r,1424d:114)[1440r,1440d:113)[1552r,1552d:112)[1584r,1584d:111)[1600r,1600d:110)[1712r,1712d:109)[1760r,1760d:108)[1776r,1776d:107)[1808r,1808d:106)[1856r,1856d:105)[1872r,1872d:104)[1984r,1984d:103)[2016r,2016d:102)[2032r,2032d:101)[2144r,2144d:100)[2192r,2192d:99)[2208r,2208d:98)[2240r,2240d:97)[2288r,2288d:96)[2304r,2304d:95)[2416r,2416d:94)[2448r,2448d:93)[2464r,2464d:92)[2576r,2576d:91)[2624r,2624d:90)[2640r,2640d:89)[2672r,2672d:88)[2720r,2720d:87)[2736r,2736d:86)[2848r,2848d:85)[2880r,2880d:84)[2896r,2896d:83)[3008r,3008d:82)[3056r,3056d:81)[3072r,3072d:80)[3104r,3104d:79)[3152r,3152d:78)[3168r,3168d:77)[3280r,3280d:76)[3312r,3312d:75)[3328r,3328d:74)[3440r,3440d:73)[3488r,3488d:72)[3504r,3504d:71)[3536r,3536d:70)[3584r,3584d:69)[3600r,3600d:68)[3712r,3712d:67)[3744r,3744d:66)[3760r,3760d:65)[3872r,3872d:64)[3920r,3920d:63)[3936r,3936d:62)[3968r,3968d:61)[4016r,4016d:60)[4032r,4032d:59)[4144r,4144d:58)[4176r,4176d:57)[4192r,4192d:56)[4304r,4304d:55)[4352r,4352d:54)[4368r,4368d:53)[4400r,4400d:52)[4448r,4448d:51)[4464r,4464d:50)[4560r,4560d:49)[4800r,4800d:17)[4808r,4808d:16)[4816r,4816d:15)[4832r,4832d:14)[4848r,4848d:13)[4864r,4864d:12)[4880r,4880d:11)[4896r,4896d:10)[4912r,4912d:9)[4928r,4928d:8)[4944r,4944d:7)[4960r,4960d:6)[4976r,4976d:5)[4992r,4992d:4)[5008r,5008d:3)[5024r,5024d:2)[5040r,5040d:1)[5056r,5056d:0)[5072r,5072d:48)[5088r,5088d:47)[5104r,5104d:46)[5168r,5168d:45)[5184r,5184d:44)[5200r,5200d:43)[5248r,5248d:42)[5264r,5264d:41)[5280r,5280d:40)[5328r,5328d:39)[5344r,5344d:38)[5360r,5360d:37)[5408r,5408d:36)[5424r,5424d:35)[5440r,5440d:34)[5488r,5488d:33)[5504r,5504d:32)[5520r,5520d:31)[5568r,5568d:30)[5584r,5584d:29)[5600r,5600d:28)[5648r,5648d:27)[5664r,5664d:26)[5680r,5680d:25)[5728r,5728d:24)[5744r,5744d:23)[5760r,5760d:22)[5824r,5824d:21)[5840r,5840d:20) 0@5056r 1@5040r 2@5024r 3@5008r 4@4992r 5@4976r 6@4960r 7@4944r 8@4928r 9@4912r 10@4896r 11@4880r 12@4864r 13@4848r 14@4832r 15@4816r 16@4808r 17@4800r 18@472r 19@464r 20@5840r 21@5824r 22@5760r 23@5744r 24@5728r 25@5680r 26@5664r 27@5648r 28@5600r 29@5584r 30@5568r 31@5520r 32@5504r 33@5488r 34@5440r 35@5424r 36@5408r 37@5360r 38@5344r 39@5328r 40@5280r 41@5264r 42@5248r 43@5200r 44@5184r 45@5168r 46@5104r 47@5088r 48@5072r 49@4560r 50@4464r 51@4448r 52@4400r 53@4368r 54@4352r 55@4304r 56@4192r 57@4176r 58@4144r 59@4032r 60@4016r 61@3968r 62@3936r 63@3920r 64@3872r 65@3760r 66@3744r 67@3712r 68@3600r 69@3584r 70@3536r 71@3504r 72@3488r 73@3440r 74@3328r 75@3312r 76@3280r 77@3168r 78@3152r 79@3104r 80@3072r 81@3056r 82@3008r 83@2896r 84@2880r 85@2848r 86@2736r 87@2720r 88@2672r 89@2640r 90@2624r 91@2576r 92@2464r 93@2448r 94@2416r 95@2304r 96@2288r 97@2240r 98@2208r 99@2192r 100@2144r 101@2032r 102@2016r 103@1984r 104@1872r 105@1856r 106@1808r 107@1776r 108@1760r 109@1712r 110@1600r 111@1584r 112@1552r 113@1440r 114@1424r 115@1376r 116@1344r 117@1328r 118@1280r 119@1168r 120@1152r 121@1120r 122@1008r 123@992r 124@944r 125@912r 126@896r 127@848r 128@720r 129@704r 130@672r 131@496r 132@480r 133@208r 134@96r 135@80r 136@16r
R8B [456r,480r:1)[4792r,5072r:0) 0@4792r 1@456r
R8BH [456r,480r:1)[4792r,5072r:0) 0@4792r 1@456r
R8WH [456r,480r:1)[4792r,5072r:0) 0@4792r 1@456r
%0 [512r,1072r:0) 0@512r  weight:4.166667e-03
%1 [528r,1504r:0) 0@528r  weight:2.906977e-03
%2 [544r,1936r:0) 0@544r  weight:2.232143e-03
%3 [560r,2368r:0) 0@560r  weight:1.811594e-03
%4 [576r,2800r:0) 0@576r  weight:1.524390e-03
%5 [592r,3232r:0) 0@592r  weight:1.315790e-03
%6 [608r,3664r:0) 0@608r  weight:1.157407e-03
%7 [624r,4096r:0) 0@624r  weight:1.033058e-03
%8 [640r,4528r:0) 0@640r  weight:9.328358e-04
%9 [656r,880r:0) 0@656r  weight:4.316240e-03
%10 [736r,1040r:0) 0@736r  weight:5.260417e-03
%11 [976r,5152r:0) 0@976r  weight:8.828671e-04
%12 [1104r,1312r:0) 0@1104r  weight:4.429825e-03
%13 [1184r,1472r:0) 0@1184r  weight:5.382752e-03
%14 [1408r,5232r:0) 0@1408r  weight:9.564394e-04
%15 [1536r,1744r:0) 0@1536r  weight:4.429825e-03
%16 [1616r,1904r:0) 0@1616r  weight:5.382752e-03
%17 [1840r,5312r:0) 0@1840r  weight:1.043388e-03
%18 [1968r,2176r:0) 0@1968r  weight:4.429825e-03
%19 [2048r,2336r:0) 0@2048r  weight:5.382752e-03
%20 [2272r,5392r:0) 0@2272r  weight:1.147727e-03
%21 [2400r,2608r:0) 0@2400r  weight:4.429825e-03
%22 [2480r,2768r:0) 0@2480r  weight:5.382752e-03
%23 [2704r,5472r:0) 0@2704r  weight:1.275253e-03
%24 [2832r,3040r:0) 0@2832r  weight:4.429825e-03
%25 [2912r,3200r:0) 0@2912r  weight:5.382752e-03
%26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03
%27 [3264r,3472r:0) 0@3264r  weight:4.429825e-03
%28 [3344r,3632r:0) 0@3344r  weight:5.382752e-03
%29 [3568r,5632r:0) 0@3568r  weight:1.639610e-03
%30 [3696r,3904r:0) 0@3696r  weight:4.429825e-03
%31 [3776r,4064r:0) 0@3776r  weight:5.382752e-03
%32 [4000r,5712r:0) 0@4000r  weight:1.912879e-03
%33 [4128r,4336r:0) 0@4128r  weight:4.429825e-03
%34 [4208r,4496r:0) 0@4208r  weight:5.382752e-03
%35 [32r,4176r:0) 0@32r  weight:1.210387e-03
%37 [112r,640r:0) 0@112r  weight:1.306034e-02
%39 [224r,472r:0) 0@224r  weight:1.543210e-03
%40 [240r,480r:0) 0@240r  weight:1.562500e-03
%49 [960r,1088r:0) 0@960r  weight:1.325758e-02
%53 [1392r,1520r:0) 0@1392r  weight:1.325758e-02
%57 [1824r,1952r:0) 0@1824r  weight:1.325758e-02
%61 [2256r,2384r:0) 0@2256r  weight:1.325758e-02
%65 [2688r,2816r:0) 0@2688r  weight:1.325758e-02
%69 [3120r,3248r:0) 0@3120r  weight:1.325758e-02
%73 [3552r,3680r:0) 0@3552r  weight:1.325758e-02
%77 [3984r,4112r:0) 0@3984r  weight:1.325758e-02
%81 [4416r,4544r:0) 0@4416r  weight:1.325758e-02
%82 [4432r,5808r:0) 0@4432r  weight:2.274775e-03
%84 [4576r,5072r:0) 0@4576r  weight:1.116071e-03
%91 [5120r,5728r:0) 0@5120r  weight:4.464286e-03
%92 [5776r,5824r:0) 0@5776r  weight:2.232143e-03
%100 [784r,4352r:0) 0@784r  weight:8.820564e-04
RegMasks: 80r 480r 704r 896r 1152r 1328r 1584r 1760r 2016r 2192r 2448r 2624r 2880r 3056r 3312r 3488r 3744r 3920r 4176r 4352r 5072r 5168r 5248r 5328r 5408r 5488r 5568r 5648r 5728r 5824r
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=40, align=8, at location [SP+8]
  fi#1: variable sized, align=1, at location [SP+8]
  fi#2: variable sized, align=1, at location [SP+8]
  fi#3: variable sized, align=1, at location [SP+8]
  fi#4: variable sized, align=1, at location [SP+8]
  fi#5: variable sized, align=1, at location [SP+8]
  fi#6: variable sized, align=1, at location [SP+8]
  fi#7: variable sized, align=1, at location [SP+8]
  fi#8: variable sized, align=1, at location [SP+8]
  fi#9: variable sized, align=1, at location [SP+8]

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %35:gr64 = MOV64ri @malloc
64B	  $rdi = MOV32ri64 56
80B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %37:gr64 = COPY killed $rax
128B	  MOV64mr %stack.0, 1, $noreg, 0, $noreg, %37:gr64 :: (store (s64) into %ir.2)
144B	  MOV64mr %stack.0, 1, $noreg, 8, $noreg, %37:gr64 :: (store (s64) into %ir..fca.1.gep)
160B	  MOV64mi32 %stack.0, 1, $noreg, 16, $noreg, 0 :: (store (s64) into %ir..fca.2.gep)
176B	  MOV64mi32 %stack.0, 1, $noreg, 24, $noreg, 7 :: (store (s64) into %ir..fca.3.0.gep)
192B	  MOV64mi32 %stack.0, 1, $noreg, 32, $noreg, 1 :: (store (s64) into %ir..fca.4.0.gep)
208B	  ADJCALLSTACKDOWN64 16, 0, 16, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
224B	  %39:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
240B	  %40:gr64 = MOV64ri @read_input_sizes_2D_f64
384B	  $rdx = MOV32ri64 3
432B	  $r9 = MOV32ri64 1
436B	  $edi = MOV32ri 1
440B	  dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
448B	  dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
456B	  $r8 = MOV64ri32 -1
464B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 8)
472B	  PUSH64r %39:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
480B	  CALL64r %40:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit killed $rdx, implicit $rcx, implicit $r8, implicit killed $r9, implicit-def $rsp, implicit-def $ssp
496B	  ADJCALLSTACKUP64 16, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
512B	  %0:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
528B	  %1:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
544B	  %2:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
560B	  %3:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
576B	  %4:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
592B	  %5:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
608B	  %6:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
624B	  %7:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
640B	  %8:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
656B	  %9:gr64 = LEA64r $noreg, 8, %0:gr64_nosp, 0, $noreg
672B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
688B	  $rdi = COPY %9:gr64
704B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
720B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
736B	  %10:gr64 = COPY killed $rax
784B	  %100:gr64 = MOV64ri &__bzero
792B	  TEST64rr %0:gr64_nosp, %0:gr64_nosp, implicit-def $eflags
800B	  JCC_1 %bb.2, 14, implicit $eflags
816B	  JMP_1 %bb.1

832B	bb.1..lr.ph.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
864B	  $rdi = COPY %10:gr64
880B	  $rsi = COPY %9:gr64
896B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
912B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

928B	bb.2.._crit_edge:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.3(0x50000000), %bb.4(0x30000000); %bb.3(62.50%), %bb.4(37.50%)

944B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
960B	  %49:gr64 = COPY $rsp
976B	  %11:gr64 = LEA64r %49:gr64, 1, $noreg, -48, $noreg
992B	  $rsp = COPY %11:gr64
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1024B	  MOV64mr %49:gr64, 1, $noreg, -48, $noreg, %10:gr64 :: (store (s64) into %ir.22)
1040B	  MOV64mr %49:gr64, 1, $noreg, -40, $noreg, %10:gr64 :: (store (s64) into %ir..repack9)
1056B	  MOV64mi32 %49:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack11)
1072B	  MOV64mr %49:gr64, 1, $noreg, -24, $noreg, %0:gr64_nosp :: (store (s64) into %ir..repack13)
1088B	  MOV64mi32 %49:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack15)
1104B	  %12:gr64 = LEA64r $noreg, 8, %1:gr64_nosp, 0, $noreg
1120B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1136B	  $rdi = COPY %12:gr64
1152B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1184B	  %13:gr64 = COPY killed $rax
1216B	  TEST64rr %1:gr64_nosp, %1:gr64_nosp, implicit-def $eflags
1232B	  JCC_1 %bb.4, 14, implicit $eflags
1248B	  JMP_1 %bb.3

1264B	bb.3..lr.ph90.preheader:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1296B	  $rdi = COPY %13:gr64
1312B	  $rsi = COPY %12:gr64
1328B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
1344B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

1360B	bb.4.._crit_edge91:
	; predecessors: %bb.2, %bb.3
	  successors: %bb.5(0x50000000), %bb.6(0x30000000); %bb.5(62.50%), %bb.6(37.50%)

1376B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1392B	  %53:gr64 = COPY $rsp
1408B	  %14:gr64 = LEA64r %53:gr64, 1, $noreg, -48, $noreg
1424B	  $rsp = COPY %14:gr64
1440B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1456B	  MOV64mr %53:gr64, 1, $noreg, -48, $noreg, %13:gr64 :: (store (s64) into %ir.25)
1472B	  MOV64mr %53:gr64, 1, $noreg, -40, $noreg, %13:gr64 :: (store (s64) into %ir..repack18)
1488B	  MOV64mi32 %53:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack20)
1504B	  MOV64mr %53:gr64, 1, $noreg, -24, $noreg, %1:gr64_nosp :: (store (s64) into %ir..repack22)
1520B	  MOV64mi32 %53:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack24)
1536B	  %15:gr64 = LEA64r $noreg, 8, %2:gr64_nosp, 0, $noreg
1552B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1568B	  $rdi = COPY %15:gr64
1584B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1600B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1616B	  %16:gr64 = COPY killed $rax
1648B	  TEST64rr %2:gr64_nosp, %2:gr64_nosp, implicit-def $eflags
1664B	  JCC_1 %bb.6, 14, implicit $eflags
1680B	  JMP_1 %bb.5

1696B	bb.5..lr.ph93.preheader:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

1712B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1728B	  $rdi = COPY %16:gr64
1744B	  $rsi = COPY %15:gr64
1760B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
1776B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

1792B	bb.6.._crit_edge94:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.7(0x50000000), %bb.8(0x30000000); %bb.7(62.50%), %bb.8(37.50%)

1808B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1824B	  %57:gr64 = COPY $rsp
1840B	  %17:gr64 = LEA64r %57:gr64, 1, $noreg, -48, $noreg
1856B	  $rsp = COPY %17:gr64
1872B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1888B	  MOV64mr %57:gr64, 1, $noreg, -48, $noreg, %16:gr64 :: (store (s64) into %ir.28)
1904B	  MOV64mr %57:gr64, 1, $noreg, -40, $noreg, %16:gr64 :: (store (s64) into %ir..repack27)
1920B	  MOV64mi32 %57:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack29)
1936B	  MOV64mr %57:gr64, 1, $noreg, -24, $noreg, %2:gr64_nosp :: (store (s64) into %ir..repack31)
1952B	  MOV64mi32 %57:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack33)
1968B	  %18:gr64 = LEA64r $noreg, 8, %3:gr64_nosp, 0, $noreg
1984B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2000B	  $rdi = COPY %18:gr64
2016B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2048B	  %19:gr64 = COPY killed $rax
2080B	  TEST64rr %3:gr64_nosp, %3:gr64_nosp, implicit-def $eflags
2096B	  JCC_1 %bb.8, 14, implicit $eflags
2112B	  JMP_1 %bb.7

2128B	bb.7..lr.ph96.preheader:
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)

2144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2160B	  $rdi = COPY %19:gr64
2176B	  $rsi = COPY %18:gr64
2192B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
2208B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2224B	bb.8.._crit_edge97:
	; predecessors: %bb.6, %bb.7
	  successors: %bb.9(0x50000000), %bb.10(0x30000000); %bb.9(62.50%), %bb.10(37.50%)

2240B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2256B	  %61:gr64 = COPY $rsp
2272B	  %20:gr64 = LEA64r %61:gr64, 1, $noreg, -48, $noreg
2288B	  $rsp = COPY %20:gr64
2304B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2320B	  MOV64mr %61:gr64, 1, $noreg, -48, $noreg, %19:gr64 :: (store (s64) into %ir.31)
2336B	  MOV64mr %61:gr64, 1, $noreg, -40, $noreg, %19:gr64 :: (store (s64) into %ir..repack36)
2352B	  MOV64mi32 %61:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack38)
2368B	  MOV64mr %61:gr64, 1, $noreg, -24, $noreg, %3:gr64_nosp :: (store (s64) into %ir..repack40)
2384B	  MOV64mi32 %61:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack42)
2400B	  %21:gr64 = LEA64r $noreg, 8, %4:gr64_nosp, 0, $noreg
2416B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2432B	  $rdi = COPY %21:gr64
2448B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2464B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2480B	  %22:gr64 = COPY killed $rax
2512B	  TEST64rr %4:gr64_nosp, %4:gr64_nosp, implicit-def $eflags
2528B	  JCC_1 %bb.10, 14, implicit $eflags
2544B	  JMP_1 %bb.9

2560B	bb.9..lr.ph99.preheader:
	; predecessors: %bb.8
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

2576B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2592B	  $rdi = COPY %22:gr64
2608B	  $rsi = COPY %21:gr64
2624B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
2640B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2656B	bb.10.._crit_edge100:
	; predecessors: %bb.8, %bb.9
	  successors: %bb.11(0x50000000), %bb.12(0x30000000); %bb.11(62.50%), %bb.12(37.50%)

2672B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2688B	  %65:gr64 = COPY $rsp
2704B	  %23:gr64 = LEA64r %65:gr64, 1, $noreg, -48, $noreg
2720B	  $rsp = COPY %23:gr64
2736B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2752B	  MOV64mr %65:gr64, 1, $noreg, -48, $noreg, %22:gr64 :: (store (s64) into %ir.34)
2768B	  MOV64mr %65:gr64, 1, $noreg, -40, $noreg, %22:gr64 :: (store (s64) into %ir..repack45)
2784B	  MOV64mi32 %65:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack47)
2800B	  MOV64mr %65:gr64, 1, $noreg, -24, $noreg, %4:gr64_nosp :: (store (s64) into %ir..repack49)
2816B	  MOV64mi32 %65:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack51)
2832B	  %24:gr64 = LEA64r $noreg, 8, %5:gr64_nosp, 0, $noreg
2848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2864B	  $rdi = COPY %24:gr64
2880B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2912B	  %25:gr64 = COPY killed $rax
2944B	  TEST64rr %5:gr64_nosp, %5:gr64_nosp, implicit-def $eflags
2960B	  JCC_1 %bb.12, 14, implicit $eflags
2976B	  JMP_1 %bb.11

2992B	bb.11..lr.ph102.preheader:
	; predecessors: %bb.10
	  successors: %bb.12(0x80000000); %bb.12(100.00%)

3008B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3024B	  $rdi = COPY %25:gr64
3040B	  $rsi = COPY %24:gr64
3056B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
3072B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3088B	bb.12.._crit_edge103:
	; predecessors: %bb.10, %bb.11
	  successors: %bb.13(0x50000000), %bb.14(0x30000000); %bb.13(62.50%), %bb.14(37.50%)

3104B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3120B	  %69:gr64 = COPY $rsp
3136B	  %26:gr64 = LEA64r %69:gr64, 1, $noreg, -48, $noreg
3152B	  $rsp = COPY %26:gr64
3168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3184B	  MOV64mr %69:gr64, 1, $noreg, -48, $noreg, %25:gr64 :: (store (s64) into %ir.37)
3200B	  MOV64mr %69:gr64, 1, $noreg, -40, $noreg, %25:gr64 :: (store (s64) into %ir..repack54)
3216B	  MOV64mi32 %69:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack56)
3232B	  MOV64mr %69:gr64, 1, $noreg, -24, $noreg, %5:gr64_nosp :: (store (s64) into %ir..repack58)
3248B	  MOV64mi32 %69:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack60)
3264B	  %27:gr64 = LEA64r $noreg, 8, %6:gr64_nosp, 0, $noreg
3280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3296B	  $rdi = COPY %27:gr64
3312B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3328B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3344B	  %28:gr64 = COPY killed $rax
3376B	  TEST64rr %6:gr64_nosp, %6:gr64_nosp, implicit-def $eflags
3392B	  JCC_1 %bb.14, 14, implicit $eflags
3408B	  JMP_1 %bb.13

3424B	bb.13..lr.ph105.preheader:
	; predecessors: %bb.12
	  successors: %bb.14(0x80000000); %bb.14(100.00%)

3440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3456B	  $rdi = COPY %28:gr64
3472B	  $rsi = COPY %27:gr64
3488B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
3504B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3520B	bb.14.._crit_edge106:
	; predecessors: %bb.12, %bb.13
	  successors: %bb.15(0x50000000), %bb.16(0x30000000); %bb.15(62.50%), %bb.16(37.50%)

3536B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3552B	  %73:gr64 = COPY $rsp
3568B	  %29:gr64 = LEA64r %73:gr64, 1, $noreg, -48, $noreg
3584B	  $rsp = COPY %29:gr64
3600B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3616B	  MOV64mr %73:gr64, 1, $noreg, -48, $noreg, %28:gr64 :: (store (s64) into %ir.40)
3632B	  MOV64mr %73:gr64, 1, $noreg, -40, $noreg, %28:gr64 :: (store (s64) into %ir..repack63)
3648B	  MOV64mi32 %73:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack65)
3664B	  MOV64mr %73:gr64, 1, $noreg, -24, $noreg, %6:gr64_nosp :: (store (s64) into %ir..repack67)
3680B	  MOV64mi32 %73:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack69)
3696B	  %30:gr64 = LEA64r $noreg, 8, %7:gr64_nosp, 0, $noreg
3712B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3728B	  $rdi = COPY %30:gr64
3744B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3760B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3776B	  %31:gr64 = COPY killed $rax
3808B	  TEST64rr %7:gr64_nosp, %7:gr64_nosp, implicit-def $eflags
3824B	  JCC_1 %bb.16, 14, implicit $eflags
3840B	  JMP_1 %bb.15

3856B	bb.15..lr.ph108.preheader:
	; predecessors: %bb.14
	  successors: %bb.16(0x80000000); %bb.16(100.00%)

3872B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3888B	  $rdi = COPY %31:gr64
3904B	  $rsi = COPY %30:gr64
3920B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
3936B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

3952B	bb.16.._crit_edge109:
	; predecessors: %bb.14, %bb.15
	  successors: %bb.17(0x50000000), %bb.18(0x30000000); %bb.17(62.50%), %bb.18(37.50%)

3968B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3984B	  %77:gr64 = COPY $rsp
4000B	  %32:gr64 = LEA64r %77:gr64, 1, $noreg, -48, $noreg
4016B	  $rsp = COPY %32:gr64
4032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4048B	  MOV64mr %77:gr64, 1, $noreg, -48, $noreg, %31:gr64 :: (store (s64) into %ir.43)
4064B	  MOV64mr %77:gr64, 1, $noreg, -40, $noreg, %31:gr64 :: (store (s64) into %ir..repack72)
4080B	  MOV64mi32 %77:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack74)
4096B	  MOV64mr %77:gr64, 1, $noreg, -24, $noreg, %7:gr64_nosp :: (store (s64) into %ir..repack76)
4112B	  MOV64mi32 %77:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack78)
4128B	  %33:gr64 = LEA64r $noreg, 8, %8:gr64_nosp, 0, $noreg
4144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4160B	  $rdi = COPY %33:gr64
4176B	  CALL64r %35:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
4192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4208B	  %34:gr64 = COPY killed $rax
4240B	  TEST64rr %8:gr64_nosp, %8:gr64_nosp, implicit-def $eflags
4256B	  JCC_1 %bb.18, 14, implicit $eflags
4272B	  JMP_1 %bb.17

4288B	bb.17..lr.ph111.preheader:
	; predecessors: %bb.16
	  successors: %bb.18(0x80000000); %bb.18(100.00%)

4304B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4320B	  $rdi = COPY %34:gr64
4336B	  $rsi = COPY %33:gr64
4352B	  CALL64r %100:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
4368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

4384B	bb.18.._crit_edge112:
	; predecessors: %bb.16, %bb.17

4400B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4416B	  %81:gr64 = COPY $rsp
4432B	  %82:gr64 = LEA64r %81:gr64, 1, $noreg, -48, $noreg
4448B	  $rsp = COPY %82:gr64
4464B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4480B	  MOV64mr %81:gr64, 1, $noreg, -48, $noreg, %34:gr64 :: (store (s64) into %ir.46)
4496B	  MOV64mr %81:gr64, 1, $noreg, -40, $noreg, %34:gr64 :: (store (s64) into %ir..repack81)
4512B	  MOV64mi32 %81:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack83)
4528B	  MOV64mr %81:gr64, 1, $noreg, -24, $noreg, %8:gr64_nosp :: (store (s64) into %ir..repack85)
4544B	  MOV64mi32 %81:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack87)
4560B	  ADJCALLSTACKDOWN64 144, 0, 144, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4576B	  %84:gr64 = MOV64ri @read_input_2D_f64
4720B	  $rdx = MOV32ri64 3
4768B	  $r9 = MOV32ri64 1
4772B	  $edi = MOV32ri 1
4776B	  dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
4784B	  dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
4792B	  $r8 = MOV64ri32 -1
4800B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 136)
4808B	  PUSH64r %82:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 128)
4816B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 120)
4832B	  PUSH64r %32:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 112)
4848B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 104)
4864B	  PUSH64r %29:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 96)
4880B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 88)
4896B	  PUSH64r %26:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 80)
4912B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 72)
4928B	  PUSH64r %23:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 64)
4944B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 56)
4960B	  PUSH64r %20:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 48)
4976B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 40)
4992B	  PUSH64r %17:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 32)
5008B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 24)
5024B	  PUSH64r %14:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 16)
5040B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 8)
5056B	  PUSH64r %11:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
5072B	  CALL64r %84:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit killed $rdx, implicit $rcx, implicit $r8, implicit killed $r9, implicit-def $rsp, implicit-def $ssp
5088B	  ADJCALLSTACKUP64 144, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5104B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5120B	  %91:gr64 = MOV64ri @comet_print_memref_i64
5136B	  $rdi = MOV32ri64 1
5152B	  $rsi = COPY %11:gr64
5168B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5184B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5200B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5216B	  $rdi = MOV32ri64 1
5232B	  $rsi = COPY %14:gr64
5248B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5264B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5296B	  $rdi = MOV32ri64 1
5312B	  $rsi = COPY %17:gr64
5328B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5344B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5360B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5376B	  $rdi = MOV32ri64 1
5392B	  $rsi = COPY %20:gr64
5408B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5424B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5456B	  $rdi = MOV32ri64 1
5472B	  $rsi = COPY %23:gr64
5488B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5504B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5520B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5536B	  $rdi = MOV32ri64 1
5552B	  $rsi = COPY %26:gr64
5568B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5584B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5600B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5616B	  $rdi = MOV32ri64 1
5632B	  $rsi = COPY %29:gr64
5648B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5664B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5680B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5696B	  $rdi = MOV32ri64 1
5712B	  $rsi = COPY %32:gr64
5728B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5744B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5760B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5776B	  %92:gr64 = MOV64ri @comet_print_memref_f64
5792B	  $rdi = MOV32ri64 1
5808B	  $rsi = COPY %82:gr64
5824B	  CALL64r %92:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5840B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5856B	  RET 0

# End machine code for function main.

Enqueuing %0
AllocationOrder(GR64) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 ]
AllocationOrder(GR64_NOSP) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 ]
Enqueuing %1
Enqueuing %2
Enqueuing %3
Enqueuing %4
Enqueuing %5
Enqueuing %6
Enqueuing %7
Enqueuing %8
Enqueuing %9
Enqueuing %10
Enqueuing %11
Enqueuing %12
Enqueuing %13
Enqueuing %14
Enqueuing %15
Enqueuing %16
Enqueuing %17
Enqueuing %18
Enqueuing %19
Enqueuing %20
Enqueuing %21
Enqueuing %22
Enqueuing %23
Enqueuing %24
Enqueuing %25
Enqueuing %26
Enqueuing %27
Enqueuing %28
Enqueuing %29
Enqueuing %30
Enqueuing %31
Enqueuing %32
Enqueuing %33
Enqueuing %34
Enqueuing %35
Enqueuing %37
Enqueuing %39
Enqueuing %40
Enqueuing %49
Enqueuing %53
Enqueuing %57
Enqueuing %61
Enqueuing %65
Enqueuing %69
Enqueuing %73
Enqueuing %77
Enqueuing %81
Enqueuing %82
Enqueuing %84
Enqueuing %91
Enqueuing %92
Enqueuing %100

selectOrSplit GR64:%11 [976r,5152r:0) 0@976r  weight:8.828671e-04 w=8.828671e-04
hints: $rsi
missed hint $rsi
assigning %11 to $rbx: BH [976r,5152r:0) 0@976r BL [976r,5152r:0) 0@976r HBX [976r,5152r:0) 0@976r

selectOrSplit GR64:%14 [1408r,5232r:0) 0@1408r  weight:9.564394e-04 w=9.564394e-04
hints: $rsi
missed hint $rsi
assigning %14 to $r14: R14B [1408r,5232r:0) 0@1408r R14BH [1408r,5232r:0) 0@1408r R14WH [1408r,5232r:0) 0@1408r

selectOrSplit GR64:%17 [1840r,5312r:0) 0@1840r  weight:1.043388e-03 w=1.043388e-03
hints: $rsi
missed hint $rsi
assigning %17 to $r15: R15B [1840r,5312r:0) 0@1840r R15BH [1840r,5312r:0) 0@1840r R15WH [1840r,5312r:0) 0@1840r

selectOrSplit GR64:%20 [2272r,5392r:0) 0@2272r  weight:1.147727e-03 w=1.147727e-03
hints: $rsi
missed hint $rsi
assigning %20 to $r12: R12B [2272r,5392r:0) 0@2272r R12BH [2272r,5392r:0) 0@2272r R12WH [2272r,5392r:0) 0@2272r

selectOrSplit GR64:%23 [2704r,5472r:0) 0@2704r  weight:1.275253e-03 w=1.275253e-03
hints: $rsi
missed hint $rsi
assigning %23 to $r13: R13B [2704r,5472r:0) 0@2704r R13BH [2704r,5472r:0) 0@2704r R13WH [2704r,5472r:0) 0@2704r

selectOrSplit GR64:%26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w=1.434659e-03
hints: $rsi
RS_Assign Cascade 0
should evict: %11 [976r,5152r:0) 0@976r  weight:8.828671e-04 w= 8.828671e-04
should evict: %11 [976r,5152r:0) 0@976r  weight:8.828671e-04 w= 8.828671e-04
should evict: %11 [976r,5152r:0) 0@976r  weight:8.828671e-04 w= 8.828671e-04
evicting $rbx interference: Cascade 1
unassigning %11 from $rbx: BH BL HBX
assigning %26 to $rbx: BH [3136r,5552r:0) 0@3136r BL [3136r,5552r:0) 0@3136r HBX [3136r,5552r:0) 0@3136r
queuing new interval: %11 [976r,5152r:0) 0@976r  weight:8.828671e-04
Enqueuing %11

selectOrSplit GR64:%11 [976r,5152r:0) 0@976r  weight:8.828671e-04 w=8.828671e-04
hints: $rsi
RS_Assign Cascade 1
wait for second round
queuing new interval: %11 [976r,5152r:0) 0@976r  weight:8.828671e-04
Enqueuing %11

selectOrSplit GR64:%29 [3568r,5632r:0) 0@3568r  weight:1.639610e-03 w=1.639610e-03
hints: $rsi
RS_Assign Cascade 0
should evict: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w= 1.434659e-03
should evict: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w= 1.434659e-03
should evict: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w= 1.434659e-03
should evict: %14 [1408r,5232r:0) 0@1408r  weight:9.564394e-04 w= 9.564394e-04
should evict: %14 [1408r,5232r:0) 0@1408r  weight:9.564394e-04 w= 9.564394e-04
should evict: %14 [1408r,5232r:0) 0@1408r  weight:9.564394e-04 w= 9.564394e-04
evicting $r14 interference: Cascade 2
unassigning %14 from $r14: R14B R14BH R14WH
assigning %29 to $r14: R14B [3568r,5632r:0) 0@3568r R14BH [3568r,5632r:0) 0@3568r R14WH [3568r,5632r:0) 0@3568r
queuing new interval: %14 [1408r,5232r:0) 0@1408r  weight:9.564394e-04
Enqueuing %14

selectOrSplit GR64:%14 [1408r,5232r:0) 0@1408r  weight:9.564394e-04 w=9.564394e-04
hints: $rsi
RS_Assign Cascade 2
wait for second round
queuing new interval: %14 [1408r,5232r:0) 0@1408r  weight:9.564394e-04
Enqueuing %14

selectOrSplit GR64:%32 [4000r,5712r:0) 0@4000r  weight:1.912879e-03 w=1.912879e-03
hints: $rsi
RS_Assign Cascade 0
should evict: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w= 1.434659e-03
should evict: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w= 1.434659e-03
should evict: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w= 1.434659e-03
should evict: %17 [1840r,5312r:0) 0@1840r  weight:1.043388e-03 w= 1.043388e-03
should evict: %17 [1840r,5312r:0) 0@1840r  weight:1.043388e-03 w= 1.043388e-03
should evict: %17 [1840r,5312r:0) 0@1840r  weight:1.043388e-03 w= 1.043388e-03
evicting $r15 interference: Cascade 3
unassigning %17 from $r15: R15B R15BH R15WH
assigning %32 to $r15: R15B [4000r,5712r:0) 0@4000r R15BH [4000r,5712r:0) 0@4000r R15WH [4000r,5712r:0) 0@4000r
queuing new interval: %17 [1840r,5312r:0) 0@1840r  weight:1.043388e-03
Enqueuing %17

selectOrSplit GR64:%17 [1840r,5312r:0) 0@1840r  weight:1.043388e-03 w=1.043388e-03
hints: $rsi
RS_Assign Cascade 3
wait for second round
queuing new interval: %17 [1840r,5312r:0) 0@1840r  weight:1.043388e-03
Enqueuing %17

selectOrSplit GR64:%82 [4432r,5808r:0) 0@4432r  weight:2.274775e-03 w=2.274775e-03
hints: $rsi
RS_Assign Cascade 0
should evict: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w= 1.434659e-03
should evict: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w= 1.434659e-03
should evict: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w= 1.434659e-03
should evict: %20 [2272r,5392r:0) 0@2272r  weight:1.147727e-03 w= 1.147727e-03
should evict: %20 [2272r,5392r:0) 0@2272r  weight:1.147727e-03 w= 1.147727e-03
should evict: %20 [2272r,5392r:0) 0@2272r  weight:1.147727e-03 w= 1.147727e-03
evicting $r12 interference: Cascade 4
unassigning %20 from $r12: R12B R12BH R12WH
assigning %82 to $r12: R12B [4432r,5808r:0) 0@4432r R12BH [4432r,5808r:0) 0@4432r R12WH [4432r,5808r:0) 0@4432r
queuing new interval: %20 [2272r,5392r:0) 0@2272r  weight:1.147727e-03
Enqueuing %20

selectOrSplit GR64:%20 [2272r,5392r:0) 0@2272r  weight:1.147727e-03 w=1.147727e-03
hints: $rsi
RS_Assign Cascade 4
wait for second round
queuing new interval: %20 [2272r,5392r:0) 0@2272r  weight:1.147727e-03
Enqueuing %20

selectOrSplit GR64:%37 [112r,640r:0) 0@112r  weight:1.306034e-02 w=1.306034e-02
hints: $rax
missed hint $rax
assigning %37 to $rbx: BH [112r,640r:0) 0@112r BL [112r,640r:0) 0@112r HBX [112r,640r:0) 0@112r

selectOrSplit GR64:%10 [736r,1040r:0) 0@736r  weight:5.260417e-03 w=5.260417e-03
hints: $rax $rdi
missed hint $rax
assigning %10 to $rbx: BH [736r,1040r:0) 0@736r BL [736r,1040r:0) 0@736r HBX [736r,1040r:0) 0@736r

selectOrSplit GR64:%13 [1184r,1472r:0) 0@1184r  weight:5.382752e-03 w=5.382752e-03
hints: $rax $rdi
missed hint $rax
assigning %13 to $rbx: BH [1184r,1472r:0) 0@1184r BL [1184r,1472r:0) 0@1184r HBX [1184r,1472r:0) 0@1184r

selectOrSplit GR64:%16 [1616r,1904r:0) 0@1616r  weight:5.382752e-03 w=5.382752e-03
hints: $rax $rdi
missed hint $rax
assigning %16 to $rbx: BH [1616r,1904r:0) 0@1616r BL [1616r,1904r:0) 0@1616r HBX [1616r,1904r:0) 0@1616r

selectOrSplit GR64:%19 [2048r,2336r:0) 0@2048r  weight:5.382752e-03 w=5.382752e-03
hints: $rax $rdi
missed hint $rax
assigning %19 to $rbx: BH [2048r,2336r:0) 0@2048r BL [2048r,2336r:0) 0@2048r HBX [2048r,2336r:0) 0@2048r

selectOrSplit GR64:%22 [2480r,2768r:0) 0@2480r  weight:5.382752e-03 w=5.382752e-03
hints: $rax $rdi
missed hint $rax
assigning %22 to $rbx: BH [2480r,2768r:0) 0@2480r BL [2480r,2768r:0) 0@2480r HBX [2480r,2768r:0) 0@2480r

selectOrSplit GR64:%25 [2912r,3200r:0) 0@2912r  weight:5.382752e-03 w=5.382752e-03
hints: $rax $rdi
missed hint $rax
assigning %25 to $r14: R14B [2912r,3200r:0) 0@2912r R14BH [2912r,3200r:0) 0@2912r R14WH [2912r,3200r:0) 0@2912r

selectOrSplit GR64:%28 [3344r,3632r:0) 0@3344r  weight:5.382752e-03 w=5.382752e-03
hints: $rax $rdi
missed hint $rax
assigning %28 to $r15: R15B [3344r,3632r:0) 0@3344r R15BH [3344r,3632r:0) 0@3344r R15WH [3344r,3632r:0) 0@3344r

selectOrSplit GR64:%31 [3776r,4064r:0) 0@3776r  weight:5.382752e-03 w=5.382752e-03
hints: $rax $rdi
missed hint $rax
assigning %31 to $r12: R12B [3776r,4064r:0) 0@3776r R12BH [3776r,4064r:0) 0@3776r R12WH [3776r,4064r:0) 0@3776r

selectOrSplit GR64:%34 [4208r,4496r:0) 0@4208r  weight:5.382752e-03 w=5.382752e-03
hints: $rax $rdi
RS_Assign Cascade 0
should evict: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w= 1.434659e-03
should evict: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w= 1.434659e-03
should evict: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w= 1.434659e-03
should evict: %23 [2704r,5472r:0) 0@2704r  weight:1.275253e-03 w= 1.275253e-03
should evict: %23 [2704r,5472r:0) 0@2704r  weight:1.275253e-03 w= 1.275253e-03
should evict: %23 [2704r,5472r:0) 0@2704r  weight:1.275253e-03 w= 1.275253e-03
evicting $r13 interference: Cascade 5
unassigning %23 from $r13: R13B R13BH R13WH
assigning %34 to $r13: R13B [4208r,4496r:0) 0@4208r R13BH [4208r,4496r:0) 0@4208r R13WH [4208r,4496r:0) 0@4208r
queuing new interval: %23 [2704r,5472r:0) 0@2704r  weight:1.275253e-03
Enqueuing %23

selectOrSplit GR64:%23 [2704r,5472r:0) 0@2704r  weight:1.275253e-03 w=1.275253e-03
hints: $rsi
RS_Assign Cascade 5
wait for second round
queuing new interval: %23 [2704r,5472r:0) 0@2704r  weight:1.275253e-03
Enqueuing %23

selectOrSplit GR64:%9 [656r,880r:0) 0@656r  weight:4.316240e-03 w=4.316240e-03
hints: $rdi $rsi
missed hint $rdi
assigning %9 to $r14: R14B [656r,880r:0) 0@656r R14BH [656r,880r:0) 0@656r R14WH [656r,880r:0) 0@656r

selectOrSplit GR64:%12 [1104r,1312r:0) 0@1104r  weight:4.429825e-03 w=4.429825e-03
hints: $rdi $rsi
missed hint $rdi
assigning %12 to $r14: R14B [1104r,1312r:0) 0@1104r R14BH [1104r,1312r:0) 0@1104r R14WH [1104r,1312r:0) 0@1104r

selectOrSplit GR64:%15 [1536r,1744r:0) 0@1536r  weight:4.429825e-03 w=4.429825e-03
hints: $rdi $rsi
missed hint $rdi
assigning %15 to $r14: R14B [1536r,1744r:0) 0@1536r R14BH [1536r,1744r:0) 0@1536r R14WH [1536r,1744r:0) 0@1536r

selectOrSplit GR64:%18 [1968r,2176r:0) 0@1968r  weight:4.429825e-03 w=4.429825e-03
hints: $rdi $rsi
missed hint $rdi
assigning %18 to $r14: R14B [1968r,2176r:0) 0@1968r R14BH [1968r,2176r:0) 0@1968r R14WH [1968r,2176r:0) 0@1968r

selectOrSplit GR64:%21 [2400r,2608r:0) 0@2400r  weight:4.429825e-03 w=4.429825e-03
hints: $rdi $rsi
missed hint $rdi
assigning %21 to $r14: R14B [2400r,2608r:0) 0@2400r R14BH [2400r,2608r:0) 0@2400r R14WH [2400r,2608r:0) 0@2400r

selectOrSplit GR64:%24 [2832r,3040r:0) 0@2832r  weight:4.429825e-03 w=4.429825e-03
hints: $rdi $rsi
missed hint $rdi
assigning %24 to $rbx: BH [2832r,3040r:0) 0@2832r BL [2832r,3040r:0) 0@2832r HBX [2832r,3040r:0) 0@2832r

selectOrSplit GR64:%27 [3264r,3472r:0) 0@3264r  weight:4.429825e-03 w=4.429825e-03
hints: $rdi $rsi
missed hint $rdi
assigning %27 to $r14: R14B [3264r,3472r:0) 0@3264r R14BH [3264r,3472r:0) 0@3264r R14WH [3264r,3472r:0) 0@3264r

selectOrSplit GR64:%30 [3696r,3904r:0) 0@3696r  weight:4.429825e-03 w=4.429825e-03
hints: $rdi $rsi
missed hint $rdi
assigning %30 to $r15: R15B [3696r,3904r:0) 0@3696r R15BH [3696r,3904r:0) 0@3696r R15WH [3696r,3904r:0) 0@3696r

selectOrSplit GR64:%33 [4128r,4336r:0) 0@4128r  weight:4.429825e-03 w=4.429825e-03
hints: $rdi $rsi
missed hint $rdi
assigning %33 to $r12: R12B [4128r,4336r:0) 0@4128r R12BH [4128r,4336r:0) 0@4128r R12WH [4128r,4336r:0) 0@4128r

selectOrSplit GR64:%35 [32r,4176r:0) 0@32r  weight:1.210387e-03 w=1.210387e-03
assigning %35 to $r13: R13B [32r,4176r:0) 0@32r R13BH [32r,4176r:0) 0@32r R13WH [32r,4176r:0) 0@32r

selectOrSplit GR64_NOSP:%8 [640r,4528r:0) 0@640r  weight:9.328358e-04 w=9.328358e-04
RS_Assign Cascade 0
wait for second round
queuing new interval: %8 [640r,4528r:0) 0@640r  weight:9.328358e-04
Enqueuing %8

selectOrSplit GR64:%100 [784r,4352r:0) 0@784r  weight:8.820564e-04 w=8.820564e-04
RS_Assign Cascade 0
wait for second round
queuing new interval: %100 [784r,4352r:0) 0@784r  weight:8.820564e-04
Enqueuing %100

selectOrSplit GR64_NOSP:%7 [624r,4096r:0) 0@624r  weight:1.033058e-03 w=1.033058e-03
RS_Assign Cascade 0
wait for second round
queuing new interval: %7 [624r,4096r:0) 0@624r  weight:1.033058e-03
Enqueuing %7

selectOrSplit GR64_NOSP:%6 [608r,3664r:0) 0@608r  weight:1.157407e-03 w=1.157407e-03
assigning %6 to $r12: R12B [608r,3664r:0) 0@608r R12BH [608r,3664r:0) 0@608r R12WH [608r,3664r:0) 0@608r

selectOrSplit GR64_NOSP:%5 [592r,3232r:0) 0@592r  weight:1.315790e-03 w=1.315790e-03
assigning %5 to $r15: R15B [592r,3232r:0) 0@592r R15BH [592r,3232r:0) 0@592r R15WH [592r,3232r:0) 0@592r

selectOrSplit GR64_NOSP:%4 [576r,2800r:0) 0@576r  weight:1.524390e-03 w=1.524390e-03
RS_Assign Cascade 0
should evict: %5 [592r,3232r:0) 0@592r  weight:1.315790e-03 w= 1.315790e-03
should evict: %5 [592r,3232r:0) 0@592r  weight:1.315790e-03 w= 1.315790e-03
should evict: %5 [592r,3232r:0) 0@592r  weight:1.315790e-03 w= 1.315790e-03
should evict: %6 [608r,3664r:0) 0@608r  weight:1.157407e-03 w= 1.157407e-03
should evict: %6 [608r,3664r:0) 0@608r  weight:1.157407e-03 w= 1.157407e-03
should evict: %6 [608r,3664r:0) 0@608r  weight:1.157407e-03 w= 1.157407e-03
evicting $r12 interference: Cascade 6
unassigning %6 from $r12: R12B R12BH R12WH
assigning %4 to $r12: R12B [576r,2800r:0) 0@576r R12BH [576r,2800r:0) 0@576r R12WH [576r,2800r:0) 0@576r
queuing new interval: %6 [608r,3664r:0) 0@608r  weight:1.157407e-03
Enqueuing %6

selectOrSplit GR64_NOSP:%6 [608r,3664r:0) 0@608r  weight:1.157407e-03 w=1.157407e-03
RS_Assign Cascade 6
wait for second round
queuing new interval: %6 [608r,3664r:0) 0@608r  weight:1.157407e-03
Enqueuing %6

selectOrSplit GR64_NOSP:%3 [560r,2368r:0) 0@560r  weight:1.811594e-03 w=1.811594e-03
RS_Assign Cascade 0
should evict: %5 [592r,3232r:0) 0@592r  weight:1.315790e-03 w= 1.315790e-03
should evict: %5 [592r,3232r:0) 0@592r  weight:1.315790e-03 w= 1.315790e-03
should evict: %5 [592r,3232r:0) 0@592r  weight:1.315790e-03 w= 1.315790e-03
should evict: %35 [32r,4176r:0) 0@32r  weight:1.210387e-03 w= 1.210387e-03
should evict: %35 [32r,4176r:0) 0@32r  weight:1.210387e-03 w= 1.210387e-03
should evict: %35 [32r,4176r:0) 0@32r  weight:1.210387e-03 w= 1.210387e-03
evicting $r13 interference: Cascade 7
unassigning %35 from $r13: R13B R13BH R13WH
assigning %3 to $r13: R13B [560r,2368r:0) 0@560r R13BH [560r,2368r:0) 0@560r R13WH [560r,2368r:0) 0@560r
queuing new interval: %35 [32r,4176r:0) 0@32r  weight:1.210387e-03
Enqueuing %35

selectOrSplit GR64:%35 [32r,4176r:0) 0@32r  weight:1.210387e-03 w=1.210387e-03
RS_Assign Cascade 7
wait for second round
queuing new interval: %35 [32r,4176r:0) 0@32r  weight:1.210387e-03
Enqueuing %35

selectOrSplit GR64_NOSP:%2 [544r,1936r:0) 0@544r  weight:2.232143e-03 w=2.232143e-03
RS_Assign Cascade 0
should evict: %5 [592r,3232r:0) 0@592r  weight:1.315790e-03 w= 1.315790e-03
should evict: %5 [592r,3232r:0) 0@592r  weight:1.315790e-03 w= 1.315790e-03
should evict: %5 [592r,3232r:0) 0@592r  weight:1.315790e-03 w= 1.315790e-03
evicting $r15 interference: Cascade 8
unassigning %5 from $r15: R15B R15BH R15WH
assigning %2 to $r15: R15B [544r,1936r:0) 0@544r R15BH [544r,1936r:0) 0@544r R15WH [544r,1936r:0) 0@544r
queuing new interval: %5 [592r,3232r:0) 0@592r  weight:1.315790e-03
Enqueuing %5

selectOrSplit GR64_NOSP:%5 [592r,3232r:0) 0@592r  weight:1.315790e-03 w=1.315790e-03
RS_Assign Cascade 8
wait for second round
queuing new interval: %5 [592r,3232r:0) 0@592r  weight:1.315790e-03
Enqueuing %5

selectOrSplit GR64_NOSP:%1 [528r,1504r:0) 0@528r  weight:2.906977e-03 w=2.906977e-03
RS_Assign Cascade 0
should evict: %2 [544r,1936r:0) 0@544r  weight:2.232143e-03 w= 2.232143e-03
should evict: %2 [544r,1936r:0) 0@544r  weight:2.232143e-03 w= 2.232143e-03
should evict: %2 [544r,1936r:0) 0@544r  weight:2.232143e-03 w= 2.232143e-03
should evict: %4 [576r,2800r:0) 0@576r  weight:1.524390e-03 w= 1.524390e-03
should evict: %4 [576r,2800r:0) 0@576r  weight:1.524390e-03 w= 1.524390e-03
should evict: %4 [576r,2800r:0) 0@576r  weight:1.524390e-03 w= 1.524390e-03
evicting $r12 interference: Cascade 9
unassigning %4 from $r12: R12B R12BH R12WH
assigning %1 to $r12: R12B [528r,1504r:0) 0@528r R12BH [528r,1504r:0) 0@528r R12WH [528r,1504r:0) 0@528r
queuing new interval: %4 [576r,2800r:0) 0@576r  weight:1.524390e-03
Enqueuing %4

selectOrSplit GR64_NOSP:%4 [576r,2800r:0) 0@576r  weight:1.524390e-03 w=1.524390e-03
RS_Assign Cascade 9
wait for second round
queuing new interval: %4 [576r,2800r:0) 0@576r  weight:1.524390e-03
Enqueuing %4

selectOrSplit GR64:%91 [5120r,5728r:0) 0@5120r  weight:4.464286e-03 w=4.464286e-03
assigning %91 to $r13: R13B [5120r,5728r:0) 0@5120r R13BH [5120r,5728r:0) 0@5120r R13WH [5120r,5728r:0) 0@5120r

selectOrSplit GR64_NOSP:%0 [512r,1072r:0) 0@512r  weight:4.166667e-03 w=4.166667e-03
RS_Assign Cascade 0
should evict: %2 [544r,1936r:0) 0@544r  weight:2.232143e-03 w= 2.232143e-03
should evict: %2 [544r,1936r:0) 0@544r  weight:2.232143e-03 w= 2.232143e-03
should evict: %2 [544r,1936r:0) 0@544r  weight:2.232143e-03 w= 2.232143e-03
should evict: %3 [560r,2368r:0) 0@560r  weight:1.811594e-03 w= 1.811594e-03
should evict: %3 [560r,2368r:0) 0@560r  weight:1.811594e-03 w= 1.811594e-03
should evict: %3 [560r,2368r:0) 0@560r  weight:1.811594e-03 w= 1.811594e-03
evicting $r13 interference: Cascade 10
unassigning %3 from $r13: R13B R13BH R13WH
assigning %0 to $r13: R13B [512r,1072r:0) 0@512r R13BH [512r,1072r:0) 0@512r R13WH [512r,1072r:0) 0@512r
queuing new interval: %3 [560r,2368r:0) 0@560r  weight:1.811594e-03
Enqueuing %3

selectOrSplit GR64_NOSP:%3 [560r,2368r:0) 0@560r  weight:1.811594e-03 w=1.811594e-03
RS_Assign Cascade 10
wait for second round
queuing new interval: %3 [560r,2368r:0) 0@560r  weight:1.811594e-03
Enqueuing %3

selectOrSplit GR64:%84 [4576r,5072r:0) 0@4576r  weight:1.116071e-03 w=1.116071e-03
assigning %84 to $rax: AH [4576r,5072r:0) 0@4576r AL [4576r,5072r:0) 0@4576r HAX [4576r,5072r:0) 0@4576r

selectOrSplit GR64:%39 [224r,472r:0) 0@224r  weight:1.543210e-03 w=1.543210e-03
assigning %39 to $rax: AH [224r,472r:0) 0@224r AL [224r,472r:0) 0@224r HAX [224r,472r:0) 0@224r

selectOrSplit GR64:%40 [240r,480r:0) 0@240r  weight:1.562500e-03 w=1.562500e-03
assigning %40 to $r10: R10B [240r,480r:0) 0@240r R10BH [240r,480r:0) 0@240r R10WH [240r,480r:0) 0@240r

selectOrSplit GR64:%49 [960r,1088r:0) 0@960r  weight:1.325758e-02 w=1.325758e-02
assigning %49 to $rax: AH [960r,1088r:0) 0@960r AL [960r,1088r:0) 0@960r HAX [960r,1088r:0) 0@960r

selectOrSplit GR64:%53 [1392r,1520r:0) 0@1392r  weight:1.325758e-02 w=1.325758e-02
assigning %53 to $rax: AH [1392r,1520r:0) 0@1392r AL [1392r,1520r:0) 0@1392r HAX [1392r,1520r:0) 0@1392r

selectOrSplit GR64:%57 [1824r,1952r:0) 0@1824r  weight:1.325758e-02 w=1.325758e-02
assigning %57 to $rax: AH [1824r,1952r:0) 0@1824r AL [1824r,1952r:0) 0@1824r HAX [1824r,1952r:0) 0@1824r

selectOrSplit GR64:%61 [2256r,2384r:0) 0@2256r  weight:1.325758e-02 w=1.325758e-02
assigning %61 to $rax: AH [2256r,2384r:0) 0@2256r AL [2256r,2384r:0) 0@2256r HAX [2256r,2384r:0) 0@2256r

selectOrSplit GR64:%65 [2688r,2816r:0) 0@2688r  weight:1.325758e-02 w=1.325758e-02
assigning %65 to $rax: AH [2688r,2816r:0) 0@2688r AL [2688r,2816r:0) 0@2688r HAX [2688r,2816r:0) 0@2688r

selectOrSplit GR64:%69 [3120r,3248r:0) 0@3120r  weight:1.325758e-02 w=1.325758e-02
assigning %69 to $rax: AH [3120r,3248r:0) 0@3120r AL [3120r,3248r:0) 0@3120r HAX [3120r,3248r:0) 0@3120r

selectOrSplit GR64:%73 [3552r,3680r:0) 0@3552r  weight:1.325758e-02 w=1.325758e-02
assigning %73 to $rax: AH [3552r,3680r:0) 0@3552r AL [3552r,3680r:0) 0@3552r HAX [3552r,3680r:0) 0@3552r

selectOrSplit GR64:%77 [3984r,4112r:0) 0@3984r  weight:1.325758e-02 w=1.325758e-02
assigning %77 to $rax: AH [3984r,4112r:0) 0@3984r AL [3984r,4112r:0) 0@3984r HAX [3984r,4112r:0) 0@3984r

selectOrSplit GR64:%81 [4416r,4544r:0) 0@4416r  weight:1.325758e-02 w=1.325758e-02
assigning %81 to $rax: AH [4416r,4544r:0) 0@4416r AL [4416r,4544r:0) 0@4416r HAX [4416r,4544r:0) 0@4416r

selectOrSplit GR64:%92 [5776r,5824r:0) 0@5776r  weight:2.232143e-03 w=2.232143e-03
assigning %92 to $rax: AH [5776r,5824r:0) 0@5776r AL [5776r,5824r:0) 0@5776r HAX [5776r,5824r:0) 0@5776r

selectOrSplit GR64:%11 [976r,5152r:0) 0@976r  weight:8.828671e-04 w=8.828671e-04
hints: $rsi
RS_Split Cascade 1
Analyze counted 4 instrs in 2 blocks, through 15 blocks.
Compact region bundles, v=4, none.
Cost of isolating all blocks = 2.0
$rsi	no positive bundles
$rax	no positive bundles
$rcx	no positive bundles
$rdx	no positive bundles
$rdi	no positive bundles
$r8	no positive bundles
$r9	no positive bundles
$r10	static = 2.0 worse than no bundles
$r11	static = 2.0 worse than no bundles
$rbx	no positive bundles
$r14	no positive bundles
$r15	no positive bundles
$r12	no positive bundles
$r13	no positive bundles
    enterIntvBefore 976r: not live
    leaveIntvAfter 992r: valno 0
    useIntv [976B;992r): [976B;992r):1
    enterIntvBefore 5056r: valno 0
    leaveIntvAfter 5152r: not live
    useIntv [5048r;5168B): [976B;992r):1 [5048r;5168B):2
Multi-mapped complement 0@984r for parent 0@976r hoist to %bb.2 984r
Removing 0 back-copies.
  blit [976r,5152r:0): [976r;992r)=1(%102):0 [992r;5048r)=0(%101)(recalc) [5048r;5152r)=2(%103):0
  rewr %bb.2	976r:1	%102:gr64 = LEA64r %49:gr64, 1, $noreg, -48, $noreg
  rewr %bb.2	992B:1	$rsp = COPY %102:gr64
  rewr %bb.18	5152B:2	$rsi = COPY %103:gr64
  rewr %bb.18	5056B:2	PUSH64r %103:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
  rewr %bb.2	984B:1	%101:gr64 = COPY %102:gr64
  rewr %bb.18	5048B:0	%103:gr64 = COPY %101:gr64
queuing new interval: %101 [984r,5048r:0) 0@984r  weight:4.525089e-04
Enqueuing %101
queuing new interval: %102 [976r,992r:0) 0@976r  weight:7.283654e-03
Enqueuing %102
queuing new interval: %103 [5048r,5152r:0) 0@5048r  weight:6.011905e-03
Enqueuing %103

selectOrSplit GR64:%103 [5048r,5152r:0) 0@5048r  weight:6.011905e-03 w=6.011905e-03
hints: $rsi
RS_Assign Cascade 0
should evict: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w= 1.434659e-03
should evict: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w= 1.434659e-03
should evict: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w= 1.434659e-03
evicting $rbx interference: Cascade 11
unassigning %26 from $rbx: BH BL HBX
assigning %103 to $rbx: BH [5048r,5152r:0) 0@5048r BL [5048r,5152r:0) 0@5048r HBX [5048r,5152r:0) 0@5048r
queuing new interval: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03
Enqueuing %26

selectOrSplit GR64:%26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w=1.434659e-03
hints: $rsi
RS_Assign Cascade 11
wait for second round
queuing new interval: %26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03
Enqueuing %26

selectOrSplit GR64:%101 [984r,5048r:0) 0@984r  weight:4.525089e-04 w=4.525089e-04
hints: $rbx
RS_Spill Cascade 0
Inline spilling GR64:%101 [984r,5048r:0) 0@984r  weight:4.525089e-04
From original %11
Merged spilled regs: SS#10 [984r,5048r:0) 0@x  weight:0.000000e+00
spillAroundUses %101
	folded:   984r	MOV64mr %stack.10, 1, $noreg, 0, $noreg, %102:gr64 :: (store (s64) into %stack.10)
Checking redundant spills for 0@5048r in %103 [5048r,5152r:0) 0@5048r  weight:6.011905e-03
Merged to stack int: SS#10 [984r,5152r:0) 0@x  weight:0.000000e+00
	folded:   5048r	%103:gr64 = MOV64rm %stack.10, 1, $noreg, 0, $noreg :: (load (s64) from %stack.10)

selectOrSplit GR64:%102 [976r,992r:0) 0@976r  weight:7.283654e-03 w=7.283654e-03
assigning %102 to $rcx: CH [976r,992r:0) 0@976r CL [976r,992r:0) 0@976r HCX [976r,992r:0) 0@976r

selectOrSplit GR64:%35 [32r,4176r:0) 0@32r  weight:1.210387e-03 w=1.210387e-03
RS_Split Cascade 7
Analyze counted 11 instrs in 9 blocks, through 8 blocks.
Compact region bundles, v=8, none.
Cost of isolating all blocks = 9.0
$rax	no positive bundles
$rcx	no positive bundles
$rdx	no positive bundles
$rsi	no positive bundles
$rdi	no positive bundles
$r8	no positive bundles
$r9	no positive bundles
$r10	no positive bundles
$r11	no positive bundles
$rbx	static = 11.0 worse than no bundles
$r14	no positive bundles
$r15	static = 10.0 worse than no bundles
$r12	static = 6.0, v=5, total = 6.0 with bundles EB#3 EB#4 EB#5 EB#6 EB#7.
$r13	static = 2.0, v=7, total = 2.0 with bundles EB#2 EB#3 EB#4 EB#5 EB#6 EB#7 EB#8.
Split for $r13 in 7 bundles, intv 1.
splitAroundRegion with 2 globals.
%bb.0 isolated.
    enterIntvBefore 32r: not live
    leaveIntvAfter 704r: valno 0
    useIntv [32B;704r): [32B;704r):2
%bb.2 [928B;1264B), uses 1152r-1152r, reg-out 1, enter after 1072r, stack-in, reload after interference.
    selectIntv 2 -> 1
    enterIntvBefore 1152r: valno 0
    useIntv [1144r;1264B): [32B;704r):2 [1144r;1264B):1
%bb.4 [1360B;1696B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [1360B;1696B): [32B;704r):2 [1144r;1264B):1 [1360B;1696B):1
%bb.6 [1792B;2128B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [1792B;2128B): [32B;704r):2 [1144r;1264B):1 [1360B;1696B):1 [1792B;2128B):1
%bb.8 [2224B;2560B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [2224B;2560B): [32B;704r):2 [1144r;1264B):1 [1360B;1696B):1 [1792B;2128B):1 [2224B;2560B):1
%bb.10 [2656B;2992B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [2656B;2992B): [32B;704r):2 [1144r;1264B):1 [1360B;1696B):1 [1792B;2128B):1 [2224B;2560B):1 [2656B;2992B):1
%bb.12 [3088B;3424B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [3088B;3424B): [32B;704r):2 [1144r;1264B):1 [1360B;1696B):1 [1792B;2128B):1 [2224B;2560B):1 [2656B;2992B):1 [3088B;3424B):1
%bb.14 [3520B;3856B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [3520B;3856B): [32B;704r):2 [1144r;1264B):1 [1360B;1696B):1 [1792B;2128B):1 [2224B;2560B):1 [2656B;2992B):1 [3088B;3424B):1 [3520B;3856B):1
%bb.16 [3952B;4288B), uses 4176r-4176r, reg-in 1, leave before 4208r, killed in block before interference.
    selectIntv 1 -> 1
    useIntv [3952B;4176r): [32B;704r):2 [1144r;1264B):1 [1360B;1696B):1 [1792B;2128B):1 [2224B;2560B):1 [2656B;2992B):1 [3088B;3424B):1 [3520B;3856B):1 [3952B;4176r):1
%bb.3 [1264B;1360B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [1264B;1360B): [32B;704r):2 [1144r;1696B):1 [1792B;2128B):1 [2224B;2560B):1 [2656B;2992B):1 [3088B;3424B):1 [3520B;3856B):1 [3952B;4176r):1
%bb.5 [1696B;1792B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [1696B;1792B): [32B;704r):2 [1144r;2128B):1 [2224B;2560B):1 [2656B;2992B):1 [3088B;3424B):1 [3520B;3856B):1 [3952B;4176r):1
%bb.7 [2128B;2224B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [2128B;2224B): [32B;704r):2 [1144r;2560B):1 [2656B;2992B):1 [3088B;3424B):1 [3520B;3856B):1 [3952B;4176r):1
%bb.9 [2560B;2656B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [2560B;2656B): [32B;704r):2 [1144r;2992B):1 [3088B;3424B):1 [3520B;3856B):1 [3952B;4176r):1
%bb.11 [2992B;3088B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [2992B;3088B): [32B;704r):2 [1144r;3424B):1 [3520B;3856B):1 [3952B;4176r):1
%bb.13 [3424B;3520B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [3424B;3520B): [32B;704r):2 [1144r;3856B):1 [3952B;4176r):1
%bb.15 [3856B;3952B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [3856B;3952B): [32B;704r):2 [1144r;4176r):1
Multi-mapped complement 0@696r for parent 0@32r hoist to %bb.0 696r
Removing 0 back-copies.
  blit [32r,4176r:0): [32r;704r)=2(%106):0 [704r;1144r)=0(%104)(recalc) [1144r;4176r)=1(%105):0
  rewr %bb.0	32r:2	%106:gr64 = MOV64ri @malloc
  rewr %bb.0	80B:2	CALL64r %106:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  rewr %bb.0	704B:2	CALL64r %106:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  rewr %bb.2	1152B:1	CALL64r %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  rewr %bb.4	1584B:1	CALL64r %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  rewr %bb.6	2016B:1	CALL64r %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  rewr %bb.8	2448B:1	CALL64r %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  rewr %bb.10	2880B:1	CALL64r %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  rewr %bb.12	3312B:1	CALL64r %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  rewr %bb.14	3744B:1	CALL64r %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  rewr %bb.16	4176B:1	CALL64r %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  rewr %bb.0	696B:2	%104:gr64 = COPY %106:gr64
  rewr %bb.2	1144B:0	%105:gr64 = COPY %104:gr64
queuing new interval: %104 [696r,1144r:0) 0@696r  weight:1.191038e-03
Enqueuing %104
queuing new interval: %105 [1144r,4176r:0) 0@1144r  weight:1.324301e-03
Enqueuing %105
queuing new interval: %106 [32r,704r:0) 0@32r  weight:1.884328e-03
Enqueuing %106

selectOrSplit GR64:%105 [1144r,4176r:0) 0@1144r  weight:1.324301e-03 w=1.324301e-03
assigning %105 to $r13: R13B [1144r,4176r:0) 0@1144r R13BH [1144r,4176r:0) 0@1144r R13WH [1144r,4176r:0) 0@1144r

selectOrSplit GR64:%106 [32r,704r:0) 0@32r  weight:1.884328e-03 w=1.884328e-03
RS_Assign Cascade 0
wait for second round
queuing new interval: %106 [32r,704r:0) 0@32r  weight:1.884328e-03
Enqueuing %106

selectOrSplit GR64:%104 [696r,1144r:0) 0@696r  weight:1.191038e-03 w=1.191038e-03
hints: $r13
RS_Spill Cascade 0
Inline spilling GR64:%104 [696r,1144r:0) 0@696r  weight:1.191038e-03
From original %35
	remat:  1140r	%107:gr64 = MOV64ri @malloc
	        1144e	%105:gr64 = COPY killed %107:gr64

All defs dead: dead %104:gr64 = COPY %106:gr64
Remat created 1 dead defs.
Deleting dead def 696r	dead %104:gr64 = COPY %106:gr64
Shrink: %106 [32r,704r:0) 0@32r  weight:1.884328e-03
Shrunk: %106 [32r,704r:0) 0@32r  weight:1.884328e-03
0 registers to spill after remat.
queuing new interval: %107 [1140r,1144r:0) 0@1140r  weight:INF
Enqueuing %107

selectOrSplit GR64:%107 [1140r,1144r:0) 0@1140r  weight:INF w=INF
hints: $r13
assigning %107 to $r13: R13B [1140r,1144r:0) 0@1140r R13BH [1140r,1144r:0) 0@1140r R13WH [1140r,1144r:0) 0@1140r

selectOrSplit GR64_NOSP:%8 [640r,4528r:0) 0@640r  weight:9.328358e-04 w=9.328358e-04
RS_Split Cascade 0
Analyze counted 4 instrs in 3 blocks, through 16 blocks.
Compact region bundles, v=5, none.
Cost of isolating all blocks = 3.0
$rax	no positive bundles
$rcx	static = 3.0 worse than no bundles
$rdx	static = 3.0 worse than no bundles
$rsi	static = 3.0 worse than no bundles
$rdi	static = 3.0 worse than no bundles
$r8	static = 3.0 worse than no bundles
$r9	static = 3.0 worse than no bundles
$r10	static = 3.0 worse than no bundles
$r11	static = 3.0 worse than no bundles
$rbx	static = 1.0, v=7, total = 2.0 with bundles EB#8 EB#9.
$r14	no positive bundles
$r15	no positive bundles
$r12	no positive bundles
$r13	no positive bundles
Split for $rbx in 2 bundles, intv 1.
splitAroundRegion with 2 globals.
%bb.0 isolated.
%bb.16 [3952B;4288B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [3952B;4288B): [3952B;4288B):1
%bb.18 [4384B;5872B), uses 4528r-4528r, reg-in 1, leave before 5048r, killed in block before interference.
    selectIntv 1 -> 1
    useIntv [4384B;4528r): [3952B;4288B):1 [4384B;4528r):1
%bb.14 [3520B;3856B) intf invalid-invalid, live-through 0 -> 1, reload on exit.
    selectIntv 1 -> 1
    enterIntvAtEnd %bb.14, 3840d: valno 0 [3816r;3856B):1 [3952B;4288B):1 [4384B;4528r):1
%bb.15 [3856B;3952B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [3856B;3952B): [3816r;4288B):1 [4384B;4528r):1
%bb.17 [4288B;4384B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [4288B;4384B): [3816r;4528r):1
Direct complement def at 640r
Removing 0 back-copies.
  blit [640r,4528r:0): [640r;3816r)=0(%108):0 [3816r;4528r)=1(%109):0
  rewr %bb.0	640r:0	%108:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
  rewr %bb.16	4240B:1	TEST64rr %109:gr64_nosp, %8:gr64_nosp, implicit-def $eflags
  rewr %bb.16	4240B:1	TEST64rr %109:gr64_nosp, %109:gr64_nosp, implicit-def $eflags
  rewr %bb.18	4528B:1	MOV64mr %81:gr64, 1, $noreg, -24, $noreg, %109:gr64_nosp :: (store (s64) into %ir..repack85)
  rewr %bb.16	4128B:1	%33:gr64 = LEA64r $noreg, 8, %109:gr64_nosp, 0, $noreg
  rewr %bb.14	3816B:0	%109:gr64_nosp = COPY %108:gr64_nosp
Inflated %108 to GR64
queuing new interval: %108 [640r,3816r:0) 0@640r  weight:5.648769e-04
Enqueuing %108
queuing new interval: %109 [3816r,4528r:0) 0@3816r  weight:3.633094e-03
Enqueuing %109

selectOrSplit GR64:%108 [640r,3816r:0) 0@640r  weight:5.648769e-04 w=5.648769e-04
RS_Spill Cascade 0
Inline spilling GR64:%108 [640r,3816r:0) 0@640r  weight:5.648769e-04
From original %8
Merged spilled regs: SS#11 [640r,3816r:0) 0@x  weight:0.000000e+00
spillAroundUses %108
	rewrite: 640r	%110:gr64 = MOV64rm %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)

	spill:   648r	MOV64mr %stack.11, 1, $noreg, 0, $noreg, killed %110:gr64 :: (store (s64) into %stack.11)
Checking redundant spills for 0@3816r in %109 [3816r,4528r:0) 0@3816r  weight:3.633094e-03
Merged to stack int: SS#11 [640r,4528r:0) 0@x  weight:0.000000e+00
	folded:   3816r	%109:gr64_nosp = MOV64rm %stack.11, 1, $noreg, 0, $noreg :: (load (s64) from %stack.11)
queuing new interval: %110 [640r,648r:0) 0@640r  weight:INF
Enqueuing %110

selectOrSplit GR64_NOSP:%109 [3816r,4528r:0) 0@3816r  weight:3.633094e-03 w=3.633094e-03
assigning %109 to $rbx: BH [3816r,4528r:0) 0@3816r BL [3816r,4528r:0) 0@3816r HBX [3816r,4528r:0) 0@3816r

selectOrSplit GR64:%110 [640r,648r:0) 0@640r  weight:INF w=INF
assigning %110 to $rax: AH [640r,648r:0) 0@640r AL [640r,648r:0) 0@640r HAX [640r,648r:0) 0@640r

selectOrSplit GR64:%14 [1408r,5232r:0) 0@1408r  weight:9.564394e-04 w=9.564394e-04
hints: $rsi
RS_Split Cascade 2
Analyze counted 4 instrs in 2 blocks, through 13 blocks.
Compact region bundles, v=4, none.
Cost of isolating all blocks = 2.0
$rsi	no positive bundles
$rax	no positive bundles
$rcx	no positive bundles
$rdx	no positive bundles
$rdi	no positive bundles
$r8	no positive bundles
$r9	no positive bundles
$r10	static = 2.0 worse than no bundles
$r11	static = 2.0 worse than no bundles
$rbx	no positive bundles
$r14	no positive bundles
$r15	no positive bundles
$r12	no positive bundles
$r13	no positive bundles
    enterIntvBefore 1408r: not live
    leaveIntvAfter 1424r: valno 0
    useIntv [1408B;1424r): [1408B;1424r):1
    enterIntvBefore 5024r: valno 0
    leaveIntvAfter 5232r: not live
    useIntv [5016r;5248B): [1408B;1424r):1 [5016r;5248B):2
Multi-mapped complement 0@1416r for parent 0@1408r hoist to %bb.4 1416r
Removing 0 back-copies.
  blit [1408r,5232r:0): [1408r;1424r)=1(%112):0 [1424r;5016r)=0(%111)(recalc) [5016r;5232r)=2(%113):0
  rewr %bb.4	1408r:1	%112:gr64 = LEA64r %53:gr64, 1, $noreg, -48, $noreg
  rewr %bb.4	1424B:1	$rsp = COPY %112:gr64
  rewr %bb.18	5232B:2	$rsi = COPY %113:gr64
  rewr %bb.18	5024B:2	PUSH64r %113:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 16)
  rewr %bb.4	1416B:1	%111:gr64 = COPY %112:gr64
  rewr %bb.18	5016B:0	%113:gr64 = COPY %111:gr64
queuing new interval: %111 [1416r,5016r:0) 0@1416r  weight:5.050000e-04
Enqueuing %111
queuing new interval: %112 [1408r,1424r:0) 0@1408r  weight:7.283654e-03
Enqueuing %112
queuing new interval: %113 [5016r,5232r:0) 0@5016r  weight:4.918831e-03
Enqueuing %113

selectOrSplit GR64:%113 [5016r,5232r:0) 0@5016r  weight:4.918831e-03 w=4.918831e-03
hints: $rsi
RS_Assign Cascade 0
should evict: %29 [3568r,5632r:0) 0@3568r  weight:1.639610e-03 w= 1.639610e-03
should evict: %29 [3568r,5632r:0) 0@3568r  weight:1.639610e-03 w= 1.639610e-03
should evict: %29 [3568r,5632r:0) 0@3568r  weight:1.639610e-03 w= 1.639610e-03
evicting $r14 interference: Cascade 12
unassigning %29 from $r14: R14B R14BH R14WH
assigning %113 to $r14: R14B [5016r,5232r:0) 0@5016r R14BH [5016r,5232r:0) 0@5016r R14WH [5016r,5232r:0) 0@5016r
queuing new interval: %29 [3568r,5632r:0) 0@3568r  weight:1.639610e-03
Enqueuing %29

selectOrSplit GR64:%29 [3568r,5632r:0) 0@3568r  weight:1.639610e-03 w=1.639610e-03
hints: $rsi
RS_Assign Cascade 12
wait for second round
queuing new interval: %29 [3568r,5632r:0) 0@3568r  weight:1.639610e-03
Enqueuing %29

selectOrSplit GR64:%111 [1416r,5016r:0) 0@1416r  weight:5.050000e-04 w=5.050000e-04
hints: $r14
RS_Spill Cascade 0
Inline spilling GR64:%111 [1416r,5016r:0) 0@1416r  weight:5.050000e-04
From original %14
Merged spilled regs: SS#12 [1416r,5016r:0) 0@x  weight:0.000000e+00
spillAroundUses %111
	folded:   1416r	MOV64mr %stack.12, 1, $noreg, 0, $noreg, %112:gr64 :: (store (s64) into %stack.12)
Checking redundant spills for 0@5016r in %113 [5016r,5232r:0) 0@5016r  weight:4.918831e-03
Merged to stack int: SS#12 [1416r,5232r:0) 0@x  weight:0.000000e+00
	folded:   5016r	%113:gr64 = MOV64rm %stack.12, 1, $noreg, 0, $noreg :: (load (s64) from %stack.12)

selectOrSplit GR64:%112 [1408r,1424r:0) 0@1408r  weight:7.283654e-03 w=7.283654e-03
assigning %112 to $rcx: CH [1408r,1424r:0) 0@1408r CL [1408r,1424r:0) 0@1408r HCX [1408r,1424r:0) 0@1408r

selectOrSplit GR64:%100 [784r,4352r:0) 0@784r  weight:8.820564e-04 w=8.820564e-04
RS_Split Cascade 0
Analyze counted 10 instrs in 10 blocks, through 8 blocks.
Compact region bundles, v=8 EB#1.
$rax	static = 5.333333333, v=2 no bundles.
$rcx	static = 5.333333333, v=2 no bundles.
$rdx	static = 5.333333333, v=2 no bundles.
$rsi	no positive bundles
$rdi	no positive bundles
$r8	static = 5.333333333, v=2 no bundles.
$r9	static = 5.333333333, v=2 no bundles.
$r10	static = 5.333333333, v=2 no bundles.
$r11	static = 5.333333333, v=2 no bundles.
$rbx	static = 10.33333333, v=2 no bundles.
$r14	static = 6.333333333, v=2, total = 11.33333333 with bundles EB#8 EB#9.
$r15	static = 7.666666667, v=4, total = 10.33333333 with bundles EB#4 EB#5 EB#6.
$r12	static = 5.666666667, v=6, total = 7.666666667 with bundles EB#3 EB#4 EB#5 EB#6 EB#7.
$r13	no positive bundles
Split for $r12 in 5 bundles, intv 1.
Split for compact region in 1 bundles, intv 2.
splitAroundRegion with 3 globals.
%bb.0 [0B;832B), uses 784r-784r, reg-out 2, enter after invalid, defined in block after interference.
    selectIntv 2 -> 2
    useIntv [784r;832B): [784r;832B):2
%bb.1 [832B;928B) intf invalid-invalid, live-through 2 -> 2, straight through.
    selectIntv 2 -> 2
    useIntv [832B;928B): [784r;928B):2
%bb.3 isolated.
%bb.5 [1696B;1792B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 2 -> 1
    useIntv [1696B;1792B): [784r;928B):2 [1696B;1792B):1
%bb.7 [2128B;2224B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [2128B;2224B): [784r;928B):2 [1696B;1792B):1 [2128B;2224B):1
%bb.9 [2560B;2656B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [2560B;2656B): [784r;928B):2 [1696B;1792B):1 [2128B;2224B):1 [2560B;2656B):1
%bb.11 [2992B;3088B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [2992B;3088B): [784r;928B):2 [1696B;1792B):1 [2128B;2224B):1 [2560B;2656B):1 [2992B;3088B):1
%bb.13 [3424B;3520B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [3424B;3520B): [784r;928B):2 [1696B;1792B):1 [2128B;2224B):1 [2560B;2656B):1 [2992B;3088B):1 [3424B;3520B):1
%bb.15 isolated.
%bb.17 isolated.
%bb.4 [1360B;1696B) intf invalid-1504r, live-through 0 -> 1, reload on exit.
    selectIntv 1 -> 1
    enterIntvAtEnd %bb.4, 1680d: valno 0 [784r;928B):2 [1656r;1792B):1 [2128B;2224B):1 [2560B;2656B):1 [2992B;3088B):1 [3424B;3520B):1
%bb.6 [1792B;2128B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [1792B;2128B): [784r;928B):2 [1656r;2224B):1 [2560B;2656B):1 [2992B;3088B):1 [3424B;3520B):1
%bb.8 [2224B;2560B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [2224B;2560B): [784r;928B):2 [1656r;2656B):1 [2992B;3088B):1 [3424B;3520B):1
%bb.10 [2656B;2992B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [2656B;2992B): [784r;928B):2 [1656r;3088B):1 [3424B;3520B):1
%bb.12 [3088B;3424B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [3088B;3424B): [784r;928B):2 [1656r;3520B):1
%bb.14 [3520B;3856B) intf 3776r-invalid, live-through 1 -> 0, spill on entry.
    selectIntv 1 -> 1
    leaveIntvAtTop %bb.14, 3520B [784r;928B):2 [1656r;3528r):1
%bb.2 [928B;1264B) intf invalid-invalid, live-through 2 -> 0, spill on entry.
    selectIntv 1 -> 2
    leaveIntvAtTop %bb.2, 928B [784r;936r):2 [1656r;3528r):1
Multi-mapped complement 0@3528r for parent 0@784r hoist to %bb.14 3528r
Multi-mapped complement 1@936r for parent 0@784r hoist to %bb.2 936r
Removing 1 back-copies.
Removing 3528r	%114:gr64 = COPY %100:gr64
  cannot find simple kill of RegIdx 1
  blit [784r,4352r:0): [784r;936r)=2(%116):0 [936r;1656r)=0(%114)(recalc) [1656r;3528r)=1(%115)(recalc) [3528r;4352r)=0(%114)(recalc)
  rewr %bb.0	784r:2	%116:gr64 = MOV64ri &__bzero
  rewr %bb.17	4352B:0	CALL64r %114:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  rewr %bb.15	3920B:0	CALL64r %114:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  rewr %bb.13	3488B:1	CALL64r %115:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  rewr %bb.11	3056B:1	CALL64r %115:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  rewr %bb.9	2624B:1	CALL64r %115:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  rewr %bb.7	2192B:1	CALL64r %115:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  rewr %bb.5	1760B:1	CALL64r %115:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  rewr %bb.3	1328B:0	CALL64r %114:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  rewr %bb.1	896B:2	CALL64r %116:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  rewr %bb.4	1656B:0	%115:gr64 = COPY %114:gr64
  rewr %bb.2	936B:2	%114:gr64 = COPY %116:gr64
queuing new interval: %114 [936r,4352r:0) 0@936r  weight:5.293501e-04
Enqueuing %114
queuing new interval: %115 [1656r,3488r:0) 0@1656r  weight:9.804361e-04
Enqueuing %115
queuing new interval: %116 [784r,936r:0) 0@784r  weight:2.439614e-03
Enqueuing %116

selectOrSplit GR64:%114 [936r,4352r:0) 0@936r  weight:5.293501e-04 w=5.293501e-04
RS_Spill Cascade 0
Inline spilling GR64:%114 [936r,4352r:0) 0@936r  weight:5.293501e-04
From original %100
	remat:  4344r	%117:gr64 = MOV64ri &__bzero
	        4352e	CALL64r killed %117:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp

	remat:  3912r	%118:gr64 = MOV64ri &__bzero
	        3920e	CALL64r killed %118:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp

	remat:  1320r	%119:gr64 = MOV64ri &__bzero
	        1328e	CALL64r killed %119:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp

	remat:  1652r	%120:gr64 = MOV64ri &__bzero
	        1656e	%115:gr64 = COPY killed %120:gr64

All defs dead: dead %114:gr64 = COPY %116:gr64
Remat created 1 dead defs.
Deleting dead def 936r	dead %114:gr64 = COPY %116:gr64
Shrink: %116 [784r,936r:0) 0@784r  weight:2.439614e-03
 live-in at 832B
Shrunk: %116 [784r,896r:0) 0@784r  weight:2.439614e-03
0 registers to spill after remat.
queuing new interval: %117 [4344r,4352r:0) 0@4344r  weight:INF
Enqueuing %117
queuing new interval: %118 [3912r,3920r:0) 0@3912r  weight:INF
Enqueuing %118
queuing new interval: %119 [1320r,1328r:0) 0@1320r  weight:INF
Enqueuing %119
queuing new interval: %120 [1652r,1656r:0) 0@1652r  weight:INF
Enqueuing %120

selectOrSplit GR64:%115 [1656r,3488r:0) 0@1656r  weight:9.804361e-04 w=9.804361e-04
assigning %115 to $r12: R12B [1656r,3488r:0) 0@1656r R12BH [1656r,3488r:0) 0@1656r R12WH [1656r,3488r:0) 0@1656r

selectOrSplit GR64:%116 [784r,896r:0) 0@784r  weight:2.439614e-03 w=2.439614e-03
assigning %116 to $rax: AH [784r,896r:0) 0@784r AL [784r,896r:0) 0@784r HAX [784r,896r:0) 0@784r

selectOrSplit GR64:%117 [4344r,4352r:0) 0@4344r  weight:INF w=INF
assigning %117 to $rax: AH [4344r,4352r:0) 0@4344r AL [4344r,4352r:0) 0@4344r HAX [4344r,4352r:0) 0@4344r

selectOrSplit GR64:%118 [3912r,3920r:0) 0@3912r  weight:INF w=INF
assigning %118 to $rax: AH [3912r,3920r:0) 0@3912r AL [3912r,3920r:0) 0@3912r HAX [3912r,3920r:0) 0@3912r

selectOrSplit GR64:%119 [1320r,1328r:0) 0@1320r  weight:INF w=INF
assigning %119 to $rax: AH [1320r,1328r:0) 0@1320r AL [1320r,1328r:0) 0@1320r HAX [1320r,1328r:0) 0@1320r

selectOrSplit GR64:%120 [1652r,1656r:0) 0@1652r  weight:INF w=INF
hints: $r12
assigning %120 to $r12: R12B [1652r,1656r:0) 0@1652r R12BH [1652r,1656r:0) 0@1652r R12WH [1652r,1656r:0) 0@1652r

selectOrSplit GR64_NOSP:%7 [624r,4096r:0) 0@624r  weight:1.033058e-03 w=1.033058e-03
RS_Split Cascade 0
Analyze counted 4 instrs in 3 blocks, through 14 blocks.
Compact region bundles, v=5, none.
Cost of isolating all blocks = 3.0
$rax	no positive bundles
$rcx	static = 3.0 worse than no bundles
$rdx	static = 3.0 worse than no bundles
$rsi	static = 3.0 worse than no bundles
$rdi	static = 3.0 worse than no bundles
$r8	static = 3.0 worse than no bundles
$r9	static = 3.0 worse than no bundles
$r10	static = 3.0 worse than no bundles
$r11	static = 3.0 worse than no bundles
$rbx	static = 3.0 worse than no bundles
$r14	static = 1.0, v=3, total = 2.0 with bundles EB#8.
$r15	no positive bundles
$r12	static = 4.0 worse than $r14
$r13	no positive bundles
Split for $r14 in 1 bundles, intv 1.
splitAroundRegion with 2 globals.
%bb.0 isolated.
%bb.14 [3520B;3856B), uses 3696r-3808r, reg-out 1, enter after invalid, stack-in, reload after interference.
    selectIntv 1 -> 1
    enterIntvBefore 3696r: valno 0
    useIntv [3688r;3856B): [3688r;3856B):1
%bb.16 [3952B;4288B), uses 4096r-4096r, reg-in 1, leave before invalid, killed in block before interference.
    selectIntv 1 -> 1
    useIntv [3952B;4096r): [3688r;3856B):1 [3952B;4096r):1
%bb.15 [3856B;3952B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [3856B;3952B): [3688r;4096r):1
Direct complement def at 624r
Removing 0 back-copies.
  blit [624r,4096r:0): [624r;3688r)=0(%121):0 [3688r;4096r)=1(%122):0
  rewr %bb.0	624r:0	%121:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
  rewr %bb.14	3808B:1	TEST64rr %122:gr64_nosp, %7:gr64_nosp, implicit-def $eflags
  rewr %bb.14	3808B:1	TEST64rr %122:gr64_nosp, %122:gr64_nosp, implicit-def $eflags
  rewr %bb.16	4096B:1	MOV64mr %77:gr64, 1, $noreg, -24, $noreg, %122:gr64_nosp :: (store (s64) into %ir..repack76)
  rewr %bb.14	3696B:1	%30:gr64 = LEA64r $noreg, 8, %122:gr64_nosp, 0, $noreg
  rewr %bb.14	3688B:0	%122:gr64_nosp = COPY %121:gr64_nosp
Inflated %121 to GR64
queuing new interval: %121 [624r,3688r:0) 0@624r  weight:5.831409e-04
Enqueuing %121
queuing new interval: %122 [3688r,4096r:0) 0@3688r  weight:5.000000e-03
Enqueuing %122

selectOrSplit GR64:%121 [624r,3688r:0) 0@624r  weight:5.831409e-04 w=5.831409e-04
RS_Spill Cascade 0
Inline spilling GR64:%121 [624r,3688r:0) 0@624r  weight:5.831409e-04
From original %7
Merged spilled regs: SS#13 [624r,3688r:0) 0@x  weight:0.000000e+00
spillAroundUses %121
	rewrite: 624r	%123:gr64 = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)

	spill:   632r	MOV64mr %stack.13, 1, $noreg, 0, $noreg, killed %123:gr64 :: (store (s64) into %stack.13)
Checking redundant spills for 0@3688r in %122 [3688r,4096r:0) 0@3688r  weight:5.000000e-03
Merged to stack int: SS#13 [624r,4096r:0) 0@x  weight:0.000000e+00
	folded:   3688r	%122:gr64_nosp = MOV64rm %stack.13, 1, $noreg, 0, $noreg :: (load (s64) from %stack.13)
queuing new interval: %123 [624r,632r:0) 0@624r  weight:INF
Enqueuing %123

selectOrSplit GR64_NOSP:%122 [3688r,4096r:0) 0@3688r  weight:5.000000e-03 w=5.000000e-03
assigning %122 to $r14: R14B [3688r,4096r:0) 0@3688r R14BH [3688r,4096r:0) 0@3688r R14WH [3688r,4096r:0) 0@3688r

selectOrSplit GR64:%123 [624r,632r:0) 0@624r  weight:INF w=INF
assigning %123 to $rax: AH [624r,632r:0) 0@624r AL [624r,632r:0) 0@624r HAX [624r,632r:0) 0@624r

selectOrSplit GR64:%17 [1840r,5312r:0) 0@1840r  weight:1.043388e-03 w=1.043388e-03
hints: $rsi
RS_Split Cascade 3
Analyze counted 4 instrs in 2 blocks, through 11 blocks.
Compact region bundles, v=4, none.
Cost of isolating all blocks = 2.0
$rsi	no positive bundles
$rax	no positive bundles
$rcx	no positive bundles
$rdx	no positive bundles
$rdi	no positive bundles
$r8	no positive bundles
$r9	no positive bundles
$r10	static = 2.0 worse than no bundles
$r11	static = 2.0 worse than no bundles
$rbx	no positive bundles
$r14	static = 2.0 worse than no bundles
$r15	no positive bundles
$r12	no positive bundles
$r13	no positive bundles
    enterIntvBefore 1840r: not live
    leaveIntvAfter 1856r: valno 0
    useIntv [1840B;1856r): [1840B;1856r):1
    enterIntvBefore 4992r: valno 0
    leaveIntvAfter 5312r: not live
    useIntv [4984r;5328B): [1840B;1856r):1 [4984r;5328B):2
Multi-mapped complement 0@1848r for parent 0@1840r hoist to %bb.6 1848r
Removing 0 back-copies.
  blit [1840r,5312r:0): [1840r;1856r)=1(%125):0 [1856r;4984r)=0(%124)(recalc) [4984r;5312r)=2(%126):0
  rewr %bb.6	1840r:1	%125:gr64 = LEA64r %57:gr64, 1, $noreg, -48, $noreg
  rewr %bb.6	1856B:1	$rsp = COPY %125:gr64
  rewr %bb.18	5312B:2	$rsi = COPY %126:gr64
  rewr %bb.18	4992B:2	PUSH64r %126:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 32)
  rewr %bb.6	1848B:1	%124:gr64 = COPY %125:gr64
  rewr %bb.18	4984B:0	%126:gr64 = COPY %124:gr64
queuing new interval: %124 [1848r,4984r:0) 0@1848r  weight:5.712670e-04
Enqueuing %124
queuing new interval: %125 [1840r,1856r:0) 0@1840r  weight:7.283654e-03
Enqueuing %125
queuing new interval: %126 [4984r,5312r:0) 0@4984r  weight:4.162088e-03
Enqueuing %126

selectOrSplit GR64:%126 [4984r,5312r:0) 0@4984r  weight:4.162088e-03 w=4.162088e-03
hints: $rsi
RS_Assign Cascade 0
should evict: %32 [4000r,5712r:0) 0@4000r  weight:1.912879e-03 w= 1.912879e-03
should evict: %32 [4000r,5712r:0) 0@4000r  weight:1.912879e-03 w= 1.912879e-03
should evict: %32 [4000r,5712r:0) 0@4000r  weight:1.912879e-03 w= 1.912879e-03
evicting $r15 interference: Cascade 13
unassigning %32 from $r15: R15B R15BH R15WH
assigning %126 to $r15: R15B [4984r,5312r:0) 0@4984r R15BH [4984r,5312r:0) 0@4984r R15WH [4984r,5312r:0) 0@4984r
queuing new interval: %32 [4000r,5712r:0) 0@4000r  weight:1.912879e-03
Enqueuing %32

selectOrSplit GR64:%32 [4000r,5712r:0) 0@4000r  weight:1.912879e-03 w=1.912879e-03
hints: $rsi
RS_Assign Cascade 13
wait for second round
queuing new interval: %32 [4000r,5712r:0) 0@4000r  weight:1.912879e-03
Enqueuing %32

selectOrSplit GR64:%124 [1848r,4984r:0) 0@1848r  weight:5.712670e-04 w=5.712670e-04
hints: $r15
RS_Spill Cascade 0
Inline spilling GR64:%124 [1848r,4984r:0) 0@1848r  weight:5.712670e-04
From original %17
Merged spilled regs: SS#14 [1848r,4984r:0) 0@x  weight:0.000000e+00
spillAroundUses %124
	folded:   1848r	MOV64mr %stack.14, 1, $noreg, 0, $noreg, %125:gr64 :: (store (s64) into %stack.14)
Checking redundant spills for 0@4984r in %126 [4984r,5312r:0) 0@4984r  weight:4.162088e-03
Merged to stack int: SS#14 [1848r,5312r:0) 0@x  weight:0.000000e+00
	folded:   4984r	%126:gr64 = MOV64rm %stack.14, 1, $noreg, 0, $noreg :: (load (s64) from %stack.14)

selectOrSplit GR64:%125 [1840r,1856r:0) 0@1840r  weight:7.283654e-03 w=7.283654e-03
assigning %125 to $rcx: CH [1840r,1856r:0) 0@1840r CL [1840r,1856r:0) 0@1840r HCX [1840r,1856r:0) 0@1840r

selectOrSplit GR64:%20 [2272r,5392r:0) 0@2272r  weight:1.147727e-03 w=1.147727e-03
hints: $rsi
RS_Split Cascade 4
Analyze counted 4 instrs in 2 blocks, through 9 blocks.
Compact region bundles, v=4, none.
Cost of isolating all blocks = 2.0
$rsi	no positive bundles
$rax	no positive bundles
$rcx	no positive bundles
$rdx	no positive bundles
$rdi	no positive bundles
$r8	no positive bundles
$r9	no positive bundles
$r10	static = 2.0 worse than no bundles
$r11	static = 2.0 worse than no bundles
$rbx	no positive bundles
$r14	static = 2.0 worse than no bundles
$r15	static = 1.0, v=8, total = 3.0 with bundles EB#5.
$r12	no positive bundles
$r13	no positive bundles
    enterIntvBefore 2272r: not live
    leaveIntvAfter 2288r: valno 0
    useIntv [2272B;2288r): [2272B;2288r):1
    enterIntvBefore 4960r: valno 0
    leaveIntvAfter 5392r: not live
    useIntv [4952r;5408B): [2272B;2288r):1 [4952r;5408B):2
Multi-mapped complement 0@2280r for parent 0@2272r hoist to %bb.8 2280r
Removing 0 back-copies.
  blit [2272r,5392r:0): [2272r;2288r)=1(%128):0 [2288r;4952r)=0(%127)(recalc) [4952r;5392r)=2(%129):0
  rewr %bb.8	2272r:1	%128:gr64 = LEA64r %61:gr64, 1, $noreg, -48, $noreg
  rewr %bb.8	2288B:1	$rsp = COPY %128:gr64
  rewr %bb.18	5392B:2	$rsi = COPY %129:gr64
  rewr %bb.18	4960B:2	PUSH64r %129:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 48)
  rewr %bb.8	2280B:1	%127:gr64 = COPY %128:gr64
  rewr %bb.18	4952B:0	%129:gr64 = COPY %127:gr64
queuing new interval: %127 [2280r,4952r:0) 0@2280r  weight:6.575521e-04
Enqueuing %127
queuing new interval: %128 [2272r,2288r:0) 0@2272r  weight:7.283654e-03
Enqueuing %128
queuing new interval: %129 [4952r,5392r:0) 0@4952r  weight:3.607143e-03
Enqueuing %129

selectOrSplit GR64:%129 [4952r,5392r:0) 0@4952r  weight:3.607143e-03 w=3.607143e-03
hints: $rsi
RS_Assign Cascade 0
should evict: %82 [4432r,5808r:0) 0@4432r  weight:2.274775e-03 w= 2.274775e-03
should evict: %82 [4432r,5808r:0) 0@4432r  weight:2.274775e-03 w= 2.274775e-03
should evict: %82 [4432r,5808r:0) 0@4432r  weight:2.274775e-03 w= 2.274775e-03
evicting $r12 interference: Cascade 14
unassigning %82 from $r12: R12B R12BH R12WH
assigning %129 to $r12: R12B [4952r,5392r:0) 0@4952r R12BH [4952r,5392r:0) 0@4952r R12WH [4952r,5392r:0) 0@4952r
queuing new interval: %82 [4432r,5808r:0) 0@4432r  weight:2.274775e-03
Enqueuing %82

selectOrSplit GR64:%82 [4432r,5808r:0) 0@4432r  weight:2.274775e-03 w=2.274775e-03
hints: $rsi
RS_Assign Cascade 14
wait for second round
queuing new interval: %82 [4432r,5808r:0) 0@4432r  weight:2.274775e-03
Enqueuing %82

selectOrSplit GR64:%127 [2280r,4952r:0) 0@2280r  weight:6.575521e-04 w=6.575521e-04
hints: $r12
RS_Spill Cascade 0
Inline spilling GR64:%127 [2280r,4952r:0) 0@2280r  weight:6.575521e-04
From original %20
Merged spilled regs: SS#15 [2280r,4952r:0) 0@x  weight:0.000000e+00
spillAroundUses %127
	folded:   2280r	MOV64mr %stack.15, 1, $noreg, 0, $noreg, %128:gr64 :: (store (s64) into %stack.15)
Checking redundant spills for 0@4952r in %129 [4952r,5392r:0) 0@4952r  weight:3.607143e-03
Merged to stack int: SS#15 [2280r,5392r:0) 0@x  weight:0.000000e+00
	folded:   4952r	%129:gr64 = MOV64rm %stack.15, 1, $noreg, 0, $noreg :: (load (s64) from %stack.15)

selectOrSplit GR64:%128 [2272r,2288r:0) 0@2272r  weight:7.283654e-03 w=7.283654e-03
assigning %128 to $rcx: CH [2272r,2288r:0) 0@2272r CL [2272r,2288r:0) 0@2272r HCX [2272r,2288r:0) 0@2272r

selectOrSplit GR64_NOSP:%6 [608r,3664r:0) 0@608r  weight:1.157407e-03 w=1.157407e-03
RS_Split Cascade 6
Analyze counted 4 instrs in 3 blocks, through 12 blocks.
Compact region bundles, v=5, none.
Cost of isolating all blocks = 3.0
$rax	no positive bundles
$rcx	static = 3.0 worse than no bundles
$rdx	static = 3.0 worse than no bundles
$rsi	static = 3.0 worse than no bundles
$rdi	static = 3.0 worse than no bundles
$r8	static = 3.0 worse than no bundles
$r9	static = 3.0 worse than no bundles
$r10	static = 3.0 worse than no bundles
$r11	static = 3.0 worse than no bundles
$rbx	static = 1.0, v=3, total = 2.0 with bundles EB#7.
$r14	no positive bundles
$r15	static = 4.0 worse than $rbx
$r12	no positive bundles
$r13	no positive bundles
Split for $rbx in 1 bundles, intv 1.
splitAroundRegion with 2 globals.
%bb.0 isolated.
%bb.12 [3088B;3424B), uses 3264r-3376r, reg-out 1, enter after invalid, stack-in, reload after interference.
    selectIntv 1 -> 1
    enterIntvBefore 3264r: valno 0
    useIntv [3256r;3424B): [3256r;3424B):1
%bb.14 [3520B;3856B), uses 3664r-3664r, reg-in 1, leave before 3816r, killed in block before interference.
    selectIntv 1 -> 1
    useIntv [3520B;3664r): [3256r;3424B):1 [3520B;3664r):1
%bb.13 [3424B;3520B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [3424B;3520B): [3256r;3664r):1
Direct complement def at 608r
Removing 0 back-copies.
  blit [608r,3664r:0): [608r;3256r)=0(%130):0 [3256r;3664r)=1(%131):0
  rewr %bb.0	608r:0	%130:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
  rewr %bb.12	3376B:1	TEST64rr %131:gr64_nosp, %6:gr64_nosp, implicit-def $eflags
  rewr %bb.12	3376B:1	TEST64rr %131:gr64_nosp, %131:gr64_nosp, implicit-def $eflags
  rewr %bb.14	3664B:1	MOV64mr %73:gr64, 1, $noreg, -24, $noreg, %131:gr64_nosp :: (store (s64) into %ir..repack67)
  rewr %bb.12	3264B:1	%27:gr64 = LEA64r $noreg, 8, %131:gr64_nosp, 0, $noreg
  rewr %bb.12	3256B:0	%131:gr64_nosp = COPY %130:gr64_nosp
Inflated %130 to GR64
queuing new interval: %130 [608r,3256r:0) 0@608r  weight:6.627297e-04
Enqueuing %130
queuing new interval: %131 [3256r,3664r:0) 0@3256r  weight:5.000000e-03
Enqueuing %131

selectOrSplit GR64:%130 [608r,3256r:0) 0@608r  weight:6.627297e-04 w=6.627297e-04
RS_Spill Cascade 0
Inline spilling GR64:%130 [608r,3256r:0) 0@608r  weight:6.627297e-04
From original %6
Merged spilled regs: SS#16 [608r,3256r:0) 0@x  weight:0.000000e+00
spillAroundUses %130
	rewrite: 608r	%132:gr64 = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)

	spill:   616r	MOV64mr %stack.16, 1, $noreg, 0, $noreg, killed %132:gr64 :: (store (s64) into %stack.16)
Checking redundant spills for 0@3256r in %131 [3256r,3664r:0) 0@3256r  weight:5.000000e-03
Merged to stack int: SS#16 [608r,3664r:0) 0@x  weight:0.000000e+00
	folded:   3256r	%131:gr64_nosp = MOV64rm %stack.16, 1, $noreg, 0, $noreg :: (load (s64) from %stack.16)
queuing new interval: %132 [608r,616r:0) 0@608r  weight:INF
Enqueuing %132

selectOrSplit GR64_NOSP:%131 [3256r,3664r:0) 0@3256r  weight:5.000000e-03 w=5.000000e-03
assigning %131 to $rbx: BH [3256r,3664r:0) 0@3256r BL [3256r,3664r:0) 0@3256r HBX [3256r,3664r:0) 0@3256r

selectOrSplit GR64:%132 [608r,616r:0) 0@608r  weight:INF w=INF
assigning %132 to $rax: AH [608r,616r:0) 0@608r AL [608r,616r:0) 0@608r HAX [608r,616r:0) 0@608r

selectOrSplit GR64:%23 [2704r,5472r:0) 0@2704r  weight:1.275253e-03 w=1.275253e-03
hints: $rsi
RS_Split Cascade 5
Analyze counted 4 instrs in 2 blocks, through 7 blocks.
Compact region bundles, v=4, none.
Cost of isolating all blocks = 2.0
$rsi	no positive bundles
$rax	no positive bundles
$rcx	no positive bundles
$rdx	no positive bundles
$rdi	no positive bundles
$r8	no positive bundles
$r9	no positive bundles
$r10	static = 2.0 worse than no bundles
$r11	static = 2.0 worse than no bundles
$rbx	no positive bundles
$r14	static = 2.0 worse than no bundles
$r15	static = 1.0, v=6 no bundles.
$r12	static = 2.0 worse than no bundles
$r13	no positive bundles
    enterIntvBefore 2704r: not live
    leaveIntvAfter 2720r: valno 0
    useIntv [2704B;2720r): [2704B;2720r):1
    enterIntvBefore 4928r: valno 0
    leaveIntvAfter 5472r: not live
    useIntv [4920r;5488B): [2704B;2720r):1 [4920r;5488B):2
Multi-mapped complement 0@2712r for parent 0@2704r hoist to %bb.10 2712r
Removing 0 back-copies.
  blit [2704r,5472r:0): [2704r;2720r)=1(%134):0 [2720r;4920r)=0(%133)(recalc) [4920r;5472r)=2(%135):0
  rewr %bb.10	2704r:1	%134:gr64 = LEA64r %65:gr64, 1, $noreg, -48, $noreg
  rewr %bb.10	2720B:1	$rsp = COPY %134:gr64
  rewr %bb.18	5472B:2	$rsi = COPY %135:gr64
  rewr %bb.18	4928B:2	PUSH64r %135:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 64)
  rewr %bb.10	2712B:1	%133:gr64 = COPY %134:gr64
  rewr %bb.18	4920B:0	%135:gr64 = COPY %133:gr64
queuing new interval: %133 [2712r,4920r:0) 0@2712r  weight:7.745399e-04
Enqueuing %133
queuing new interval: %134 [2704r,2720r:0) 0@2704r  weight:7.283654e-03
Enqueuing %134
queuing new interval: %135 [4920r,5472r:0) 0@4920r  weight:3.182773e-03
Enqueuing %135

selectOrSplit GR64:%135 [4920r,5472r:0) 0@4920r  weight:3.182773e-03 w=3.182773e-03
hints: $rsi
RS_Assign Cascade 0
wait for second round
queuing new interval: %135 [4920r,5472r:0) 0@4920r  weight:3.182773e-03
Enqueuing %135

selectOrSplit GR64:%133 [2712r,4920r:0) 0@2712r  weight:7.745399e-04 w=7.745399e-04
RS_Spill Cascade 0
Inline spilling GR64:%133 [2712r,4920r:0) 0@2712r  weight:7.745399e-04
From original %23
Merged spilled regs: SS#17 [2712r,4920r:0) 0@x  weight:0.000000e+00
spillAroundUses %133
	folded:   2712r	MOV64mr %stack.17, 1, $noreg, 0, $noreg, %134:gr64 :: (store (s64) into %stack.17)
Checking redundant spills for 0@4920r in %135 [4920r,5472r:0) 0@4920r  weight:3.182773e-03
Merged to stack int: SS#17 [2712r,5472r:0) 0@x  weight:0.000000e+00
	folded:   4920r	%135:gr64 = MOV64rm %stack.17, 1, $noreg, 0, $noreg :: (load (s64) from %stack.17)

selectOrSplit GR64:%134 [2704r,2720r:0) 0@2704r  weight:7.283654e-03 w=7.283654e-03
assigning %134 to $rcx: CH [2704r,2720r:0) 0@2704r CL [2704r,2720r:0) 0@2704r HCX [2704r,2720r:0) 0@2704r

selectOrSplit GR64_NOSP:%5 [592r,3232r:0) 0@592r  weight:1.315790e-03 w=1.315790e-03
RS_Split Cascade 8
Analyze counted 4 instrs in 3 blocks, through 10 blocks.
Compact region bundles, v=5, none.
Cost of isolating all blocks = 3.0
$rax	no positive bundles
$rcx	static = 3.0 worse than no bundles
$rdx	static = 3.0 worse than no bundles
$rsi	static = 3.0 worse than no bundles
$rdi	static = 3.0 worse than no bundles
$r8	static = 3.0 worse than no bundles
$r9	static = 3.0 worse than no bundles
$r10	static = 3.0 worse than no bundles
$r11	static = 3.0 worse than no bundles
$rbx	no positive bundles
$r14	static = 4.0 worse than no bundles
$r15	static = 1.0, v=5, total = 2.0 with bundles EB#5 EB#6.
$r12	no positive bundles
$r13	no positive bundles
Split for $r15 in 2 bundles, intv 1.
splitAroundRegion with 2 globals.
%bb.0 isolated.
%bb.10 [2656B;2992B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [2656B;2992B): [2656B;2992B):1
%bb.12 [3088B;3424B), uses 3232r-3232r, reg-in 1, leave before 3344r, killed in block before interference.
    selectIntv 1 -> 1
    useIntv [3088B;3232r): [2656B;2992B):1 [3088B;3232r):1
%bb.8 [2224B;2560B) intf invalid-invalid, live-through 0 -> 1, reload on exit.
    selectIntv 1 -> 1
    enterIntvAtEnd %bb.8, 2544d: valno 0 [2520r;2560B):1 [2656B;2992B):1 [3088B;3232r):1
%bb.9 [2560B;2656B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [2560B;2656B): [2520r;2992B):1 [3088B;3232r):1
%bb.11 [2992B;3088B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [2992B;3088B): [2520r;3232r):1
Direct complement def at 592r
Removing 0 back-copies.
  blit [592r,3232r:0): [592r;2520r)=0(%136):0 [2520r;3232r)=1(%137):0
  rewr %bb.0	592r:0	%136:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
  rewr %bb.10	2944B:1	TEST64rr %137:gr64_nosp, %5:gr64_nosp, implicit-def $eflags
  rewr %bb.10	2944B:1	TEST64rr %137:gr64_nosp, %137:gr64_nosp, implicit-def $eflags
  rewr %bb.12	3232B:1	MOV64mr %69:gr64, 1, $noreg, -24, $noreg, %137:gr64_nosp :: (store (s64) into %ir..repack58)
  rewr %bb.10	2832B:1	%24:gr64 = LEA64r $noreg, 8, %137:gr64_nosp, 0, $noreg
  rewr %bb.8	2520B:0	%137:gr64_nosp = COPY %136:gr64_nosp
Inflated %136 to GR64
queuing new interval: %136 [592r,2520r:0) 0@592r  weight:8.676976e-04
Enqueuing %136
queuing new interval: %137 [2520r,3232r:0) 0@2520r  weight:3.633094e-03
Enqueuing %137

selectOrSplit GR64:%136 [592r,2520r:0) 0@592r  weight:8.676976e-04 w=8.676976e-04
RS_Spill Cascade 0
Inline spilling GR64:%136 [592r,2520r:0) 0@592r  weight:8.676976e-04
From original %5
Merged spilled regs: SS#18 [592r,2520r:0) 0@x  weight:0.000000e+00
spillAroundUses %136
	rewrite: 592r	%138:gr64 = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)

	spill:   600r	MOV64mr %stack.18, 1, $noreg, 0, $noreg, killed %138:gr64 :: (store (s64) into %stack.18)
Checking redundant spills for 0@2520r in %137 [2520r,3232r:0) 0@2520r  weight:3.633094e-03
Merged to stack int: SS#18 [592r,3232r:0) 0@x  weight:0.000000e+00
	folded:   2520r	%137:gr64_nosp = MOV64rm %stack.18, 1, $noreg, 0, $noreg :: (load (s64) from %stack.18)
queuing new interval: %138 [592r,600r:0) 0@592r  weight:INF
Enqueuing %138

selectOrSplit GR64_NOSP:%137 [2520r,3232r:0) 0@2520r  weight:3.633094e-03 w=3.633094e-03
assigning %137 to $r15: R15B [2520r,3232r:0) 0@2520r R15BH [2520r,3232r:0) 0@2520r R15WH [2520r,3232r:0) 0@2520r

selectOrSplit GR64:%138 [592r,600r:0) 0@592r  weight:INF w=INF
assigning %138 to $rax: AH [592r,600r:0) 0@592r AL [592r,600r:0) 0@592r HAX [592r,600r:0) 0@592r

selectOrSplit GR64:%26 [3136r,5552r:0) 0@3136r  weight:1.434659e-03 w=1.434659e-03
hints: $rsi
RS_Split Cascade 11
Analyze counted 4 instrs in 2 blocks, through 5 blocks.
Compact region bundles, v=4, none.
Cost of isolating all blocks = 2.0
$rsi	no positive bundles
$rax	no positive bundles
$rcx	no positive bundles
$rdx	no positive bundles
$rdi	no positive bundles
$r8	no positive bundles
$r9	no positive bundles
$r10	static = 2.0 worse than no bundles
$r11	static = 2.0 worse than no bundles
$rbx	no positive bundles
$r14	static = 2.0 worse than no bundles
$r15	static = 2.0 worse than no bundles
$r12	static = 2.0 worse than no bundles
$r13	no positive bundles
    enterIntvBefore 3136r: not live
    leaveIntvAfter 3152r: valno 0
    useIntv [3136B;3152r): [3136B;3152r):1
    enterIntvBefore 4896r: valno 0
    leaveIntvAfter 5552r: not live
    useIntv [4888r;5568B): [3136B;3152r):1 [4888r;5568B):2
Multi-mapped complement 0@3144r for parent 0@3136r hoist to %bb.12 3144r
Removing 0 back-copies.
  blit [3136r,5552r:0): [3136r;3152r)=1(%140):0 [3152r;4888r)=0(%139)(recalc) [4888r;5552r)=2(%141):0
  rewr %bb.12	3136r:1	%140:gr64 = LEA64r %69:gr64, 1, $noreg, -48, $noreg
  rewr %bb.12	3152B:1	$rsp = COPY %140:gr64
  rewr %bb.18	5552B:2	$rsi = COPY %141:gr64
  rewr %bb.18	4896B:2	PUSH64r %141:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 80)
  rewr %bb.12	3144B:1	%139:gr64 = COPY %140:gr64
  rewr %bb.18	4888B:0	%141:gr64 = COPY %139:gr64
queuing new interval: %139 [3144r,4888r:0) 0@3144r  weight:9.421642e-04
Enqueuing %139
queuing new interval: %140 [3136r,3152r:0) 0@3136r  weight:7.283654e-03
Enqueuing %140
queuing new interval: %141 [4888r,5552r:0) 0@4888r  weight:2.847744e-03
Enqueuing %141

selectOrSplit GR64:%141 [4888r,5552r:0) 0@4888r  weight:2.847744e-03 w=2.847744e-03
hints: $rsi
RS_Assign Cascade 0
wait for second round
queuing new interval: %141 [4888r,5552r:0) 0@4888r  weight:2.847744e-03
Enqueuing %141

selectOrSplit GR64:%139 [3144r,4888r:0) 0@3144r  weight:9.421642e-04 w=9.421642e-04
RS_Spill Cascade 0
Inline spilling GR64:%139 [3144r,4888r:0) 0@3144r  weight:9.421642e-04
From original %26
Merged spilled regs: SS#19 [3144r,4888r:0) 0@x  weight:0.000000e+00
spillAroundUses %139
	folded:   3144r	MOV64mr %stack.19, 1, $noreg, 0, $noreg, %140:gr64 :: (store (s64) into %stack.19)
Checking redundant spills for 0@4888r in %141 [4888r,5552r:0) 0@4888r  weight:2.847744e-03
Merged to stack int: SS#19 [3144r,5552r:0) 0@x  weight:0.000000e+00
	folded:   4888r	%141:gr64 = MOV64rm %stack.19, 1, $noreg, 0, $noreg :: (load (s64) from %stack.19)

selectOrSplit GR64:%140 [3136r,3152r:0) 0@3136r  weight:7.283654e-03 w=7.283654e-03
assigning %140 to $rcx: CH [3136r,3152r:0) 0@3136r CL [3136r,3152r:0) 0@3136r HCX [3136r,3152r:0) 0@3136r

selectOrSplit GR64_NOSP:%4 [576r,2800r:0) 0@576r  weight:1.524390e-03 w=1.524390e-03
RS_Split Cascade 9
Analyze counted 4 instrs in 3 blocks, through 8 blocks.
Compact region bundles, v=5, none.
Cost of isolating all blocks = 3.0
$rax	no positive bundles
$rcx	no positive bundles
$rdx	static = 3.0 worse than no bundles
$rsi	static = 3.0 worse than no bundles
$rdi	static = 3.0 worse than no bundles
$r8	static = 3.0 worse than no bundles
$r9	static = 3.0 worse than no bundles
$r10	static = 3.0 worse than no bundles
$r11	static = 3.0 worse than no bundles
$rbx	no positive bundles
$r14	static = 3.0 worse than no bundles
$r15	static = 3.0 worse than no bundles
$r12	no positive bundles
$r13	no positive bundles
    enterIntvBefore 2400r: valno 0
    leaveIntvAfter 2512r: valno 0
    useIntv [2392r;2512r): [2392r;2512r):1
Multi-mapped complement 0@2488r for parent 0@576r hoist to %bb.8 2488r
Direct complement def at 576r
Removing 1 back-copies.
Removing 2488r	%142:gr64_nosp = COPY %4:gr64_nosp
  blit [576r,2800r:0): [576r;2392r)=0(%142)(recalc) [2392r;2512r)=1(%143):0 [2512r;2800r)=0(%142)(recalc)
  rewr %bb.0	576r:0	%142:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
  rewr %bb.8	2512B:1	TEST64rr %143:gr64_nosp, %4:gr64_nosp, implicit-def $eflags
  rewr %bb.8	2512B:1	TEST64rr %143:gr64_nosp, %143:gr64_nosp, implicit-def $eflags
  rewr %bb.10	2800B:0	MOV64mr %65:gr64, 1, $noreg, -24, $noreg, %142:gr64_nosp :: (store (s64) into %ir..repack49)
  rewr %bb.8	2400B:1	%21:gr64 = LEA64r $noreg, 8, %143:gr64_nosp, 0, $noreg
  rewr %bb.8	2392B:0	%143:gr64_nosp = COPY %142:gr64_nosp
Inflated %142 to GR64
queuing new interval: %142 [576r,2800r:0) 0@576r  weight:1.154726e-03
Enqueuing %142
queuing new interval: %143 [2392r,2512r:0) 0@2392r  weight:5.826923e-03
Enqueuing %143

selectOrSplit GR64:%142 [576r,2800r:0) 0@576r  weight:1.154726e-03 w=1.154726e-03
RS_Spill Cascade 0
should evict: %115 [1656r,3488r:0) 0@1656r  weight:9.804361e-04 w= 9.804361e-04
Inline spilling GR64:%142 [576r,2800r:0) 0@576r  weight:1.154726e-03
From original %4
Merged spilled regs: SS#20 [576r,2800r:0) 0@x  weight:0.000000e+00
spillAroundUses %142
	rewrite: 576r	%144:gr64 = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)

	spill:   584r	MOV64mr %stack.20, 1, $noreg, 0, $noreg, killed %144:gr64 :: (store (s64) into %stack.20)
	reload:   2792r	%145:gr64 = MOV64rm %stack.20, 1, $noreg, 0, $noreg :: (load (s64) from %stack.20)
	rewrite: 2800r	MOV64mr %65:gr64, 1, $noreg, -24, $noreg, killed %145:gr64 :: (store (s64) into %ir..repack49)

Checking redundant spills for 0@2392r in %143 [2392r,2512r:0) 0@2392r  weight:5.826923e-03
Merged to stack int: SS#20 [576r,2800r:0) 0@x  weight:0.000000e+00
	folded:   2392r	%143:gr64_nosp = MOV64rm %stack.20, 1, $noreg, 0, $noreg :: (load (s64) from %stack.20)
queuing new interval: %144 [576r,584r:0) 0@576r  weight:INF
Enqueuing %144
queuing new interval: %145 [2792r,2800r:0) 0@2792r  weight:INF
Enqueuing %145

selectOrSplit GR64:%144 [576r,584r:0) 0@576r  weight:INF w=INF
assigning %144 to $rax: AH [576r,584r:0) 0@576r AL [576r,584r:0) 0@576r HAX [576r,584r:0) 0@576r

selectOrSplit GR64:%145 [2792r,2800r:0) 0@2792r  weight:INF w=INF
assigning %145 to $rcx: CH [2792r,2800r:0) 0@2792r CL [2792r,2800r:0) 0@2792r HCX [2792r,2800r:0) 0@2792r

selectOrSplit GR64_NOSP:%143 [2392r,2512r:0) 0@2392r  weight:5.826923e-03 w=5.826923e-03
assigning %143 to $r15: R15B [2392r,2512r:0) 0@2392r R15BH [2392r,2512r:0) 0@2392r R15WH [2392r,2512r:0) 0@2392r

selectOrSplit GR64:%29 [3568r,5632r:0) 0@3568r  weight:1.639610e-03 w=1.639610e-03
hints: $rsi
RS_Split Cascade 12
Analyze counted 4 instrs in 2 blocks, through 3 blocks.
Compact region bundles, v=3, none.
Cost of isolating all blocks = 2.0
$rsi	no positive bundles
$rax	no positive bundles
$rcx	no positive bundles
$rdx	no positive bundles
$rdi	no positive bundles
$r8	no positive bundles
$r9	no positive bundles
$r10	static = 2.0 worse than no bundles
$r11	static = 2.0 worse than no bundles
$rbx	no positive bundles
$r14	static = 2.0 worse than no bundles
$r15	static = 2.0 worse than no bundles
$r12	static = 2.0 worse than no bundles
$r13	no positive bundles
    enterIntvBefore 3568r: not live
    leaveIntvAfter 3584r: valno 0
    useIntv [3568B;3584r): [3568B;3584r):1
    enterIntvBefore 4864r: valno 0
    leaveIntvAfter 5632r: not live
    useIntv [4856r;5648B): [3568B;3584r):1 [4856r;5648B):2
Multi-mapped complement 0@3576r for parent 0@3568r hoist to %bb.14 3576r
Removing 0 back-copies.
  blit [3568r,5632r:0): [3568r;3584r)=1(%147):0 [3584r;4856r)=0(%146)(recalc) [4856r;5632r)=2(%148):0
  rewr %bb.14	3568r:1	%147:gr64 = LEA64r %73:gr64, 1, $noreg, -48, $noreg
  rewr %bb.14	3584B:1	$rsp = COPY %147:gr64
  rewr %bb.18	5632B:2	$rsi = COPY %148:gr64
  rewr %bb.18	4864B:2	PUSH64r %148:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 96)
  rewr %bb.14	3576B:1	%146:gr64 = COPY %147:gr64
  rewr %bb.18	4856B:0	%148:gr64 = COPY %146:gr64
queuing new interval: %146 [3576r,4856r:0) 0@3576r  weight:1.202381e-03
Enqueuing %146
queuing new interval: %147 [3568r,3584r:0) 0@3568r  weight:7.283654e-03
Enqueuing %147
queuing new interval: %148 [4856r,5632r:0) 0@4856r  weight:2.576531e-03
Enqueuing %148

selectOrSplit GR64:%148 [4856r,5632r:0) 0@4856r  weight:2.576531e-03 w=2.576531e-03
hints: $rsi
RS_Assign Cascade 0
wait for second round
queuing new interval: %148 [4856r,5632r:0) 0@4856r  weight:2.576531e-03
Enqueuing %148

selectOrSplit GR64:%146 [3576r,4856r:0) 0@3576r  weight:1.202381e-03 w=1.202381e-03
RS_Spill Cascade 0
Inline spilling GR64:%146 [3576r,4856r:0) 0@3576r  weight:1.202381e-03
From original %29
Merged spilled regs: SS#21 [3576r,4856r:0) 0@x  weight:0.000000e+00
spillAroundUses %146
	folded:   3576r	MOV64mr %stack.21, 1, $noreg, 0, $noreg, %147:gr64 :: (store (s64) into %stack.21)
Checking redundant spills for 0@4856r in %148 [4856r,5632r:0) 0@4856r  weight:2.576531e-03
Merged to stack int: SS#21 [3576r,5632r:0) 0@x  weight:0.000000e+00
	folded:   4856r	%148:gr64 = MOV64rm %stack.21, 1, $noreg, 0, $noreg :: (load (s64) from %stack.21)

selectOrSplit GR64:%147 [3568r,3584r:0) 0@3568r  weight:7.283654e-03 w=7.283654e-03
assigning %147 to $rcx: CH [3568r,3584r:0) 0@3568r CL [3568r,3584r:0) 0@3568r HCX [3568r,3584r:0) 0@3568r

selectOrSplit GR64_NOSP:%3 [560r,2368r:0) 0@560r  weight:1.811594e-03 w=1.811594e-03
RS_Split Cascade 10
Analyze counted 4 instrs in 3 blocks, through 6 blocks.
Compact region bundles, v=5, none.
Cost of isolating all blocks = 3.0
$rax	no positive bundles
$rcx	no positive bundles
$rdx	static = 3.0 worse than no bundles
$rsi	static = 3.0 worse than no bundles
$rdi	static = 3.0 worse than no bundles
$r8	static = 3.0 worse than no bundles
$r9	static = 3.0 worse than no bundles
$r10	static = 3.0 worse than no bundles
$r11	static = 3.0 worse than no bundles
$rbx	no positive bundles
$r14	static = 3.0 worse than no bundles
$r15	static = 2.0, v=1, total = 2.0 with bundles EB#4.
$r12	no positive bundles
$r13	no positive bundles
Split for $r15 in 1 bundles, intv 1.
splitAroundRegion with 2 globals.
%bb.0 isolated.
%bb.6 [1792B;2128B), uses 1968r-2080r, reg-out 1, enter after 1936r, stack-in, reload after interference.
    selectIntv 1 -> 1
    enterIntvBefore 1968r: valno 0
    useIntv [1960r;2128B): [1960r;2128B):1
%bb.8 [2224B;2560B), uses 2368r-2368r, reg-in 1, leave before 2392r, killed in block before interference.
    selectIntv 1 -> 1
    useIntv [2224B;2368r): [1960r;2128B):1 [2224B;2368r):1
%bb.7 [2128B;2224B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [2128B;2224B): [1960r;2368r):1
Direct complement def at 560r
Removing 0 back-copies.
  blit [560r,2368r:0): [560r;1960r)=0(%149):0 [1960r;2368r)=1(%150):0
  rewr %bb.0	560r:0	%149:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
  rewr %bb.6	2080B:1	TEST64rr %150:gr64_nosp, %3:gr64_nosp, implicit-def $eflags
  rewr %bb.6	2080B:1	TEST64rr %150:gr64_nosp, %150:gr64_nosp, implicit-def $eflags
  rewr %bb.8	2368B:1	MOV64mr %61:gr64, 1, $noreg, -24, $noreg, %150:gr64_nosp :: (store (s64) into %ir..repack40)
  rewr %bb.6	1968B:1	%18:gr64 = LEA64r $noreg, 8, %150:gr64_nosp, 0, $noreg
  rewr %bb.6	1960B:0	%150:gr64_nosp = COPY %149:gr64_nosp
Inflated %149 to GR64
queuing new interval: %149 [560r,1960r:0) 0@560r  weight:1.122222e-03
Enqueuing %149
queuing new interval: %150 [1960r,2368r:0) 0@1960r  weight:5.000000e-03
Enqueuing %150

selectOrSplit GR64:%149 [560r,1960r:0) 0@560r  weight:1.122222e-03 w=1.122222e-03
RS_Spill Cascade 0
should evict: %115 [1656r,3488r:0) 0@1656r  weight:9.804361e-04 w= 9.804361e-04
Inline spilling GR64:%149 [560r,1960r:0) 0@560r  weight:1.122222e-03
From original %3
Merged spilled regs: SS#22 [560r,1960r:0) 0@x  weight:0.000000e+00
spillAroundUses %149
	rewrite: 560r	%151:gr64 = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)

	spill:   568r	MOV64mr %stack.22, 1, $noreg, 0, $noreg, killed %151:gr64 :: (store (s64) into %stack.22)
Checking redundant spills for 0@1960r in %150 [1960r,2368r:0) 0@1960r  weight:5.000000e-03
Merged to stack int: SS#22 [560r,2368r:0) 0@x  weight:0.000000e+00
	folded:   1960r	%150:gr64_nosp = MOV64rm %stack.22, 1, $noreg, 0, $noreg :: (load (s64) from %stack.22)
queuing new interval: %151 [560r,568r:0) 0@560r  weight:INF
Enqueuing %151

selectOrSplit GR64_NOSP:%150 [1960r,2368r:0) 0@1960r  weight:5.000000e-03 w=5.000000e-03
assigning %150 to $r15: R15B [1960r,2368r:0) 0@1960r R15BH [1960r,2368r:0) 0@1960r R15WH [1960r,2368r:0) 0@1960r

selectOrSplit GR64:%151 [560r,568r:0) 0@560r  weight:INF w=INF
assigning %151 to $rax: AH [560r,568r:0) 0@560r AL [560r,568r:0) 0@560r HAX [560r,568r:0) 0@560r

selectOrSplit GR64:%32 [4000r,5712r:0) 0@4000r  weight:1.912879e-03 w=1.912879e-03
hints: $rsi
RS_Split Cascade 13
Analyze counted 4 instrs in 2 blocks, through 1 blocks.
Compact region bundles, v=1, none.
Cost of isolating all blocks = 2.0
$rsi	no positive bundles
$rax	no positive bundles
$rcx	no positive bundles
$rdx	no positive bundles
$rdi	no positive bundles
$r8	no positive bundles
$r9	no positive bundles
$r10	no positive bundles
$r11	no positive bundles
$rbx	no positive bundles
$r14	no positive bundles
$r15	static = 1.0, v=1, total = 1.0 with bundles EB#9.
$r12	no positive bundles
$r13	no positive bundles
Split for $r15 in 1 bundles, intv 1.
splitAroundRegion with 2 globals.
%bb.16 [3952B;4288B), uses 4000r-4016r, reg-out 1, enter after invalid, defined in block after interference.
    selectIntv 1 -> 1
    useIntv [4000r;4288B): [4000r;4288B):1
%bb.18 [4384B;5872B), uses 4832r-5712r, reg-in 1, leave before 4984r, killed in block, creating local interval 2.
    leaveIntvAfter 5712r: not live
    enterIntvBefore 4984r: valno 0
    useIntv [4980r;5728B): [4000r;4288B):1 [4980r;5728B):2
    selectIntv 2 -> 1
    useIntv [4384B;4980r): [4000r;4288B):1 [4384B;4980r):1 [4980r;5728B):2
%bb.17 [4288B;4384B) intf invalid-invalid, live-through 1 -> 1, straight through.
    selectIntv 1 -> 1
    useIntv [4288B;4384B): [4000r;4980r):1 [4980r;5728B):2
Removing 0 back-copies.
  blit [4000r,5712r:0): [4000r;4980r)=1(%153):0 [4980r;5712r)=2(%154):0
  rewr %bb.16	4000r:1	%153:gr64 = LEA64r %77:gr64, 1, $noreg, -48, $noreg
  rewr %bb.16	4016B:1	$rsp = COPY %153:gr64
  rewr %bb.18	5712B:2	$rsi = COPY %154:gr64
  rewr %bb.18	4832B:1	PUSH64r %153:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 112)
  rewr %bb.18	4980B:1	%154:gr64 = COPY %153:gr64
Main interval covers the same 3 blocks as original.
not queueing unused  %152 EMPTY  weight:INF
queuing new interval: %153 [4000r,4980r:0) 0@4000r  weight:2.927536e-03
Enqueuing %153
queuing new interval: %154 [4980r,5712r:0) 0@4980r  weight:1.784452e-03
Enqueuing %154

selectOrSplit GR64:%154 [4980r,5712r:0) 0@4980r  weight:1.784452e-03 w=1.784452e-03
hints: $rsi
RS_Assign Cascade 0
wait for second round
queuing new interval: %154 [4980r,5712r:0) 0@4980r  weight:1.784452e-03
Enqueuing %154

selectOrSplit GR64:%153 [4000r,4980r:0) 0@4000r  weight:2.927536e-03 w=2.927536e-03
assigning %153 to $r15: R15B [4000r,4980r:0) 0@4000r R15BH [4000r,4980r:0) 0@4000r R15WH [4000r,4980r:0) 0@4000r

selectOrSplit GR64:%82 [4432r,5808r:0) 0@4432r  weight:2.274775e-03 w=2.274775e-03
hints: $rsi
RS_Split Cascade 14
Analyze counted 4 instrs in 1 blocks, through 0 blocks.
tryLocalSplit:  4432r 4448r 4808r 5808r
10 regmasks in block: 5072r:4808r-5808r
$rsi 4432r-4448r I=0.000000e+00 w=6.944444e-03 (best) extend
$rsi 4432r-4808r I=INF shrink
$rsi 4448r-4808r I=INF extend
$rsi 4808r-5808r I=INF end
$rax 4432r-4448r I=1.325758e-02 w=6.944444e-03 extend
$rax 4448r-4808r I=1.325758e-02 w=5.050505e-03 extend
$rax 4808r-5808r I=INF end
$rcx 4432r-4448r I=0.000000e+00 w=6.944444e-03 (best) extend
$rcx 4432r-4808r I=INF shrink
$rcx 4448r-4808r I=INF extend
$rcx 4808r-5808r I=INF end
$rdx 4432r-4448r I=0.000000e+00 w=6.944444e-03 (best) extend
$rdx 4432r-4808r I=INF shrink
$rdx 4448r-4808r I=INF extend
$rdx 4808r-5808r I=INF end
$rdi 4432r-4448r I=0.000000e+00 w=6.944444e-03 (best) extend
$rdi 4432r-4808r I=INF shrink
$rdi 4448r-4808r I=INF extend
$rdi 4808r-5808r I=INF end
$r8 4432r-4448r I=0.000000e+00 w=6.944444e-03 (best) extend
$r8 4432r-4808r I=INF shrink
$r8 4448r-4808r I=INF extend
$r8 4808r-5808r I=INF end
$r9 4432r-4448r I=0.000000e+00 w=6.944444e-03 (best) extend
$r9 4432r-4808r I=INF shrink
$r9 4448r-4808r I=INF extend
$r9 4808r-5808r I=INF end
$r10 4432r-4448r I=0.000000e+00 w=6.944444e-03 (best) extend
$r10 4432r-4808r I=0.000000e+00 w=5.050505e-03 extend
$r10 4432r-5808r I=INF all
$r11 4432r-4448r I=0.000000e+00 w=6.944444e-03 (best) extend
$r11 4432r-4808r I=0.000000e+00 w=5.050505e-03 extend
$r11 4432r-5808r I=INF all
$rbx 4432r-4448r I=3.633094e-03 w=6.944444e-03 extend
$rbx 4432r-4808r I=3.633094e-03 w=5.050505e-03 extend
$rbx 4432r-5808r I=6.011905e-03 all
$r14 4432r-4448r I=0.000000e+00 w=6.944444e-03 (best) extend
$r14 4432r-4808r I=0.000000e+00 w=5.050505e-03 extend
$r14 4432r-5808r I=4.918831e-03 all
$r15 4432r-4448r I=2.927536e-03 w=6.944444e-03 extend
$r15 4432r-4808r I=2.927536e-03 w=5.050505e-03 extend
$r15 4432r-5808r I=4.162088e-03 all
$r12 4432r-4448r I=0.000000e+00 w=6.944444e-03 (best) extend
$r12 4432r-4808r I=0.000000e+00 w=5.050505e-03 extend
$r12 4432r-5808r I=3.607143e-03 all
$r13 4432r-4448r I=5.382752e-03 w=6.944444e-03 extend
$r13 4432r-4808r I=5.382752e-03 w=5.050505e-03 shrink
$r13 4448r-4808r I=5.382752e-03 w=5.050505e-03 extend
$r13 4808r-5808r I=4.464286e-03 w=2.118644e-03 end
Best local split range: 4432r-4448r, 6.805420e-03, 2 instrs
    enterIntvBefore 4432r: not live
    leaveIntvAfter 4448r: valno 0
    useIntv [4432B;4456r): [4432B;4456r):1
  blit [4432r,5808r:0): [4432r;4456r)=1(%156):0 [4456r;5808r)=0(%155):0
  rewr %bb.18	4432r:1	%156:gr64 = LEA64r %81:gr64, 1, $noreg, -48, $noreg
  rewr %bb.18	4448B:1	$rsp = COPY %156:gr64
  rewr %bb.18	5808B:0	$rsi = COPY %155:gr64
  rewr %bb.18	4808B:0	PUSH64r %155:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 128)
  rewr %bb.18	4456B:1	%155:gr64 = COPY %156:gr64
queuing new interval: %155 [4456r,5808r:0) 0@4456r  weight:1.729452e-03
Enqueuing %155
queuing new interval: %156 [4432r,4456r:0) 0@4432r  weight:7.146226e-03
Enqueuing %156

selectOrSplit GR64:%155 [4456r,5808r:0) 0@4456r  weight:1.729452e-03 w=1.729452e-03
hints: $rsi
RS_Assign Cascade 0
wait for second round
queuing new interval: %155 [4456r,5808r:0) 0@4456r  weight:1.729452e-03
Enqueuing %155

selectOrSplit GR64:%156 [4432r,4456r:0) 0@4432r  weight:7.146226e-03 w=7.146226e-03
assigning %156 to $rcx: CH [4432r,4456r:0) 0@4432r CL [4432r,4456r:0) 0@4432r HCX [4432r,4456r:0) 0@4432r

selectOrSplit GR64:%155 [4456r,5808r:0) 0@4456r  weight:1.729452e-03 w=1.729452e-03
hints: $rsi $rcx
RS_Split Cascade 0
Analyze counted 3 instrs in 1 blocks, through 0 blocks.
tryLocalSplit:  4456r 4808r 5808r
10 regmasks in block: 5072r:4808r-5808r
$rsi 4456r-4808r I=INF extend
$rsi 4808r-5808r I=INF end
$rcx 4456r-4808r I=INF extend
$rcx 4808r-5808r I=INF end
$rax 4456r-4808r I=1.325758e-02 w=3.906250e-03 extend
$rax 4808r-5808r I=INF end
$rdx 4456r-4808r I=INF extend
$rdx 4808r-5808r I=INF end
$rdi 4456r-4808r I=INF extend
$rdi 4808r-5808r I=INF end
$r8 4456r-4808r I=INF extend
$r8 4808r-5808r I=INF end
$r9 4456r-4808r I=INF extend
$r9 4808r-5808r I=INF end
$r10 4456r-4808r I=0.000000e+00 w=3.906250e-03 (best) extend
$r10 4456r-5808r I=INF all
$r11 4456r-4808r I=0.000000e+00 w=3.906250e-03 (best) extend
$r11 4456r-5808r I=INF all
$rbx 4456r-4808r I=3.633094e-03 w=3.906250e-03 extend
$rbx 4456r-5808r I=6.011905e-03 all
$r14 4456r-4808r I=0.000000e+00 w=3.906250e-03 (best) extend
$r14 4456r-5808r I=4.918831e-03 all
$r15 4456r-4808r I=2.927536e-03 w=3.906250e-03 extend
$r15 4456r-5808r I=4.162088e-03 all
$r12 4456r-4808r I=0.000000e+00 w=3.906250e-03 (best) extend
$r12 4456r-5808r I=3.607143e-03 all
$r13 4456r-4808r I=5.382752e-03 w=3.906250e-03 extend
$r13 4808r-5808r I=4.464286e-03 w=2.118644e-03 end
Best local split range: 4456r-4808r, 3.828049e-03, 2 instrs
    enterIntvBefore 4456r: not live
    leaveIntvAfter 4808r: valno 0
    useIntv [4456B;4812r): [4456B;4812r):1
  blit [4456r,5808r:0): [4456r;4812r)=1(%158):0 [4812r;5808r)=0(%157):0
  rewr %bb.18	4456r:1	%158:gr64 = COPY %156:gr64
  rewr %bb.18	5808B:0	$rsi = COPY %157:gr64
  rewr %bb.18	4808B:1	PUSH64r %158:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 128)
  rewr %bb.18	4812B:1	%157:gr64 = COPY %158:gr64
Tagging non-progress ranges: %158
queuing new interval: %157 [4812r,5808r:0) 0@4812r  weight:1.446991e-03
Enqueuing %157
queuing new interval: %158 [4456r,4812r:0) 0@4456r  weight:4.007936e-03
Enqueuing %158

selectOrSplit GR64:%157 [4812r,5808r:0) 0@4812r  weight:1.446991e-03 w=1.446991e-03
hints: $rsi
RS_Assign Cascade 0
wait for second round
queuing new interval: %157 [4812r,5808r:0) 0@4812r  weight:1.446991e-03
Enqueuing %157

selectOrSplit GR64:%158 [4456r,4812r:0) 0@4456r  weight:4.007936e-03 w=4.007936e-03
hints: $rcx
assigning %158 to $r10: R10B [4456r,4812r:0) 0@4456r R10BH [4456r,4812r:0) 0@4456r R10WH [4456r,4812r:0) 0@4456r

selectOrSplit GR64:%157 [4812r,5808r:0) 0@4812r  weight:1.446991e-03 w=1.446991e-03
hints: $rsi $r10
RS_Split Cascade 0
Analyze counted 2 instrs in 1 blocks, through 0 blocks.
Inline spilling GR64:%157 [4812r,5808r:0) 0@4812r  weight:1.446991e-03
From original %82
Merged spilled regs: SS#23 [4812r,5808r:0) 0@x  weight:0.000000e+00
spillAroundUses %157
	merged orig valno 0: SS#23 [4432r,5808r:0) 0@x  weight:0.000000e+00
Checking redundant spills for 0@4456r in %158 [4456r,4812r:0) 0@4456r  weight:4.007936e-03
Merged to stack int: SS#23 [4432r,5808r:0) 0@x  weight:0.000000e+00
Checking redundant spills for 0@4812r in %157 [4812r,5808r:0) 0@4812r  weight:1.446991e-03
	hoisted: 4456r	MOV64mr %stack.23, 1, $noreg, 0, $noreg, %158:gr64 :: (store (s64) into %stack.23)
	folded:   5808r	$rsi = MOV64rm %stack.23, 1, $noreg, 0, $noreg :: (load (s64) from %stack.23)
Eliminating 1 dead defs
Deleting dead def 4812r	dead %157:gr64 = COPY %158:gr64
unassigning %158 from $r10: R10B R10BH R10WH
Enqueuing %158
Shrink: %158 [4456r,4812r:0) 0@4456r  weight:4.007936e-03
Shrunk: %158 [4456r,4808r:0) 0@4456r  weight:4.007936e-03

selectOrSplit GR64:%158 [4456r,4808r:0) 0@4456r  weight:4.007936e-03 w=4.007936e-03
hints: $rcx
assigning %158 to $r10: R10B [4456r,4808r:0) 0@4456r R10BH [4456r,4808r:0) 0@4456r R10WH [4456r,4808r:0) 0@4456r

selectOrSplit GR64:%148 [4856r,5632r:0) 0@4856r  weight:2.576531e-03 w=2.576531e-03
hints: $rsi
RS_Split Cascade 0
Analyze counted 3 instrs in 1 blocks, through 0 blocks.
tryLocalSplit:  4856r 4864r 5632r
10 regmasks in block: 5072r:4864r-5632r
$rsi 4856r-4864r I=INF extend
$rsi 4864r-5632r I=INF end
$rax 4856r-4864r I=1.116071e-03 w=7.075472e-03 (best) extend
$rax 4856r-5632r I=INF all
$rcx 4856r-4864r I=INF extend
$rcx 4864r-5632r I=INF end
$rdx 4856r-4864r I=INF extend
$rdx 4864r-5632r I=INF end
$rdi 4856r-4864r I=INF extend
$rdi 4864r-5632r I=INF end
$r8 4856r-4864r I=INF extend
$r8 4864r-5632r I=INF end
$r9 4856r-4864r I=INF extend
$r9 4864r-5632r I=INF end
$r10 4856r-4864r I=0.000000e+00 w=7.075472e-03 (best) extend
$r10 4856r-5632r I=INF all
$r11 4856r-4864r I=0.000000e+00 w=7.075472e-03 (best) extend
$r11 4856r-5632r I=INF all
$rbx 4856r-4864r I=0.000000e+00 w=7.075472e-03 (best) extend
$rbx 4856r-5632r I=6.011905e-03 all
$r14 4856r-4864r I=0.000000e+00 w=7.075472e-03 (best) extend
$r14 4856r-5632r I=4.918831e-03 all
$r15 4856r-4864r I=2.927536e-03 w=7.075472e-03 extend
$r15 4856r-5632r I=4.162088e-03 all
$r12 4856r-4864r I=0.000000e+00 w=7.075472e-03 (best) extend
$r12 4856r-5632r I=3.607143e-03 all
$r13 4856r-4864r I=0.000000e+00 w=7.075472e-03 (best) extend
$r13 4856r-5632r I=4.464286e-03 all
Best local split range: 4856r-4864r, 6.933824e-03, 2 instrs
    enterIntvBefore 4856r: not live
    leaveIntvAfter 4864r: valno 0
    useIntv [4856B;4872r): [4856B;4872r):1
  blit [4856r,5632r:0): [4856r;4872r)=1(%160):0 [4872r;5632r)=0(%159):0
  rewr %bb.18	4856r:1	%160:gr64 = MOV64rm %stack.21, 1, $noreg, 0, $noreg :: (load (s64) from %stack.21)
  rewr %bb.18	5632B:0	$rsi = COPY %159:gr64
  rewr %bb.18	4864B:1	PUSH64r %160:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 96)
  rewr %bb.18	4872B:1	%159:gr64 = COPY %160:gr64
Tagging non-progress ranges: %160
queuing new interval: %159 [4872r,5632r:0) 0@4872r  weight:1.741379e-03
Enqueuing %159
queuing new interval: %160 [4856r,4872r:0) 0@4856r  weight:7.283654e-03
Enqueuing %160

selectOrSplit GR64:%159 [4872r,5632r:0) 0@4872r  weight:1.741379e-03 w=1.741379e-03
hints: $rsi
RS_Assign Cascade 0
wait for second round
queuing new interval: %159 [4872r,5632r:0) 0@4872r  weight:1.741379e-03
Enqueuing %159

selectOrSplit GR64:%160 [4856r,4872r:0) 0@4856r  weight:7.283654e-03 w=7.283654e-03
assigning %160 to $r10: R10B [4856r,4872r:0) 0@4856r R10BH [4856r,4872r:0) 0@4856r R10WH [4856r,4872r:0) 0@4856r

selectOrSplit GR64:%159 [4872r,5632r:0) 0@4872r  weight:1.741379e-03 w=1.741379e-03
hints: $rsi $r10
RS_Split Cascade 0
Analyze counted 2 instrs in 1 blocks, through 0 blocks.
Inline spilling GR64:%159 [4872r,5632r:0) 0@4872r  weight:1.741379e-03
From original %29
	also spill snippet %160 [4856r,4872r:0) 0@4856r  weight:7.283654e-03
Merged spilled regs: SS#21 [3576r,5632r:0) 0@x  weight:0.000000e+00
spillAroundUses %159
	folded:   5632r	$rsi = MOV64rm %stack.21, 1, $noreg, 0, $noreg :: (load (s64) from %stack.21)
spillAroundUses %160
Coalescing stack access: %160:gr64 = MOV64rm %stack.21, 1, $noreg, 0, $noreg :: (load (s64) from %stack.21)
	folded:   4864r	PUSH64rmm %stack.21, 1, $noreg, 0, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 96), (load (s64) from %stack.21)
unassigning %160 from $r10: R10B R10BH R10WH

selectOrSplit GR64:%154 [4980r,5712r:0) 0@4980r  weight:1.784452e-03 w=1.784452e-03
hints: $rsi $r15
RS_Split Cascade 0
Analyze counted 2 instrs in 1 blocks, through 0 blocks.
Inline spilling GR64:%154 [4980r,5712r:0) 0@4980r  weight:1.784452e-03
From original %32
Merged spilled regs: SS#24 [4980r,5712r:0) 0@x  weight:0.000000e+00
spillAroundUses %154
	folded:   4980r	MOV64mr %stack.24, 1, $noreg, 0, $noreg, %153:gr64 :: (store (s64) into %stack.24)
	folded:   5712r	$rsi = MOV64rm %stack.24, 1, $noreg, 0, $noreg :: (load (s64) from %stack.24)

selectOrSplit GR64:%106 [32r,704r:0) 0@32r  weight:1.884328e-03 w=1.884328e-03
RS_Split Cascade 0
Analyze counted 3 instrs in 1 blocks, through 0 blocks.
tryLocalSplit:  32r 80r 704r
3 regmasks in block: 80r:32r-80r 80r:80r-704r
$rax 32r-80r I=INF extend
$rax 80r-704r I=INF end
$rcx 32r-80r I=INF extend
$rcx 80r-704r I=INF end
$rdx 32r-80r I=INF extend
$rdx 80r-704r I=INF end
$rsi 32r-80r I=INF extend
$rsi 80r-704r I=INF end
$rdi 32r-80r I=INF extend
$rdi 80r-704r I=INF end
$r8 32r-80r I=INF extend
$r8 80r-704r I=INF end
$r9 32r-80r I=INF extend
$r9 80r-704r I=INF end
$r10 32r-80r I=INF extend
$r10 80r-704r I=INF end
$r11 32r-80r I=INF extend
$r11 80r-704r I=INF end
$rbx 32r-80r I=0.000000e+00 w=6.465517e-03 (best) extend
$rbx 32r-704r I=1.306034e-02 all
$r14 32r-80r I=0.000000e+00 w=6.465517e-03 (best) extend
$r14 32r-704r I=4.316240e-03 all
$r15 32r-80r I=0.000000e+00 w=6.465517e-03 (best) extend
$r15 32r-704r I=2.232143e-03 all
$r12 32r-80r I=0.000000e+00 w=6.465517e-03 (best) extend
$r12 32r-704r I=2.906977e-03 all
$r13 32r-80r I=0.000000e+00 w=6.465517e-03 (best) extend
$r13 32r-704r I=4.166667e-03 all
Best local split range: 32r-80r, 6.336081e-03, 2 instrs
    enterIntvBefore 32r: not live
    leaveIntvAfter 80r: valno 0
    useIntv [32B;88r): [32B;88r):1
  blit [32r,704r:0): [32r;88r)=1(%162):0 [88r;704r)=0(%161):0
  rewr %bb.0	32r:1	%162:gr64 = MOV64ri @malloc
  rewr %bb.0	80B:1	CALL64r %162:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  rewr %bb.0	704B:0	CALL64r %161:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  rewr %bb.0	88B:1	%161:gr64 = COPY %162:gr64
Tagging non-progress ranges: %162
queuing new interval: %161 [88r,704r:0) 0@88r  weight:9.940945e-04
Enqueuing %161
queuing new interval: %162 [32r,88r:0) 0@32r  weight:3.322368e-03
Enqueuing %162

selectOrSplit GR64:%161 [88r,704r:0) 0@88r  weight:9.940945e-04 w=9.940945e-04
RS_Assign Cascade 0
wait for second round
queuing new interval: %161 [88r,704r:0) 0@88r  weight:9.940945e-04
Enqueuing %161

selectOrSplit GR64:%162 [32r,88r:0) 0@32r  weight:3.322368e-03 w=3.322368e-03
assigning %162 to $rbx: BH [32r,88r:0) 0@32r BL [32r,88r:0) 0@32r HBX [32r,88r:0) 0@32r

selectOrSplit GR64:%141 [4888r,5552r:0) 0@4888r  weight:2.847744e-03 w=2.847744e-03
hints: $rsi
RS_Split Cascade 0
Analyze counted 3 instrs in 1 blocks, through 0 blocks.
tryLocalSplit:  4888r 4896r 5552r
10 regmasks in block: 5072r:4896r-5552r
$rsi 4888r-4896r I=INF extend
$rsi 4896r-5552r I=INF end
$rax 4888r-4896r I=1.116071e-03 w=7.075472e-03 (best) extend
$rax 4888r-5552r I=INF all
$rcx 4888r-4896r I=INF extend
$rcx 4896r-5552r I=INF end
$rdx 4888r-4896r I=INF extend
$rdx 4896r-5552r I=INF end
$rdi 4888r-4896r I=INF extend
$rdi 4896r-5552r I=INF end
$r8 4888r-4896r I=INF extend
$r8 4896r-5552r I=INF end
$r9 4888r-4896r I=INF extend
$r9 4896r-5552r I=INF end
$r10 4888r-4896r I=0.000000e+00 w=7.075472e-03 (best) extend
$r10 4888r-5552r I=INF all
$r11 4888r-4896r I=0.000000e+00 w=7.075472e-03 (best) extend
$r11 4888r-5552r I=INF all
$rbx 4888r-4896r I=0.000000e+00 w=7.075472e-03 (best) extend
$rbx 4888r-5552r I=6.011905e-03 all
$r14 4888r-4896r I=0.000000e+00 w=7.075472e-03 (best) extend
$r14 4888r-5552r I=4.918831e-03 all
$r15 4888r-4896r I=2.927536e-03 w=7.075472e-03 extend
$r15 4888r-5552r I=4.162088e-03 all
$r12 4888r-4896r I=0.000000e+00 w=7.075472e-03 (best) extend
$r12 4888r-5552r I=3.607143e-03 all
$r13 4888r-4896r I=0.000000e+00 w=7.075472e-03 (best) extend
$r13 4888r-5552r I=4.464286e-03 all
Best local split range: 4888r-4896r, 6.933824e-03, 2 instrs
    enterIntvBefore 4888r: not live
    leaveIntvAfter 4896r: valno 0
    useIntv [4888B;4904r): [4888B;4904r):1
  blit [4888r,5552r:0): [4888r;4904r)=1(%164):0 [4904r;5552r)=0(%163):0
  rewr %bb.18	4888r:1	%164:gr64 = MOV64rm %stack.19, 1, $noreg, 0, $noreg :: (load (s64) from %stack.19)
  rewr %bb.18	5552B:0	$rsi = COPY %163:gr64
  rewr %bb.18	4896B:1	PUSH64r %164:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 80)
  rewr %bb.18	4904B:1	%163:gr64 = COPY %164:gr64
Tagging non-progress ranges: %164
queuing new interval: %163 [4904r,5552r:0) 0@4904r  weight:1.927481e-03
Enqueuing %163
queuing new interval: %164 [4888r,4904r:0) 0@4888r  weight:7.283654e-03
Enqueuing %164

selectOrSplit GR64:%163 [4904r,5552r:0) 0@4904r  weight:1.927481e-03 w=1.927481e-03
hints: $rsi
RS_Assign Cascade 0
wait for second round
queuing new interval: %163 [4904r,5552r:0) 0@4904r  weight:1.927481e-03
Enqueuing %163

selectOrSplit GR64:%164 [4888r,4904r:0) 0@4888r  weight:7.283654e-03 w=7.283654e-03
assigning %164 to $r10: R10B [4888r,4904r:0) 0@4888r R10BH [4888r,4904r:0) 0@4888r R10WH [4888r,4904r:0) 0@4888r

selectOrSplit GR64:%163 [4904r,5552r:0) 0@4904r  weight:1.927481e-03 w=1.927481e-03
hints: $rsi $r10
RS_Split Cascade 0
Analyze counted 2 instrs in 1 blocks, through 0 blocks.
Inline spilling GR64:%163 [4904r,5552r:0) 0@4904r  weight:1.927481e-03
From original %26
	also spill snippet %164 [4888r,4904r:0) 0@4888r  weight:7.283654e-03
Merged spilled regs: SS#19 [3144r,5552r:0) 0@x  weight:0.000000e+00
spillAroundUses %163
	folded:   5552r	$rsi = MOV64rm %stack.19, 1, $noreg, 0, $noreg :: (load (s64) from %stack.19)
spillAroundUses %164
Coalescing stack access: %164:gr64 = MOV64rm %stack.19, 1, $noreg, 0, $noreg :: (load (s64) from %stack.19)
	folded:   4896r	PUSH64rmm %stack.19, 1, $noreg, 0, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 80), (load (s64) from %stack.19)
unassigning %164 from $r10: R10B R10BH R10WH

selectOrSplit GR64:%161 [88r,704r:0) 0@88r  weight:9.940945e-04 w=9.940945e-04
hints: $rbx
RS_Split Cascade 0
Analyze counted 2 instrs in 1 blocks, through 0 blocks.
Inline spilling GR64:%161 [88r,704r:0) 0@88r  weight:9.940945e-04
From original %35
	remat:  692r	%165:gr64 = MOV64ri @malloc
	        704e	CALL64r killed %165:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax

All defs dead: dead %161:gr64 = COPY %162:gr64
Remat created 1 dead defs.
Deleting dead def 88r	dead %161:gr64 = COPY %162:gr64
unassigning %162 from $rbx: BH BL HBX
Enqueuing %162
Shrink: %162 [32r,88r:0) 0@32r  weight:3.322368e-03
Shrunk: %162 [32r,80r:0) 0@32r  weight:3.322368e-03
0 registers to spill after remat.
queuing new interval: %165 [692r,704r:0) 0@692r  weight:INF
Enqueuing %165

selectOrSplit GR64:%162 [32r,80r:0) 0@32r  weight:3.322368e-03 w=3.322368e-03
assigning %162 to $rax: AH [32r,80r:0) 0@32r AL [32r,80r:0) 0@32r HAX [32r,80r:0) 0@32r

selectOrSplit GR64:%165 [692r,704r:0) 0@692r  weight:INF w=INF
assigning %165 to $rax: AH [692r,704r:0) 0@692r AL [692r,704r:0) 0@692r HAX [692r,704r:0) 0@692r

selectOrSplit GR64:%135 [4920r,5472r:0) 0@4920r  weight:3.182773e-03 w=3.182773e-03
hints: $rsi
RS_Split Cascade 0
Analyze counted 3 instrs in 1 blocks, through 0 blocks.
tryLocalSplit:  4920r 4928r 5472r
10 regmasks in block: 5072r:4928r-5472r
$rsi 4920r-4928r I=INF extend
$rsi 4928r-5472r I=INF end
$rax 4920r-4928r I=1.116071e-03 w=7.075472e-03 (best) extend
$rax 4920r-5472r I=INF all
$rcx 4920r-4928r I=INF extend
$rcx 4928r-5472r I=INF end
$rdx 4920r-4928r I=INF extend
$rdx 4928r-5472r I=INF end
$rdi 4920r-4928r I=INF extend
$rdi 4928r-5472r I=INF end
$r8 4920r-4928r I=INF extend
$r8 4928r-5472r I=INF end
$r9 4920r-4928r I=INF extend
$r9 4928r-5472r I=INF end
$r10 4920r-4928r I=0.000000e+00 w=7.075472e-03 (best) extend
$r10 4920r-5472r I=INF all
$r11 4920r-4928r I=0.000000e+00 w=7.075472e-03 (best) extend
$r11 4920r-5472r I=INF all
$rbx 4920r-4928r I=0.000000e+00 w=7.075472e-03 (best) extend
$rbx 4920r-5472r I=6.011905e-03 all
$r14 4920r-4928r I=0.000000e+00 w=7.075472e-03 (best) extend
$r14 4920r-5472r I=4.918831e-03 all
$r15 4920r-4928r I=2.927536e-03 w=7.075472e-03 extend
$r15 4920r-5472r I=4.162088e-03 all
$r12 4920r-4928r I=0.000000e+00 w=7.075472e-03 (best) extend
$r12 4920r-5472r I=3.607143e-03 all
$r13 4920r-4928r I=0.000000e+00 w=7.075472e-03 (best) extend
$r13 4920r-5472r I=4.464286e-03 all
Best local split range: 4920r-4928r, 6.933824e-03, 2 instrs
    enterIntvBefore 4920r: not live
    leaveIntvAfter 4928r: valno 0
    useIntv [4920B;4936r): [4920B;4936r):1
  blit [4920r,5472r:0): [4920r;4936r)=1(%167):0 [4936r;5472r)=0(%166):0
  rewr %bb.18	4920r:1	%167:gr64 = MOV64rm %stack.17, 1, $noreg, 0, $noreg :: (load (s64) from %stack.17)
  rewr %bb.18	5472B:0	$rsi = COPY %166:gr64
  rewr %bb.18	4928B:1	PUSH64r %167:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 64)
  rewr %bb.18	4936B:1	%166:gr64 = COPY %167:gr64
Tagging non-progress ranges: %167
queuing new interval: %166 [4936r,5472r:0) 0@4936r  weight:2.158120e-03
Enqueuing %166
queuing new interval: %167 [4920r,4936r:0) 0@4920r  weight:7.283654e-03
Enqueuing %167

selectOrSplit GR64:%166 [4936r,5472r:0) 0@4936r  weight:2.158120e-03 w=2.158120e-03
hints: $rsi
RS_Assign Cascade 0
wait for second round
queuing new interval: %166 [4936r,5472r:0) 0@4936r  weight:2.158120e-03
Enqueuing %166

selectOrSplit GR64:%167 [4920r,4936r:0) 0@4920r  weight:7.283654e-03 w=7.283654e-03
assigning %167 to $r10: R10B [4920r,4936r:0) 0@4920r R10BH [4920r,4936r:0) 0@4920r R10WH [4920r,4936r:0) 0@4920r

selectOrSplit GR64:%166 [4936r,5472r:0) 0@4936r  weight:2.158120e-03 w=2.158120e-03
hints: $rsi $r10
RS_Split Cascade 0
Analyze counted 2 instrs in 1 blocks, through 0 blocks.
Inline spilling GR64:%166 [4936r,5472r:0) 0@4936r  weight:2.158120e-03
From original %23
	also spill snippet %167 [4920r,4936r:0) 0@4920r  weight:7.283654e-03
Merged spilled regs: SS#17 [2712r,5472r:0) 0@x  weight:0.000000e+00
spillAroundUses %166
	folded:   5472r	$rsi = MOV64rm %stack.17, 1, $noreg, 0, $noreg :: (load (s64) from %stack.17)
spillAroundUses %167
Coalescing stack access: %167:gr64 = MOV64rm %stack.17, 1, $noreg, 0, $noreg :: (load (s64) from %stack.17)
	folded:   4928r	PUSH64rmm %stack.17, 1, $noreg, 0, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 64), (load (s64) from %stack.17)
unassigning %167 from $r10: R10B R10BH R10WH
Trying to reconcile hints for: %37($rbx)
%37($rbx) is recolorable.
Trying to reconcile hints for: %10($rbx)
%10($rbx) is recolorable.
Trying to reconcile hints for: %13($rbx)
%13($rbx) is recolorable.
Trying to reconcile hints for: %16($rbx)
%16($rbx) is recolorable.
Trying to reconcile hints for: %19($rbx)
%19($rbx) is recolorable.
Trying to reconcile hints for: %22($rbx)
%22($rbx) is recolorable.
Trying to reconcile hints for: %25($r14)
%25($r14) is recolorable.
Trying to reconcile hints for: %28($r15)
%28($r15) is recolorable.
Trying to reconcile hints for: %31($r12)
%31($r12) is recolorable.
Trying to reconcile hints for: %34($r13)
%34($r13) is recolorable.
Trying to reconcile hints for: %9($r14)
%9($r14) is recolorable.
Trying to reconcile hints for: %12($r14)
%12($r14) is recolorable.
Trying to reconcile hints for: %15($r14)
%15($r14) is recolorable.
Trying to reconcile hints for: %18($r14)
%18($r14) is recolorable.
Trying to reconcile hints for: %21($r14)
%21($r14) is recolorable.
Trying to reconcile hints for: %24($rbx)
%24($rbx) is recolorable.
Trying to reconcile hints for: %27($r14)
%27($r14) is recolorable.
Trying to reconcile hints for: %30($r15)
%30($r15) is recolorable.
Trying to reconcile hints for: %33($r12)
%33($r12) is recolorable.
Trying to reconcile hints for: %103($rbx)
%103($rbx) is recolorable.
Trying to reconcile hints for: %113($r14)
%113($r14) is recolorable.
Trying to reconcile hints for: %126($r15)
%126($r15) is recolorable.
Trying to reconcile hints for: %129($r12)
%129($r12) is recolorable.

For Slot10 and VN0:
Equal spills in BB: 2 
Orders size is 1
BB2,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot11 and VN0:
Equal spills in BB: 0 
Orders size is 1
BB0,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot12 and VN0:
Equal spills in BB: 4 
Orders size is 1
BB4,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot13 and VN0:
Equal spills in BB: 0 
Orders size is 1
BB0,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot14 and VN0:
Equal spills in BB: 6 
Orders size is 1
BB6,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot15 and VN0:
Equal spills in BB: 8 
Orders size is 1
BB8,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot16 and VN0:
Equal spills in BB: 0 
Orders size is 1
BB0,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot17 and VN0:
Equal spills in BB: 10 
Orders size is 1
BB10,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot18 and VN0:
Equal spills in BB: 0 
Orders size is 1
BB0,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot19 and VN0:
Equal spills in BB: 12 
Orders size is 1
BB12,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot20 and VN0:
Equal spills in BB: 0 
Orders size is 1
BB0,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot21 and VN0:
Equal spills in BB: 14 
Orders size is 1
BB14,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot22 and VN0:
Equal spills in BB: 0 
Orders size is 1
BB0,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot23 and VN0:
Equal spills in BB: 18 
Orders size is 1
BB18,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot24 and VN0:
Equal spills in BB: 18 
Orders size is 2
BB18,BB16,
Finally inserted spills in BB: 
Finally removed spills in BB: 
********** REWRITE VIRTUAL REGISTERS **********
********** Function: main
********** REGISTER MAP **********
[%0 -> $r13] GR64_NOSP
[%1 -> $r12] GR64_NOSP
[%2 -> $r15] GR64_NOSP
[%9 -> $r14] GR64
[%10 -> $rbx] GR64
[%12 -> $r14] GR64
[%13 -> $rbx] GR64
[%15 -> $r14] GR64
[%16 -> $rbx] GR64
[%18 -> $r14] GR64
[%19 -> $rbx] GR64
[%21 -> $r14] GR64
[%22 -> $rbx] GR64
[%24 -> $rbx] GR64
[%25 -> $r14] GR64
[%27 -> $r14] GR64
[%28 -> $r15] GR64
[%30 -> $r15] GR64
[%31 -> $r12] GR64
[%33 -> $r12] GR64
[%34 -> $r13] GR64
[%37 -> $rbx] GR64
[%39 -> $rax] GR64
[%40 -> $r10] GR64
[%49 -> $rax] GR64
[%53 -> $rax] GR64
[%57 -> $rax] GR64
[%61 -> $rax] GR64
[%65 -> $rax] GR64
[%69 -> $rax] GR64
[%73 -> $rax] GR64
[%77 -> $rax] GR64
[%81 -> $rax] GR64
[%84 -> $rax] GR64
[%91 -> $r13] GR64
[%92 -> $rax] GR64
[%102 -> $rcx] GR64
[%103 -> $rbx] GR64
[%105 -> $r13] GR64
[%107 -> $r13] GR64
[%109 -> $rbx] GR64_NOSP
[%110 -> $rax] GR64
[%112 -> $rcx] GR64
[%113 -> $r14] GR64
[%115 -> $r12] GR64
[%116 -> $rax] GR64
[%117 -> $rax] GR64
[%118 -> $rax] GR64
[%119 -> $rax] GR64
[%120 -> $r12] GR64
[%122 -> $r14] GR64_NOSP
[%123 -> $rax] GR64
[%125 -> $rcx] GR64
[%126 -> $r15] GR64
[%128 -> $rcx] GR64
[%129 -> $r12] GR64
[%131 -> $rbx] GR64_NOSP
[%132 -> $rax] GR64
[%134 -> $rcx] GR64
[%137 -> $r15] GR64_NOSP
[%138 -> $rax] GR64
[%140 -> $rcx] GR64
[%143 -> $r15] GR64_NOSP
[%144 -> $rax] GR64
[%145 -> $rcx] GR64
[%147 -> $rcx] GR64
[%150 -> $r15] GR64_NOSP
[%151 -> $rax] GR64
[%153 -> $r15] GR64
[%156 -> $rcx] GR64
[%158 -> $r10] GR64
[%162 -> $rax] GR64
[%165 -> $rax] GR64
[%3 -> fi#22] GR64_NOSP
[%4 -> fi#20] GR64_NOSP
[%5 -> fi#18] GR64_NOSP
[%6 -> fi#16] GR64_NOSP
[%7 -> fi#13] GR64_NOSP
[%8 -> fi#11] GR64_NOSP
[%11 -> fi#10] GR64
[%14 -> fi#12] GR64
[%17 -> fi#14] GR64
[%20 -> fi#15] GR64
[%23 -> fi#17] GR64
[%26 -> fi#19] GR64
[%29 -> fi#21] GR64
[%32 -> fi#24] GR64
[%82 -> fi#23] GR64
[%101 -> fi#10] GR64
[%108 -> fi#11] GR64
[%111 -> fi#12] GR64
[%121 -> fi#13] GR64
[%124 -> fi#14] GR64
[%127 -> fi#15] GR64
[%130 -> fi#16] GR64
[%133 -> fi#17] GR64
[%136 -> fi#18] GR64
[%139 -> fi#19] GR64
[%142 -> fi#20] GR64
[%146 -> fi#21] GR64
[%149 -> fi#22] GR64
[%154 -> fi#24] GR64
[%157 -> fi#23] GR64
[%159 -> fi#21] GR64
[%163 -> fi#19] GR64
[%166 -> fi#17] GR64

0B	bb.0 (%ir-block.0):
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %162:gr64 = MOV64ri @malloc
64B	  $rdi = MOV32ri64 56
80B	  CALL64r killed %162:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %37:gr64 = COPY $rax
128B	  MOV64mr %stack.0, 1, $noreg, 0, $noreg, %37:gr64 :: (store (s64) into %ir.2)
144B	  MOV64mr %stack.0, 1, $noreg, 8, $noreg, %37:gr64 :: (store (s64) into %ir..fca.1.gep)
160B	  MOV64mi32 %stack.0, 1, $noreg, 16, $noreg, 0 :: (store (s64) into %ir..fca.2.gep)
176B	  MOV64mi32 %stack.0, 1, $noreg, 24, $noreg, 7 :: (store (s64) into %ir..fca.3.0.gep)
192B	  MOV64mi32 %stack.0, 1, $noreg, 32, $noreg, 1 :: (store (s64) into %ir..fca.4.0.gep)
208B	  ADJCALLSTACKDOWN64 16, 0, 16, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
224B	  %39:gr64 = LEA64r %stack.0, 1, $noreg, 0, $noreg
240B	  %40:gr64 = MOV64ri @read_input_sizes_2D_f64
384B	  $rdx = MOV32ri64 3
432B	  $r9 = MOV32ri64 1
436B	  $edi = MOV32ri 1
440B	  dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
448B	  dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
456B	  $r8 = MOV64ri32 -1
464B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 8)
472B	  PUSH64r killed %39:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
480B	  CALL64r killed %40:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
496B	  ADJCALLSTACKUP64 16, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
512B	  %0:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
528B	  %1:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
544B	  %2:gr64_nosp = MOV64rm %37:gr64, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
560B	  %151:gr64 = MOV64rm %37:gr64, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
568B	  MOV64mr %stack.22, 1, $noreg, 0, $noreg, killed %151:gr64 :: (store (s64) into %stack.22)
576B	  %144:gr64 = MOV64rm %37:gr64, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
584B	  MOV64mr %stack.20, 1, $noreg, 0, $noreg, killed %144:gr64 :: (store (s64) into %stack.20)
592B	  %138:gr64 = MOV64rm %37:gr64, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
600B	  MOV64mr %stack.18, 1, $noreg, 0, $noreg, killed %138:gr64 :: (store (s64) into %stack.18)
608B	  %132:gr64 = MOV64rm %37:gr64, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
616B	  MOV64mr %stack.16, 1, $noreg, 0, $noreg, killed %132:gr64 :: (store (s64) into %stack.16)
624B	  %123:gr64 = MOV64rm %37:gr64, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
632B	  MOV64mr %stack.13, 1, $noreg, 0, $noreg, killed %123:gr64 :: (store (s64) into %stack.13)
640B	  %110:gr64 = MOV64rm killed %37:gr64, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
648B	  MOV64mr %stack.11, 1, $noreg, 0, $noreg, killed %110:gr64 :: (store (s64) into %stack.11)
656B	  %9:gr64 = LEA64r $noreg, 8, %0:gr64_nosp, 0, $noreg
672B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
688B	  $rdi = COPY %9:gr64
692B	  %165:gr64 = MOV64ri @malloc
704B	  CALL64r killed %165:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
720B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
736B	  %10:gr64 = COPY $rax
784B	  %116:gr64 = MOV64ri &__bzero
792B	  TEST64rr %0:gr64_nosp, %0:gr64_nosp, implicit-def $eflags
800B	  JCC_1 %bb.2, 14, implicit $eflags
816B	  JMP_1 %bb.1
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = MOV64ri @malloc
> $rdi = MOV32ri64 56
> CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rbx = COPY $rax
> MOV64mr %stack.0, 1, $noreg, 0, $noreg, renamable $rbx :: (store (s64) into %ir.2)
> MOV64mr %stack.0, 1, $noreg, 8, $noreg, renamable $rbx :: (store (s64) into %ir..fca.1.gep)
> MOV64mi32 %stack.0, 1, $noreg, 16, $noreg, 0 :: (store (s64) into %ir..fca.2.gep)
> MOV64mi32 %stack.0, 1, $noreg, 24, $noreg, 7 :: (store (s64) into %ir..fca.3.0.gep)
> MOV64mi32 %stack.0, 1, $noreg, 32, $noreg, 1 :: (store (s64) into %ir..fca.4.0.gep)
> ADJCALLSTACKDOWN64 16, 0, 16, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = LEA64r %stack.0, 1, $noreg, 0, $noreg
> renamable $r10 = MOV64ri @read_input_sizes_2D_f64
> $rdx = MOV32ri64 3
> $r9 = MOV32ri64 1
> $edi = MOV32ri 1
> dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
> dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
> $r8 = MOV64ri32 -1
> PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 8)
> PUSH64r killed renamable $rax, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
> CALL64r killed renamable $r10, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 16, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $r13 = MOV64rm renamable $rbx, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
> renamable $r12 = MOV64rm renamable $rbx, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
> renamable $r15 = MOV64rm renamable $rbx, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
> renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
> MOV64mr %stack.22, 1, $noreg, 0, $noreg, killed renamable $rax :: (store (s64) into %stack.22)
> renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
> MOV64mr %stack.20, 1, $noreg, 0, $noreg, killed renamable $rax :: (store (s64) into %stack.20)
> renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
> MOV64mr %stack.18, 1, $noreg, 0, $noreg, killed renamable $rax :: (store (s64) into %stack.18)
> renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
> MOV64mr %stack.16, 1, $noreg, 0, $noreg, killed renamable $rax :: (store (s64) into %stack.16)
> renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
> MOV64mr %stack.13, 1, $noreg, 0, $noreg, killed renamable $rax :: (store (s64) into %stack.13)
> renamable $rax = MOV64rm killed renamable $rbx, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
> MOV64mr %stack.11, 1, $noreg, 0, $noreg, killed renamable $rax :: (store (s64) into %stack.11)
> renamable $r14 = LEA64r $noreg, 8, renamable $r13, 0, $noreg
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $r14
> renamable $rax = MOV64ri @malloc
> CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rbx = COPY $rax
> renamable $rax = MOV64ri &__bzero
> TEST64rr renamable $r13, renamable $r13, implicit-def $eflags
> JCC_1 %bb.2, 14, implicit $eflags
> JMP_1 %bb.1
832B	bb.1..lr.ph.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)
	  liveins: $rax, $rbx, $r12, $r13, $r14, $r15
848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
864B	  $rdi = COPY %10:gr64
880B	  $rsi = COPY killed %9:gr64
896B	  CALL64r killed %116:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
912B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $rbx
> $rsi = COPY killed renamable $r14
> CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
928B	bb.2.._crit_edge:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.3(0x50000000), %bb.4(0x30000000); %bb.3(62.50%), %bb.4(37.50%)
	  liveins: $rbx, $r12, $r13, $r15
944B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
960B	  %49:gr64 = COPY $rsp
976B	  %102:gr64 = LEA64r %49:gr64, 1, $noreg, -48, $noreg
984B	  MOV64mr %stack.10, 1, $noreg, 0, $noreg, %102:gr64 :: (store (s64) into %stack.10)
992B	  $rsp = COPY killed %102:gr64
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1024B	  MOV64mr %49:gr64, 1, $noreg, -48, $noreg, %10:gr64 :: (store (s64) into %ir.22)
1040B	  MOV64mr %49:gr64, 1, $noreg, -40, $noreg, killed %10:gr64 :: (store (s64) into %ir..repack9)
1056B	  MOV64mi32 %49:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack11)
1072B	  MOV64mr %49:gr64, 1, $noreg, -24, $noreg, killed %0:gr64_nosp :: (store (s64) into %ir..repack13)
1088B	  MOV64mi32 killed %49:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack15)
1104B	  %12:gr64 = LEA64r $noreg, 8, %1:gr64_nosp, 0, $noreg
1120B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1136B	  $rdi = COPY %12:gr64
1140B	  %107:gr64 = MOV64ri @malloc
1144B	  %105:gr64 = COPY killed %107:gr64
1152B	  CALL64r %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1184B	  %13:gr64 = COPY $rax
1216B	  TEST64rr %1:gr64_nosp, %1:gr64_nosp, implicit-def $eflags
1232B	  JCC_1 %bb.4, 14, implicit $eflags
1248B	  JMP_1 %bb.3
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = COPY $rsp
> renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
> MOV64mr %stack.10, 1, $noreg, 0, $noreg, renamable $rcx :: (store (s64) into %stack.10)
> $rsp = COPY killed renamable $rcx
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> MOV64mr renamable $rax, 1, $noreg, -48, $noreg, renamable $rbx :: (store (s64) into %ir.22)
> MOV64mr renamable $rax, 1, $noreg, -40, $noreg, killed renamable $rbx :: (store (s64) into %ir..repack9)
> MOV64mi32 renamable $rax, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack11)
> MOV64mr renamable $rax, 1, $noreg, -24, $noreg, killed renamable $r13 :: (store (s64) into %ir..repack13)
> MOV64mi32 killed renamable $rax, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack15)
> renamable $r14 = LEA64r $noreg, 8, renamable $r12, 0, $noreg
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $r14
> renamable $r13 = MOV64ri @malloc
> renamable $r13 = COPY killed renamable $r13
Identity copy: renamable $r13 = COPY killed renamable $r13
  deleted.
> CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rbx = COPY $rax
> TEST64rr renamable $r12, renamable $r12, implicit-def $eflags
> JCC_1 %bb.4, 14, implicit $eflags
> JMP_1 %bb.3
1264B	bb.3..lr.ph90.preheader:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)
	  liveins: $rbx, $r12, $r13, $r14, $r15
1280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1296B	  $rdi = COPY %13:gr64
1312B	  $rsi = COPY killed %12:gr64
1320B	  %119:gr64 = MOV64ri &__bzero
1328B	  CALL64r killed %119:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
1344B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $rbx
> $rsi = COPY killed renamable $r14
> renamable $rax = MOV64ri &__bzero
> CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1360B	bb.4.._crit_edge91:
	; predecessors: %bb.2, %bb.3
	  successors: %bb.5(0x50000000), %bb.6(0x30000000); %bb.5(62.50%), %bb.6(37.50%)
	  liveins: $rbx, $r12, $r13, $r15
1376B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1392B	  %53:gr64 = COPY $rsp
1408B	  %112:gr64 = LEA64r %53:gr64, 1, $noreg, -48, $noreg
1416B	  MOV64mr %stack.12, 1, $noreg, 0, $noreg, %112:gr64 :: (store (s64) into %stack.12)
1424B	  $rsp = COPY killed %112:gr64
1440B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1456B	  MOV64mr %53:gr64, 1, $noreg, -48, $noreg, %13:gr64 :: (store (s64) into %ir.25)
1472B	  MOV64mr %53:gr64, 1, $noreg, -40, $noreg, killed %13:gr64 :: (store (s64) into %ir..repack18)
1488B	  MOV64mi32 %53:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack20)
1504B	  MOV64mr %53:gr64, 1, $noreg, -24, $noreg, killed %1:gr64_nosp :: (store (s64) into %ir..repack22)
1520B	  MOV64mi32 killed %53:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack24)
1536B	  %15:gr64 = LEA64r $noreg, 8, %2:gr64_nosp, 0, $noreg
1552B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1568B	  $rdi = COPY %15:gr64
1584B	  CALL64r %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1600B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1616B	  %16:gr64 = COPY $rax
1648B	  TEST64rr %2:gr64_nosp, %2:gr64_nosp, implicit-def $eflags
1652B	  %120:gr64 = MOV64ri &__bzero
1656B	  %115:gr64 = COPY killed %120:gr64
1664B	  JCC_1 %bb.6, 14, implicit $eflags
1680B	  JMP_1 %bb.5
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = COPY $rsp
> renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
> MOV64mr %stack.12, 1, $noreg, 0, $noreg, renamable $rcx :: (store (s64) into %stack.12)
> $rsp = COPY killed renamable $rcx
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> MOV64mr renamable $rax, 1, $noreg, -48, $noreg, renamable $rbx :: (store (s64) into %ir.25)
> MOV64mr renamable $rax, 1, $noreg, -40, $noreg, killed renamable $rbx :: (store (s64) into %ir..repack18)
> MOV64mi32 renamable $rax, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack20)
> MOV64mr renamable $rax, 1, $noreg, -24, $noreg, killed renamable $r12 :: (store (s64) into %ir..repack22)
> MOV64mi32 killed renamable $rax, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack24)
> renamable $r14 = LEA64r $noreg, 8, renamable $r15, 0, $noreg
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $r14
> CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rbx = COPY $rax
> TEST64rr renamable $r15, renamable $r15, implicit-def $eflags
> renamable $r12 = MOV64ri &__bzero
> renamable $r12 = COPY killed renamable $r12
Identity copy: renamable $r12 = COPY killed renamable $r12
  deleted.
> JCC_1 %bb.6, 14, implicit $eflags
> JMP_1 %bb.5
1696B	bb.5..lr.ph93.preheader:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)
	  liveins: $rbx, $r12, $r13, $r14, $r15
1712B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1728B	  $rdi = COPY %16:gr64
1744B	  $rsi = COPY killed %15:gr64
1760B	  CALL64r %115:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
1776B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $rbx
> $rsi = COPY killed renamable $r14
> CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1792B	bb.6.._crit_edge94:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.7(0x50000000), %bb.8(0x30000000); %bb.7(62.50%), %bb.8(37.50%)
	  liveins: $rbx, $r12, $r13, $r15
1808B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1824B	  %57:gr64 = COPY $rsp
1840B	  %125:gr64 = LEA64r %57:gr64, 1, $noreg, -48, $noreg
1848B	  MOV64mr %stack.14, 1, $noreg, 0, $noreg, %125:gr64 :: (store (s64) into %stack.14)
1856B	  $rsp = COPY killed %125:gr64
1872B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1888B	  MOV64mr %57:gr64, 1, $noreg, -48, $noreg, %16:gr64 :: (store (s64) into %ir.28)
1904B	  MOV64mr %57:gr64, 1, $noreg, -40, $noreg, killed %16:gr64 :: (store (s64) into %ir..repack27)
1920B	  MOV64mi32 %57:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack29)
1936B	  MOV64mr %57:gr64, 1, $noreg, -24, $noreg, killed %2:gr64_nosp :: (store (s64) into %ir..repack31)
1952B	  MOV64mi32 killed %57:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack33)
1960B	  %150:gr64_nosp = MOV64rm %stack.22, 1, $noreg, 0, $noreg :: (load (s64) from %stack.22)
1968B	  %18:gr64 = LEA64r $noreg, 8, %150:gr64_nosp, 0, $noreg
1984B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2000B	  $rdi = COPY %18:gr64
2016B	  CALL64r %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2048B	  %19:gr64 = COPY $rax
2080B	  TEST64rr %150:gr64_nosp, %150:gr64_nosp, implicit-def $eflags
2096B	  JCC_1 %bb.8, 14, implicit $eflags
2112B	  JMP_1 %bb.7
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = COPY $rsp
> renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
> MOV64mr %stack.14, 1, $noreg, 0, $noreg, renamable $rcx :: (store (s64) into %stack.14)
> $rsp = COPY killed renamable $rcx
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> MOV64mr renamable $rax, 1, $noreg, -48, $noreg, renamable $rbx :: (store (s64) into %ir.28)
> MOV64mr renamable $rax, 1, $noreg, -40, $noreg, killed renamable $rbx :: (store (s64) into %ir..repack27)
> MOV64mi32 renamable $rax, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack29)
> MOV64mr renamable $rax, 1, $noreg, -24, $noreg, killed renamable $r15 :: (store (s64) into %ir..repack31)
> MOV64mi32 killed renamable $rax, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack33)
> renamable $r15 = MOV64rm %stack.22, 1, $noreg, 0, $noreg :: (load (s64) from %stack.22)
> renamable $r14 = LEA64r $noreg, 8, renamable $r15, 0, $noreg
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $r14
> CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rbx = COPY $rax
> TEST64rr renamable $r15, renamable $r15, implicit-def $eflags
> JCC_1 %bb.8, 14, implicit $eflags
> JMP_1 %bb.7
2128B	bb.7..lr.ph96.preheader:
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)
	  liveins: $rbx, $r12, $r13, $r14, $r15
2144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2160B	  $rdi = COPY %19:gr64
2176B	  $rsi = COPY killed %18:gr64
2192B	  CALL64r %115:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
2208B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $rbx
> $rsi = COPY killed renamable $r14
> CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2224B	bb.8.._crit_edge97:
	; predecessors: %bb.6, %bb.7
	  successors: %bb.9(0x50000000), %bb.10(0x30000000); %bb.9(62.50%), %bb.10(37.50%)
	  liveins: $rbx, $r12, $r13, $r15
2240B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2256B	  %61:gr64 = COPY $rsp
2272B	  %128:gr64 = LEA64r %61:gr64, 1, $noreg, -48, $noreg
2280B	  MOV64mr %stack.15, 1, $noreg, 0, $noreg, %128:gr64 :: (store (s64) into %stack.15)
2288B	  $rsp = COPY killed %128:gr64
2304B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2320B	  MOV64mr %61:gr64, 1, $noreg, -48, $noreg, %19:gr64 :: (store (s64) into %ir.31)
2336B	  MOV64mr %61:gr64, 1, $noreg, -40, $noreg, killed %19:gr64 :: (store (s64) into %ir..repack36)
2352B	  MOV64mi32 %61:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack38)
2368B	  MOV64mr %61:gr64, 1, $noreg, -24, $noreg, killed %150:gr64_nosp :: (store (s64) into %ir..repack40)
2384B	  MOV64mi32 killed %61:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack42)
2392B	  %143:gr64_nosp = MOV64rm %stack.20, 1, $noreg, 0, $noreg :: (load (s64) from %stack.20)
2400B	  %21:gr64 = LEA64r $noreg, 8, %143:gr64_nosp, 0, $noreg
2416B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2432B	  $rdi = COPY %21:gr64
2448B	  CALL64r %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2464B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2480B	  %22:gr64 = COPY $rax
2512B	  TEST64rr killed %143:gr64_nosp, %143:gr64_nosp, implicit-def $eflags
2520B	  %137:gr64_nosp = MOV64rm %stack.18, 1, $noreg, 0, $noreg :: (load (s64) from %stack.18)
2528B	  JCC_1 %bb.10, 14, implicit $eflags
2544B	  JMP_1 %bb.9
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = COPY $rsp
> renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
> MOV64mr %stack.15, 1, $noreg, 0, $noreg, renamable $rcx :: (store (s64) into %stack.15)
> $rsp = COPY killed renamable $rcx
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> MOV64mr renamable $rax, 1, $noreg, -48, $noreg, renamable $rbx :: (store (s64) into %ir.31)
> MOV64mr renamable $rax, 1, $noreg, -40, $noreg, killed renamable $rbx :: (store (s64) into %ir..repack36)
> MOV64mi32 renamable $rax, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack38)
> MOV64mr renamable $rax, 1, $noreg, -24, $noreg, killed renamable $r15 :: (store (s64) into %ir..repack40)
> MOV64mi32 killed renamable $rax, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack42)
> renamable $r15 = MOV64rm %stack.20, 1, $noreg, 0, $noreg :: (load (s64) from %stack.20)
> renamable $r14 = LEA64r $noreg, 8, renamable $r15, 0, $noreg
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $r14
> CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rbx = COPY $rax
> TEST64rr killed renamable $r15, renamable $r15, implicit-def $eflags
> renamable $r15 = MOV64rm %stack.18, 1, $noreg, 0, $noreg :: (load (s64) from %stack.18)
> JCC_1 %bb.10, 14, implicit $eflags
> JMP_1 %bb.9
2560B	bb.9..lr.ph99.preheader:
	; predecessors: %bb.8
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $rbx, $r12, $r13, $r14, $r15
2576B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2592B	  $rdi = COPY %22:gr64
2608B	  $rsi = COPY killed %21:gr64
2624B	  CALL64r %115:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
2640B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $rbx
> $rsi = COPY killed renamable $r14
> CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2656B	bb.10.._crit_edge100:
	; predecessors: %bb.8, %bb.9
	  successors: %bb.11(0x50000000), %bb.12(0x30000000); %bb.11(62.50%), %bb.12(37.50%)
	  liveins: $rbx, $r12, $r13, $r15
2672B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2688B	  %65:gr64 = COPY $rsp
2704B	  %134:gr64 = LEA64r %65:gr64, 1, $noreg, -48, $noreg
2712B	  MOV64mr %stack.17, 1, $noreg, 0, $noreg, %134:gr64 :: (store (s64) into %stack.17)
2720B	  $rsp = COPY killed %134:gr64
2736B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2752B	  MOV64mr %65:gr64, 1, $noreg, -48, $noreg, %22:gr64 :: (store (s64) into %ir.34)
2768B	  MOV64mr %65:gr64, 1, $noreg, -40, $noreg, killed %22:gr64 :: (store (s64) into %ir..repack45)
2784B	  MOV64mi32 %65:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack47)
2792B	  %145:gr64 = MOV64rm %stack.20, 1, $noreg, 0, $noreg :: (load (s64) from %stack.20)
2800B	  MOV64mr %65:gr64, 1, $noreg, -24, $noreg, killed %145:gr64 :: (store (s64) into %ir..repack49)
2816B	  MOV64mi32 killed %65:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack51)
2832B	  %24:gr64 = LEA64r $noreg, 8, %137:gr64_nosp, 0, $noreg
2848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2864B	  $rdi = COPY %24:gr64
2880B	  CALL64r %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2912B	  %25:gr64 = COPY $rax
2944B	  TEST64rr %137:gr64_nosp, %137:gr64_nosp, implicit-def $eflags
2960B	  JCC_1 %bb.12, 14, implicit $eflags
2976B	  JMP_1 %bb.11
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = COPY $rsp
> renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
> MOV64mr %stack.17, 1, $noreg, 0, $noreg, renamable $rcx :: (store (s64) into %stack.17)
> $rsp = COPY killed renamable $rcx
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> MOV64mr renamable $rax, 1, $noreg, -48, $noreg, renamable $rbx :: (store (s64) into %ir.34)
> MOV64mr renamable $rax, 1, $noreg, -40, $noreg, killed renamable $rbx :: (store (s64) into %ir..repack45)
> MOV64mi32 renamable $rax, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack47)
> renamable $rcx = MOV64rm %stack.20, 1, $noreg, 0, $noreg :: (load (s64) from %stack.20)
> MOV64mr renamable $rax, 1, $noreg, -24, $noreg, killed renamable $rcx :: (store (s64) into %ir..repack49)
> MOV64mi32 killed renamable $rax, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack51)
> renamable $rbx = LEA64r $noreg, 8, renamable $r15, 0, $noreg
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $rbx
> CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $r14 = COPY $rax
> TEST64rr renamable $r15, renamable $r15, implicit-def $eflags
> JCC_1 %bb.12, 14, implicit $eflags
> JMP_1 %bb.11
2992B	bb.11..lr.ph102.preheader:
	; predecessors: %bb.10
	  successors: %bb.12(0x80000000); %bb.12(100.00%)
	  liveins: $rbx, $r12, $r13, $r14, $r15
3008B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3024B	  $rdi = COPY %25:gr64
3040B	  $rsi = COPY killed %24:gr64
3056B	  CALL64r %115:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
3072B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $r14
> $rsi = COPY killed renamable $rbx
> CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3088B	bb.12.._crit_edge103:
	; predecessors: %bb.10, %bb.11
	  successors: %bb.13(0x50000000), %bb.14(0x30000000); %bb.13(62.50%), %bb.14(37.50%)
	  liveins: $r12, $r13, $r14, $r15
3104B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3120B	  %69:gr64 = COPY $rsp
3136B	  %140:gr64 = LEA64r %69:gr64, 1, $noreg, -48, $noreg
3144B	  MOV64mr %stack.19, 1, $noreg, 0, $noreg, %140:gr64 :: (store (s64) into %stack.19)
3152B	  $rsp = COPY killed %140:gr64
3168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3184B	  MOV64mr %69:gr64, 1, $noreg, -48, $noreg, %25:gr64 :: (store (s64) into %ir.37)
3200B	  MOV64mr %69:gr64, 1, $noreg, -40, $noreg, killed %25:gr64 :: (store (s64) into %ir..repack54)
3216B	  MOV64mi32 %69:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack56)
3232B	  MOV64mr %69:gr64, 1, $noreg, -24, $noreg, killed %137:gr64_nosp :: (store (s64) into %ir..repack58)
3248B	  MOV64mi32 killed %69:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack60)
3256B	  %131:gr64_nosp = MOV64rm %stack.16, 1, $noreg, 0, $noreg :: (load (s64) from %stack.16)
3264B	  %27:gr64 = LEA64r $noreg, 8, %131:gr64_nosp, 0, $noreg
3280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3296B	  $rdi = COPY %27:gr64
3312B	  CALL64r %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3328B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3344B	  %28:gr64 = COPY $rax
3376B	  TEST64rr %131:gr64_nosp, %131:gr64_nosp, implicit-def $eflags
3392B	  JCC_1 %bb.14, 14, implicit $eflags
3408B	  JMP_1 %bb.13
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = COPY $rsp
> renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
> MOV64mr %stack.19, 1, $noreg, 0, $noreg, renamable $rcx :: (store (s64) into %stack.19)
> $rsp = COPY killed renamable $rcx
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> MOV64mr renamable $rax, 1, $noreg, -48, $noreg, renamable $r14 :: (store (s64) into %ir.37)
> MOV64mr renamable $rax, 1, $noreg, -40, $noreg, killed renamable $r14 :: (store (s64) into %ir..repack54)
> MOV64mi32 renamable $rax, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack56)
> MOV64mr renamable $rax, 1, $noreg, -24, $noreg, killed renamable $r15 :: (store (s64) into %ir..repack58)
> MOV64mi32 killed renamable $rax, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack60)
> renamable $rbx = MOV64rm %stack.16, 1, $noreg, 0, $noreg :: (load (s64) from %stack.16)
> renamable $r14 = LEA64r $noreg, 8, renamable $rbx, 0, $noreg
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $r14
> CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $r15 = COPY $rax
> TEST64rr renamable $rbx, renamable $rbx, implicit-def $eflags
> JCC_1 %bb.14, 14, implicit $eflags
> JMP_1 %bb.13
3424B	bb.13..lr.ph105.preheader:
	; predecessors: %bb.12
	  successors: %bb.14(0x80000000); %bb.14(100.00%)
	  liveins: $rbx, $r12, $r13, $r14, $r15
3440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3456B	  $rdi = COPY %28:gr64
3472B	  $rsi = COPY killed %27:gr64
3488B	  CALL64r killed %115:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
3504B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $r15
> $rsi = COPY killed renamable $r14
> CALL64r killed renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3520B	bb.14.._crit_edge106:
	; predecessors: %bb.12, %bb.13
	  successors: %bb.15(0x50000000), %bb.16(0x30000000); %bb.15(62.50%), %bb.16(37.50%)
	  liveins: $rbx, $r13, $r15
3536B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3552B	  %73:gr64 = COPY $rsp
3568B	  %147:gr64 = LEA64r %73:gr64, 1, $noreg, -48, $noreg
3576B	  MOV64mr %stack.21, 1, $noreg, 0, $noreg, %147:gr64 :: (store (s64) into %stack.21)
3584B	  $rsp = COPY killed %147:gr64
3600B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3616B	  MOV64mr %73:gr64, 1, $noreg, -48, $noreg, %28:gr64 :: (store (s64) into %ir.40)
3632B	  MOV64mr %73:gr64, 1, $noreg, -40, $noreg, killed %28:gr64 :: (store (s64) into %ir..repack63)
3648B	  MOV64mi32 %73:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack65)
3664B	  MOV64mr %73:gr64, 1, $noreg, -24, $noreg, killed %131:gr64_nosp :: (store (s64) into %ir..repack67)
3680B	  MOV64mi32 killed %73:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack69)
3688B	  %122:gr64_nosp = MOV64rm %stack.13, 1, $noreg, 0, $noreg :: (load (s64) from %stack.13)
3696B	  %30:gr64 = LEA64r $noreg, 8, %122:gr64_nosp, 0, $noreg
3712B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3728B	  $rdi = COPY %30:gr64
3744B	  CALL64r %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3760B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3776B	  %31:gr64 = COPY $rax
3808B	  TEST64rr %122:gr64_nosp, %122:gr64_nosp, implicit-def $eflags
3816B	  %109:gr64_nosp = MOV64rm %stack.11, 1, $noreg, 0, $noreg :: (load (s64) from %stack.11)
3824B	  JCC_1 %bb.16, 14, implicit $eflags
3840B	  JMP_1 %bb.15
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = COPY $rsp
> renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
> MOV64mr %stack.21, 1, $noreg, 0, $noreg, renamable $rcx :: (store (s64) into %stack.21)
> $rsp = COPY killed renamable $rcx
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> MOV64mr renamable $rax, 1, $noreg, -48, $noreg, renamable $r15 :: (store (s64) into %ir.40)
> MOV64mr renamable $rax, 1, $noreg, -40, $noreg, killed renamable $r15 :: (store (s64) into %ir..repack63)
> MOV64mi32 renamable $rax, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack65)
> MOV64mr renamable $rax, 1, $noreg, -24, $noreg, killed renamable $rbx :: (store (s64) into %ir..repack67)
> MOV64mi32 killed renamable $rax, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack69)
> renamable $r14 = MOV64rm %stack.13, 1, $noreg, 0, $noreg :: (load (s64) from %stack.13)
> renamable $r15 = LEA64r $noreg, 8, renamable $r14, 0, $noreg
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $r15
> CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $r12 = COPY $rax
> TEST64rr renamable $r14, renamable $r14, implicit-def $eflags
> renamable $rbx = MOV64rm %stack.11, 1, $noreg, 0, $noreg :: (load (s64) from %stack.11)
> JCC_1 %bb.16, 14, implicit $eflags
> JMP_1 %bb.15
3856B	bb.15..lr.ph108.preheader:
	; predecessors: %bb.14
	  successors: %bb.16(0x80000000); %bb.16(100.00%)
	  liveins: $rbx, $r12, $r13, $r14, $r15
3872B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3888B	  $rdi = COPY %31:gr64
3904B	  $rsi = COPY killed %30:gr64
3912B	  %118:gr64 = MOV64ri &__bzero
3920B	  CALL64r killed %118:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
3936B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $r12
> $rsi = COPY killed renamable $r15
> renamable $rax = MOV64ri &__bzero
> CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3952B	bb.16.._crit_edge109:
	; predecessors: %bb.14, %bb.15
	  successors: %bb.17(0x50000000), %bb.18(0x30000000); %bb.17(62.50%), %bb.18(37.50%)
	  liveins: $rbx, $r12, $r13, $r14
3968B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3984B	  %77:gr64 = COPY $rsp
4000B	  %153:gr64 = LEA64r %77:gr64, 1, $noreg, -48, $noreg
4016B	  $rsp = COPY %153:gr64
4032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4048B	  MOV64mr %77:gr64, 1, $noreg, -48, $noreg, %31:gr64 :: (store (s64) into %ir.43)
4064B	  MOV64mr %77:gr64, 1, $noreg, -40, $noreg, killed %31:gr64 :: (store (s64) into %ir..repack72)
4080B	  MOV64mi32 %77:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack74)
4096B	  MOV64mr %77:gr64, 1, $noreg, -24, $noreg, killed %122:gr64_nosp :: (store (s64) into %ir..repack76)
4112B	  MOV64mi32 killed %77:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack78)
4128B	  %33:gr64 = LEA64r $noreg, 8, %109:gr64_nosp, 0, $noreg
4144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4160B	  $rdi = COPY %33:gr64
4176B	  CALL64r killed %105:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
4192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4208B	  %34:gr64 = COPY $rax
4240B	  TEST64rr %109:gr64_nosp, %109:gr64_nosp, implicit-def $eflags
4256B	  JCC_1 %bb.18, 14, implicit $eflags
4272B	  JMP_1 %bb.17
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = COPY $rsp
> renamable $r15 = LEA64r renamable $rax, 1, $noreg, -48, $noreg
> $rsp = COPY renamable $r15
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> MOV64mr renamable $rax, 1, $noreg, -48, $noreg, renamable $r12 :: (store (s64) into %ir.43)
> MOV64mr renamable $rax, 1, $noreg, -40, $noreg, killed renamable $r12 :: (store (s64) into %ir..repack72)
> MOV64mi32 renamable $rax, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack74)
> MOV64mr renamable $rax, 1, $noreg, -24, $noreg, killed renamable $r14 :: (store (s64) into %ir..repack76)
> MOV64mi32 killed renamable $rax, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack78)
> renamable $r12 = LEA64r $noreg, 8, renamable $rbx, 0, $noreg
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $r12
> CALL64r killed renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $r13 = COPY $rax
> TEST64rr renamable $rbx, renamable $rbx, implicit-def $eflags
> JCC_1 %bb.18, 14, implicit $eflags
> JMP_1 %bb.17
4288B	bb.17..lr.ph111.preheader:
	; predecessors: %bb.16
	  successors: %bb.18(0x80000000); %bb.18(100.00%)
	  liveins: $rbx, $r12, $r13, $r15
4304B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4320B	  $rdi = COPY %34:gr64
4336B	  $rsi = COPY killed %33:gr64
4344B	  %117:gr64 = MOV64ri &__bzero
4352B	  CALL64r killed %117:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
4368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $r13
> $rsi = COPY killed renamable $r12
> renamable $rax = MOV64ri &__bzero
> CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4384B	bb.18.._crit_edge112:
	; predecessors: %bb.16, %bb.17
	  liveins: $rbx, $r13, $r15
4400B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4416B	  %81:gr64 = COPY $rsp
4432B	  %156:gr64 = LEA64r %81:gr64, 1, $noreg, -48, $noreg
4448B	  $rsp = COPY %156:gr64
4456B	  %158:gr64 = COPY killed %156:gr64
4460B	  MOV64mr %stack.23, 1, $noreg, 0, $noreg, %158:gr64 :: (store (s64) into %stack.23)
4464B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4480B	  MOV64mr %81:gr64, 1, $noreg, -48, $noreg, %34:gr64 :: (store (s64) into %ir.46)
4496B	  MOV64mr %81:gr64, 1, $noreg, -40, $noreg, killed %34:gr64 :: (store (s64) into %ir..repack81)
4512B	  MOV64mi32 %81:gr64, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack83)
4528B	  MOV64mr %81:gr64, 1, $noreg, -24, $noreg, killed %109:gr64_nosp :: (store (s64) into %ir..repack85)
4544B	  MOV64mi32 killed %81:gr64, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack87)
4560B	  ADJCALLSTACKDOWN64 144, 0, 144, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4576B	  %84:gr64 = MOV64ri @read_input_2D_f64
4720B	  $rdx = MOV32ri64 3
4768B	  $r9 = MOV32ri64 1
4772B	  $edi = MOV32ri 1
4776B	  dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
4784B	  dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
4792B	  $r8 = MOV64ri32 -1
4800B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 136)
4808B	  PUSH64r killed %158:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 128)
4816B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 120)
4832B	  PUSH64r %153:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 112)
4848B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 104)
4864B	  PUSH64rmm %stack.21, 1, $noreg, 0, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 96), (load (s64) from %stack.21)
4880B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 88)
4896B	  PUSH64rmm %stack.19, 1, $noreg, 0, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 80), (load (s64) from %stack.19)
4912B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 72)
4928B	  PUSH64rmm %stack.17, 1, $noreg, 0, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 64), (load (s64) from %stack.17)
4944B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 56)
4952B	  %129:gr64 = MOV64rm %stack.15, 1, $noreg, 0, $noreg :: (load (s64) from %stack.15)
4960B	  PUSH64r %129:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 48)
4976B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 40)
4980B	  MOV64mr %stack.24, 1, $noreg, 0, $noreg, killed %153:gr64 :: (store (s64) into %stack.24)
4984B	  %126:gr64 = MOV64rm %stack.14, 1, $noreg, 0, $noreg :: (load (s64) from %stack.14)
4992B	  PUSH64r %126:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 32)
5008B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 24)
5016B	  %113:gr64 = MOV64rm %stack.12, 1, $noreg, 0, $noreg :: (load (s64) from %stack.12)
5024B	  PUSH64r %113:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 16)
5040B	  PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 8)
5048B	  %103:gr64 = MOV64rm %stack.10, 1, $noreg, 0, $noreg :: (load (s64) from %stack.10)
5056B	  PUSH64r %103:gr64, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
5072B	  CALL64r killed %84:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
5088B	  ADJCALLSTACKUP64 144, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5104B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5120B	  %91:gr64 = MOV64ri @comet_print_memref_i64
5136B	  $rdi = MOV32ri64 1
5152B	  $rsi = COPY killed %103:gr64
5168B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5184B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5200B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5216B	  $rdi = MOV32ri64 1
5232B	  $rsi = COPY killed %113:gr64
5248B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5264B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5280B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5296B	  $rdi = MOV32ri64 1
5312B	  $rsi = COPY killed %126:gr64
5328B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5344B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5360B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5376B	  $rdi = MOV32ri64 1
5392B	  $rsi = COPY killed %129:gr64
5408B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5424B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5456B	  $rdi = MOV32ri64 1
5472B	  $rsi = MOV64rm %stack.17, 1, $noreg, 0, $noreg :: (load (s64) from %stack.17)
5488B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5504B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5520B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5536B	  $rdi = MOV32ri64 1
5552B	  $rsi = MOV64rm %stack.19, 1, $noreg, 0, $noreg :: (load (s64) from %stack.19)
5568B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5584B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5600B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5616B	  $rdi = MOV32ri64 1
5632B	  $rsi = MOV64rm %stack.21, 1, $noreg, 0, $noreg :: (load (s64) from %stack.21)
5648B	  CALL64r %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5664B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5680B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5696B	  $rdi = MOV32ri64 1
5712B	  $rsi = MOV64rm %stack.24, 1, $noreg, 0, $noreg :: (load (s64) from %stack.24)
5728B	  CALL64r killed %91:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5744B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5760B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5776B	  %92:gr64 = MOV64ri @comet_print_memref_f64
5792B	  $rdi = MOV32ri64 1
5808B	  $rsi = MOV64rm %stack.23, 1, $noreg, 0, $noreg :: (load (s64) from %stack.23)
5824B	  CALL64r killed %92:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5840B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5856B	  RET 0
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = COPY $rsp
> renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
> $rsp = COPY renamable $rcx
> renamable $r10 = COPY killed renamable $rcx
> MOV64mr %stack.23, 1, $noreg, 0, $noreg, renamable $r10 :: (store (s64) into %stack.23)
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> MOV64mr renamable $rax, 1, $noreg, -48, $noreg, renamable $r13 :: (store (s64) into %ir.46)
> MOV64mr renamable $rax, 1, $noreg, -40, $noreg, killed renamable $r13 :: (store (s64) into %ir..repack81)
> MOV64mi32 renamable $rax, 1, $noreg, -32, $noreg, 0 :: (store (s64) into %ir..repack83)
> MOV64mr renamable $rax, 1, $noreg, -24, $noreg, killed renamable $rbx :: (store (s64) into %ir..repack85)
> MOV64mi32 killed renamable $rax, 1, $noreg, -16, $noreg, 1 :: (store (s64) into %ir..repack87)
> ADJCALLSTACKDOWN64 144, 0, 144, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = MOV64ri @read_input_2D_f64
> $rdx = MOV32ri64 3
> $r9 = MOV32ri64 1
> $edi = MOV32ri 1
> dead $esi = MOV32r0 implicit-def dead $eflags, implicit-def $rsi
> dead $ecx = MOV32r0 implicit-def dead $eflags, implicit-def $rcx
> $r8 = MOV64ri32 -1
> PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 136)
> PUSH64r killed renamable $r10, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 128)
> PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 120)
> PUSH64r renamable $r15, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 112)
> PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 104)
> PUSH64rmm %stack.21, 1, $noreg, 0, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 96), (load (s64) from %stack.21)
> PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 88)
> PUSH64rmm %stack.19, 1, $noreg, 0, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 80), (load (s64) from %stack.19)
> PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 72)
> PUSH64rmm %stack.17, 1, $noreg, 0, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 64), (load (s64) from %stack.17)
> PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 56)
> renamable $r12 = MOV64rm %stack.15, 1, $noreg, 0, $noreg :: (load (s64) from %stack.15)
> PUSH64r renamable $r12, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 48)
> PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 40)
> MOV64mr %stack.24, 1, $noreg, 0, $noreg, killed renamable $r15 :: (store (s64) into %stack.24)
> renamable $r15 = MOV64rm %stack.14, 1, $noreg, 0, $noreg :: (load (s64) from %stack.14)
> PUSH64r renamable $r15, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 32)
> PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 24)
> renamable $r14 = MOV64rm %stack.12, 1, $noreg, 0, $noreg :: (load (s64) from %stack.12)
> PUSH64r renamable $r14, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 16)
> PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 8)
> renamable $rbx = MOV64rm %stack.10, 1, $noreg, 0, $noreg :: (load (s64) from %stack.10)
> PUSH64r renamable $rbx, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
> CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 144, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $r13 = MOV64ri @comet_print_memref_i64
> $rdi = MOV32ri64 1
> $rsi = COPY killed renamable $rbx
> CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = MOV32ri64 1
> $rsi = COPY killed renamable $r14
> CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = MOV32ri64 1
> $rsi = COPY killed renamable $r15
> CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = MOV32ri64 1
> $rsi = COPY killed renamable $r12
> CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = MOV32ri64 1
> $rsi = MOV64rm %stack.17, 1, $noreg, 0, $noreg :: (load (s64) from %stack.17)
> CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = MOV32ri64 1
> $rsi = MOV64rm %stack.19, 1, $noreg, 0, $noreg :: (load (s64) from %stack.19)
> CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = MOV32ri64 1
> $rsi = MOV64rm %stack.21, 1, $noreg, 0, $noreg :: (load (s64) from %stack.21)
> CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = MOV32ri64 1
> $rsi = MOV64rm %stack.24, 1, $noreg, 0, $noreg :: (load (s64) from %stack.24)
> CALL64r killed renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = MOV64ri @comet_print_memref_f64
> $rdi = MOV32ri64 1
> $rsi = MOV64rm %stack.23, 1, $noreg, 0, $noreg :: (load (s64) from %stack.23)
> CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> RET 0
********** Stack Slot Coloring **********
********** Function: main
Spill slot intervals:
SS#10 [984r,5152r:0) 0@x  weight:2.000000e+00
SS#11 [640r,4528r:0) 0@x  weight:2.000000e+00
SS#12 [1416r,5232r:0) 0@x  weight:2.000000e+00
SS#13 [624r,4096r:0) 0@x  weight:2.000000e+00
SS#14 [1848r,5312r:0) 0@x  weight:2.000000e+00
SS#15 [2280r,5392r:0) 0@x  weight:2.000000e+00
SS#16 [608r,3664r:0) 0@x  weight:2.000000e+00
SS#17 [2712r,5472r:0) 0@x  weight:3.000000e+00
SS#18 [592r,3232r:0) 0@x  weight:2.000000e+00
SS#19 [3144r,5552r:0) 0@x  weight:3.000000e+00
SS#20 [576r,2800r:0) 0@x  weight:3.000000e+00
SS#21 [3576r,5632r:0) 0@x  weight:3.000000e+00
SS#22 [560r,2368r:0) 0@x  weight:2.000000e+00
SS#23 [4432r,5808r:0) 0@x  weight:2.000000e+00
SS#24 [4980r,5712r:0) 0@x  weight:2.000000e+00

Color spill slot intervals:
Assigning fi#17 to fi#10
Assigning fi#19 to fi#11
Assigning fi#20 to fi#11
Assigning fi#21 to fi#12
Assigning fi#10 to fi#13
Assigning fi#11 to fi#14
Assigning fi#12 to fi#15
Assigning fi#13 to fi#16
Assigning fi#14 to fi#17
Assigning fi#15 to fi#18
Assigning fi#16 to fi#19
Assigning fi#18 to fi#12
Assigning fi#22 to fi#10
Assigning fi#23 to fi#16
Assigning fi#24 to fi#14

Spill slots after coloring:
SS#11 [640r,4528r:0) 0@x  weight:6.000000e+00
SS#10 [984r,5152r:0) 0@x  weight:5.000000e+00
SS#12 [1416r,5232r:0) 0@x  weight:5.000000e+00
SS#14 [1848r,5312r:0) 0@x  weight:4.000000e+00
SS#16 [608r,3664r:0) 0@x  weight:4.000000e+00
SS#17 [2712r,5472r:0) 0@x  weight:2.000000e+00
SS#19 [3144r,5552r:0) 0@x  weight:2.000000e+00
SS#13 [624r,4096r:0) 0@x  weight:2.000000e+00
SS#15 [2280r,5392r:0) 0@x  weight:2.000000e+00
SS#18 [592r,3232r:0) 0@x  weight:2.000000e+00
SS#20 [576r,2800r:0) 0@x  weight:0.000000e+00
SS#21 [3576r,5632r:0) 0@x  weight:0.000000e+00
SS#22 [560r,2368r:0) 0@x  weight:0.000000e+00
SS#23 [4432r,5808r:0) 0@x  weight:0.000000e+00
SS#24 [4980r,5712r:0) 0@x  weight:0.000000e+00

Removing unused stack object fi#20
Removing unused stack object fi#21
Removing unused stack object fi#22
Removing unused stack object fi#23
Removing unused stack object fi#24
MCP: BackwardCopyPropagateBlock 
MCP: ForwardCopyPropagateBlock 
MCP: Copy is a deletion candidate:   renamable $rbx = COPY $rax
MCP: Replacing $rbx
     with $rax
     in MOV64mr %stack.0, 1, $noreg, 0, $noreg, renamable $rbx :: (store (s64) into %ir.2)
     from renamable $rbx = COPY $rax
MCP: After replacement: MOV64mr %stack.0, 1, $noreg, 0, $noreg, $rax :: (store (s64) into %ir.2)

MCP: Replacing $rbx
     with $rax
     in MOV64mr %stack.0, 1, $noreg, 8, $noreg, renamable $rbx :: (store (s64) into %ir..fca.1.gep)
     from renamable $rbx = COPY $rax
MCP: After replacement: MOV64mr %stack.0, 1, $noreg, 8, $noreg, $rax :: (store (s64) into %ir..fca.1.gep)

MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is a deletion candidate:   renamable $rbx = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph.preheader
MCP: ForwardCopyPropagateBlock .lr.ph.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $rbx
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: BackwardCopyPropagateBlock ._crit_edge
MCP: ForwardCopyPropagateBlock ._crit_edge
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is a deletion candidate:   renamable $rbx = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph90.preheader
MCP: ForwardCopyPropagateBlock .lr.ph90.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $rbx
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: BackwardCopyPropagateBlock ._crit_edge91
MCP: ForwardCopyPropagateBlock ._crit_edge91
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is a deletion candidate:   renamable $rbx = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph93.preheader
MCP: ForwardCopyPropagateBlock .lr.ph93.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $rbx
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: BackwardCopyPropagateBlock ._crit_edge94
MCP: ForwardCopyPropagateBlock ._crit_edge94
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is a deletion candidate:   renamable $rbx = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph96.preheader
MCP: ForwardCopyPropagateBlock .lr.ph96.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $rbx
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: BackwardCopyPropagateBlock ._crit_edge97
MCP: ForwardCopyPropagateBlock ._crit_edge97
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is a deletion candidate:   renamable $rbx = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph99.preheader
MCP: ForwardCopyPropagateBlock .lr.ph99.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $rbx
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: BackwardCopyPropagateBlock ._crit_edge100
MCP: ForwardCopyPropagateBlock ._crit_edge100
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is a deletion candidate:   renamable $r14 = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph102.preheader
MCP: ForwardCopyPropagateBlock .lr.ph102.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r14
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $rbx
MCP: BackwardCopyPropagateBlock ._crit_edge103
MCP: ForwardCopyPropagateBlock ._crit_edge103
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is a deletion candidate:   renamable $r15 = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph105.preheader
MCP: ForwardCopyPropagateBlock .lr.ph105.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r15
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r15
MCP: Copy is used - not dead:   $rdi = COPY renamable $r15
MCP: Copy is used - not dead:   $rdi = COPY renamable $r15
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: BackwardCopyPropagateBlock ._crit_edge106
MCP: ForwardCopyPropagateBlock ._crit_edge106
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r15
MCP: Copy is used - not dead:   $rdi = COPY renamable $r15
MCP: Copy is used - not dead:   $rdi = COPY renamable $r15
MCP: Copy is used - not dead:   $rdi = COPY renamable $r15
MCP: Copy is a deletion candidate:   renamable $r12 = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph108.preheader
MCP: ForwardCopyPropagateBlock .lr.ph108.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r12
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r15
MCP: Copy is used - not dead:   $rdi = COPY renamable $r12
MCP: Copy is used - not dead:   $rdi = COPY renamable $r12
MCP: Copy is used - not dead:   $rdi = COPY renamable $r12
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r15
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r15
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r15
MCP: BackwardCopyPropagateBlock ._crit_edge109
MCP: ForwardCopyPropagateBlock ._crit_edge109
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY renamable $r15
MCP: Copy is used - not dead:   $rsp = COPY renamable $r15
MCP: Copy is used - not dead:   $rsp = COPY renamable $r15
MCP: Copy is used - not dead:   $rsp = COPY renamable $r15
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r12
MCP: Copy is used - not dead:   $rdi = COPY renamable $r12
MCP: Copy is used - not dead:   $rdi = COPY renamable $r12
MCP: Copy is used - not dead:   $rdi = COPY renamable $r12
MCP: Copy is a deletion candidate:   renamable $r13 = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph111.preheader
MCP: ForwardCopyPropagateBlock .lr.ph111.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r13
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r12
MCP: Copy is used - not dead:   $rdi = COPY renamable $r13
MCP: Copy is used - not dead:   $rdi = COPY renamable $r13
MCP: Copy is used - not dead:   $rdi = COPY renamable $r13
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r12
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r12
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r12
MCP: BackwardCopyPropagateBlock ._crit_edge112
MCP: ForwardCopyPropagateBlock ._crit_edge112
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY renamable $rcx
MCP: Copy is a deletion candidate:   renamable $r10 = COPY killed renamable $rcx
MCP: Replacing $r10
     with $rcx
     in MOV64mr %stack.16, 1, $noreg, 0, $noreg, renamable $r10 :: (store (s64) into %stack.16)
     from renamable $r10 = COPY killed renamable $rcx
MCP: After replacement: MOV64mr %stack.16, 1, $noreg, 0, $noreg, $rcx :: (store (s64) into %stack.16)

MCP: Copy is used - not dead:   $rsp = COPY renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $r10 = COPY renamable $rcx
MCP: Copy is used - not dead:   renamable $r10 = COPY renamable $rcx
MCP: Copy is used - not dead:   renamable $r10 = COPY renamable $rcx
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $rbx
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r15
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r15
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r15
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r15
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r12
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r12
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r12
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r12
******** Post-regalloc Machine LICM: main ********
***** X86 Load Value Injection (LVI) Load Hardening : main *****

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[]
 - 1: BB1[.lr.ph.preheader]
 - 2: BB2[._crit_edge]
 - 3: BB3[.lr.ph90.preheader]
 - 4: BB4[._crit_edge91]
 - 5: BB5[.lr.ph93.preheader]
 - 6: BB6[._crit_edge94]
 - 7: BB7[.lr.ph96.preheader]
 - 8: BB8[._crit_edge97]
 - 9: BB9[.lr.ph99.preheader]
 - 10: BB10[._crit_edge100]
 - 11: BB11[.lr.ph102.preheader]
 - 12: BB12[._crit_edge103]
 - 13: BB13[.lr.ph105.preheader]
 - 14: BB14[._crit_edge106]
 - 15: BB15[.lr.ph108.preheader]
 - 16: BB16[._crit_edge109]
 - 17: BB17[.lr.ph111.preheader]
 - 18: BB18[._crit_edge112]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => [ local  ] weight = 1342177280, succ = BB1[.lr.ph.preheader]
  => [ local  ] weight = 805306368, succ = BB2[._crit_edge]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB1[.lr.ph.preheader]
  => assign 6000000000000000 (0000000000000000) to BB2[._crit_edge]
 - node: BB1[.lr.ph.preheader]
  => [ local  ] weight = 2147483648, succ = BB2[._crit_edge]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB2[._crit_edge]
 - node: BB2[._crit_edge]
  => [ local  ] weight = 1342177280, succ = BB3[.lr.ph90.preheader]
  => [ local  ] weight = 805306368, succ = BB4[._crit_edge91]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB3[.lr.ph90.preheader]
  => assign 6000000000000000 (0000000000000000) to BB4[._crit_edge91]
 - node: BB3[.lr.ph90.preheader]
  => [ local  ] weight = 2147483648, succ = BB4[._crit_edge91]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB4[._crit_edge91]
 - node: BB4[._crit_edge91]
  => [ local  ] weight = 1342177280, succ = BB5[.lr.ph93.preheader]
  => [ local  ] weight = 805306368, succ = BB6[._crit_edge94]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB5[.lr.ph93.preheader]
  => assign 6000000000000000 (0000000000000000) to BB6[._crit_edge94]
 - node: BB5[.lr.ph93.preheader]
  => [ local  ] weight = 2147483648, succ = BB6[._crit_edge94]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB6[._crit_edge94]
 - node: BB6[._crit_edge94]
  => [ local  ] weight = 1342177280, succ = BB7[.lr.ph96.preheader]
  => [ local  ] weight = 805306368, succ = BB8[._crit_edge97]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB7[.lr.ph96.preheader]
  => assign 6000000000000000 (0000000000000000) to BB8[._crit_edge97]
 - node: BB7[.lr.ph96.preheader]
  => [ local  ] weight = 2147483648, succ = BB8[._crit_edge97]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB8[._crit_edge97]
 - node: BB8[._crit_edge97]
  => [ local  ] weight = 1342177280, succ = BB9[.lr.ph99.preheader]
  => [ local  ] weight = 805306368, succ = BB10[._crit_edge100]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB9[.lr.ph99.preheader]
  => assign 6000000000000000 (0000000000000000) to BB10[._crit_edge100]
 - node: BB9[.lr.ph99.preheader]
  => [ local  ] weight = 2147483648, succ = BB10[._crit_edge100]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB10[._crit_edge100]
 - node: BB10[._crit_edge100]
  => [ local  ] weight = 1342177280, succ = BB11[.lr.ph102.preheader]
  => [ local  ] weight = 805306368, succ = BB12[._crit_edge103]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB11[.lr.ph102.preheader]
  => assign 6000000000000000 (0000000000000000) to BB12[._crit_edge103]
 - node: BB11[.lr.ph102.preheader]
  => [ local  ] weight = 2147483648, succ = BB12[._crit_edge103]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB12[._crit_edge103]
 - node: BB12[._crit_edge103]
  => [ local  ] weight = 1342177280, succ = BB13[.lr.ph105.preheader]
  => [ local  ] weight = 805306368, succ = BB14[._crit_edge106]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB13[.lr.ph105.preheader]
  => assign 6000000000000000 (0000000000000000) to BB14[._crit_edge106]
 - node: BB13[.lr.ph105.preheader]
  => [ local  ] weight = 2147483648, succ = BB14[._crit_edge106]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB14[._crit_edge106]
 - node: BB14[._crit_edge106]
  => [ local  ] weight = 1342177280, succ = BB15[.lr.ph108.preheader]
  => [ local  ] weight = 805306368, succ = BB16[._crit_edge109]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB15[.lr.ph108.preheader]
  => assign 6000000000000000 (0000000000000000) to BB16[._crit_edge109]
 - node: BB15[.lr.ph108.preheader]
  => [ local  ] weight = 2147483648, succ = BB16[._crit_edge109]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB16[._crit_edge109]
 - node: BB16[._crit_edge109]
  => [ local  ] weight = 1342177280, succ = BB17[.lr.ph111.preheader]
  => [ local  ] weight = 805306368, succ = BB18[._crit_edge112]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB17[.lr.ph111.preheader]
  => assign 6000000000000000 (0000000000000000) to BB18[._crit_edge112]
 - node: BB17[.lr.ph111.preheader]
  => [ local  ] weight = 2147483648, succ = BB18[._crit_edge112]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB18[._crit_edge112]
 - node: BB18[._crit_edge112]
  => mass:  ffffffffffffffff
float-to-int: min = 0.625, max = 1.0, factor = 12.8
 - BB0[]: float = 1.0, scaled = 12.8, int = 12
 - BB1[.lr.ph.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB2[._crit_edge]: float = 1.0, scaled = 12.8, int = 12
 - BB3[.lr.ph90.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB4[._crit_edge91]: float = 1.0, scaled = 12.8, int = 12
 - BB5[.lr.ph93.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB6[._crit_edge94]: float = 1.0, scaled = 12.8, int = 12
 - BB7[.lr.ph96.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB8[._crit_edge97]: float = 1.0, scaled = 12.8, int = 12
 - BB9[.lr.ph99.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB10[._crit_edge100]: float = 1.0, scaled = 12.8, int = 12
 - BB11[.lr.ph102.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB12[._crit_edge103]: float = 1.0, scaled = 12.8, int = 12
 - BB13[.lr.ph105.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB14[._crit_edge106]: float = 1.0, scaled = 12.8, int = 12
 - BB15[.lr.ph108.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB16[._crit_edge109]: float = 1.0, scaled = 12.8, int = 12
 - BB17[.lr.ph111.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB18[._crit_edge112]: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: main
 - BB0[]: float = 1.0, int = 12
 - BB1[.lr.ph.preheader]: float = 0.625, int = 8
 - BB2[._crit_edge]: float = 1.0, int = 12
 - BB3[.lr.ph90.preheader]: float = 0.625, int = 8
 - BB4[._crit_edge91]: float = 1.0, int = 12
 - BB5[.lr.ph93.preheader]: float = 0.625, int = 8
 - BB6[._crit_edge94]: float = 1.0, int = 12
 - BB7[.lr.ph96.preheader]: float = 0.625, int = 8
 - BB8[._crit_edge97]: float = 1.0, int = 12
 - BB9[.lr.ph99.preheader]: float = 0.625, int = 8
 - BB10[._crit_edge100]: float = 1.0, int = 12
 - BB11[.lr.ph102.preheader]: float = 0.625, int = 8
 - BB12[._crit_edge103]: float = 1.0, int = 12
 - BB13[.lr.ph105.preheader]: float = 0.625, int = 8
 - BB14[._crit_edge106]: float = 1.0, int = 12
 - BB15[.lr.ph108.preheader]: float = 0.625, int = 8
 - BB16[._crit_edge109]: float = 1.0, int = 12
 - BB17[.lr.ph111.preheader]: float = 0.625, int = 8
 - BB18[._crit_edge112]: float = 1.0, int = 12

		Looking for trivial roots
Found a new trivial root: %bb.18
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 19, Num: 20
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.18
3: %bb.17
4: %bb.16
5: %bb.15
6: %bb.14
7: %bb.13
8: %bb.12
9: %bb.11
10: %bb.10
11: %bb.9
12: %bb.8
13: %bb.7
14: %bb.6
15: %bb.5
16: %bb.4
17: %bb.3
18: %bb.2
19: %bb.1
20: %bb.0
Found roots: %bb.18 
**** Analysing main
Look into: 0 
Frame instruction: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

No Shrink wrap candidate found
alloc FI(11) at SP[-64]
alloc FI(12) at SP[-72]
alloc FI(10) at SP[-80]
alloc FI(16) at SP[-88]
alloc FI(14) at SP[-96]
alloc FI(19) at SP[-104]
alloc FI(18) at SP[-112]
alloc FI(17) at SP[-120]
alloc FI(15) at SP[-128]
alloc FI(13) at SP[-136]
alloc FI(0) at SP[-176]
alloc FI(9) at SP[-176]
alloc FI(8) at SP[-176]
alloc FI(7) at SP[-176]
alloc FI(6) at SP[-176]
alloc FI(5) at SP[-176]
alloc FI(4) at SP[-176]
alloc FI(3) at SP[-176]
alloc FI(2) at SP[-176]
alloc FI(1) at SP[-176]
Found interesting instruction in %bb.0:  renamable $rax = MOV64ri @malloc
Found interesting instruction in %bb.0:  $rdi = MOV32ri64 56
Found interesting instruction in %bb.0:  renamable $rax = LEA64r $rbp, 1, $noreg, -160, $noreg
Found interesting instruction in %bb.0:  renamable $r10 = MOV64ri @read_input_sizes_2D_f64
Found interesting instruction in %bb.0:  $rdx = MOV32ri64 3
Found interesting instruction in %bb.0:  $r9 = MOV32ri64 1
Found interesting instruction in %bb.0:  $edi = MOV32ri 1
Found interesting instruction in %bb.0:  $r8 = MOV64ri32 -1
Found interesting instruction in %bb.0:  renamable $rax = MOV64ri @malloc
Found interesting instruction in %bb.0:  renamable $rax = MOV64ri &__bzero
Reusable instruction from pred(s): in %bb.1:  renamable $rax = MOV64ri &__bzero
Found interesting instruction in %bb.2:  renamable $r13 = MOV64ri @malloc
Reusable instruction from pred(s): in %bb.3:  renamable $r13 = MOV64ri @malloc
Found interesting instruction in %bb.3:  renamable $rax = MOV64ri &__bzero
Reusable instruction from pred(s): in %bb.4:  renamable $r13 = MOV64ri @malloc
Found interesting instruction in %bb.4:  renamable $r12 = MOV64ri &__bzero
Reusable instruction from pred(s): in %bb.5:  renamable $r12 = MOV64ri &__bzero
Reusable instruction from pred(s): in %bb.5:  renamable $r13 = MOV64ri @malloc
Reusable instruction from pred(s): in %bb.6:  renamable $r12 = MOV64ri &__bzero
Reusable instruction from pred(s): in %bb.6:  renamable $r13 = MOV64ri @malloc
Reusable instruction from pred(s): in %bb.7:  renamable $r12 = MOV64ri &__bzero
Reusable instruction from pred(s): in %bb.7:  renamable $r13 = MOV64ri @malloc
Reusable instruction from pred(s): in %bb.8:  renamable $r12 = MOV64ri &__bzero
Reusable instruction from pred(s): in %bb.8:  renamable $r13 = MOV64ri @malloc
Reusable instruction from pred(s): in %bb.9:  renamable $r12 = MOV64ri &__bzero
Reusable instruction from pred(s): in %bb.9:  renamable $r13 = MOV64ri @malloc
Reusable instruction from pred(s): in %bb.10:  renamable $r12 = MOV64ri &__bzero
Reusable instruction from pred(s): in %bb.10:  renamable $r13 = MOV64ri @malloc
Reusable instruction from pred(s): in %bb.11:  renamable $r12 = MOV64ri &__bzero
Reusable instruction from pred(s): in %bb.11:  renamable $r13 = MOV64ri @malloc
Reusable instruction from pred(s): in %bb.12:  renamable $r12 = MOV64ri &__bzero
Reusable instruction from pred(s): in %bb.12:  renamable $r13 = MOV64ri @malloc
Reusable instruction from pred(s): in %bb.13:  renamable $r12 = MOV64ri &__bzero
Reusable instruction from pred(s): in %bb.13:  renamable $r13 = MOV64ri @malloc
Reusable instruction from pred(s): in %bb.14:  renamable $r12 = MOV64ri &__bzero
Reusable instruction from pred(s): in %bb.14:  renamable $r13 = MOV64ri @malloc
Reusable instruction from pred(s): in %bb.15:  renamable $r13 = MOV64ri @malloc
Found interesting instruction in %bb.15:  renamable $rax = MOV64ri &__bzero
Reusable instruction from pred(s): in %bb.16:  renamable $r13 = MOV64ri @malloc
Found interesting instruction in %bb.17:  renamable $rax = MOV64ri &__bzero
Found interesting instruction in %bb.18:  renamable $rax = MOV64ri @read_input_2D_f64
Found interesting instruction in %bb.18:  $rdx = MOV32ri64 3
Found interesting instruction in %bb.18:  $r9 = MOV32ri64 1
Found interesting instruction in %bb.18:  $edi = MOV32ri 1
Found interesting instruction in %bb.18:  $r8 = MOV64ri32 -1
Found interesting instruction in %bb.18:  renamable $r13 = MOV64ri @comet_print_memref_i64
Found interesting instruction in %bb.18:  $rdi = MOV32ri64 1
Found interesting instruction in %bb.18:  $rdi = MOV32ri64 1
Found interesting instruction in %bb.18:  $rdi = MOV32ri64 1
Found interesting instruction in %bb.18:  $rdi = MOV32ri64 1
Found interesting instruction in %bb.18:  $rdi = MOV32ri64 1
Found interesting instruction in %bb.18:  $rdi = MOV32ri64 1
Found interesting instruction in %bb.18:  $rdi = MOV32ri64 1
Found interesting instruction in %bb.18:  $rdi = MOV32ri64 1
Found interesting instruction in %bb.18:  renamable $rax = MOV64ri @comet_print_memref_f64
Found interesting instruction in %bb.18:  $rdi = MOV32ri64 1
Found interesting instruction in %bb.18:  $rsp = LEA64r $rbp, 1, $noreg, -40, $noreg

TryTailMergeBlocks: %bb.0, %bb.1
  with successor %bb.2
  which has fall-through from %bb.1
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.2, %bb.3
  with successor %bb.4
  which has fall-through from %bb.3
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.4, %bb.5
  with successor %bb.6
  which has fall-through from %bb.5
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.6, %bb.7
  with successor %bb.8
  which has fall-through from %bb.7
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.8, %bb.9
  with successor %bb.10
  which has fall-through from %bb.9
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.10, %bb.11
  with successor %bb.12
  which has fall-through from %bb.11
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.12, %bb.13
  with successor %bb.14
  which has fall-through from %bb.13
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.14, %bb.15
  with successor %bb.16
  which has fall-through from %bb.15
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.16, %bb.17
  with successor %bb.18
  which has fall-through from %bb.17
Looking for common tails of at least 3 instructions
MCP: BackwardCopyPropagateBlock 
MCP: ForwardCopyPropagateBlock 
MCP: Copy is a deletion candidate:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is a deletion candidate:   renamable $rbx = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph.preheader
MCP: ForwardCopyPropagateBlock .lr.ph.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $rbx
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: BackwardCopyPropagateBlock ._crit_edge
MCP: ForwardCopyPropagateBlock ._crit_edge
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is a deletion candidate:   renamable $rbx = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph90.preheader
MCP: ForwardCopyPropagateBlock .lr.ph90.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $rbx
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: BackwardCopyPropagateBlock ._crit_edge91
MCP: ForwardCopyPropagateBlock ._crit_edge91
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is a deletion candidate:   renamable $rbx = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph93.preheader
MCP: ForwardCopyPropagateBlock .lr.ph93.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $rbx
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: BackwardCopyPropagateBlock ._crit_edge94
MCP: ForwardCopyPropagateBlock ._crit_edge94
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is a deletion candidate:   renamable $rbx = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph96.preheader
MCP: ForwardCopyPropagateBlock .lr.ph96.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $rbx
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: BackwardCopyPropagateBlock ._crit_edge97
MCP: ForwardCopyPropagateBlock ._crit_edge97
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is a deletion candidate:   renamable $rbx = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph99.preheader
MCP: ForwardCopyPropagateBlock .lr.ph99.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $rbx
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: BackwardCopyPropagateBlock ._crit_edge100
MCP: ForwardCopyPropagateBlock ._crit_edge100
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is a deletion candidate:   renamable $r14 = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph102.preheader
MCP: ForwardCopyPropagateBlock .lr.ph102.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r14
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $rbx
MCP: BackwardCopyPropagateBlock ._crit_edge103
MCP: ForwardCopyPropagateBlock ._crit_edge103
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r14
MCP: Copy is a deletion candidate:   renamable $r15 = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph105.preheader
MCP: ForwardCopyPropagateBlock .lr.ph105.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r15
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY renamable $r15
MCP: Copy is used - not dead:   $rdi = COPY renamable $r15
MCP: Copy is used - not dead:   $rdi = COPY renamable $r15
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: BackwardCopyPropagateBlock ._crit_edge106
MCP: ForwardCopyPropagateBlock ._crit_edge106
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r15
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY killed renamable $rcx
MCP: Copy is used - not dead:   $rdi = COPY renamable $r15
MCP: Copy is used - not dead:   $rdi = COPY renamable $r15
MCP: Copy is used - not dead:   $rdi = COPY renamable $r15
MCP: Copy is a deletion candidate:   renamable $r12 = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph108.preheader
MCP: ForwardCopyPropagateBlock .lr.ph108.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r12
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r15
MCP: Copy is used - not dead:   $rdi = COPY renamable $r12
MCP: Copy is used - not dead:   $rdi = COPY renamable $r12
MCP: Copy is used - not dead:   $rdi = COPY renamable $r12
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r15
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r15
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r15
MCP: BackwardCopyPropagateBlock ._crit_edge109
MCP: ForwardCopyPropagateBlock ._crit_edge109
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY renamable $r15
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r12
MCP: Copy is used - not dead:   $rsp = COPY renamable $r15
MCP: Copy is used - not dead:   $rsp = COPY renamable $r15
MCP: Copy is used - not dead:   $rsp = COPY renamable $r15
MCP: Copy is used - not dead:   $rdi = COPY renamable $r12
MCP: Copy is used - not dead:   $rdi = COPY renamable $r12
MCP: Copy is used - not dead:   $rdi = COPY renamable $r12
MCP: Copy is a deletion candidate:   renamable $r13 = COPY $rax
MCP: BackwardCopyPropagateBlock .lr.ph111.preheader
MCP: ForwardCopyPropagateBlock .lr.ph111.preheader
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $r13
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r12
MCP: Copy is used - not dead:   $rdi = COPY renamable $r13
MCP: Copy is used - not dead:   $rdi = COPY renamable $r13
MCP: Copy is used - not dead:   $rdi = COPY renamable $r13
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r12
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r12
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r12
MCP: BackwardCopyPropagateBlock ._crit_edge112
MCP: ForwardCopyPropagateBlock ._crit_edge112
MCP: Copy is a deletion candidate:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is a deletion candidate:   $rsp = COPY renamable $rcx
MCP: Copy is a deletion candidate:   renamable $r10 = COPY renamable $rcx
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   renamable $rax = COPY $rsp
MCP: Copy is used - not dead:   $rsp = COPY renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY renamable $rcx
MCP: Copy is used - not dead:   $rsp = COPY renamable $rcx
MCP: Copy is used - not dead:   renamable $r10 = COPY renamable $rcx
MCP: Copy is used - not dead:   renamable $r10 = COPY renamable $rcx
MCP: Copy is used - not dead:   renamable $r10 = COPY renamable $rcx
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $rbx
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r14
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r15
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r15
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r15
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r15
MCP: Copy is a deletion candidate:   $rsi = COPY killed renamable $r12
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r12
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r12
MCP: Copy is used - not dead:   $rsi = COPY killed renamable $r12
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: main
real copy:   renamable $rbx = COPY $rax
replaced by: $rbx = MOV64rr $rax
real copy:   $rdi = COPY renamable $r14
replaced by: $rdi = MOV64rr $r14
real copy:   renamable $rbx = COPY $rax
replaced by: $rbx = MOV64rr $rax
real copy:   $rdi = COPY renamable $rbx
replaced by: $rdi = MOV64rr $rbx
real copy:   $rsi = COPY killed renamable $r14
replaced by: $rsi = MOV64rr killed $r14
real copy:   renamable $rax = COPY $rsp
replaced by: $rax = MOV64rr $rsp
real copy:   $rsp = COPY killed renamable $rcx
replaced by: $rsp = MOV64rr killed $rcx
real copy:   $rdi = COPY renamable $r14
replaced by: $rdi = MOV64rr $r14
real copy:   renamable $rbx = COPY $rax
replaced by: $rbx = MOV64rr $rax
real copy:   $rdi = COPY renamable $rbx
replaced by: $rdi = MOV64rr $rbx
real copy:   $rsi = COPY killed renamable $r14
replaced by: $rsi = MOV64rr killed $r14
real copy:   renamable $rax = COPY $rsp
replaced by: $rax = MOV64rr $rsp
real copy:   $rsp = COPY killed renamable $rcx
replaced by: $rsp = MOV64rr killed $rcx
real copy:   $rdi = COPY renamable $r14
replaced by: $rdi = MOV64rr $r14
real copy:   renamable $rbx = COPY $rax
replaced by: $rbx = MOV64rr $rax
real copy:   $rdi = COPY renamable $rbx
replaced by: $rdi = MOV64rr $rbx
real copy:   $rsi = COPY killed renamable $r14
replaced by: $rsi = MOV64rr killed $r14
real copy:   renamable $rax = COPY $rsp
replaced by: $rax = MOV64rr $rsp
real copy:   $rsp = COPY killed renamable $rcx
replaced by: $rsp = MOV64rr killed $rcx
real copy:   $rdi = COPY renamable $r14
replaced by: $rdi = MOV64rr $r14
real copy:   renamable $rbx = COPY $rax
replaced by: $rbx = MOV64rr $rax
real copy:   $rdi = COPY renamable $rbx
replaced by: $rdi = MOV64rr $rbx
real copy:   $rsi = COPY killed renamable $r14
replaced by: $rsi = MOV64rr killed $r14
real copy:   renamable $rax = COPY $rsp
replaced by: $rax = MOV64rr $rsp
real copy:   $rsp = COPY killed renamable $rcx
replaced by: $rsp = MOV64rr killed $rcx
real copy:   $rdi = COPY renamable $r14
replaced by: $rdi = MOV64rr $r14
real copy:   renamable $rbx = COPY $rax
replaced by: $rbx = MOV64rr $rax
real copy:   $rdi = COPY renamable $rbx
replaced by: $rdi = MOV64rr $rbx
real copy:   $rsi = COPY killed renamable $r14
replaced by: $rsi = MOV64rr killed $r14
real copy:   renamable $rax = COPY $rsp
replaced by: $rax = MOV64rr $rsp
real copy:   $rsp = COPY killed renamable $rcx
replaced by: $rsp = MOV64rr killed $rcx
real copy:   $rdi = COPY renamable $rbx
replaced by: $rdi = MOV64rr $rbx
real copy:   renamable $r14 = COPY $rax
replaced by: $r14 = MOV64rr $rax
real copy:   $rdi = COPY renamable $r14
replaced by: $rdi = MOV64rr $r14
real copy:   $rsi = COPY killed renamable $rbx
replaced by: $rsi = MOV64rr killed $rbx
real copy:   renamable $rax = COPY $rsp
replaced by: $rax = MOV64rr $rsp
real copy:   $rsp = COPY killed renamable $rcx
replaced by: $rsp = MOV64rr killed $rcx
real copy:   $rdi = COPY renamable $r14
replaced by: $rdi = MOV64rr $r14
real copy:   renamable $r15 = COPY $rax
replaced by: $r15 = MOV64rr $rax
real copy:   $rdi = COPY renamable $r15
replaced by: $rdi = MOV64rr $r15
real copy:   $rsi = COPY killed renamable $r14
replaced by: $rsi = MOV64rr killed $r14
real copy:   renamable $rax = COPY $rsp
replaced by: $rax = MOV64rr $rsp
real copy:   $rsp = COPY killed renamable $rcx
replaced by: $rsp = MOV64rr killed $rcx
real copy:   $rdi = COPY renamable $r15
replaced by: $rdi = MOV64rr $r15
real copy:   renamable $r12 = COPY $rax
replaced by: $r12 = MOV64rr $rax
real copy:   $rdi = COPY renamable $r12
replaced by: $rdi = MOV64rr $r12
real copy:   $rsi = COPY killed renamable $r15
replaced by: $rsi = MOV64rr killed $r15
real copy:   renamable $rax = COPY $rsp
replaced by: $rax = MOV64rr $rsp
real copy:   $rsp = COPY renamable $r15
replaced by: $rsp = MOV64rr $r15
real copy:   $rdi = COPY renamable $r12
replaced by: $rdi = MOV64rr $r12
real copy:   renamable $r13 = COPY $rax
replaced by: $r13 = MOV64rr $rax
real copy:   $rdi = COPY renamable $r13
replaced by: $rdi = MOV64rr $r13
real copy:   $rsi = COPY killed renamable $r12
replaced by: $rsi = MOV64rr killed $r12
real copy:   renamable $rax = COPY $rsp
replaced by: $rax = MOV64rr $rsp
real copy:   $rsp = COPY renamable $rcx
replaced by: $rsp = MOV64rr $rcx
real copy:   renamable $r10 = COPY renamable $rcx
replaced by: $r10 = MOV64rr $rcx
real copy:   $rsi = COPY killed renamable $rbx
replaced by: $rsi = MOV64rr killed $rbx
real copy:   $rsi = COPY killed renamable $r14
replaced by: $rsi = MOV64rr killed $r14
real copy:   $rsi = COPY killed renamable $r15
replaced by: $rsi = MOV64rr killed $r15
real copy:   $rsi = COPY killed renamable $r12
replaced by: $rsi = MOV64rr killed $r12

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[]
 - 1: BB1[.lr.ph.preheader]
 - 2: BB2[._crit_edge]
 - 3: BB3[.lr.ph90.preheader]
 - 4: BB4[._crit_edge91]
 - 5: BB5[.lr.ph93.preheader]
 - 6: BB6[._crit_edge94]
 - 7: BB7[.lr.ph96.preheader]
 - 8: BB8[._crit_edge97]
 - 9: BB9[.lr.ph99.preheader]
 - 10: BB10[._crit_edge100]
 - 11: BB11[.lr.ph102.preheader]
 - 12: BB12[._crit_edge103]
 - 13: BB13[.lr.ph105.preheader]
 - 14: BB14[._crit_edge106]
 - 15: BB15[.lr.ph108.preheader]
 - 16: BB16[._crit_edge109]
 - 17: BB17[.lr.ph111.preheader]
 - 18: BB18[._crit_edge112]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => [ local  ] weight = 1342177280, succ = BB1[.lr.ph.preheader]
  => [ local  ] weight = 805306368, succ = BB2[._crit_edge]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB1[.lr.ph.preheader]
  => assign 6000000000000000 (0000000000000000) to BB2[._crit_edge]
 - node: BB1[.lr.ph.preheader]
  => [ local  ] weight = 2147483648, succ = BB2[._crit_edge]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB2[._crit_edge]
 - node: BB2[._crit_edge]
  => [ local  ] weight = 1342177280, succ = BB3[.lr.ph90.preheader]
  => [ local  ] weight = 805306368, succ = BB4[._crit_edge91]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB3[.lr.ph90.preheader]
  => assign 6000000000000000 (0000000000000000) to BB4[._crit_edge91]
 - node: BB3[.lr.ph90.preheader]
  => [ local  ] weight = 2147483648, succ = BB4[._crit_edge91]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB4[._crit_edge91]
 - node: BB4[._crit_edge91]
  => [ local  ] weight = 1342177280, succ = BB5[.lr.ph93.preheader]
  => [ local  ] weight = 805306368, succ = BB6[._crit_edge94]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB5[.lr.ph93.preheader]
  => assign 6000000000000000 (0000000000000000) to BB6[._crit_edge94]
 - node: BB5[.lr.ph93.preheader]
  => [ local  ] weight = 2147483648, succ = BB6[._crit_edge94]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB6[._crit_edge94]
 - node: BB6[._crit_edge94]
  => [ local  ] weight = 1342177280, succ = BB7[.lr.ph96.preheader]
  => [ local  ] weight = 805306368, succ = BB8[._crit_edge97]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB7[.lr.ph96.preheader]
  => assign 6000000000000000 (0000000000000000) to BB8[._crit_edge97]
 - node: BB7[.lr.ph96.preheader]
  => [ local  ] weight = 2147483648, succ = BB8[._crit_edge97]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB8[._crit_edge97]
 - node: BB8[._crit_edge97]
  => [ local  ] weight = 1342177280, succ = BB9[.lr.ph99.preheader]
  => [ local  ] weight = 805306368, succ = BB10[._crit_edge100]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB9[.lr.ph99.preheader]
  => assign 6000000000000000 (0000000000000000) to BB10[._crit_edge100]
 - node: BB9[.lr.ph99.preheader]
  => [ local  ] weight = 2147483648, succ = BB10[._crit_edge100]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB10[._crit_edge100]
 - node: BB10[._crit_edge100]
  => [ local  ] weight = 1342177280, succ = BB11[.lr.ph102.preheader]
  => [ local  ] weight = 805306368, succ = BB12[._crit_edge103]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB11[.lr.ph102.preheader]
  => assign 6000000000000000 (0000000000000000) to BB12[._crit_edge103]
 - node: BB11[.lr.ph102.preheader]
  => [ local  ] weight = 2147483648, succ = BB12[._crit_edge103]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB12[._crit_edge103]
 - node: BB12[._crit_edge103]
  => [ local  ] weight = 1342177280, succ = BB13[.lr.ph105.preheader]
  => [ local  ] weight = 805306368, succ = BB14[._crit_edge106]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB13[.lr.ph105.preheader]
  => assign 6000000000000000 (0000000000000000) to BB14[._crit_edge106]
 - node: BB13[.lr.ph105.preheader]
  => [ local  ] weight = 2147483648, succ = BB14[._crit_edge106]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB14[._crit_edge106]
 - node: BB14[._crit_edge106]
  => [ local  ] weight = 1342177280, succ = BB15[.lr.ph108.preheader]
  => [ local  ] weight = 805306368, succ = BB16[._crit_edge109]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB15[.lr.ph108.preheader]
  => assign 6000000000000000 (0000000000000000) to BB16[._crit_edge109]
 - node: BB15[.lr.ph108.preheader]
  => [ local  ] weight = 2147483648, succ = BB16[._crit_edge109]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB16[._crit_edge109]
 - node: BB16[._crit_edge109]
  => [ local  ] weight = 1342177280, succ = BB17[.lr.ph111.preheader]
  => [ local  ] weight = 805306368, succ = BB18[._crit_edge112]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB17[.lr.ph111.preheader]
  => assign 6000000000000000 (0000000000000000) to BB18[._crit_edge112]
 - node: BB17[.lr.ph111.preheader]
  => [ local  ] weight = 2147483648, succ = BB18[._crit_edge112]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB18[._crit_edge112]
 - node: BB18[._crit_edge112]
  => mass:  ffffffffffffffff
float-to-int: min = 0.625, max = 1.0, factor = 12.8
 - BB0[]: float = 1.0, scaled = 12.8, int = 12
 - BB1[.lr.ph.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB2[._crit_edge]: float = 1.0, scaled = 12.8, int = 12
 - BB3[.lr.ph90.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB4[._crit_edge91]: float = 1.0, scaled = 12.8, int = 12
 - BB5[.lr.ph93.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB6[._crit_edge94]: float = 1.0, scaled = 12.8, int = 12
 - BB7[.lr.ph96.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB8[._crit_edge97]: float = 1.0, scaled = 12.8, int = 12
 - BB9[.lr.ph99.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB10[._crit_edge100]: float = 1.0, scaled = 12.8, int = 12
 - BB11[.lr.ph102.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB12[._crit_edge103]: float = 1.0, scaled = 12.8, int = 12
 - BB13[.lr.ph105.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB14[._crit_edge106]: float = 1.0, scaled = 12.8, int = 12
 - BB15[.lr.ph108.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB16[._crit_edge109]: float = 1.0, scaled = 12.8, int = 12
 - BB17[.lr.ph111.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB18[._crit_edge112]: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: main
 - BB0[]: float = 1.0, int = 12
 - BB1[.lr.ph.preheader]: float = 0.625, int = 8
 - BB2[._crit_edge]: float = 1.0, int = 12
 - BB3[.lr.ph90.preheader]: float = 0.625, int = 8
 - BB4[._crit_edge91]: float = 1.0, int = 12
 - BB5[.lr.ph93.preheader]: float = 0.625, int = 8
 - BB6[._crit_edge94]: float = 1.0, int = 12
 - BB7[.lr.ph96.preheader]: float = 0.625, int = 8
 - BB8[._crit_edge97]: float = 1.0, int = 12
 - BB9[.lr.ph99.preheader]: float = 0.625, int = 8
 - BB10[._crit_edge100]: float = 1.0, int = 12
 - BB11[.lr.ph102.preheader]: float = 0.625, int = 8
 - BB12[._crit_edge103]: float = 1.0, int = 12
 - BB13[.lr.ph105.preheader]: float = 0.625, int = 8
 - BB14[._crit_edge106]: float = 1.0, int = 12
 - BB15[.lr.ph108.preheader]: float = 0.625, int = 8
 - BB16[._crit_edge109]: float = 1.0, int = 12
 - BB17[.lr.ph111.preheader]: float = 0.625, int = 8
 - BB18[._crit_edge112]: float = 1.0, int = 12

		Looking for trivial roots
Found a new trivial root: %bb.18
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 19, Num: 20
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.18
3: %bb.17
4: %bb.16
5: %bb.15
6: %bb.14
7: %bb.13
8: %bb.12
9: %bb.11
10: %bb.10
11: %bb.9
12: %bb.8
13: %bb.7
14: %bb.6
15: %bb.5
16: %bb.4
17: %bb.3
18: %bb.2
19: %bb.1
20: %bb.0
Found roots: %bb.18 
Pre-computing triangle chains.
Selecting best successor for: %bb.0 ('')
    Candidate: %bb.1 ('.lr.ph.preheader'), probability: 0x50000000 / 0x80000000 = 62.50%
    Setting it as best candidate
    Not a candidate: %bb.2 ('._crit_edge') -> 0x30000000 / 0x80000000 = 37.50% (prob) (non-cold CFG conflict)
    Selected: %bb.1 ('.lr.ph.preheader')
Merging from %bb.0 ('') to %bb.1 ('.lr.ph.preheader')
Selecting best successor for: %bb.1 ('.lr.ph.preheader')
    Candidate: %bb.2 ('._crit_edge'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.2 ('._crit_edge')
Merging from %bb.1 ('.lr.ph.preheader') to %bb.2 ('._crit_edge')
Selecting best successor for: %bb.2 ('._crit_edge')
    Candidate: %bb.3 ('.lr.ph90.preheader'), probability: 0x50000000 / 0x80000000 = 62.50%
    Setting it as best candidate
    Not a candidate: %bb.4 ('._crit_edge91') -> 0x30000000 / 0x80000000 = 37.50% (prob) (non-cold CFG conflict)
    Selected: %bb.3 ('.lr.ph90.preheader')
Merging from %bb.2 ('._crit_edge') to %bb.3 ('.lr.ph90.preheader')
Selecting best successor for: %bb.3 ('.lr.ph90.preheader')
    Candidate: %bb.4 ('._crit_edge91'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.4 ('._crit_edge91')
Merging from %bb.3 ('.lr.ph90.preheader') to %bb.4 ('._crit_edge91')
Selecting best successor for: %bb.4 ('._crit_edge91')
    Candidate: %bb.5 ('.lr.ph93.preheader'), probability: 0x50000000 / 0x80000000 = 62.50%
    Setting it as best candidate
    Not a candidate: %bb.6 ('._crit_edge94') -> 0x30000000 / 0x80000000 = 37.50% (prob) (non-cold CFG conflict)
    Selected: %bb.5 ('.lr.ph93.preheader')
Merging from %bb.4 ('._crit_edge91') to %bb.5 ('.lr.ph93.preheader')
Selecting best successor for: %bb.5 ('.lr.ph93.preheader')
    Candidate: %bb.6 ('._crit_edge94'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.6 ('._crit_edge94')
Merging from %bb.5 ('.lr.ph93.preheader') to %bb.6 ('._crit_edge94')
Selecting best successor for: %bb.6 ('._crit_edge94')
    Candidate: %bb.7 ('.lr.ph96.preheader'), probability: 0x50000000 / 0x80000000 = 62.50%
    Setting it as best candidate
    Not a candidate: %bb.8 ('._crit_edge97') -> 0x30000000 / 0x80000000 = 37.50% (prob) (non-cold CFG conflict)
    Selected: %bb.7 ('.lr.ph96.preheader')
Merging from %bb.6 ('._crit_edge94') to %bb.7 ('.lr.ph96.preheader')
Selecting best successor for: %bb.7 ('.lr.ph96.preheader')
    Candidate: %bb.8 ('._crit_edge97'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.8 ('._crit_edge97')
Merging from %bb.7 ('.lr.ph96.preheader') to %bb.8 ('._crit_edge97')
Selecting best successor for: %bb.8 ('._crit_edge97')
    Candidate: %bb.9 ('.lr.ph99.preheader'), probability: 0x50000000 / 0x80000000 = 62.50%
    Setting it as best candidate
    Not a candidate: %bb.10 ('._crit_edge100') -> 0x30000000 / 0x80000000 = 37.50% (prob) (non-cold CFG conflict)
    Selected: %bb.9 ('.lr.ph99.preheader')
Merging from %bb.8 ('._crit_edge97') to %bb.9 ('.lr.ph99.preheader')
Selecting best successor for: %bb.9 ('.lr.ph99.preheader')
    Candidate: %bb.10 ('._crit_edge100'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.10 ('._crit_edge100')
Merging from %bb.9 ('.lr.ph99.preheader') to %bb.10 ('._crit_edge100')
Selecting best successor for: %bb.10 ('._crit_edge100')
    Candidate: %bb.11 ('.lr.ph102.preheader'), probability: 0x50000000 / 0x80000000 = 62.50%
    Setting it as best candidate
    Not a candidate: %bb.12 ('._crit_edge103') -> 0x30000000 / 0x80000000 = 37.50% (prob) (non-cold CFG conflict)
    Selected: %bb.11 ('.lr.ph102.preheader')
Merging from %bb.10 ('._crit_edge100') to %bb.11 ('.lr.ph102.preheader')
Selecting best successor for: %bb.11 ('.lr.ph102.preheader')
    Candidate: %bb.12 ('._crit_edge103'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.12 ('._crit_edge103')
Merging from %bb.11 ('.lr.ph102.preheader') to %bb.12 ('._crit_edge103')
Selecting best successor for: %bb.12 ('._crit_edge103')
    Candidate: %bb.13 ('.lr.ph105.preheader'), probability: 0x50000000 / 0x80000000 = 62.50%
    Setting it as best candidate
    Not a candidate: %bb.14 ('._crit_edge106') -> 0x30000000 / 0x80000000 = 37.50% (prob) (non-cold CFG conflict)
    Selected: %bb.13 ('.lr.ph105.preheader')
Merging from %bb.12 ('._crit_edge103') to %bb.13 ('.lr.ph105.preheader')
Selecting best successor for: %bb.13 ('.lr.ph105.preheader')
    Candidate: %bb.14 ('._crit_edge106'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.14 ('._crit_edge106')
Merging from %bb.13 ('.lr.ph105.preheader') to %bb.14 ('._crit_edge106')
Selecting best successor for: %bb.14 ('._crit_edge106')
    Candidate: %bb.15 ('.lr.ph108.preheader'), probability: 0x50000000 / 0x80000000 = 62.50%
    Setting it as best candidate
    Not a candidate: %bb.16 ('._crit_edge109') -> 0x30000000 / 0x80000000 = 37.50% (prob) (non-cold CFG conflict)
    Selected: %bb.15 ('.lr.ph108.preheader')
Merging from %bb.14 ('._crit_edge106') to %bb.15 ('.lr.ph108.preheader')
Selecting best successor for: %bb.15 ('.lr.ph108.preheader')
    Candidate: %bb.16 ('._crit_edge109'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.16 ('._crit_edge109')
Merging from %bb.15 ('.lr.ph108.preheader') to %bb.16 ('._crit_edge109')
Selecting best successor for: %bb.16 ('._crit_edge109')
    Candidate: %bb.17 ('.lr.ph111.preheader'), probability: 0x50000000 / 0x80000000 = 62.50%
    Setting it as best candidate
    Not a candidate: %bb.18 ('._crit_edge112') -> 0x30000000 / 0x80000000 = 37.50% (prob) (non-cold CFG conflict)
    Selected: %bb.17 ('.lr.ph111.preheader')
Merging from %bb.16 ('._crit_edge109') to %bb.17 ('.lr.ph111.preheader')
Selecting best successor for: %bb.17 ('.lr.ph111.preheader')
    Candidate: %bb.18 ('._crit_edge112'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.18 ('._crit_edge112')
Merging from %bb.17 ('.lr.ph111.preheader') to %bb.18 ('._crit_edge112')
Selecting best successor for: %bb.18 ('._crit_edge112')
Finished forming chain for header block %bb.0 ('')
[MBP] Function: main
Placing chain %bb.0 ('')
          ... %bb.1 ('.lr.ph.preheader')
Updating terminators on %bb.0
          ... %bb.2 ('._crit_edge')
Updating terminators on %bb.1
          ... %bb.3 ('.lr.ph90.preheader')
Updating terminators on %bb.2
          ... %bb.4 ('._crit_edge91')
Updating terminators on %bb.3
          ... %bb.5 ('.lr.ph93.preheader')
Updating terminators on %bb.4
          ... %bb.6 ('._crit_edge94')
Updating terminators on %bb.5
          ... %bb.7 ('.lr.ph96.preheader')
Updating terminators on %bb.6
          ... %bb.8 ('._crit_edge97')
Updating terminators on %bb.7
          ... %bb.9 ('.lr.ph99.preheader')
Updating terminators on %bb.8
          ... %bb.10 ('._crit_edge100')
Updating terminators on %bb.9
          ... %bb.11 ('.lr.ph102.preheader')
Updating terminators on %bb.10
          ... %bb.12 ('._crit_edge103')
Updating terminators on %bb.11
          ... %bb.13 ('.lr.ph105.preheader')
Updating terminators on %bb.12
          ... %bb.14 ('._crit_edge106')
Updating terminators on %bb.13
          ... %bb.15 ('.lr.ph108.preheader')
Updating terminators on %bb.14
          ... %bb.16 ('._crit_edge109')
Updating terminators on %bb.15
          ... %bb.17 ('.lr.ph111.preheader')
Updating terminators on %bb.16
          ... %bb.18 ('._crit_edge112')
Updating terminators on %bb.17

TryTailMergeBlocks: %bb.0, %bb.1
  with successor %bb.2
  which has fall-through from %bb.1
Looking for common tails of at least 5 instructions

TryTailMergeBlocks: %bb.2, %bb.3
  with successor %bb.4
  which has fall-through from %bb.3
Looking for common tails of at least 5 instructions

TryTailMergeBlocks: %bb.4, %bb.5
  with successor %bb.6
  which has fall-through from %bb.5
Looking for common tails of at least 5 instructions

TryTailMergeBlocks: %bb.6, %bb.7
  with successor %bb.8
  which has fall-through from %bb.7
Looking for common tails of at least 5 instructions

TryTailMergeBlocks: %bb.8, %bb.9
  with successor %bb.10
  which has fall-through from %bb.9
Looking for common tails of at least 5 instructions

TryTailMergeBlocks: %bb.10, %bb.11
  with successor %bb.12
  which has fall-through from %bb.11
Looking for common tails of at least 5 instructions

TryTailMergeBlocks: %bb.12, %bb.13
  with successor %bb.14
  which has fall-through from %bb.13
Looking for common tails of at least 5 instructions

TryTailMergeBlocks: %bb.14, %bb.15
  with successor %bb.16
  which has fall-through from %bb.15
Looking for common tails of at least 5 instructions

TryTailMergeBlocks: %bb.16, %bb.17
  with successor %bb.18
  which has fall-through from %bb.17
Looking for common tails of at least 5 instructions
********** REACHING DEFINITION ANALYSIS **********
%bb.0: all preds known
%bb.0: entry
SPL:	0	frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
SPH:	0	frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
HSP:	0	frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
BPL:	3	$rbp = frame-setup MOV64rr $rsp
BPH:	3	$rbp = frame-setup MOV64rr $rsp
HBP:	3	$rbp = frame-setup MOV64rr $rsp
SPL:	5	frame-setup PUSH64r killed $r15, implicit-def $rsp, implicit $rsp
SPH:	5	frame-setup PUSH64r killed $r15, implicit-def $rsp, implicit $rsp
HSP:	5	frame-setup PUSH64r killed $r15, implicit-def $rsp, implicit $rsp
SPL:	6	frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
SPH:	6	frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
HSP:	6	frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
SPL:	7	frame-setup PUSH64r killed $r13, implicit-def $rsp, implicit $rsp
SPH:	7	frame-setup PUSH64r killed $r13, implicit-def $rsp, implicit $rsp
HSP:	7	frame-setup PUSH64r killed $r13, implicit-def $rsp, implicit $rsp
SPL:	8	frame-setup PUSH64r killed $r12, implicit-def $rsp, implicit $rsp
SPH:	8	frame-setup PUSH64r killed $r12, implicit-def $rsp, implicit $rsp
HSP:	8	frame-setup PUSH64r killed $r12, implicit-def $rsp, implicit $rsp
SPL:	9	frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
SPH:	9	frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
HSP:	9	frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
SPL:	10	$rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 120, implicit-def dead $eflags
SPH:	10	$rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 120, implicit-def dead $eflags
HSP:	10	$rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 120, implicit-def dead $eflags
EFLAGS:	10	$rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 120, implicit-def dead $eflags
AH:	16	renamable $rax = MOV64ri @malloc
AL:	16	renamable $rax = MOV64ri @malloc
HAX:	16	renamable $rax = MOV64ri @malloc
DIL:	17	$edi = MOV32ri 56, implicit-def $rdi
DIH:	17	$edi = MOV32ri 56, implicit-def $rdi
HDI:	17	$edi = MOV32ri 56, implicit-def $rdi
DIL:	17	$edi = MOV32ri 56, implicit-def $rdi
DIH:	17	$edi = MOV32ri 56, implicit-def $rdi
HDI:	17	$edi = MOV32ri 56, implicit-def $rdi
SPL:	18	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SPH:	18	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HSP:	18	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SSP:	18	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AH:	18	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AL:	18	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HAX:	18	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
BH:	19	$rbx = MOV64rr $rax
BL:	19	$rbx = MOV64rr $rax
HBX:	19	$rbx = MOV64rr $rax
AH:	25	renamable $rax = LEA64r $rbp, 1, $noreg, -160, $noreg
AL:	25	renamable $rax = LEA64r $rbp, 1, $noreg, -160, $noreg
HAX:	25	renamable $rax = LEA64r $rbp, 1, $noreg, -160, $noreg
R10B:	26	renamable $r10 = MOV64ri @read_input_sizes_2D_f64
R10BH:	26	renamable $r10 = MOV64ri @read_input_sizes_2D_f64
R10WH:	26	renamable $r10 = MOV64ri @read_input_sizes_2D_f64
DH:	27	$edx = MOV32ri 3, implicit-def $rdx
DL:	27	$edx = MOV32ri 3, implicit-def $rdx
HDX:	27	$edx = MOV32ri 3, implicit-def $rdx
DH:	27	$edx = MOV32ri 3, implicit-def $rdx
DL:	27	$edx = MOV32ri 3, implicit-def $rdx
HDX:	27	$edx = MOV32ri 3, implicit-def $rdx
R9B:	28	$r9d = MOV32ri 1, implicit-def $r9
R9BH:	28	$r9d = MOV32ri 1, implicit-def $r9
R9WH:	28	$r9d = MOV32ri 1, implicit-def $r9
R9B:	28	$r9d = MOV32ri 1, implicit-def $r9
R9BH:	28	$r9d = MOV32ri 1, implicit-def $r9
R9WH:	28	$r9d = MOV32ri 1, implicit-def $r9
DIL:	29	$edi = MOV32ri 1
DIH:	29	$edi = MOV32ri 1
HDI:	29	$edi = MOV32ri 1
SIL:	30	dead $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags, implicit-def $rsi
SIH:	30	dead $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags, implicit-def $rsi
HSI:	30	dead $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags, implicit-def $rsi
EFLAGS:	30	dead $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags, implicit-def $rsi
SIL:	30	dead $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags, implicit-def $rsi
SIH:	30	dead $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags, implicit-def $rsi
HSI:	30	dead $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags, implicit-def $rsi
CH:	31	dead $ecx = XOR32rr undef $ecx(tied-def 0), undef $ecx, implicit-def dead $eflags, implicit-def $rcx
CL:	31	dead $ecx = XOR32rr undef $ecx(tied-def 0), undef $ecx, implicit-def dead $eflags, implicit-def $rcx
HCX:	31	dead $ecx = XOR32rr undef $ecx(tied-def 0), undef $ecx, implicit-def dead $eflags, implicit-def $rcx
EFLAGS:	31	dead $ecx = XOR32rr undef $ecx(tied-def 0), undef $ecx, implicit-def dead $eflags, implicit-def $rcx
CH:	31	dead $ecx = XOR32rr undef $ecx(tied-def 0), undef $ecx, implicit-def dead $eflags, implicit-def $rcx
CL:	31	dead $ecx = XOR32rr undef $ecx(tied-def 0), undef $ecx, implicit-def dead $eflags, implicit-def $rcx
HCX:	31	dead $ecx = XOR32rr undef $ecx(tied-def 0), undef $ecx, implicit-def dead $eflags, implicit-def $rcx
R8B:	32	$r8 = MOV64ri32 -1
R8BH:	32	$r8 = MOV64ri32 -1
R8WH:	32	$r8 = MOV64ri32 -1
SPL:	33	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 8)
SPH:	33	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 8)
HSP:	33	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 8)
SPL:	34	PUSH64r killed renamable $rax, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
SPH:	34	PUSH64r killed renamable $rax, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
HSP:	34	PUSH64r killed renamable $rax, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
SPL:	35	CALL64r killed renamable $r10, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
SPH:	35	CALL64r killed renamable $r10, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
HSP:	35	CALL64r killed renamable $r10, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
SSP:	35	CALL64r killed renamable $r10, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
SPL:	36	$rsp = ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
SPH:	36	$rsp = ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
HSP:	36	$rsp = ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
EFLAGS:	36	$rsp = ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
R13B:	37	renamable $r13 = MOV64rm renamable $rbx, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
R13BH:	37	renamable $r13 = MOV64rm renamable $rbx, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
R13WH:	37	renamable $r13 = MOV64rm renamable $rbx, 1, $noreg, 0, $noreg :: (load (s64) from %ir.1, align 4)
R12B:	38	renamable $r12 = MOV64rm renamable $rbx, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
R12BH:	38	renamable $r12 = MOV64rm renamable $rbx, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
R12WH:	38	renamable $r12 = MOV64rm renamable $rbx, 1, $noreg, 8, $noreg :: (load (s64) from %ir.4, align 4)
R15B:	39	renamable $r15 = MOV64rm renamable $rbx, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
R15BH:	39	renamable $r15 = MOV64rm renamable $rbx, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
R15WH:	39	renamable $r15 = MOV64rm renamable $rbx, 1, $noreg, 16, $noreg :: (load (s64) from %ir.6, align 4)
AH:	40	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
AL:	40	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
HAX:	40	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 24, $noreg :: (load (s64) from %ir.8, align 4)
AH:	42	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
AL:	42	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
HAX:	42	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 32, $noreg :: (load (s64) from %ir.10, align 4)
AH:	44	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
AL:	44	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
HAX:	44	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 40, $noreg :: (load (s64) from %ir.12, align 4)
AH:	46	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
AL:	46	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
HAX:	46	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 48, $noreg :: (load (s64) from %ir.14, align 4)
AH:	48	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
AL:	48	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
HAX:	48	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 56, $noreg :: (load (s64) from %ir.16, align 4)
AH:	50	renamable $rax = MOV64rm killed renamable $rbx, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
AL:	50	renamable $rax = MOV64rm killed renamable $rbx, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
HAX:	50	renamable $rax = MOV64rm killed renamable $rbx, 1, $noreg, 64, $noreg :: (load (s64) from %ir.18, align 4)
R14B:	52	renamable $r14 = LEA64r $noreg, 8, renamable $r13, 0, $noreg
R14BH:	52	renamable $r14 = LEA64r $noreg, 8, renamable $r13, 0, $noreg
R14WH:	52	renamable $r14 = LEA64r $noreg, 8, renamable $r13, 0, $noreg
DIL:	53	$rdi = MOV64rr $r14
DIH:	53	$rdi = MOV64rr $r14
HDI:	53	$rdi = MOV64rr $r14
AH:	54	renamable $rax = MOV64ri @malloc
AL:	54	renamable $rax = MOV64ri @malloc
HAX:	54	renamable $rax = MOV64ri @malloc
SPL:	55	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SPH:	55	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HSP:	55	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SSP:	55	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AH:	55	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AL:	55	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HAX:	55	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
BH:	56	$rbx = MOV64rr $rax
BL:	56	$rbx = MOV64rr $rax
HBX:	56	$rbx = MOV64rr $rax
AH:	57	renamable $rax = MOV64ri &__bzero
AL:	57	renamable $rax = MOV64ri &__bzero
HAX:	57	renamable $rax = MOV64ri &__bzero
EFLAGS:	58	TEST64rr renamable $r13, renamable $r13, implicit-def $eflags
%bb.1: all preds known
DIL:	0	$rdi = MOV64rr $rbx
DIH:	0	$rdi = MOV64rr $rbx
HDI:	0	$rdi = MOV64rr $rbx
SIL:	1	$rsi = MOV64rr killed $r14
SIH:	1	$rsi = MOV64rr killed $r14
HSI:	1	$rsi = MOV64rr killed $r14
SPL:	2	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	2	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	2	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	2	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
%bb.2: all preds known
AH:	0	$rax = MOV64rr $rsp
AL:	0	$rax = MOV64rr $rsp
HAX:	0	$rax = MOV64rr $rsp
CH:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
CL:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
HCX:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
SPL:	3	$rsp = MOV64rr killed $rcx
SPH:	3	$rsp = MOV64rr killed $rcx
HSP:	3	$rsp = MOV64rr killed $rcx
R14B:	9	renamable $r14 = LEA64r $noreg, 8, renamable $r12, 0, $noreg
R14BH:	9	renamable $r14 = LEA64r $noreg, 8, renamable $r12, 0, $noreg
R14WH:	9	renamable $r14 = LEA64r $noreg, 8, renamable $r12, 0, $noreg
DIL:	10	$rdi = MOV64rr $r14
DIH:	10	$rdi = MOV64rr $r14
HDI:	10	$rdi = MOV64rr $r14
R13B:	11	renamable $r13 = MOV64ri @malloc
R13BH:	11	renamable $r13 = MOV64ri @malloc
R13WH:	11	renamable $r13 = MOV64ri @malloc
SPL:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SPH:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HSP:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SSP:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AH:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AL:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HAX:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
BH:	13	$rbx = MOV64rr $rax
BL:	13	$rbx = MOV64rr $rax
HBX:	13	$rbx = MOV64rr $rax
EFLAGS:	14	TEST64rr renamable $r12, renamable $r12, implicit-def $eflags
%bb.3: all preds known
DIL:	0	$rdi = MOV64rr $rbx
DIH:	0	$rdi = MOV64rr $rbx
HDI:	0	$rdi = MOV64rr $rbx
SIL:	1	$rsi = MOV64rr killed $r14
SIH:	1	$rsi = MOV64rr killed $r14
HSI:	1	$rsi = MOV64rr killed $r14
AH:	2	renamable $rax = MOV64ri &__bzero
AL:	2	renamable $rax = MOV64ri &__bzero
HAX:	2	renamable $rax = MOV64ri &__bzero
SPL:	3	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	3	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	3	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	3	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
%bb.4: all preds known
AH:	0	$rax = MOV64rr $rsp
AL:	0	$rax = MOV64rr $rsp
HAX:	0	$rax = MOV64rr $rsp
CH:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
CL:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
HCX:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
SPL:	3	$rsp = MOV64rr killed $rcx
SPH:	3	$rsp = MOV64rr killed $rcx
HSP:	3	$rsp = MOV64rr killed $rcx
R14B:	9	renamable $r14 = LEA64r $noreg, 8, renamable $r15, 0, $noreg
R14BH:	9	renamable $r14 = LEA64r $noreg, 8, renamable $r15, 0, $noreg
R14WH:	9	renamable $r14 = LEA64r $noreg, 8, renamable $r15, 0, $noreg
DIL:	10	$rdi = MOV64rr $r14
DIH:	10	$rdi = MOV64rr $r14
HDI:	10	$rdi = MOV64rr $r14
SPL:	11	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SPH:	11	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HSP:	11	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SSP:	11	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AH:	11	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AL:	11	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HAX:	11	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
BH:	12	$rbx = MOV64rr $rax
BL:	12	$rbx = MOV64rr $rax
HBX:	12	$rbx = MOV64rr $rax
EFLAGS:	13	TEST64rr renamable $r15, renamable $r15, implicit-def $eflags
R12B:	14	renamable $r12 = MOV64ri &__bzero
R12BH:	14	renamable $r12 = MOV64ri &__bzero
R12WH:	14	renamable $r12 = MOV64ri &__bzero
%bb.5: all preds known
DIL:	0	$rdi = MOV64rr $rbx
DIH:	0	$rdi = MOV64rr $rbx
HDI:	0	$rdi = MOV64rr $rbx
SIL:	1	$rsi = MOV64rr killed $r14
SIH:	1	$rsi = MOV64rr killed $r14
HSI:	1	$rsi = MOV64rr killed $r14
SPL:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
%bb.6: all preds known
AH:	0	$rax = MOV64rr $rsp
AL:	0	$rax = MOV64rr $rsp
HAX:	0	$rax = MOV64rr $rsp
CH:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
CL:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
HCX:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
SPL:	3	$rsp = MOV64rr killed $rcx
SPH:	3	$rsp = MOV64rr killed $rcx
HSP:	3	$rsp = MOV64rr killed $rcx
R15B:	9	renamable $r15 = MOV64rm $rbp, 1, $noreg, -64, $noreg :: (load (s64) from %stack.10)
R15BH:	9	renamable $r15 = MOV64rm $rbp, 1, $noreg, -64, $noreg :: (load (s64) from %stack.10)
R15WH:	9	renamable $r15 = MOV64rm $rbp, 1, $noreg, -64, $noreg :: (load (s64) from %stack.10)
R14B:	10	renamable $r14 = LEA64r $noreg, 8, renamable $r15, 0, $noreg
R14BH:	10	renamable $r14 = LEA64r $noreg, 8, renamable $r15, 0, $noreg
R14WH:	10	renamable $r14 = LEA64r $noreg, 8, renamable $r15, 0, $noreg
DIL:	11	$rdi = MOV64rr $r14
DIH:	11	$rdi = MOV64rr $r14
HDI:	11	$rdi = MOV64rr $r14
SPL:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SPH:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HSP:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SSP:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AH:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AL:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HAX:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
BH:	13	$rbx = MOV64rr $rax
BL:	13	$rbx = MOV64rr $rax
HBX:	13	$rbx = MOV64rr $rax
EFLAGS:	14	TEST64rr renamable $r15, renamable $r15, implicit-def $eflags
%bb.7: all preds known
DIL:	0	$rdi = MOV64rr $rbx
DIH:	0	$rdi = MOV64rr $rbx
HDI:	0	$rdi = MOV64rr $rbx
SIL:	1	$rsi = MOV64rr killed $r14
SIH:	1	$rsi = MOV64rr killed $r14
HSI:	1	$rsi = MOV64rr killed $r14
SPL:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
%bb.8: all preds known
AH:	0	$rax = MOV64rr $rsp
AL:	0	$rax = MOV64rr $rsp
HAX:	0	$rax = MOV64rr $rsp
CH:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
CL:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
HCX:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
SPL:	3	$rsp = MOV64rr killed $rcx
SPH:	3	$rsp = MOV64rr killed $rcx
HSP:	3	$rsp = MOV64rr killed $rcx
R15B:	9	renamable $r15 = MOV64rm $rbp, 1, $noreg, -48, $noreg :: (load (s64) from %stack.11)
R15BH:	9	renamable $r15 = MOV64rm $rbp, 1, $noreg, -48, $noreg :: (load (s64) from %stack.11)
R15WH:	9	renamable $r15 = MOV64rm $rbp, 1, $noreg, -48, $noreg :: (load (s64) from %stack.11)
R14B:	10	renamable $r14 = LEA64r $noreg, 8, renamable $r15, 0, $noreg
R14BH:	10	renamable $r14 = LEA64r $noreg, 8, renamable $r15, 0, $noreg
R14WH:	10	renamable $r14 = LEA64r $noreg, 8, renamable $r15, 0, $noreg
DIL:	11	$rdi = MOV64rr $r14
DIH:	11	$rdi = MOV64rr $r14
HDI:	11	$rdi = MOV64rr $r14
SPL:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SPH:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HSP:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SSP:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AH:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AL:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HAX:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
BH:	13	$rbx = MOV64rr $rax
BL:	13	$rbx = MOV64rr $rax
HBX:	13	$rbx = MOV64rr $rax
EFLAGS:	14	TEST64rr killed renamable $r15, renamable $r15, implicit-def $eflags
R15B:	15	renamable $r15 = MOV64rm $rbp, 1, $noreg, -56, $noreg :: (load (s64) from %stack.12)
R15BH:	15	renamable $r15 = MOV64rm $rbp, 1, $noreg, -56, $noreg :: (load (s64) from %stack.12)
R15WH:	15	renamable $r15 = MOV64rm $rbp, 1, $noreg, -56, $noreg :: (load (s64) from %stack.12)
%bb.9: all preds known
DIL:	0	$rdi = MOV64rr $rbx
DIH:	0	$rdi = MOV64rr $rbx
HDI:	0	$rdi = MOV64rr $rbx
SIL:	1	$rsi = MOV64rr killed $r14
SIH:	1	$rsi = MOV64rr killed $r14
HSI:	1	$rsi = MOV64rr killed $r14
SPL:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
%bb.10: all preds known
AH:	0	$rax = MOV64rr $rsp
AL:	0	$rax = MOV64rr $rsp
HAX:	0	$rax = MOV64rr $rsp
CH:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
CL:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
HCX:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
SPL:	3	$rsp = MOV64rr killed $rcx
SPH:	3	$rsp = MOV64rr killed $rcx
HSP:	3	$rsp = MOV64rr killed $rcx
CH:	7	renamable $rcx = MOV64rm $rbp, 1, $noreg, -48, $noreg :: (load (s64) from %stack.11)
CL:	7	renamable $rcx = MOV64rm $rbp, 1, $noreg, -48, $noreg :: (load (s64) from %stack.11)
HCX:	7	renamable $rcx = MOV64rm $rbp, 1, $noreg, -48, $noreg :: (load (s64) from %stack.11)
BH:	10	renamable $rbx = LEA64r $noreg, 8, renamable $r15, 0, $noreg
BL:	10	renamable $rbx = LEA64r $noreg, 8, renamable $r15, 0, $noreg
HBX:	10	renamable $rbx = LEA64r $noreg, 8, renamable $r15, 0, $noreg
DIL:	11	$rdi = MOV64rr $rbx
DIH:	11	$rdi = MOV64rr $rbx
HDI:	11	$rdi = MOV64rr $rbx
SPL:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SPH:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HSP:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SSP:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AH:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AL:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HAX:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
R14B:	13	$r14 = MOV64rr $rax
R14BH:	13	$r14 = MOV64rr $rax
R14WH:	13	$r14 = MOV64rr $rax
EFLAGS:	14	TEST64rr renamable $r15, renamable $r15, implicit-def $eflags
%bb.11: all preds known
DIL:	0	$rdi = MOV64rr $r14
DIH:	0	$rdi = MOV64rr $r14
HDI:	0	$rdi = MOV64rr $r14
SIL:	1	$rsi = MOV64rr killed $rbx
SIH:	1	$rsi = MOV64rr killed $rbx
HSI:	1	$rsi = MOV64rr killed $rbx
SPL:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	2	CALL64r renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
%bb.12: all preds known
AH:	0	$rax = MOV64rr $rsp
AL:	0	$rax = MOV64rr $rsp
HAX:	0	$rax = MOV64rr $rsp
CH:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
CL:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
HCX:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
SPL:	3	$rsp = MOV64rr killed $rcx
SPH:	3	$rsp = MOV64rr killed $rcx
HSP:	3	$rsp = MOV64rr killed $rcx
BH:	9	renamable $rbx = MOV64rm $rbp, 1, $noreg, -88, $noreg :: (load (s64) from %stack.19)
BL:	9	renamable $rbx = MOV64rm $rbp, 1, $noreg, -88, $noreg :: (load (s64) from %stack.19)
HBX:	9	renamable $rbx = MOV64rm $rbp, 1, $noreg, -88, $noreg :: (load (s64) from %stack.19)
R14B:	10	renamable $r14 = LEA64r $noreg, 8, renamable $rbx, 0, $noreg
R14BH:	10	renamable $r14 = LEA64r $noreg, 8, renamable $rbx, 0, $noreg
R14WH:	10	renamable $r14 = LEA64r $noreg, 8, renamable $rbx, 0, $noreg
DIL:	11	$rdi = MOV64rr $r14
DIH:	11	$rdi = MOV64rr $r14
HDI:	11	$rdi = MOV64rr $r14
SPL:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SPH:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HSP:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SSP:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AH:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AL:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HAX:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
R15B:	13	$r15 = MOV64rr $rax
R15BH:	13	$r15 = MOV64rr $rax
R15WH:	13	$r15 = MOV64rr $rax
EFLAGS:	14	TEST64rr renamable $rbx, renamable $rbx, implicit-def $eflags
%bb.13: all preds known
DIL:	0	$rdi = MOV64rr $r15
DIH:	0	$rdi = MOV64rr $r15
HDI:	0	$rdi = MOV64rr $r15
SIL:	1	$rsi = MOV64rr killed $r14
SIH:	1	$rsi = MOV64rr killed $r14
HSI:	1	$rsi = MOV64rr killed $r14
SPL:	2	CALL64r killed renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	2	CALL64r killed renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	2	CALL64r killed renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	2	CALL64r killed renamable $r12, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
%bb.14: all preds known
AH:	0	$rax = MOV64rr $rsp
AL:	0	$rax = MOV64rr $rsp
HAX:	0	$rax = MOV64rr $rsp
CH:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
CL:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
HCX:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
SPL:	3	$rsp = MOV64rr killed $rcx
SPH:	3	$rsp = MOV64rr killed $rcx
HSP:	3	$rsp = MOV64rr killed $rcx
R14B:	9	renamable $r14 = MOV64rm $rbp, 1, $noreg, -72, $noreg :: (load (s64) from %stack.16)
R14BH:	9	renamable $r14 = MOV64rm $rbp, 1, $noreg, -72, $noreg :: (load (s64) from %stack.16)
R14WH:	9	renamable $r14 = MOV64rm $rbp, 1, $noreg, -72, $noreg :: (load (s64) from %stack.16)
R15B:	10	renamable $r15 = LEA64r $noreg, 8, renamable $r14, 0, $noreg
R15BH:	10	renamable $r15 = LEA64r $noreg, 8, renamable $r14, 0, $noreg
R15WH:	10	renamable $r15 = LEA64r $noreg, 8, renamable $r14, 0, $noreg
DIL:	11	$rdi = MOV64rr $r15
DIH:	11	$rdi = MOV64rr $r15
HDI:	11	$rdi = MOV64rr $r15
SPL:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SPH:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HSP:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SSP:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AH:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AL:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HAX:	12	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
R12B:	13	$r12 = MOV64rr $rax
R12BH:	13	$r12 = MOV64rr $rax
R12WH:	13	$r12 = MOV64rr $rax
EFLAGS:	14	TEST64rr renamable $r14, renamable $r14, implicit-def $eflags
BH:	15	renamable $rbx = MOV64rm $rbp, 1, $noreg, -80, $noreg :: (load (s64) from %stack.14)
BL:	15	renamable $rbx = MOV64rm $rbp, 1, $noreg, -80, $noreg :: (load (s64) from %stack.14)
HBX:	15	renamable $rbx = MOV64rm $rbp, 1, $noreg, -80, $noreg :: (load (s64) from %stack.14)
%bb.15: all preds known
DIL:	0	$rdi = MOV64rr $r12
DIH:	0	$rdi = MOV64rr $r12
HDI:	0	$rdi = MOV64rr $r12
SIL:	1	$rsi = MOV64rr killed $r15
SIH:	1	$rsi = MOV64rr killed $r15
HSI:	1	$rsi = MOV64rr killed $r15
AH:	2	renamable $rax = MOV64ri &__bzero
AL:	2	renamable $rax = MOV64ri &__bzero
HAX:	2	renamable $rax = MOV64ri &__bzero
SPL:	3	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	3	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	3	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	3	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
%bb.16: all preds known
AH:	0	$rax = MOV64rr $rsp
AL:	0	$rax = MOV64rr $rsp
HAX:	0	$rax = MOV64rr $rsp
R15B:	1	renamable $r15 = LEA64r renamable $rax, 1, $noreg, -48, $noreg
R15BH:	1	renamable $r15 = LEA64r renamable $rax, 1, $noreg, -48, $noreg
R15WH:	1	renamable $r15 = LEA64r renamable $rax, 1, $noreg, -48, $noreg
SPL:	2	$rsp = MOV64rr $r15
SPH:	2	$rsp = MOV64rr $r15
HSP:	2	$rsp = MOV64rr $r15
R12B:	8	renamable $r12 = LEA64r $noreg, 8, renamable $rbx, 0, $noreg
R12BH:	8	renamable $r12 = LEA64r $noreg, 8, renamable $rbx, 0, $noreg
R12WH:	8	renamable $r12 = LEA64r $noreg, 8, renamable $rbx, 0, $noreg
DIL:	9	$rdi = MOV64rr $r12
DIH:	9	$rdi = MOV64rr $r12
HDI:	9	$rdi = MOV64rr $r12
SPL:	10	CALL64r killed renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SPH:	10	CALL64r killed renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HSP:	10	CALL64r killed renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
SSP:	10	CALL64r killed renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AH:	10	CALL64r killed renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
AL:	10	CALL64r killed renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
HAX:	10	CALL64r killed renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
R13B:	11	$r13 = MOV64rr $rax
R13BH:	11	$r13 = MOV64rr $rax
R13WH:	11	$r13 = MOV64rr $rax
EFLAGS:	12	TEST64rr renamable $rbx, renamable $rbx, implicit-def $eflags
%bb.17: all preds known
DIL:	0	$rdi = MOV64rr $r13
DIH:	0	$rdi = MOV64rr $r13
HDI:	0	$rdi = MOV64rr $r13
SIL:	1	$rsi = MOV64rr killed $r12
SIH:	1	$rsi = MOV64rr killed $r12
HSI:	1	$rsi = MOV64rr killed $r12
AH:	2	renamable $rax = MOV64ri &__bzero
AL:	2	renamable $rax = MOV64ri &__bzero
HAX:	2	renamable $rax = MOV64ri &__bzero
SPL:	3	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	3	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	3	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	3	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
%bb.18: all preds known
AH:	0	$rax = MOV64rr $rsp
AL:	0	$rax = MOV64rr $rsp
HAX:	0	$rax = MOV64rr $rsp
CH:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
CL:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
HCX:	1	renamable $rcx = LEA64r renamable $rax, 1, $noreg, -48, $noreg
SPL:	2	$rsp = MOV64rr $rcx
SPH:	2	$rsp = MOV64rr $rcx
HSP:	2	$rsp = MOV64rr $rcx
R10B:	3	$r10 = MOV64rr $rcx
R10BH:	3	$r10 = MOV64rr $rcx
R10WH:	3	$r10 = MOV64rr $rcx
AH:	10	renamable $rax = MOV64ri @read_input_2D_f64
AL:	10	renamable $rax = MOV64ri @read_input_2D_f64
HAX:	10	renamable $rax = MOV64ri @read_input_2D_f64
DH:	11	$edx = MOV32ri 3, implicit-def $rdx
DL:	11	$edx = MOV32ri 3, implicit-def $rdx
HDX:	11	$edx = MOV32ri 3, implicit-def $rdx
DH:	11	$edx = MOV32ri 3, implicit-def $rdx
DL:	11	$edx = MOV32ri 3, implicit-def $rdx
HDX:	11	$edx = MOV32ri 3, implicit-def $rdx
R9B:	12	$r9d = MOV32ri 1, implicit-def $r9
R9BH:	12	$r9d = MOV32ri 1, implicit-def $r9
R9WH:	12	$r9d = MOV32ri 1, implicit-def $r9
R9B:	12	$r9d = MOV32ri 1, implicit-def $r9
R9BH:	12	$r9d = MOV32ri 1, implicit-def $r9
R9WH:	12	$r9d = MOV32ri 1, implicit-def $r9
DIL:	13	$edi = MOV32ri 1
DIH:	13	$edi = MOV32ri 1
HDI:	13	$edi = MOV32ri 1
SIL:	14	dead $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags, implicit-def $rsi
SIH:	14	dead $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags, implicit-def $rsi
HSI:	14	dead $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags, implicit-def $rsi
EFLAGS:	14	dead $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags, implicit-def $rsi
SIL:	14	dead $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags, implicit-def $rsi
SIH:	14	dead $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags, implicit-def $rsi
HSI:	14	dead $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags, implicit-def $rsi
CH:	15	dead $ecx = XOR32rr undef $ecx(tied-def 0), undef $ecx, implicit-def dead $eflags, implicit-def $rcx
CL:	15	dead $ecx = XOR32rr undef $ecx(tied-def 0), undef $ecx, implicit-def dead $eflags, implicit-def $rcx
HCX:	15	dead $ecx = XOR32rr undef $ecx(tied-def 0), undef $ecx, implicit-def dead $eflags, implicit-def $rcx
EFLAGS:	15	dead $ecx = XOR32rr undef $ecx(tied-def 0), undef $ecx, implicit-def dead $eflags, implicit-def $rcx
CH:	15	dead $ecx = XOR32rr undef $ecx(tied-def 0), undef $ecx, implicit-def dead $eflags, implicit-def $rcx
CL:	15	dead $ecx = XOR32rr undef $ecx(tied-def 0), undef $ecx, implicit-def dead $eflags, implicit-def $rcx
HCX:	15	dead $ecx = XOR32rr undef $ecx(tied-def 0), undef $ecx, implicit-def dead $eflags, implicit-def $rcx
R8B:	16	$r8 = MOV64ri32 -1
R8BH:	16	$r8 = MOV64ri32 -1
R8WH:	16	$r8 = MOV64ri32 -1
SPL:	17	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 136)
SPH:	17	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 136)
HSP:	17	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s32) into stack + 136)
SPL:	18	PUSH64r killed renamable $r10, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 128)
SPH:	18	PUSH64r killed renamable $r10, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 128)
HSP:	18	PUSH64r killed renamable $r10, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 128)
SPL:	19	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 120)
SPH:	19	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 120)
HSP:	19	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 120)
SPL:	20	PUSH64r renamable $r15, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 112)
SPH:	20	PUSH64r renamable $r15, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 112)
HSP:	20	PUSH64r renamable $r15, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 112)
SPL:	21	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 104)
SPH:	21	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 104)
HSP:	21	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 104)
SPL:	22	PUSH64rmm $rbp, 1, $noreg, -56, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 96), (load (s64) from %stack.12)
SPH:	22	PUSH64rmm $rbp, 1, $noreg, -56, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 96), (load (s64) from %stack.12)
HSP:	22	PUSH64rmm $rbp, 1, $noreg, -56, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 96), (load (s64) from %stack.12)
SPL:	23	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 88)
SPH:	23	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 88)
HSP:	23	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 88)
SPL:	24	PUSH64rmm $rbp, 1, $noreg, -48, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 80), (load (s64) from %stack.11)
SPH:	24	PUSH64rmm $rbp, 1, $noreg, -48, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 80), (load (s64) from %stack.11)
HSP:	24	PUSH64rmm $rbp, 1, $noreg, -48, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 80), (load (s64) from %stack.11)
SPL:	25	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 72)
SPH:	25	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 72)
HSP:	25	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 72)
SPL:	26	PUSH64rmm $rbp, 1, $noreg, -64, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 64), (load (s64) from %stack.10)
SPH:	26	PUSH64rmm $rbp, 1, $noreg, -64, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 64), (load (s64) from %stack.10)
HSP:	26	PUSH64rmm $rbp, 1, $noreg, -64, $noreg, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 64), (load (s64) from %stack.10)
SPL:	27	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 56)
SPH:	27	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 56)
HSP:	27	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 56)
R12B:	28	renamable $r12 = MOV64rm $rbp, 1, $noreg, -96, $noreg :: (load (s64) from %stack.18)
R12BH:	28	renamable $r12 = MOV64rm $rbp, 1, $noreg, -96, $noreg :: (load (s64) from %stack.18)
R12WH:	28	renamable $r12 = MOV64rm $rbp, 1, $noreg, -96, $noreg :: (load (s64) from %stack.18)
SPL:	29	PUSH64r renamable $r12, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 48)
SPH:	29	PUSH64r renamable $r12, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 48)
HSP:	29	PUSH64r renamable $r12, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 48)
SPL:	30	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 40)
SPH:	30	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 40)
HSP:	30	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 40)
R15B:	32	renamable $r15 = MOV64rm $rbp, 1, $noreg, -104, $noreg :: (load (s64) from %stack.17)
R15BH:	32	renamable $r15 = MOV64rm $rbp, 1, $noreg, -104, $noreg :: (load (s64) from %stack.17)
R15WH:	32	renamable $r15 = MOV64rm $rbp, 1, $noreg, -104, $noreg :: (load (s64) from %stack.17)
SPL:	33	PUSH64r renamable $r15, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 32)
SPH:	33	PUSH64r renamable $r15, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 32)
HSP:	33	PUSH64r renamable $r15, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 32)
SPL:	34	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 24)
SPH:	34	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 24)
HSP:	34	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 24)
R14B:	35	renamable $r14 = MOV64rm $rbp, 1, $noreg, -112, $noreg :: (load (s64) from %stack.15)
R14BH:	35	renamable $r14 = MOV64rm $rbp, 1, $noreg, -112, $noreg :: (load (s64) from %stack.15)
R14WH:	35	renamable $r14 = MOV64rm $rbp, 1, $noreg, -112, $noreg :: (load (s64) from %stack.15)
SPL:	36	PUSH64r renamable $r14, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 16)
SPH:	36	PUSH64r renamable $r14, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 16)
HSP:	36	PUSH64r renamable $r14, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 16)
SPL:	37	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 8)
SPH:	37	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 8)
HSP:	37	PUSH64i8 1, implicit-def $rsp, implicit $rsp :: (store (s64) into stack + 8)
BH:	38	renamable $rbx = MOV64rm $rbp, 1, $noreg, -120, $noreg :: (load (s64) from %stack.13)
BL:	38	renamable $rbx = MOV64rm $rbp, 1, $noreg, -120, $noreg :: (load (s64) from %stack.13)
HBX:	38	renamable $rbx = MOV64rm $rbp, 1, $noreg, -120, $noreg :: (load (s64) from %stack.13)
SPL:	39	PUSH64r renamable $rbx, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
SPH:	39	PUSH64r renamable $rbx, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
HSP:	39	PUSH64r renamable $rbx, implicit-def $rsp, implicit $rsp :: (store (s64) into stack)
SPL:	40	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
SPH:	40	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
HSP:	40	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
SSP:	40	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit $rdx, implicit $rcx, implicit $r8, implicit $r9, implicit-def $rsp, implicit-def $ssp
SPL:	41	$rsp = ADD64ri32 $rsp(tied-def 0), 144, implicit-def dead $eflags
SPH:	41	$rsp = ADD64ri32 $rsp(tied-def 0), 144, implicit-def dead $eflags
HSP:	41	$rsp = ADD64ri32 $rsp(tied-def 0), 144, implicit-def dead $eflags
EFLAGS:	41	$rsp = ADD64ri32 $rsp(tied-def 0), 144, implicit-def dead $eflags
R13B:	42	renamable $r13 = MOV64ri @comet_print_memref_i64
R13BH:	42	renamable $r13 = MOV64ri @comet_print_memref_i64
R13WH:	42	renamable $r13 = MOV64ri @comet_print_memref_i64
DIL:	43	$edi = MOV32ri 1, implicit-def $rdi
DIH:	43	$edi = MOV32ri 1, implicit-def $rdi
HDI:	43	$edi = MOV32ri 1, implicit-def $rdi
DIL:	43	$edi = MOV32ri 1, implicit-def $rdi
DIH:	43	$edi = MOV32ri 1, implicit-def $rdi
HDI:	43	$edi = MOV32ri 1, implicit-def $rdi
SIL:	44	$rsi = MOV64rr killed $rbx
SIH:	44	$rsi = MOV64rr killed $rbx
HSI:	44	$rsi = MOV64rr killed $rbx
SPL:	45	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	45	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	45	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	45	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
DIL:	46	$edi = MOV32ri 1, implicit-def $rdi
DIH:	46	$edi = MOV32ri 1, implicit-def $rdi
HDI:	46	$edi = MOV32ri 1, implicit-def $rdi
DIL:	46	$edi = MOV32ri 1, implicit-def $rdi
DIH:	46	$edi = MOV32ri 1, implicit-def $rdi
HDI:	46	$edi = MOV32ri 1, implicit-def $rdi
SIL:	47	$rsi = MOV64rr killed $r14
SIH:	47	$rsi = MOV64rr killed $r14
HSI:	47	$rsi = MOV64rr killed $r14
SPL:	48	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	48	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	48	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	48	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
DIL:	49	$edi = MOV32ri 1, implicit-def $rdi
DIH:	49	$edi = MOV32ri 1, implicit-def $rdi
HDI:	49	$edi = MOV32ri 1, implicit-def $rdi
DIL:	49	$edi = MOV32ri 1, implicit-def $rdi
DIH:	49	$edi = MOV32ri 1, implicit-def $rdi
HDI:	49	$edi = MOV32ri 1, implicit-def $rdi
SIL:	50	$rsi = MOV64rr killed $r15
SIH:	50	$rsi = MOV64rr killed $r15
HSI:	50	$rsi = MOV64rr killed $r15
SPL:	51	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	51	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	51	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	51	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
DIL:	52	$edi = MOV32ri 1, implicit-def $rdi
DIH:	52	$edi = MOV32ri 1, implicit-def $rdi
HDI:	52	$edi = MOV32ri 1, implicit-def $rdi
DIL:	52	$edi = MOV32ri 1, implicit-def $rdi
DIH:	52	$edi = MOV32ri 1, implicit-def $rdi
HDI:	52	$edi = MOV32ri 1, implicit-def $rdi
SIL:	53	$rsi = MOV64rr killed $r12
SIH:	53	$rsi = MOV64rr killed $r12
HSI:	53	$rsi = MOV64rr killed $r12
SPL:	54	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	54	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	54	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	54	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
DIL:	55	$edi = MOV32ri 1, implicit-def $rdi
DIH:	55	$edi = MOV32ri 1, implicit-def $rdi
HDI:	55	$edi = MOV32ri 1, implicit-def $rdi
DIL:	55	$edi = MOV32ri 1, implicit-def $rdi
DIH:	55	$edi = MOV32ri 1, implicit-def $rdi
HDI:	55	$edi = MOV32ri 1, implicit-def $rdi
SIL:	56	$rsi = MOV64rm $rbp, 1, $noreg, -64, $noreg :: (load (s64) from %stack.10)
SIH:	56	$rsi = MOV64rm $rbp, 1, $noreg, -64, $noreg :: (load (s64) from %stack.10)
HSI:	56	$rsi = MOV64rm $rbp, 1, $noreg, -64, $noreg :: (load (s64) from %stack.10)
SPL:	57	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	57	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	57	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	57	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
DIL:	58	$edi = MOV32ri 1, implicit-def $rdi
DIH:	58	$edi = MOV32ri 1, implicit-def $rdi
HDI:	58	$edi = MOV32ri 1, implicit-def $rdi
DIL:	58	$edi = MOV32ri 1, implicit-def $rdi
DIH:	58	$edi = MOV32ri 1, implicit-def $rdi
HDI:	58	$edi = MOV32ri 1, implicit-def $rdi
SIL:	59	$rsi = MOV64rm $rbp, 1, $noreg, -48, $noreg :: (load (s64) from %stack.11)
SIH:	59	$rsi = MOV64rm $rbp, 1, $noreg, -48, $noreg :: (load (s64) from %stack.11)
HSI:	59	$rsi = MOV64rm $rbp, 1, $noreg, -48, $noreg :: (load (s64) from %stack.11)
SPL:	60	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	60	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	60	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	60	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
DIL:	61	$edi = MOV32ri 1, implicit-def $rdi
DIH:	61	$edi = MOV32ri 1, implicit-def $rdi
HDI:	61	$edi = MOV32ri 1, implicit-def $rdi
DIL:	61	$edi = MOV32ri 1, implicit-def $rdi
DIH:	61	$edi = MOV32ri 1, implicit-def $rdi
HDI:	61	$edi = MOV32ri 1, implicit-def $rdi
SIL:	62	$rsi = MOV64rm $rbp, 1, $noreg, -56, $noreg :: (load (s64) from %stack.12)
SIH:	62	$rsi = MOV64rm $rbp, 1, $noreg, -56, $noreg :: (load (s64) from %stack.12)
HSI:	62	$rsi = MOV64rm $rbp, 1, $noreg, -56, $noreg :: (load (s64) from %stack.12)
SPL:	63	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	63	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	63	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	63	CALL64r renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
DIL:	64	$edi = MOV32ri 1, implicit-def $rdi
DIH:	64	$edi = MOV32ri 1, implicit-def $rdi
HDI:	64	$edi = MOV32ri 1, implicit-def $rdi
DIL:	64	$edi = MOV32ri 1, implicit-def $rdi
DIH:	64	$edi = MOV32ri 1, implicit-def $rdi
HDI:	64	$edi = MOV32ri 1, implicit-def $rdi
SIL:	65	$rsi = MOV64rm $rbp, 1, $noreg, -80, $noreg :: (load (s64) from %stack.14)
SIH:	65	$rsi = MOV64rm $rbp, 1, $noreg, -80, $noreg :: (load (s64) from %stack.14)
HSI:	65	$rsi = MOV64rm $rbp, 1, $noreg, -80, $noreg :: (load (s64) from %stack.14)
SPL:	66	CALL64r killed renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	66	CALL64r killed renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	66	CALL64r killed renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	66	CALL64r killed renamable $r13, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
AH:	67	renamable $rax = MOV64ri @comet_print_memref_f64
AL:	67	renamable $rax = MOV64ri @comet_print_memref_f64
HAX:	67	renamable $rax = MOV64ri @comet_print_memref_f64
DIL:	68	$edi = MOV32ri 1, implicit-def $rdi
DIH:	68	$edi = MOV32ri 1, implicit-def $rdi
HDI:	68	$edi = MOV32ri 1, implicit-def $rdi
DIL:	68	$edi = MOV32ri 1, implicit-def $rdi
DIH:	68	$edi = MOV32ri 1, implicit-def $rdi
HDI:	68	$edi = MOV32ri 1, implicit-def $rdi
SIL:	69	$rsi = MOV64rm $rbp, 1, $noreg, -72, $noreg :: (load (s64) from %stack.16)
SIH:	69	$rsi = MOV64rm $rbp, 1, $noreg, -72, $noreg :: (load (s64) from %stack.16)
HSI:	69	$rsi = MOV64rm $rbp, 1, $noreg, -72, $noreg :: (load (s64) from %stack.16)
SPL:	70	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPH:	70	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
HSP:	70	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SSP:	70	CALL64r killed renamable $rax, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
SPL:	71	$rsp = LEA64r $rbp, 1, $noreg, -40, $noreg
SPH:	71	$rsp = LEA64r $rbp, 1, $noreg, -40, $noreg
HSP:	71	$rsp = LEA64r $rbp, 1, $noreg, -40, $noreg
BH:	72	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
BL:	72	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
HBX:	72	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
SPL:	72	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
SPH:	72	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
HSP:	72	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
R12B:	73	$r12 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
R12BH:	73	$r12 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
R12WH:	73	$r12 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
SPL:	73	$r12 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
SPH:	73	$r12 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
HSP:	73	$r12 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
R13B:	74	$r13 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
R13BH:	74	$r13 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
R13WH:	74	$r13 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
SPL:	74	$r13 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
SPH:	74	$r13 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
HSP:	74	$r13 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
R14B:	75	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
R14BH:	75	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
R14WH:	75	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
SPL:	75	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
SPH:	75	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
HSP:	75	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
R15B:	76	$r15 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
R15BH:	76	$r15 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
R15WH:	76	$r15 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
SPL:	76	$r15 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
SPH:	76	$r15 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
HSP:	76	$r15 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
BPL:	77	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
BPH:	77	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
HBP:	77	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
SPL:	77	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
SPH:	77	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
HSP:	77	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
********** FIX EXECUTION DOMAIN: VR128X **********
%bb.0: entry
%bb.1: all preds known
%bb.2: all preds known
%bb.3: all preds known
%bb.4: all preds known
%bb.5: all preds known
%bb.6: all preds known
%bb.7: all preds known
%bb.8: all preds known
%bb.9: all preds known
%bb.10: all preds known
%bb.11: all preds known
%bb.12: all preds known
%bb.13: all preds known
%bb.14: all preds known
%bb.15: all preds known
%bb.16: all preds known
%bb.17: all preds known
%bb.18: all preds known
********** BREAK FALSE DEPENDENCIES **********
Start X86FixupBWInsts
End X86FixupBWInsts
Start X86FixupLEAs
End X86FixupLEAs
********** COMPUTING STACKMAP LIVENESS: main **********
X86 Indirect Thunks
X86 Return Thunks
***** X86 Load Value Injection (LVI) Ret-Hardening : main *****
MergeICmpsLegacyPass: _mlir_main
		Looking for trivial roots
Found a new trivial root: %1
Last visited node: %1
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %1
Found roots: %1 
---- Branch Probability Info : _mlir_main ----

Computing probabilities for 

block-frequency: _mlir_main
===========================
reverse-post-order-traversal
 - 0: 
loop-detection
compute-mass-in-function
 - node: 
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - : float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _mlir_main
 - : float = 1.0, int = 8

********** Begin Constant Hoisting **********
********** Function: _mlir_main
********** End Constant Hoisting **********
********** Begin TLS Variable Hoist **********
********** Function: _mlir_main
********** End TLS Variable Hoist **********
*** Interleaved Access Pass: _mlir_main
---- Branch Probability Info : _mlir_main ----

		Looking for trivial roots
Found a new trivial root: %1
Last visited node: %1
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %1
Found roots: %1 
Computing probabilities for 

block-frequency: _mlir_main
===========================
reverse-post-order-traversal
 - 0: 
loop-detection
compute-mass-in-function
 - node: 
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - : float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _mlir_main
 - : float = 1.0, int = 8

[SafeStack] Function: _mlir_main
[SafeStack]     safestack is not requested for this function
		Looking for trivial roots
Found a new trivial root: %1
Last visited node: %1
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %1
Found roots: %1 
---- Branch Probability Info : _mlir_main ----

Computing probabilities for 



=== _mlir_main
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %0
Creating constant: t4: i32 = TargetConstant<0>
Creating new node: t6: ch,glue = X86ISD::TC_RETURN t0, GlobalAddress:i64<ptr @main> 0, TargetConstant:i32<0>, RegisterMask:Untyped
Initial selection DAG: %bb.0 '_mlir_main:'
SelectionDAG has 7 nodes:
  t0: ch,glue = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %0
  t6: ch,glue = X86ISD::TC_RETURN t0, GlobalAddress:i64<ptr @main> 0, TargetConstant:i32<0>, RegisterMask:Untyped



Combining: t6: ch,glue = X86ISD::TC_RETURN t0, GlobalAddress:i64<ptr @main> 0, TargetConstant:i32<0>, RegisterMask:Untyped

Combining: t5: Untyped = RegisterMask

Combining: t4: i32 = TargetConstant<0>

Combining: t3: i64 = GlobalAddress<ptr @main> 0

Combining: t0: ch,glue = EntryToken
Optimized lowered selection DAG: %bb.0 '_mlir_main:'
SelectionDAG has 5 nodes:
    t0: ch,glue = EntryToken
  t6: ch,glue = X86ISD::TC_RETURN t0, GlobalAddress:i64<ptr @main> 0, TargetConstant:i32<0>, RegisterMask:Untyped


Legalizing node: t5: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t5: Untyped = RegisterMask

Legalizing node: t4: i32 = TargetConstant<0>
Ignoring node results
Legally typed node: t4: i32 = TargetConstant<0>

Legalizing node: t3: i64 = GlobalAddress<ptr @main> 0
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = GlobalAddress<ptr @main> 0

Legalizing node: t0: ch,glue = EntryToken
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Legally typed node: t0: ch,glue = EntryToken

Legalizing node: t6: ch,glue = X86ISD::TC_RETURN t0, GlobalAddress:i64<ptr @main> 0, TargetConstant:i32<0>, RegisterMask:Untyped
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch,glue = EntryToken
Legal operand
Analyzing operand: t3: i64 = GlobalAddress<ptr @main> 0
Legal operand
Analyzing operand: t5: Untyped = RegisterMask
Legal operand
Legally typed node: t6: ch,glue = X86ISD::TC_RETURN t0, GlobalAddress:i64<ptr @main> 0, TargetConstant:i32<0>, RegisterMask:Untyped

Legalizing node: t65535: ch = handlenode t6
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch,glue = X86ISD::TC_RETURN t0, GlobalAddress:i64<ptr @main> 0, TargetConstant:i32<0>, RegisterMask:Untyped
Legal operand
Legally typed node: t65535: ch = handlenode t6

Type-legalized selection DAG: %bb.0 '_mlir_main:'
SelectionDAG has 5 nodes:
    t0: ch,glue = EntryToken
  t6: ch,glue = X86ISD::TC_RETURN t0, GlobalAddress:i64<ptr @main> 0, TargetConstant:i32<0>, RegisterMask:Untyped



Legalizing: t6: ch,glue = X86ISD::TC_RETURN t0, GlobalAddress:i64<ptr @main> 0, TargetConstant:i32<0>, RegisterMask:Untyped
Legal node: nothing to do

Legalizing: t5: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t4: i32 = TargetConstant<0>

Legalizing: t3: i64 = GlobalAddress<ptr @main> 0
Trying custom legalization
Creating new node: t8: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @main> 0
Successfully custom legalized node
 ... replacing: t3: i64 = GlobalAddress<ptr @main> 0
     with:      t8: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @main> 0

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Legalizing: t8: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @main> 0
Legal node: nothing to do

Legalizing: t7: i64 = TargetGlobalAddress<ptr @main> 0
Legal node: nothing to do
Legalized selection DAG: %bb.0 '_mlir_main:'
SelectionDAG has 6 nodes:
    t0: ch,glue = EntryToken
    t8: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @main> 0
  t6: ch,glue = X86ISD::TC_RETURN t0, t8, TargetConstant:i32<0>, RegisterMask:Untyped



Legalizing: t8: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @main> 0
Legal node: nothing to do

Combining: t8: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @main> 0

Legalizing: t7: i64 = TargetGlobalAddress<ptr @main> 0
Legal node: nothing to do

Combining: t7: i64 = TargetGlobalAddress<ptr @main> 0

Legalizing: t6: ch,glue = X86ISD::TC_RETURN t0, t8, TargetConstant:i32<0>, RegisterMask:Untyped
Legal node: nothing to do

Combining: t6: ch,glue = X86ISD::TC_RETURN t0, t8, TargetConstant:i32<0>, RegisterMask:Untyped

Legalizing: t5: Untyped = RegisterMask
Legal node: nothing to do

Combining: t5: Untyped = RegisterMask

Legalizing: t4: i32 = TargetConstant<0>

Combining: t4: i32 = TargetConstant<0>

Legalizing: t0: ch,glue = EntryToken
Legal node: nothing to do

Combining: t0: ch,glue = EntryToken
Optimized legalized selection DAG: %bb.0 '_mlir_main:'
SelectionDAG has 6 nodes:
    t0: ch,glue = EntryToken
    t8: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @main> 0
  t6: ch,glue = X86ISD::TC_RETURN t0, t8, TargetConstant:i32<0>, RegisterMask:Untyped


===== Instruction selection begins: %bb.0 ''

ISEL: Starting selection on root node: t6: ch,glue = X86ISD::TC_RETURN t0, t8, TargetConstant:i32<0>, RegisterMask:Untyped
ISEL: Starting pattern match
  Initial Opcode index to 45491
  Match failed at index 45496
  Continuing at 45562
  Match failed at index 45568
  Continuing at 45656
  Skipped scope entry (due to false predicate) at index 45665, continuing at 45675
  Morphed node: t6: ch = TCRETURNri64 t8, TargetConstant:i32<0>, RegisterMask:Untyped, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t8: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<ptr @main> 0
ISEL: Starting pattern match
  Initial Opcode index to 131955
  Match failed at index 131960
  Continuing at 131970
  OpcodeSwitch from 131973 to 132007
  Match failed at index 132010
  Continuing at 132078
  TypeSwitch[i64] from 132080 to 132095
  Morphed node: t8: i64 = MOV64ri TargetGlobalAddress:i64<ptr @main> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t7: i64 = TargetGlobalAddress<ptr @main> 0

ISEL: Starting selection on root node: t5: Untyped = RegisterMask

ISEL: Starting selection on root node: t4: i32 = TargetConstant<0>

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 '_mlir_main:'
SelectionDAG has 6 nodes:
    t8: i64 = MOV64ri TargetGlobalAddress:i64<ptr @main> 0
    t0: ch,glue = EntryToken
  t6: ch = TCRETURNri64 t8, TargetConstant:i32<0>, RegisterMask:Untyped, t0


********** List Scheduling %bb.0 '' **********
SU(0): t6: ch = TCRETURNri64 t8, TargetConstant:i32<0>, RegisterMask:Untyped, t0

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t8: i64 = MOV64ri TargetGlobalAddress:i64<ptr @main> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1

Examining Available:
Height 0: SU(0): t6: ch = TCRETURNri64 t8, TargetConstant:i32<0>, RegisterMask:Untyped, t0


*** Scheduling [0]: SU(0): t6: ch = TCRETURNri64 t8, TargetConstant:i32<0>, RegisterMask:Untyped, t0


Examining Available:
Height 1: SU(1): t8: i64 = MOV64ri TargetGlobalAddress:i64<ptr @main> 0


*** Scheduling [1]: SU(1): t8: i64 = MOV64ri TargetGlobalAddress:i64<ptr @main> 0

*** Final schedule ***
SU(1): t8: i64 = MOV64ri TargetGlobalAddress:i64<ptr @main> 0

SU(0): t6: ch = TCRETURNri64 t8, TargetConstant:i32<0>, RegisterMask:Untyped, t0


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function _mlir_main: IsSSA, TracksLiveness

bb.0 (%ir-block.1):
  %1:gr64_tc = MOV64ri @main
  TCRETURNri64 killed %1:gr64_tc, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp

# End machine code for function _mlir_main.

***** Machine Function before Domain Reassignment *****
# Machine code for function _mlir_main: IsSSA, TracksLiveness

bb.0 (%ir-block.1):
  %1:gr64_tc = MOV64ri @main
  TCRETURNri64 killed %1:gr64_tc, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp

# End machine code for function _mlir_main.

# Machine code for function _mlir_main: IsSSA, TracksLiveness

0B	bb.0 (%ir-block.1):
16B	  %1:gr64_tc = MOV64ri @main
32B	  TCRETURNri64 killed %1:gr64_tc, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp

# End machine code for function _mlir_main.

********** Stack Coloring **********
********** Function: _mlir_main
********** EARLY IF-CONVERSION **********
********** Function: _mlir_main
Machine InstCombiner: _mlir_main
Combining MBB 
********** X86 cmov Conversion : _mlir_main**********

block-frequency: _mlir_main
===========================
reverse-post-order-traversal
 - 0: BB0[]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _mlir_main
 - BB0[]: float = 1.0, int = 8

******** Pre-regalloc Machine LICM: _mlir_main ********

block-frequency: _mlir_main
===========================
reverse-post-order-traversal
 - 0: BB0[]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _mlir_main
 - BB0[]: float = 1.0, int = 8

Entering: 
Exiting: 
		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
Computing cycles for function: _mlir_main
Entry block: bb.0 (%ir-block.1)
DFS visiting block: bb.0 (%ir-block.1)
  first encountered at depth 1
  preorder number: 1
DFS visiting block: bb.0 (%ir-block.1)
  ended at 1
Preorder:
  bb.0 (%ir-block.1): 0
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: _mlir_main
Encountered load fold barrier on TCRETURNri64 killed %1:gr64_tc, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp
**** Analysing _mlir_main
Start X86AvoidStoreForwardBlocks
End X86AvoidStoreForwardBlocks
********** X86 speculative load hardening : _mlir_main **********
********** X86 EFLAGS copy lowering : _mlir_main **********
Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: _mlir_main
********** REWRITING TWO-ADDR INSTRS **********
********** Function: _mlir_main
# Machine code for function _mlir_main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0 (%ir-block.1):
16B	  %1:gr64_tc = MOV64ri @main
32B	  TCRETURNri64 killed %1:gr64_tc, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp

# End machine code for function _mlir_main.

Computing live-in reg-units in ABI blocks.
Created 0 new intervals.
********** INTERVALS **********
%1 [16r,32r:0) 0@16r  weight:0.000000e+00
RegMasks: 32r
********** MACHINEINSTRS **********
# Machine code for function _mlir_main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0 (%ir-block.1):
16B	  %1:gr64_tc = MOV64ri @main
32B	  TCRETURNri64 %1:gr64_tc, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp

# End machine code for function _mlir_main.

********** SIMPLE REGISTER COALESCING **********
********** Function: _mlir_main
********** JOINING INTERVALS ***********
:
Trying to inflate 0 regs.
********** INTERVALS **********
%1 [16r,32r:0) 0@16r  weight:0.000000e+00
RegMasks: 32r
********** MACHINEINSTRS **********
# Machine code for function _mlir_main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0 (%ir-block.1):
16B	  %1:gr64_tc = MOV64ri @main
32B	  TCRETURNri64 %1:gr64_tc, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp

# End machine code for function _mlir_main.

Before MISched:
# Machine code for function _mlir_main: NoPHIs, TracksLiveness, TiedOpsRewritten

bb.0 (%ir-block.1):
  %1:gr64_tc = MOV64ri @main
  TCRETURNri64 %1:gr64_tc, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp

# End machine code for function _mlir_main.

AllocationOrder(GR32) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $ebp $r14d $r15d $r12d $r13d ]
AllocationOrder(GR16) = [ $ax $cx $dx $si $di $r8w $r9w $r10w $r11w $bx $bp $r14w $r15w $r12w $r13w ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
********** INTERVALS **********
%1 [16r,32r:0) 0@16r  weight:0.000000e+00
RegMasks: 32r
********** MACHINEINSTRS **********
# Machine code for function _mlir_main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0 (%ir-block.1):
16B	  %1:gr64_tc = MOV64ri @main
32B	  TCRETURNri64 %1:gr64_tc, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp

# End machine code for function _mlir_main.


block-frequency: _mlir_main
===========================
reverse-post-order-traversal
 - 0: BB0[]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _mlir_main
 - BB0[]: float = 1.0, int = 8

********** GREEDY REGISTER ALLOCATION **********
********** Function: _mlir_main
********** GREEDY REGISTER ALLOCATION **********
********** Function: _mlir_main
********** Compute Spill Weights **********
********** Function: _mlir_main
********** INTERVALS **********
%1 [16r,32r:0) 0@16r  weight:INF
RegMasks: 32r
********** MACHINEINSTRS **********
# Machine code for function _mlir_main: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues

0B	bb.0 (%ir-block.1):
16B	  %1:gr64_tc = MOV64ri @main
32B	  TCRETURNri64 %1:gr64_tc, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp

# End machine code for function _mlir_main.

Enqueuing %1
AllocationOrder(GR64) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp ]
AllocationOrder(GR64_TC) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r11 ] (sub-class)

selectOrSplit GR64_TC:%1 [16r,32r:0) 0@16r  weight:INF w=INF
assigning %1 to $rax: AH [16r,32r:0) 0@16r AL [16r,32r:0) 0@16r HAX [16r,32r:0) 0@16r
********** REWRITE VIRTUAL REGISTERS **********
********** Function: _mlir_main
********** REGISTER MAP **********
[%1 -> $rax] GR64_TC

0B	bb.0 (%ir-block.1):
16B	  %1:gr64_tc = MOV64ri @main
32B	  TCRETURNri64 killed %1:gr64_tc, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp
> renamable $rax = MOV64ri @main
> TCRETURNri64 killed renamable $rax, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp
********** Stack Slot Coloring **********
********** Function: _mlir_main
MCP: BackwardCopyPropagateBlock 
MCP: ForwardCopyPropagateBlock 
******** Post-regalloc Machine LICM: _mlir_main ********
***** X86 Load Value Injection (LVI) Load Hardening : _mlir_main *****

block-frequency: _mlir_main
===========================
reverse-post-order-traversal
 - 0: BB0[]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _mlir_main
 - BB0[]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
Found interesting instruction in %bb.0:  renamable $rax = MOV64ri @main
MCP: BackwardCopyPropagateBlock 
MCP: ForwardCopyPropagateBlock 
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: _mlir_main

block-frequency: _mlir_main
===========================
reverse-post-order-traversal
 - 0: BB0[]
loop-detection
compute-mass-in-function
 - node: BB0[]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _mlir_main
 - BB0[]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
********** REACHING DEFINITION ANALYSIS **********
%bb.0: all preds known
%bb.0: entry
AH:	0	renamable $rax = MOV64ri @main
AL:	0	renamable $rax = MOV64ri @main
HAX:	0	renamable $rax = MOV64ri @main
********** FIX EXECUTION DOMAIN: VR128X **********
%bb.0: entry
********** BREAK FALSE DEPENDENCIES **********
Start X86FixupBWInsts
End X86FixupBWInsts
Start X86FixupLEAs
End X86FixupLEAs
********** COMPUTING STACKMAP LIVENESS: _mlir_main **********
X86 Indirect Thunks
X86 Return Thunks
***** X86 Load Value Injection (LVI) Ret-Hardening : _mlir_main *****
assembler backend - pre-layout
--
<MCAssembler
  Sections:[
    <MCSection Fragments:[
      <MCAlignFragment<MCFragment 0x600001838320 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x6000004380f0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[55,48,89,E5,41,57,41,56,41,55,41,54,53,48,83,EC,78,48,B8,00,00,00,00,00,00,00,00,BF,38,00,00,00,FF,D0,48,89,C3,48,89,85,60,FF,FF,FF,48,89,85,68,FF,FF,FF,48,C7,85,70,FF,FF,FF,00,00,00,00,48,C7,85,78,FF,FF,FF,07,00,00,00,48,C7,45,80,01,00,00,00,48,8D,85,60,FF,FF,FF,49,BA,00,00,00,00,00,00,00,00,BA,03,00,00,00,41,B9,01,00,00,00,BF,01,00,00,00,31,F6,31,C9,49,C7,C0,FF,FF,FF,FF,6A,01,50,41,FF,D2,48,83,C4,10,4C,8B,2B,4C,8B,63,08,4C,8B,7B,10,48,8B,43,18,48,89,45,C0,48,8B,43,20,48,89,45,D0,48,8B,43,28,48,89,45,C8,48,8B,43,30,48,89,45,A8,48,8B,43,38,48,89,45,B8,48,8B,43,40,48,89,45,B0,4E,8D,34,ED,00,00,00,00,4C,89,F7,48,B8,00,00,00,00,00,00,00,00,FF,D0,48,89,C3,48,B8,00,00,00,00,00,00,00,00,4D,85,ED] (233 bytes),
        Fixups:[<MCFixup Offset:19 Value:_malloc Kind:4>,
                <MCFixup Offset:90 Value:_read_input_sizes_2D_f64 Kind:4>,
                <MCFixup Offset:207 Value:_malloc Kind:4>,
                <MCFixup Offset:222 Value:___bzero Kind:4>]>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0b0e0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_2)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x6000004381e0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,4C,89,F6,FF,D0,48,89,E0,48,8D,48,D0,48,89,4D,88,48,89,CC,48,89,58,D0,48,89,58,D8,48,C7,40,E0,00,00,00,00,4C,89,68,E8,48,C7,40,F0,01,00,00,00,4E,8D,34,E5,00,00,00,00,4C,89,F7,49,BD,00,00,00,00,00,00,00,00,41,FF,D5,48,89,C3,4D,85,E4] (80 bytes),
        Fixups:[<MCFixup Offset:63 Value:_malloc Kind:4>]>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0bf80 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_4)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x6000004382d0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,4C,89,F6,48,B8,00,00,00,00,00,00,00,00,FF,D0,48,89,E0,48,8D,48,D0,48,89,4D,90,48,89,CC,48,89,58,D0,48,89,58,D8,48,C7,40,E0,00,00,00,00,4C,89,60,E8,48,C7,40,F0,01,00,00,00,4E,8D,34,FD,00,00,00,00,4C,89,F7,41,FF,D5,48,89,C3,4D,85,FF,49,BC,00,00,00,00,00,00,00,00] (90 bytes),
        Fixups:[<MCFixup Offset:8 Value:___bzero Kind:4>,
                <MCFixup Offset:82 Value:___bzero Kind:4>]>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c0d0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_6)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x6000004383c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,4C,89,F6,41,FF,D4,48,89,E0,48,8D,48,D0,48,89,4D,98,48,89,CC,48,89,58,D0,48,89,58,D8,48,C7,40,E0,00,00,00,00,4C,89,78,E8,48,C7,40,F0,01,00,00,00,4C,8B,7D,C0,4E,8D,34,FD,00,00,00,00,4C,89,F7,41,FF,D5,48,89,C3,4D,85,FF] (75 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c220 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_8)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x6000004384b0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,4C,89,F6,41,FF,D4,48,89,E0,48,8D,48,D0,48,89,4D,A0,48,89,CC,48,89,58,D0,48,89,58,D8,48,C7,40,E0,00,00,00,00,4C,89,78,E8,48,C7,40,F0,01,00,00,00,4C,8B,7D,D0,4E,8D,34,FD,00,00,00,00,4C,89,F7,41,FF,D5,48,89,C3,4D,85,FF,4C,8B,7D,C8] (79 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c370 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_10)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x6000004385a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,4C,89,F6,41,FF,D4,48,89,E0,48,8D,48,D0,48,89,4D,C0,48,89,CC,48,89,58,D0,48,89,58,D8,48,C7,40,E0,00,00,00,00,48,8B,4D,D0,48,89,48,E8,48,C7,40,F0,01,00,00,00,4A,8D,1C,FD,00,00,00,00,48,89,DF,41,FF,D5,49,89,C6,4D,85,FF] (75 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c4c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_12)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x600000438690 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[4C,89,F7,48,89,DE,41,FF,D4,48,89,E0,48,8D,48,D0,48,89,4D,D0,48,89,CC,4C,89,70,D0,4C,89,70,D8,48,C7,40,E0,00,00,00,00,4C,89,78,E8,48,C7,40,F0,01,00,00,00,48,8B,5D,A8,4C,8D,34,DD,00,00,00,00,4C,89,F7,41,FF,D5,49,89,C7,48,85,DB] (75 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c610 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_14)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x600000438780 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[4C,89,FF,4C,89,F6,41,FF,D4,48,89,E0,48,8D,48,D0,48,89,4D,C8,48,89,CC,4C,89,78,D0,4C,89,78,D8,48,C7,40,E0,00,00,00,00,48,89,58,E8,48,C7,40,F0,01,00,00,00,4C,8B,75,B8,4E,8D,3C,F5,00,00,00,00,4C,89,FF,41,FF,D5,49,89,C4,4D,85,F6,48,8B,5D,B0] (79 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c760 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_16)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x600000438870 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[4C,89,E7,4C,89,FE,48,B8,00,00,00,00,00,00,00,00,FF,D0,48,89,E0,4C,8D,78,D0,4C,89,FC,4C,89,60,D0,4C,89,60,D8,48,C7,40,E0,00,00,00,00,4C,89,70,E8,48,C7,40,F0,01,00,00,00,4C,8D,24,DD,00,00,00,00,4C,89,E7,41,FF,D5,49,89,C5,48,85,DB] (76 bytes),
        Fixups:[<MCFixup Offset:8 Value:___bzero Kind:4>]>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0e500 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_18)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x600000438960 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[4C,89,EF,4C,89,E6,48,B8,00,00,00,00,00,00,00,00,FF,D0,48,89,E0,48,8D,48,D0,48,89,CC,49,89,CA,48,89,4D,B8,4C,89,68,D0,4C,89,68,D8,48,C7,40,E0,00,00,00,00,48,89,58,E8,48,C7,40,F0,01,00,00,00,48,B8,00,00,00,00,00,00,00,00,BA,03,00,00,00,41,B9,01,00,00,00,BF,01,00,00,00,31,F6,31,C9,49,C7,C0,FF,FF,FF,FF,6A,01,41,52,6A,01,41,57,6A,01,FF,75,C8,6A,01,FF,75,D0,6A,01,FF,75,C0,6A,01,4C,8B,65,A0,41,54,6A,01,4C,89,7D,B0,4C,8B,7D,98,41,57,6A,01,4C,8B,75,90,41,56,6A,01,48,8B,5D,88,53,FF,D0,48,81,C4,90,00,00,00,49,BD,00,00,00,00,00,00,00,00,BF,01,00,00,00,48,89,DE,41,FF,D5,BF,01,00,00,00,4C,89,F6,41,FF,D5,BF,01,00,00,00,4C,89,FE,41,FF,D5,BF,01,00,00,00,4C,89,E6,41,FF,D5,BF,01,00,00,00,48,8B,75,C0,41,FF,D5,BF,01,00,00,00,48,8B,75,D0,41,FF,D5,BF,01,00,00,00,48,8B,75,C8,41,FF,D5,BF,01,00,00,00,48,8B,75,B0,41,FF,D5,48,B8,00,00,00,00,00,00,00,00,BF,01,00,00,00,48,8B,75,B8,FF,D0,48,8D,65,D8,5B,41,5C,41,5D,41,5E,41,5F,5D,C3] (305 bytes),
        Fixups:[<MCFixup Offset:8 Value:___bzero Kind:4>,
                <MCFixup Offset:65 Value:_read_input_2D_f64 Kind:4>,
                <MCFixup Offset:169 Value:_comet_print_memref_i64 Kind:4>,
                <MCFixup Offset:271 Value:_comet_print_memref_f64 Kind:4>]>,
      <MCAlignFragment<MCFragment 0x60000182c730 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x6000004343c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[48,B8,00,00,00,00,00,00,00,00,FF,E0] (12 bytes),
        Fixups:[<MCFixup Offset:2 Value:_main Kind:4>]>]>,
    <MCSection Fragments:[
      <MCAlignFragment<MCFragment 0x60000182c6e0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x6000004344b0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,D1,58,05,01,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (32 bytes),
        Fixups:[<MCFixup Offset:0 Value: Kind:4>,
                <MCFixup Offset:8 Value: Kind:3>]>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x6000004345a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,01,7A,52,00,01,78,10,01,10,0C,07,08,90,01] (22 bytes),
        Fixups:[<MCFixup Offset:0 Value: Kind:3>]>,
      <MCAlignFragment<MCFragment 0x60000182c8c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0x600000434690 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (25 bytes),
        Fixups:[<MCFixup Offset:0 Value: Kind:3>,
                <MCFixup Offset:4 Value: Kind:3>,
                <MCFixup Offset:8 Value: Kind:4>,
                <MCFixup Offset:16 Value: Kind:4>]>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092c630 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434780 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092c7e0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434870 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[86,02] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092c750 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434960 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0D,06] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092c990 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434a50 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[83,07] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092c900 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434b40 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8C,06] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092cbd0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434c30 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8D,05] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092cab0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434d20 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8E,04] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092ca20 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434e10 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8F,03] (2 bytes)>,
      <MCAlignFragment<MCFragment 0x60000182c910 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x600000434f00 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (25 bytes),
        Fixups:[<MCFixup Offset:0 Value: Kind:3>,
                <MCFixup Offset:4 Value: Kind:3>,
                <MCFixup Offset:8 Value: Kind:4>,
                <MCFixup Offset:16 Value: Kind:4>]>,
      <MCAlignFragment<MCFragment 0x60000182caa0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x600000434ff0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>],
  Symbols:[(_main, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (_malloc, Index:0, ),
           (_read_input_sizes_2D_f64, Index:0, ),
           (___bzero, Index:0, ),
           (LBB0_2, Index:0, ),
           (LBB0_4, Index:0, ),
           (LBB0_6, Index:0, ),
           (LBB0_8, Index:0, ),
           (LBB0_10, Index:0, ),
           (LBB0_12, Index:0, ),
           (LBB0_14, Index:0, ),
           (LBB0_16, Index:0, ),
           (LBB0_18, Index:0, ),
           (_read_input_2D_f64, Index:0, ),
           (_comet_print_memref_i64, Index:0, ),
           (_comet_print_memref_f64, Index:0, ),
           (, Index:0, ),
           (__mlir_main, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, )]>
assembler backend - post-relaxation
--
<MCAssembler
  Sections:[
    <MCSection Fragments:[
      <MCAlignFragment<MCFragment 0x600001838320 LayoutOrder:0 Offset:0 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x6000004380f0 LayoutOrder:1 Offset:0 HasInstructions:1 BundlePadding:0>
        Contents:[55,48,89,E5,41,57,41,56,41,55,41,54,53,48,83,EC,78,48,B8,00,00,00,00,00,00,00,00,BF,38,00,00,00,FF,D0,48,89,C3,48,89,85,60,FF,FF,FF,48,89,85,68,FF,FF,FF,48,C7,85,70,FF,FF,FF,00,00,00,00,48,C7,85,78,FF,FF,FF,07,00,00,00,48,C7,45,80,01,00,00,00,48,8D,85,60,FF,FF,FF,49,BA,00,00,00,00,00,00,00,00,BA,03,00,00,00,41,B9,01,00,00,00,BF,01,00,00,00,31,F6,31,C9,49,C7,C0,FF,FF,FF,FF,6A,01,50,41,FF,D2,48,83,C4,10,4C,8B,2B,4C,8B,63,08,4C,8B,7B,10,48,8B,43,18,48,89,45,C0,48,8B,43,20,48,89,45,D0,48,8B,43,28,48,89,45,C8,48,8B,43,30,48,89,45,A8,48,8B,43,38,48,89,45,B8,48,8B,43,40,48,89,45,B0,4E,8D,34,ED,00,00,00,00,4C,89,F7,48,B8,00,00,00,00,00,00,00,00,FF,D0,48,89,C3,48,B8,00,00,00,00,00,00,00,00,4D,85,ED] (233 bytes),
        Fixups:[<MCFixup Offset:19 Value:_malloc Kind:4>,
                <MCFixup Offset:90 Value:_read_input_sizes_2D_f64 Kind:4>,
                <MCFixup Offset:207 Value:_malloc Kind:4>,
                <MCFixup Offset:222 Value:___bzero Kind:4>]>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0b0e0 LayoutOrder:2 Offset:233 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_2)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x6000004381e0 LayoutOrder:3 Offset:235 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,4C,89,F6,FF,D0,48,89,E0,48,8D,48,D0,48,89,4D,88,48,89,CC,48,89,58,D0,48,89,58,D8,48,C7,40,E0,00,00,00,00,4C,89,68,E8,48,C7,40,F0,01,00,00,00,4E,8D,34,E5,00,00,00,00,4C,89,F7,49,BD,00,00,00,00,00,00,00,00,41,FF,D5,48,89,C3,4D,85,E4] (80 bytes),
        Fixups:[<MCFixup Offset:63 Value:_malloc Kind:4>]>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0bf80 LayoutOrder:4 Offset:315 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_4)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x6000004382d0 LayoutOrder:5 Offset:317 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,4C,89,F6,48,B8,00,00,00,00,00,00,00,00,FF,D0,48,89,E0,48,8D,48,D0,48,89,4D,90,48,89,CC,48,89,58,D0,48,89,58,D8,48,C7,40,E0,00,00,00,00,4C,89,60,E8,48,C7,40,F0,01,00,00,00,4E,8D,34,FD,00,00,00,00,4C,89,F7,41,FF,D5,48,89,C3,4D,85,FF,49,BC,00,00,00,00,00,00,00,00] (90 bytes),
        Fixups:[<MCFixup Offset:8 Value:___bzero Kind:4>,
                <MCFixup Offset:82 Value:___bzero Kind:4>]>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c0d0 LayoutOrder:6 Offset:407 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_6)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x6000004383c0 LayoutOrder:7 Offset:409 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,4C,89,F6,41,FF,D4,48,89,E0,48,8D,48,D0,48,89,4D,98,48,89,CC,48,89,58,D0,48,89,58,D8,48,C7,40,E0,00,00,00,00,4C,89,78,E8,48,C7,40,F0,01,00,00,00,4C,8B,7D,C0,4E,8D,34,FD,00,00,00,00,4C,89,F7,41,FF,D5,48,89,C3,4D,85,FF] (75 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c220 LayoutOrder:8 Offset:484 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_8)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x6000004384b0 LayoutOrder:9 Offset:486 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,4C,89,F6,41,FF,D4,48,89,E0,48,8D,48,D0,48,89,4D,A0,48,89,CC,48,89,58,D0,48,89,58,D8,48,C7,40,E0,00,00,00,00,4C,89,78,E8,48,C7,40,F0,01,00,00,00,4C,8B,7D,D0,4E,8D,34,FD,00,00,00,00,4C,89,F7,41,FF,D5,48,89,C3,4D,85,FF,4C,8B,7D,C8] (79 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c370 LayoutOrder:10 Offset:565 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_10)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x6000004385a0 LayoutOrder:11 Offset:567 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,4C,89,F6,41,FF,D4,48,89,E0,48,8D,48,D0,48,89,4D,C0,48,89,CC,48,89,58,D0,48,89,58,D8,48,C7,40,E0,00,00,00,00,48,8B,4D,D0,48,89,48,E8,48,C7,40,F0,01,00,00,00,4A,8D,1C,FD,00,00,00,00,48,89,DF,41,FF,D5,49,89,C6,4D,85,FF] (75 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c4c0 LayoutOrder:12 Offset:642 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_12)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x600000438690 LayoutOrder:13 Offset:644 HasInstructions:1 BundlePadding:0>
        Contents:[4C,89,F7,48,89,DE,41,FF,D4,48,89,E0,48,8D,48,D0,48,89,4D,D0,48,89,CC,4C,89,70,D0,4C,89,70,D8,48,C7,40,E0,00,00,00,00,4C,89,78,E8,48,C7,40,F0,01,00,00,00,48,8B,5D,A8,4C,8D,34,DD,00,00,00,00,4C,89,F7,41,FF,D5,49,89,C7,48,85,DB] (75 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c610 LayoutOrder:14 Offset:719 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_14)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x600000438780 LayoutOrder:15 Offset:721 HasInstructions:1 BundlePadding:0>
        Contents:[4C,89,FF,4C,89,F6,41,FF,D4,48,89,E0,48,8D,48,D0,48,89,4D,C8,48,89,CC,4C,89,78,D0,4C,89,78,D8,48,C7,40,E0,00,00,00,00,48,89,58,E8,48,C7,40,F0,01,00,00,00,4C,8B,75,B8,4E,8D,3C,F5,00,00,00,00,4C,89,FF,41,FF,D5,49,89,C4,4D,85,F6,48,8B,5D,B0] (79 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c760 LayoutOrder:16 Offset:800 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_16)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x600000438870 LayoutOrder:17 Offset:802 HasInstructions:1 BundlePadding:0>
        Contents:[4C,89,E7,4C,89,FE,48,B8,00,00,00,00,00,00,00,00,FF,D0,48,89,E0,4C,8D,78,D0,4C,89,FC,4C,89,60,D0,4C,89,60,D8,48,C7,40,E0,00,00,00,00,4C,89,70,E8,48,C7,40,F0,01,00,00,00,4C,8D,24,DD,00,00,00,00,4C,89,E7,41,FF,D5,49,89,C5,48,85,DB] (76 bytes),
        Fixups:[<MCFixup Offset:8 Value:___bzero Kind:4>]>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0e500 LayoutOrder:18 Offset:878 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_18)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x600000438960 LayoutOrder:19 Offset:880 HasInstructions:1 BundlePadding:0>
        Contents:[4C,89,EF,4C,89,E6,48,B8,00,00,00,00,00,00,00,00,FF,D0,48,89,E0,48,8D,48,D0,48,89,CC,49,89,CA,48,89,4D,B8,4C,89,68,D0,4C,89,68,D8,48,C7,40,E0,00,00,00,00,48,89,58,E8,48,C7,40,F0,01,00,00,00,48,B8,00,00,00,00,00,00,00,00,BA,03,00,00,00,41,B9,01,00,00,00,BF,01,00,00,00,31,F6,31,C9,49,C7,C0,FF,FF,FF,FF,6A,01,41,52,6A,01,41,57,6A,01,FF,75,C8,6A,01,FF,75,D0,6A,01,FF,75,C0,6A,01,4C,8B,65,A0,41,54,6A,01,4C,89,7D,B0,4C,8B,7D,98,41,57,6A,01,4C,8B,75,90,41,56,6A,01,48,8B,5D,88,53,FF,D0,48,81,C4,90,00,00,00,49,BD,00,00,00,00,00,00,00,00,BF,01,00,00,00,48,89,DE,41,FF,D5,BF,01,00,00,00,4C,89,F6,41,FF,D5,BF,01,00,00,00,4C,89,FE,41,FF,D5,BF,01,00,00,00,4C,89,E6,41,FF,D5,BF,01,00,00,00,48,8B,75,C0,41,FF,D5,BF,01,00,00,00,48,8B,75,D0,41,FF,D5,BF,01,00,00,00,48,8B,75,C8,41,FF,D5,BF,01,00,00,00,48,8B,75,B0,41,FF,D5,48,B8,00,00,00,00,00,00,00,00,BF,01,00,00,00,48,8B,75,B8,FF,D0,48,8D,65,D8,5B,41,5C,41,5D,41,5E,41,5F,5D,C3] (305 bytes),
        Fixups:[<MCFixup Offset:8 Value:___bzero Kind:4>,
                <MCFixup Offset:65 Value:_read_input_2D_f64 Kind:4>,
                <MCFixup Offset:169 Value:_comet_print_memref_i64 Kind:4>,
                <MCFixup Offset:271 Value:_comet_print_memref_f64 Kind:4>]>,
      <MCAlignFragment<MCFragment 0x60000182c730 LayoutOrder:20 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x6000004343c0 LayoutOrder:21 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[48,B8,00,00,00,00,00,00,00,00,FF,E0] (12 bytes),
        Fixups:[<MCFixup Offset:2 Value:_main Kind:4>]>]>,
    <MCSection Fragments:[
      <MCAlignFragment<MCFragment 0x60000182c6e0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x6000004344b0 LayoutOrder:1 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,D1,58,05,01,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (32 bytes),
        Fixups:[<MCFixup Offset:0 Value: Kind:4>,
                <MCFixup Offset:8 Value: Kind:3>]>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x6000004345a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,01,7A,52,00,01,78,10,01,10,0C,07,08,90,01] (22 bytes),
        Fixups:[<MCFixup Offset:0 Value: Kind:3>]>,
      <MCAlignFragment<MCFragment 0x60000182c8c0 LayoutOrder:1 Offset:18446744073709551615 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0x600000434690 LayoutOrder:2 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (25 bytes),
        Fixups:[<MCFixup Offset:0 Value: Kind:3>,
                <MCFixup Offset:4 Value: Kind:3>,
                <MCFixup Offset:8 Value: Kind:4>,
                <MCFixup Offset:16 Value: Kind:4>]>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092c630 LayoutOrder:3 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434780 LayoutOrder:4 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092c7e0 LayoutOrder:5 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434870 LayoutOrder:6 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[86,02] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092c750 LayoutOrder:7 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434960 LayoutOrder:8 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0D,06] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092c990 LayoutOrder:9 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434a50 LayoutOrder:10 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[83,07] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092c900 LayoutOrder:11 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434b40 LayoutOrder:12 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8C,06] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092cbd0 LayoutOrder:13 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434c30 LayoutOrder:14 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8D,05] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092cab0 LayoutOrder:15 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434d20 LayoutOrder:16 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8E,04] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092ca20 LayoutOrder:17 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434e10 LayoutOrder:18 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8F,03] (2 bytes)>,
      <MCAlignFragment<MCFragment 0x60000182c910 LayoutOrder:19 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x600000434f00 LayoutOrder:20 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (25 bytes),
        Fixups:[<MCFixup Offset:0 Value: Kind:3>,
                <MCFixup Offset:4 Value: Kind:3>,
                <MCFixup Offset:8 Value: Kind:4>,
                <MCFixup Offset:16 Value: Kind:4>]>,
      <MCAlignFragment<MCFragment 0x60000182caa0 LayoutOrder:21 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x600000434ff0 LayoutOrder:22 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>],
  Symbols:[(_main, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (_malloc, Index:0, ),
           (_read_input_sizes_2D_f64, Index:0, ),
           (___bzero, Index:0, ),
           (LBB0_2, Index:0, ),
           (LBB0_4, Index:0, ),
           (LBB0_6, Index:0, ),
           (LBB0_8, Index:0, ),
           (LBB0_10, Index:0, ),
           (LBB0_12, Index:0, ),
           (LBB0_14, Index:0, ),
           (LBB0_16, Index:0, ),
           (LBB0_18, Index:0, ),
           (_read_input_2D_f64, Index:0, ),
           (_comet_print_memref_i64, Index:0, ),
           (_comet_print_memref_f64, Index:0, ),
           (, Index:0, ),
           (__mlir_main, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, )]>
assembler backend - final-layout
--
<MCAssembler
  Sections:[
    <MCSection Fragments:[
      <MCAlignFragment<MCFragment 0x600001838320 LayoutOrder:0 Offset:0 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x6000004380f0 LayoutOrder:1 Offset:0 HasInstructions:1 BundlePadding:0>
        Contents:[55,48,89,E5,41,57,41,56,41,55,41,54,53,48,83,EC,78,48,B8,00,00,00,00,00,00,00,00,BF,38,00,00,00,FF,D0,48,89,C3,48,89,85,60,FF,FF,FF,48,89,85,68,FF,FF,FF,48,C7,85,70,FF,FF,FF,00,00,00,00,48,C7,85,78,FF,FF,FF,07,00,00,00,48,C7,45,80,01,00,00,00,48,8D,85,60,FF,FF,FF,49,BA,00,00,00,00,00,00,00,00,BA,03,00,00,00,41,B9,01,00,00,00,BF,01,00,00,00,31,F6,31,C9,49,C7,C0,FF,FF,FF,FF,6A,01,50,41,FF,D2,48,83,C4,10,4C,8B,2B,4C,8B,63,08,4C,8B,7B,10,48,8B,43,18,48,89,45,C0,48,8B,43,20,48,89,45,D0,48,8B,43,28,48,89,45,C8,48,8B,43,30,48,89,45,A8,48,8B,43,38,48,89,45,B8,48,8B,43,40,48,89,45,B0,4E,8D,34,ED,00,00,00,00,4C,89,F7,48,B8,00,00,00,00,00,00,00,00,FF,D0,48,89,C3,48,B8,00,00,00,00,00,00,00,00,4D,85,ED] (233 bytes),
        Fixups:[<MCFixup Offset:19 Value:_malloc Kind:4>,
                <MCFixup Offset:90 Value:_read_input_sizes_2D_f64 Kind:4>,
                <MCFixup Offset:207 Value:_malloc Kind:4>,
                <MCFixup Offset:222 Value:___bzero Kind:4>]>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0b0e0 LayoutOrder:2 Offset:233 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_2)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x6000004381e0 LayoutOrder:3 Offset:235 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,4C,89,F6,FF,D0,48,89,E0,48,8D,48,D0,48,89,4D,88,48,89,CC,48,89,58,D0,48,89,58,D8,48,C7,40,E0,00,00,00,00,4C,89,68,E8,48,C7,40,F0,01,00,00,00,4E,8D,34,E5,00,00,00,00,4C,89,F7,49,BD,00,00,00,00,00,00,00,00,41,FF,D5,48,89,C3,4D,85,E4] (80 bytes),
        Fixups:[<MCFixup Offset:63 Value:_malloc Kind:4>]>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0bf80 LayoutOrder:4 Offset:315 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_4)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x6000004382d0 LayoutOrder:5 Offset:317 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,4C,89,F6,48,B8,00,00,00,00,00,00,00,00,FF,D0,48,89,E0,48,8D,48,D0,48,89,4D,90,48,89,CC,48,89,58,D0,48,89,58,D8,48,C7,40,E0,00,00,00,00,4C,89,60,E8,48,C7,40,F0,01,00,00,00,4E,8D,34,FD,00,00,00,00,4C,89,F7,41,FF,D5,48,89,C3,4D,85,FF,49,BC,00,00,00,00,00,00,00,00] (90 bytes),
        Fixups:[<MCFixup Offset:8 Value:___bzero Kind:4>,
                <MCFixup Offset:82 Value:___bzero Kind:4>]>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c0d0 LayoutOrder:6 Offset:407 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_6)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x6000004383c0 LayoutOrder:7 Offset:409 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,4C,89,F6,41,FF,D4,48,89,E0,48,8D,48,D0,48,89,4D,98,48,89,CC,48,89,58,D0,48,89,58,D8,48,C7,40,E0,00,00,00,00,4C,89,78,E8,48,C7,40,F0,01,00,00,00,4C,8B,7D,C0,4E,8D,34,FD,00,00,00,00,4C,89,F7,41,FF,D5,48,89,C3,4D,85,FF] (75 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c220 LayoutOrder:8 Offset:484 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_8)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x6000004384b0 LayoutOrder:9 Offset:486 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,4C,89,F6,41,FF,D4,48,89,E0,48,8D,48,D0,48,89,4D,A0,48,89,CC,48,89,58,D0,48,89,58,D8,48,C7,40,E0,00,00,00,00,4C,89,78,E8,48,C7,40,F0,01,00,00,00,4C,8B,7D,D0,4E,8D,34,FD,00,00,00,00,4C,89,F7,41,FF,D5,48,89,C3,4D,85,FF,4C,8B,7D,C8] (79 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c370 LayoutOrder:10 Offset:565 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_10)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x6000004385a0 LayoutOrder:11 Offset:567 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,4C,89,F6,41,FF,D4,48,89,E0,48,8D,48,D0,48,89,4D,C0,48,89,CC,48,89,58,D0,48,89,58,D8,48,C7,40,E0,00,00,00,00,48,8B,4D,D0,48,89,48,E8,48,C7,40,F0,01,00,00,00,4A,8D,1C,FD,00,00,00,00,48,89,DF,41,FF,D5,49,89,C6,4D,85,FF] (75 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c4c0 LayoutOrder:12 Offset:642 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_12)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x600000438690 LayoutOrder:13 Offset:644 HasInstructions:1 BundlePadding:0>
        Contents:[4C,89,F7,48,89,DE,41,FF,D4,48,89,E0,48,8D,48,D0,48,89,4D,D0,48,89,CC,4C,89,70,D0,4C,89,70,D8,48,C7,40,E0,00,00,00,00,4C,89,78,E8,48,C7,40,F0,01,00,00,00,48,8B,5D,A8,4C,8D,34,DD,00,00,00,00,4C,89,F7,41,FF,D5,49,89,C7,48,85,DB] (75 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c610 LayoutOrder:14 Offset:719 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_14)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x600000438780 LayoutOrder:15 Offset:721 HasInstructions:1 BundlePadding:0>
        Contents:[4C,89,FF,4C,89,F6,41,FF,D4,48,89,E0,48,8D,48,D0,48,89,4D,C8,48,89,CC,4C,89,78,D0,4C,89,78,D8,48,C7,40,E0,00,00,00,00,48,89,58,E8,48,C7,40,F0,01,00,00,00,4C,8B,75,B8,4E,8D,3C,F5,00,00,00,00,4C,89,FF,41,FF,D5,49,89,C4,4D,85,F6,48,8B,5D,B0] (79 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0c760 LayoutOrder:16 Offset:800 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_16)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x600000438870 LayoutOrder:17 Offset:802 HasInstructions:1 BundlePadding:0>
        Contents:[4C,89,E7,4C,89,FE,48,B8,00,00,00,00,00,00,00,00,FF,D0,48,89,E0,4C,8D,78,D0,4C,89,FC,4C,89,60,D0,4C,89,60,D8,48,C7,40,E0,00,00,00,00,4C,89,70,E8,48,C7,40,F0,01,00,00,00,4C,8D,24,DD,00,00,00,00,4C,89,E7,41,FF,D5,49,89,C5,48,85,DB] (76 bytes),
        Fixups:[<MCFixup Offset:8 Value:___bzero Kind:4>]>,
      <MCRelaxableFragment<MCFragment 0x7fee57a0e500 LayoutOrder:18 Offset:878 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1266 <MCOperand Expr:(LBB0_18)> <MCOperand Imm:14>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x600000438960 LayoutOrder:19 Offset:880 HasInstructions:1 BundlePadding:0>
        Contents:[4C,89,EF,4C,89,E6,48,B8,00,00,00,00,00,00,00,00,FF,D0,48,89,E0,48,8D,48,D0,48,89,CC,49,89,CA,48,89,4D,B8,4C,89,68,D0,4C,89,68,D8,48,C7,40,E0,00,00,00,00,48,89,58,E8,48,C7,40,F0,01,00,00,00,48,B8,00,00,00,00,00,00,00,00,BA,03,00,00,00,41,B9,01,00,00,00,BF,01,00,00,00,31,F6,31,C9,49,C7,C0,FF,FF,FF,FF,6A,01,41,52,6A,01,41,57,6A,01,FF,75,C8,6A,01,FF,75,D0,6A,01,FF,75,C0,6A,01,4C,8B,65,A0,41,54,6A,01,4C,89,7D,B0,4C,8B,7D,98,41,57,6A,01,4C,8B,75,90,41,56,6A,01,48,8B,5D,88,53,FF,D0,48,81,C4,90,00,00,00,49,BD,00,00,00,00,00,00,00,00,BF,01,00,00,00,48,89,DE,41,FF,D5,BF,01,00,00,00,4C,89,F6,41,FF,D5,BF,01,00,00,00,4C,89,FE,41,FF,D5,BF,01,00,00,00,4C,89,E6,41,FF,D5,BF,01,00,00,00,48,8B,75,C0,41,FF,D5,BF,01,00,00,00,48,8B,75,D0,41,FF,D5,BF,01,00,00,00,48,8B,75,C8,41,FF,D5,BF,01,00,00,00,48,8B,75,B0,41,FF,D5,48,B8,00,00,00,00,00,00,00,00,BF,01,00,00,00,48,8B,75,B8,FF,D0,48,8D,65,D8,5B,41,5C,41,5D,41,5E,41,5F,5D,C3] (305 bytes),
        Fixups:[<MCFixup Offset:8 Value:___bzero Kind:4>,
                <MCFixup Offset:65 Value:_read_input_2D_f64 Kind:4>,
                <MCFixup Offset:169 Value:_comet_print_memref_i64 Kind:4>,
                <MCFixup Offset:271 Value:_comet_print_memref_f64 Kind:4>]>,
      <MCAlignFragment<MCFragment 0x60000182c730 LayoutOrder:20 Offset:1185 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x6000004343c0 LayoutOrder:21 Offset:1200 HasInstructions:1 BundlePadding:0>
        Contents:[48,B8,00,00,00,00,00,00,00,00,FF,E0] (12 bytes),
        Fixups:[<MCFixup Offset:2 Value:_main Kind:4>]>]>,
    <MCSection Fragments:[
      <MCAlignFragment<MCFragment 0x60000182c6e0 LayoutOrder:0 Offset:0 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x6000004344b0 LayoutOrder:1 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,D1,58,05,01,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (32 bytes),
        Fixups:[<MCFixup Offset:0 Value: Kind:4>,
                <MCFixup Offset:8 Value: Kind:3>]>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x6000004345a0 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,01,7A,52,00,01,78,10,01,10,0C,07,08,90,01] (22 bytes),
        Fixups:[<MCFixup Offset:0 Value: Kind:3>]>,
      <MCAlignFragment<MCFragment 0x60000182c8c0 LayoutOrder:1 Offset:22 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0x600000434690 LayoutOrder:2 Offset:24 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (25 bytes),
        Fixups:[<MCFixup Offset:0 Value: Kind:3>,
                <MCFixup Offset:4 Value: Kind:3>,
                <MCFixup Offset:8 Value: Kind:4>,
                <MCFixup Offset:16 Value: Kind:4>]>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092c630 LayoutOrder:3 Offset:49 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434780 LayoutOrder:4 Offset:50 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092c7e0 LayoutOrder:5 Offset:52 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434870 LayoutOrder:6 Offset:52 HasInstructions:0 BundlePadding:0>
        Contents:[86,02] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092c750 LayoutOrder:7 Offset:54 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434960 LayoutOrder:8 Offset:55 HasInstructions:0 BundlePadding:0>
        Contents:[0D,06] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092c990 LayoutOrder:9 Offset:57 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434a50 LayoutOrder:10 Offset:58 HasInstructions:0 BundlePadding:0>
        Contents:[83,07] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092c900 LayoutOrder:11 Offset:60 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434b40 LayoutOrder:12 Offset:60 HasInstructions:0 BundlePadding:0>
        Contents:[8C,06] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092cbd0 LayoutOrder:13 Offset:62 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434c30 LayoutOrder:14 Offset:62 HasInstructions:0 BundlePadding:0>
        Contents:[8D,05] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092cab0 LayoutOrder:15 Offset:64 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434d20 LayoutOrder:16 Offset:64 HasInstructions:0 BundlePadding:0>
        Contents:[8E,04] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x60000092ca20 LayoutOrder:17 Offset:66 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x600000434e10 LayoutOrder:18 Offset:66 HasInstructions:0 BundlePadding:0>
        Contents:[8F,03] (2 bytes)>,
      <MCAlignFragment<MCFragment 0x60000182c910 LayoutOrder:19 Offset:68 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x600000434f00 LayoutOrder:20 Offset:72 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (25 bytes),
        Fixups:[<MCFixup Offset:0 Value: Kind:3>,
                <MCFixup Offset:4 Value: Kind:3>,
                <MCFixup Offset:8 Value: Kind:4>,
                <MCFixup Offset:16 Value: Kind:4>]>,
      <MCAlignFragment<MCFragment 0x60000182caa0 LayoutOrder:21 Offset:97 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x600000434ff0 LayoutOrder:22 Offset:104 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>],
  Symbols:[(_main, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (_malloc, Index:0, ),
           (_read_input_sizes_2D_f64, Index:0, ),
           (___bzero, Index:0, ),
           (LBB0_2, Index:0, ),
           (LBB0_4, Index:0, ),
           (LBB0_6, Index:0, ),
           (LBB0_8, Index:0, ),
           (LBB0_10, Index:0, ),
           (LBB0_12, Index:0, ),
           (LBB0_14, Index:0, ),
           (LBB0_16, Index:0, ),
           (LBB0_18, Index:0, ),
           (_read_input_2D_f64, Index:0, ),
           (_comet_print_memref_i64, Index:0, ),
           (_comet_print_memref_f64, Index:0, ),
           (, Index:0, ),
           (__mlir_main, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, )]>
Parse symbols:
emitSection SectionID: 0 Name: __text obj addr: 0x7fee5608ddd8 new addr: 0x124e7b000 DataSize: 1216 StubBufSize: 108 Allocate: 1327
	Type: 5 Name: __mlir_main SID: 0 Offset: 0x4b0 flags: 66
	Type: 5 Name: _main SID: 0 Offset: 0x0 flags: 66
Parse relocations:
	SectionID: 0
emitSection SectionID: 1 Name: __compact_unwind obj addr: 0x7fee5608e298 new addr: 0x124e7c000 DataSize: 32 StubBufSize: 8 Allocate: 47
	SectionID: 1
emitSection SectionID: 2 Name: __eh_frame obj addr: 0x7fee5608e2b8 new addr: 0x124e7c030 DataSize: 104 StubBufSize: 0 Allocate: 104
In main resolving { ("_main": 0x0000000124e7b000 [Callable]), ("__mlir_main": 0x0000000124e7b4b0 [Callable]) }
Looking up { (___bzero, RequiredSymbol), (_comet_print_memref_f64, RequiredSymbol), (_comet_print_memref_i64, RequiredSymbol), (_malloc, RequiredSymbol), (_read_input_2D_f64, RequiredSymbol), (_read_input_sizes_2D_f64, RequiredSymbol) } in [ ("main", MatchAllSymbols) ] (required state: Resolved)
Dispatching MaterializationUnits...
Done dispatching MaterializationUnits.
Entering OL_applyQueryPhase1:
  Lookup kind: Static
  Search order: [ ("main", MatchAllSymbols) ], Current index = 0 (entering new JITDylib)
  Lookup set: { (___bzero, RequiredSymbol), (_comet_print_memref_f64, RequiredSymbol), (_comet_print_memref_i64, RequiredSymbol), (_malloc, RequiredSymbol), (_read_input_2D_f64, RequiredSymbol), (_read_input_sizes_2D_f64, RequiredSymbol) }
  Definition generator candidates: { (___bzero, RequiredSymbol), (_comet_print_memref_f64, RequiredSymbol), (_comet_print_memref_i64, RequiredSymbol), (_malloc, RequiredSymbol), (_read_input_2D_f64, RequiredSymbol), (_read_input_sizes_2D_f64, RequiredSymbol) }
  Definition generator non-candidates: { }
Visiting "main" (MatchAllSymbols) with lookup set { (___bzero, RequiredSymbol), (_comet_print_memref_f64, RequiredSymbol), (_comet_print_memref_i64, RequiredSymbol), (_malloc, RequiredSymbol), (_read_input_2D_f64, RequiredSymbol), (_read_input_sizes_2D_f64, RequiredSymbol) }:
  First time visiting main, resetting candidate sets and building generator stack
  Updating candidate set...
    Remaining candidates = { (___bzero, RequiredSymbol), (_comet_print_memref_f64, RequiredSymbol), (_comet_print_memref_i64, RequiredSymbol), (_malloc, RequiredSymbol), (_read_input_2D_f64, RequiredSymbol), (_read_input_sizes_2D_f64, RequiredSymbol) }
  Running 1 remaining generators for 6 candidates
  Attempting to generate { (___bzero, RequiredSymbol), (_comet_print_memref_f64, RequiredSymbol), (_comet_print_memref_i64, RequiredSymbol), (_malloc, RequiredSymbol), (_read_input_2D_f64, RequiredSymbol), (_read_input_sizes_2D_f64, RequiredSymbol) }
Defining MU <Absolute Symbols> for main (tracker: 0x0, default will be used)
  { ("_read_input_2D_f64", [Data]), ("_read_input_sizes_2D_f64", [Data]), ("_malloc", [Data]), ("___bzero", [Data]), ("_comet_print_memref_i64", [Data]), ("_comet_print_memref_f64", [Data]) }
  Updating candidate set post-generation
All symbols matched.
Phase 1 succeeded.
Entering OL_completeLookup:
  Lookup kind: Static
  Search order: [ ("main", MatchAllSymbols) ], Current index = 1
  Lookup set: { (___bzero, RequiredSymbol), (_comet_print_memref_f64, RequiredSymbol), (_comet_print_memref_i64, RequiredSymbol), (_malloc, RequiredSymbol), (_read_input_2D_f64, RequiredSymbol), (_read_input_sizes_2D_f64, RequiredSymbol) }
  Definition generator candidates: { }
  Definition generator non-candidates: { }
Visiting "main" (MatchAllSymbols) with lookup set { (___bzero, RequiredSymbol), (_comet_print_memref_f64, RequiredSymbol), (_comet_print_memref_i64, RequiredSymbol), (_malloc, RequiredSymbol), (_read_input_2D_f64, RequiredSymbol), (_read_input_sizes_2D_f64, RequiredSymbol) }:
  Attempting to match "___bzero" (RequiredSymbol)... matched, preparing to dispatch MU@0x60000182c000 (<Absolute Symbols>)
  Attempting to match "_read_input_sizes_2D_f64" (RequiredSymbol)... matched, registering query  Attempting to match "_read_input_2D_f64" (RequiredSymbol)... matched, registering query  Attempting to match "_malloc" (RequiredSymbol)... matched, registering query  Attempting to match "_comet_print_memref_i64" (RequiredSymbol)... matched, registering query  Attempting to match "_comet_print_memref_f64" (RequiredSymbol)... matched, registering queryStripping unmatched weakly-referenced symbols
Query successfully lodged
Adding MUs to dispatch:
  For main: Adding 1 MUs.
Registering dependencies
Adding dependencies for all symbols in { ("_main", [Callable]), ("__mlir_main", [Callable]) }: { (main, { _read_input_2D_f64, _read_input_sizes_2D_f64, _malloc, ___bzero, _comet_print_memref_i64, _comet_print_memref_f64 }) }
In main adding dependencies for _main: { (main, { _read_input_2D_f64, _read_input_sizes_2D_f64, _malloc, ___bzero, _comet_print_memref_i64, _comet_print_memref_f64 }) }
In main adding dependencies for __mlir_main: { (main, { _read_input_2D_f64, _read_input_sizes_2D_f64, _malloc, ___bzero, _comet_print_memref_i64, _comet_print_memref_f64 }) }
Dispatching MaterializationUnits...
  Dispatching "<Absolute Symbols>"
Dispatching: Materialization task: <Absolute Symbols> in main
In main resolving { ("_read_input_2D_f64": 0x0000000125155820 [Data]), ("_read_input_sizes_2D_f64": 0x0000000125157c00 [Data]), ("_malloc": 0x00007ff80ae79f20 [Data]), ("___bzero": 0x00007ff80b07b526 [Data]), ("_comet_print_memref_i64": 0x00000001251543a0 [Data]), ("_comet_print_memref_f64": 0x0000000125154370 [Data]) }
Dispatching: Execute query complete callback for { ("_read_input_2D_f64": 0x0000000125155820 [Data]), ("_read_input_sizes_2D_f64": 0x0000000125157c00 [Data]), ("_malloc": 0x00007ff80ae79f20 [Data]), ("___bzero": 0x00007ff80b07b526 [Data]), ("_comet_print_memref_i64": 0x00000001251543a0 [Data]), ("_comet_print_memref_f64": 0x0000000125154370 [Data]) }
Resolving relocations Name: ___bzero	0x7ff80b07b526
resolveRelocation Section: 0 LocalAddress: 0x124e7b378 FinalAddress: 0x0000000124e7b378 Value: 0x00007ff80b07b526 Addend: 0 isPCRel: 0 MachoType: 0 Size: 8
resolveRelocation Section: 0 LocalAddress: 0x124e7b32a FinalAddress: 0x0000000124e7b32a Value: 0x00007ff80b07b526 Addend: 0 isPCRel: 0 MachoType: 0 Size: 8
resolveRelocation Section: 0 LocalAddress: 0x124e7b18f FinalAddress: 0x0000000124e7b18f Value: 0x00007ff80b07b526 Addend: 0 isPCRel: 0 MachoType: 0 Size: 8
resolveRelocation Section: 0 LocalAddress: 0x124e7b145 FinalAddress: 0x0000000124e7b145 Value: 0x00007ff80b07b526 Addend: 0 isPCRel: 0 MachoType: 0 Size: 8
resolveRelocation Section: 0 LocalAddress: 0x124e7b0de FinalAddress: 0x0000000124e7b0de Value: 0x00007ff80b07b526 Addend: 0 isPCRel: 0 MachoType: 0 Size: 8
Resolving relocations Name: _comet_print_memref_i64	0x1251543a0
resolveRelocation Section: 0 LocalAddress: 0x124e7b419 FinalAddress: 0x0000000124e7b419 Value: 0x00000001251543a0 Addend: 0 isPCRel: 0 MachoType: 0 Size: 8
Resolving relocations Name: _read_input_2D_f64	0x125155820
resolveRelocation Section: 0 LocalAddress: 0x124e7b3b1 FinalAddress: 0x0000000124e7b3b1 Value: 0x0000000125155820 Addend: 0 isPCRel: 0 MachoType: 0 Size: 8
Resolving relocations Name: _read_input_sizes_2D_f64	0x125157c00
resolveRelocation Section: 0 LocalAddress: 0x124e7b05a FinalAddress: 0x0000000124e7b05a Value: 0x0000000125157c00 Addend: 0 isPCRel: 0 MachoType: 0 Size: 8
Resolving relocations Name: _comet_print_memref_f64	0x125154370
resolveRelocation Section: 0 LocalAddress: 0x124e7b47f FinalAddress: 0x0000000124e7b47f Value: 0x0000000125154370 Addend: 0 isPCRel: 0 MachoType: 0 Size: 8
Resolving relocations Name: _malloc	0x7ff80ae79f20
resolveRelocation Section: 0 LocalAddress: 0x124e7b12a FinalAddress: 0x0000000124e7b12a Value: 0x00007ff80ae79f20 Addend: 0 isPCRel: 0 MachoType: 0 Size: 8
resolveRelocation Section: 0 LocalAddress: 0x124e7b0cf FinalAddress: 0x0000000124e7b0cf Value: 0x00007ff80ae79f20 Addend: 0 isPCRel: 0 MachoType: 0 Size: 8
resolveRelocation Section: 0 LocalAddress: 0x124e7b013 FinalAddress: 0x0000000124e7b013 Value: 0x00007ff80ae79f20 Addend: 0 isPCRel: 0 MachoType: 0 Size: 8
Resolving relocations Section #0	0x124e7b000
resolveRelocation Section: 0 LocalAddress: 0x124e7b4b2 FinalAddress: 0x0000000124e7b4b2 Value: 0x0000000124e7b000 Addend: 0 isPCRel: 0 MachoType: 0 Size: 8
resolveRelocation Section: 1 LocalAddress: 0x124e7c000 FinalAddress: 0x0000000124e7c000 Value: 0x0000000124e7b000 Addend: 0 isPCRel: 0 MachoType: 0 Size: 8
Processing FDE: Delta for text: 2896, Delta for EH: 0
Processing FDE: Delta for text: 2896, Delta for EH: 0
Processing FDE: Delta for text: 2896, Delta for EH: 0
In main emitting { ("_main", [Callable]), ("__mlir_main", [Callable]) }
In main emitting { ("_read_input_2D_f64", [Data]), ("_read_input_sizes_2D_f64", [Data]), ("_malloc", [Data]), ("___bzero", [Data]), ("_comet_print_memref_i64", [Data]), ("_comet_print_memref_f64", [Data]) }
Dispatching: Execute query complete callback for { ("__mlir_main": 0x0000000124e7b4b0 [Callable]) }
Done dispatching MaterializationUnits.
Finished emitting, for main, MU@0x600001028070 ("<null module>", { })
Done dispatching MaterializationUnits.
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: llvm/build/bin/mlir-cpu-runner first.mlir -O3 -e main -entry-point-result=void -shared-libs=build/lib/libcomet_runner_utils.dylib,llvm/build/lib/libmlir_runner_utils.dylib -debug
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  mlir-cpu-runner          0x000000010f429d4d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  mlir-cpu-runner          0x000000010f42a2cb PrintStackTraceSignalHandler(void*) + 27
2  mlir-cpu-runner          0x000000010f427fe6 llvm::sys::RunSignalHandlers() + 134
3  mlir-cpu-runner          0x000000010f42b7cf SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff80b0775ed _sigtramp + 29
5  mlir-cpu-runner          0x000000010fd61fea llvm::orc::SymbolStringPtr::SymbolStringPtr(llvm::StringMapEntry<std::__1::atomic<unsigned long>>*) + 42
6  mlir-cpu-runner          0x0000000124e7b382 llvm::orc::SymbolStringPtr::SymbolStringPtr(llvm::StringMapEntry<std::__1::atomic<unsigned long>>*) + 353473474
7  mlir-cpu-runner          0x000000010fd5dded compileAndExecute((anonymous namespace)::Options&, mlir::Operation*, llvm::StringRef, (anonymous namespace)::CompileAndExecuteConfig, void**) + 1453
8  mlir-cpu-runner          0x000000010fd451f5 compileAndExecuteVoidFunction((anonymous namespace)::Options&, mlir::Operation*, llvm::StringRef, (anonymous namespace)::CompileAndExecuteConfig) + 357
9  mlir-cpu-runner          0x000000010fd4399f mlir::JitRunnerMain(int, char**, mlir::DialectRegistry const&, mlir::JitRunnerConfig) + 1839
10 mlir-cpu-runner          0x000000010ee67d24 main + 260
11 dyld                     0x00007ff80acf041f start + 1903
